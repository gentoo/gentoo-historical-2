diff -ru ./freehdl/kernel-driver-info.hh ../freehdl-20040113.new/./freehdl/kernel-driver-info.hh
--- ./freehdl/kernel-driver-info.hh	2003-06-03 13:27:32.000000000 +0200
+++ ../freehdl-20040113.new/./freehdl/kernel-driver-info.hh	2004-10-04 15:35:33.000000000 +0200
@@ -146,6 +146,7 @@
   inline bool assign_first_transactions(const vtime &time_value);
 };
 
+#define have_driver_info
 
 /******************************************************
  * Some definitions which are used by the kernel only 
diff -ru ./freehdl/kernel-handle-info.hh ../freehdl-20040113.new/./freehdl/kernel-handle-info.hh
--- ./freehdl/kernel-handle-info.hh	2000-08-15 09:34:49.000000000 +0200
+++ ../freehdl-20040113.new/./freehdl/kernel-handle-info.hh	2004-10-04 15:40:28.000000000 +0200
@@ -18,7 +18,7 @@
   // architecture
   const handle function;
   char *scope_long_name; // Long name of the region the design is
-  handle_info() {};
+  handle_info() : function(NULL) {};
   handle_info(const char *lib, const  char *ent, const char *arch, const handle func);
   bool match(const char *lib, const char *ent, const char *arch) {
     return (lib == NULL || lib[0] == '\0' || !strcmp(lib, library)) &&
diff -ru ./freehdl/kernel-list.hh ../freehdl-20040113.new/./freehdl/kernel-list.hh
--- ./freehdl/kernel-list.hh	2002-01-14 17:18:22.000000000 +0100
+++ ../freehdl-20040113.new/./freehdl/kernel-list.hh	2004-10-04 15:54:15.000000000 +0200
@@ -1,6 +1,10 @@
 #ifndef FREEHDL_KERNEL_LIST_H
 #define FREEHDL_KERNEL_LIST_H
 
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
 
 //**********************************************************************
 // A simple list template class.
diff -ru ./freehdl/kernel-resolver-descriptor.hh ../freehdl-20040113.new/./freehdl/kernel-resolver-descriptor.hh
--- ./freehdl/kernel-resolver-descriptor.hh	2001-05-21 13:36:22.000000000 +0200
+++ ../freehdl-20040113.new/./freehdl/kernel-resolver-descriptor.hh	2004-10-04 15:35:03.000000000 +0200
@@ -19,6 +19,9 @@
 // kernel. The kernel uses this handler to execute the resolver
 // function indirectly. T is the type to be resolved while F points to
 // the user defined resolution function.
+
+#ifdef have_driver_info
+
 template<class T, T (*F)(const array_type<T >&, array_info&) >
 void resolver_handler(void *result, driver_info *driver, array_base *array, array_info *unc_ainfo)
 {
@@ -38,7 +41,7 @@
   driver->transport_assign(*(T*)result, zero_time);
 }
 
-
+#endif
 
 
 #ifdef KERNEL
diff -ru ./freehdl/std-vhdl-types.hh ../freehdl-20040113.new/./freehdl/std-vhdl-types.hh
--- ./freehdl/std-vhdl-types.hh	2004-01-12 18:32:57.000000000 +0100
+++ ../freehdl-20040113.new/./freehdl/std-vhdl-types.hh	2004-10-04 15:38:47.000000000 +0200
@@ -250,7 +250,7 @@
 }
 
 /* absolute operator */
-inline integer op_abs (const integer a) { return abs (a); }
+inline integer op_abs (const integer a) { return std::abs (a); }
 
 /* *************************************************************
  *  All VHDL access type are actually void pointer
@@ -1948,40 +1948,40 @@
 class array_alias : public T {
 public:
   array_alias(): T() {
-    info = NULL;
-    data = NULL;
+    this->info = NULL;
+    this->data = NULL;
   }
   array_alias(type_info_interface *et, type_info_interface *it, 
 	      int le, range_direction dir, int ri, int rc, void *iarray) : T() {
     /* Create a new array_info instance */
-    info = new array_info(et, it, le, dir, ri, rc);
-    data = (char*)iarray;
+    this->info = new array_info(et, it, le, dir, ri, rc);
+    this->data = (char*)iarray;
   }
   /* Note that here the bounds of the alias are taken from the
    * source array and NOT  from the array base! */
   array_alias(array_info *base, const array_base &abase) : T() {
     const array_info &ainfo = *abase.info;
-    info = new array_info(base->element_type, base->index_type, ainfo.left_bound, 
+    this->info = new array_info(base->element_type, base->index_type, ainfo.left_bound, 
 			  ainfo.index_direction, ainfo.right_bound, 1);
-    data = abase.data;
+    this->data = abase.data;
   }
   array_alias(array_info *ainfo, const void *iarray) : T() { 
-    info = ainfo; 
-    info->add_ref(); 
-    data = (char*)iarray; 
+    this->info = ainfo; 
+    this->info->add_ref(); 
+    this->data = (char*)iarray; 
   }
   array_alias &set(array_info *ainfo, void *iarray) {
-    if (info != NULL)
-      info->remove_ref();
-    info = ainfo;
-    info->add_ref();
-    data = (char*)iarray;
+    if (this->info != NULL)
+      this->info->remove_ref();
+    this->info = ainfo;
+    this->info->add_ref();
+    this->data = (char*)iarray;
     return *this;
   }
   ~array_alias() { 
     /* Note that the data array is NOT deallocated as the memory has
      * been allocated by another array_type instance */
-    data = NULL; /* Set pointer to NULL so that the destructor of
+    this->data = NULL; /* Set pointer to NULL so that the destructor of
 		  * class T will NOT remove the memory! */
   }
   array_alias &operator=(const T &a);
@@ -1992,26 +1992,26 @@
 template<class T>
 array_alias<T> &array_alias<T>::operator=(const T &a) 
 {
-  int length = info->length;
+  int length = this->info->length;
   typedef typename T::E_type E;
 
   /* Check whether array bounds are compatible */
-  if (info != a.info && length != a.info->length)
+  if (this->info != a.info && length != a.info->length)
     error(ERROR_INCOMPATIBLE_ARRAYS);
 
   /* Check whether the arrays overlap */
   const int mem_size = length * sizeof(E);
   
-  if (abs((int)a.data - (int)data) >= mem_size) {
+  if (abs((int)a.data - (int)this->data) >= mem_size) {
     /* Ok, arrays do NOT overlap! */
     /* Copy the data part of the arrays */
     if (scalar(id((E*)NULL)))
       /* If the element type is not scalar then execute init(...) for
        * each element in the array after initialing the memory to 0 */
-      memcpy(data, a.data, mem_size);
+      memcpy(this->data, a.data, mem_size);
     else
       for (int i = 0; i < length; i++)
-	((E*)data)[i] = ((E*)a.data)[i];
+	((E*)this->data)[i] = ((E*)a.data)[i];
     
   } else {
     /* Attention: arrays overlap! */
@@ -2022,18 +2022,18 @@
        * 0. Note that twe are using memmove instead of memcpy here
        * because the memory ranges of source and destination
        * overlap. */
-      memmove(data, a.data, mem_size);
+      memmove(this->data, a.data, mem_size);
 
     else {
       /* Check out whether the lower border of the source array is
        * located within the destination array as this affects the
        * iteration direction. */
-      if (a.data >= data) 
+      if (a.data >= this->data) 
 	for (int i = 0; i < length; i++)
-	  ((E*)data)[i] = ((E*)a.data)[i];
+	  ((E*)this->data)[i] = ((E*)a.data)[i];
       else 
 	for (int i = length - 1; i >= 0; i--)
-	  ((E*)data)[i] = ((E*)a.data)[i];
+	  ((E*)this->data)[i] = ((E*)a.data)[i];
     }
   }
 
diff -ru ./freehdl/tree-supp.h ../freehdl-20040113.new/./freehdl/tree-supp.h
--- ./freehdl/tree-supp.h	2001-12-18 13:39:44.000000000 +0100
+++ ../freehdl-20040113.new/./freehdl/tree-supp.h	2004-10-04 15:59:27.000000000 +0200
@@ -12,6 +12,17 @@
 
 typedef struct tree_kind_info *tree_kind;
 
+class tree_chunk_tab;
+class tree_chunk_info;
+void *tree_find_mtab (tree_chunk_tab *ctab, int n_chunks, tree_kind *kind);
+void tree_no_method (char *genfunc, tree_kind kind);
+void tree_conflicting_methods (char *genfunc, tree_kind kind);
+
+void tree_register_chunk (tree_chunk_info *chunk);
+
+void tree_set_verbose (bool);
+
+
 struct tree_chunk_info {
   int chunk_id;
   char *name;
@@ -212,14 +223,6 @@
     }
 }
 
-void *tree_find_mtab (tree_chunk_tab *ctab, int n_chunks, tree_kind *kind);
-void tree_no_method (char *genfunc, tree_kind kind);
-void tree_conflicting_methods (char *genfunc, tree_kind kind);
-
-void tree_register_chunk (tree_chunk_info *chunk);
-
-void tree_set_verbose (bool);
-
 struct tree_histogram {
   tree_histogram ();
 
diff -ru ./ieee/numeric_std.cc ../freehdl-20040113.new/./ieee/numeric_std.cc
--- ./ieee/numeric_std.cc	2004-01-12 18:35:33.000000000 +0100
+++ ../freehdl-20040113.new/./ieee/numeric_std.cc	2004-10-04 16:07:33.000000000 +0200
@@ -265,7 +265,7 @@
 L4ieee_Q11numeric_std_init_done=true;
 L3std_Q8standard_init ();
 L4ieee_Q14std_logic_1164_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/numeric_std.vhdl","numeric_std.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/numeric_std.vhdl","numeric_std.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package(":ieee",":numeric_std");
@@ -3934,7 +3934,7 @@
 L4ieee_Q11numeric_std_init ();
 L3std_Q8standard_init ();
 L4ieee_Q11numeric_std_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/numeric_std.vhdl","numeric_std.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/numeric_std.vhdl","numeric_std.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package_body(":ieee",":numeric_std");
diff -ru ./ieee/std_logic_1164.cc ../freehdl-20040113.new/./ieee/std_logic_1164.cc
--- ./ieee/std_logic_1164.cc	2004-01-12 18:35:31.000000000 +0100
+++ ../freehdl-20040113.new/./ieee/std_logic_1164.cc	2004-10-04 16:07:31.000000000 +0200
@@ -213,7 +213,7 @@
 if (L4ieee_Q14std_logic_1164_init_done) return 1;
 L4ieee_Q14std_logic_1164_init_done=true;
 L3std_Q8standard_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/std_logic_1164.vhdl","std_logic_1164.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/std_logic_1164.vhdl","std_logic_1164.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package(":ieee",":std_logic_1164");
@@ -1455,7 +1455,7 @@
 L4ieee_Q14std_logic_1164_init ();
 L3std_Q8standard_init ();
 L4ieee_Q14std_logic_1164_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/std_logic_1164.vhdl","std_logic_1164.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/std_logic_1164.vhdl","std_logic_1164.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package_body(":ieee",":std_logic_1164");
diff -ru ./ieee/std_logic_arith.cc ../freehdl-20040113.new/./ieee/std_logic_arith.cc
--- ./ieee/std_logic_arith.cc	2004-01-12 18:35:34.000000000 +0100
+++ ../freehdl-20040113.new/./ieee/std_logic_arith.cc	2004-10-04 16:07:34.000000000 +0200
@@ -332,7 +332,7 @@
 L4ieee_Q15std_logic_arith_init_done=true;
 L3std_Q8standard_init ();
 L4ieee_Q14std_logic_1164_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/std_logic_arith.vhdl","std_logic_arith.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/std_logic_arith.vhdl","std_logic_arith.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package(":ieee",":std_logic_arith");
@@ -2821,7 +2821,7 @@
 L3std_Q8standard_init ();
 L4ieee_Q15std_logic_arith_init ();
 L4ieee_Q14std_logic_1164_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/std_logic_arith.vhdl","std_logic_arith.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/std_logic_arith.vhdl","std_logic_arith.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package_body(":ieee",":std_logic_arith");
diff -ru ./ieee/std_logic_signed.cc ../freehdl-20040113.new/./ieee/std_logic_signed.cc
--- ./ieee/std_logic_signed.cc	2004-01-12 18:35:32.000000000 +0100
+++ ../freehdl-20040113.new/./ieee/std_logic_signed.cc	2004-10-04 16:07:33.000000000 +0200
@@ -115,7 +115,7 @@
 L3std_Q8standard_init ();
 L4ieee_Q15std_logic_arith_init ();
 L4ieee_Q14std_logic_1164_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/std_logic_signed.vhdl","std_logic_signed.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/std_logic_signed.vhdl","std_logic_signed.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package(":ieee",":std_logic_signed");
@@ -606,7 +606,7 @@
 L4ieee_Q16std_logic_signed_init ();
 L4ieee_Q15std_logic_arith_init ();
 L4ieee_Q14std_logic_1164_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/std_logic_signed.vhdl","std_logic_signed.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/std_logic_signed.vhdl","std_logic_signed.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package_body(":ieee",":std_logic_signed");
diff -ru ./ieee/std_logic_unsigned.cc ../freehdl-20040113.new/./ieee/std_logic_unsigned.cc
--- ./ieee/std_logic_unsigned.cc	2004-01-12 18:35:32.000000000 +0100
+++ ../freehdl-20040113.new/./ieee/std_logic_unsigned.cc	2004-10-04 16:07:33.000000000 +0200
@@ -109,7 +109,7 @@
 L3std_Q8standard_init ();
 L4ieee_Q15std_logic_arith_init ();
 L4ieee_Q14std_logic_1164_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/std_logic_unsigned.vhdl","std_logic_unsigned.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/std_logic_unsigned.vhdl","std_logic_unsigned.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package(":ieee",":std_logic_unsigned");
@@ -562,7 +562,7 @@
 L4ieee_Q18std_logic_unsigned_init ();
 L4ieee_Q15std_logic_arith_init ();
 L4ieee_Q14std_logic_1164_init ();
-register_source_file("/home/edwin/work/freehdl-teaser/ieee/std_logic_unsigned.vhdl","std_logic_unsigned.vhdl");
+register_source_file("/var/tmp/portage/freehdl-20040113/work/freehdl-20040113/ieee/std_logic_unsigned.vhdl","std_logic_unsigned.vhdl");
 name_stack iname;
 iname.push("");
 void *sref=register_package_body(":ieee",":std_logic_unsigned");
diff -ru ./kernel/driver_info.cc ../freehdl-20040113.new/./kernel/driver_info.cc
--- ./kernel/driver_info.cc	2002-07-30 13:32:45.000000000 +0200
+++ ../freehdl-20040113.new/./kernel/driver_info.cc	2004-10-04 15:40:53.000000000 +0200
@@ -13,7 +13,7 @@
 
 // free_items points to a list of free transaction items. Note, all
 // transaction lists share the SAME free_item list.
-void *fqueue<long long int, vtime>::free_items = NULL;
+template <> void *fqueue<long long int, vtime>::free_items = NULL;
 
 
 driver_info::driver_info(process_base *proc, sig_info_base *sig, int i) 
diff -ru ./vaul/lexer.cc ../freehdl-20040113.new/./vaul/lexer.cc
--- ./vaul/lexer.cc	2003-04-10 08:46:01.000000000 +0200
+++ ../freehdl-20040113.new/./vaul/lexer.cc	2004-10-04 16:01:34.000000000 +0200
@@ -1,4 +1,4 @@
-#line 2 "lex.yy.c"
+#line 2 "lexer.cc"
 /* A lexical scanner generated by flex */
 
 /* Scanner skeleton version:
@@ -10,6 +10,7 @@
 #define YY_FLEX_MINOR_VERSION 5
 
 
+
 /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
 #ifdef c_plusplus
 #ifndef __cplusplus
@@ -21,18 +22,8 @@
 #ifdef __cplusplus
 
 #include <stdlib.h>
-#include <fstream>
-using std::istream;
-using std::ostream;
-#ifndef _WIN32
-#include <unistd.h>
-#else
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-#endif
+#include <iostream>
+using namespace std;
 
 /* Use prototypes in function declarations. */
 #define YY_USE_PROTOS
@@ -602,7 +593,7 @@
 	return(skip_p? pt->skip_kval : pt->kval);
 }
 
-#line 606 "lex.yy.c"
+#line 597 "lexer.cc"
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -726,7 +717,7 @@
 YY_DECL
 	{
 	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
+	register char *yy_cp = NULL, *yy_bp = NULL;
 	register int yy_act;
 
 #line 206 "lexer.ll"
@@ -734,7 +725,7 @@
 
 	    if(stopped) return 0;
 
-#line 738 "lex.yy.c"
+#line 729 "lexer.cc"
 
 	if ( yy_init )
 		{
@@ -1049,7 +1040,7 @@
 #line 311 "lexer.ll"
 ECHO;
 	YY_BREAK
-#line 1053 "lex.yy.c"
+#line 1044 "lexer.cc"
 case YY_STATE_EOF(INITIAL):
 	yyterminate();
 
@@ -1962,7 +1953,7 @@
 	}
       
       for (int i = bits-1; i >= 0; i--)
-	*bp++ = (dig & (1 << i))? '1' : '0';
+	*bp++ = (dig & (1 << i)) ? '1' : '0';
     }
   *bp++ = '"';
   *bp = '\0';
diff -ru ./vaul/lexer.ll ../freehdl-20040113.new/./vaul/lexer.ll
--- ./vaul/lexer.ll	2003-04-10 08:45:42.000000000 +0200
+++ ../freehdl-20040113.new/./vaul/lexer.ll	2004-10-04 16:01:33.000000000 +0200
@@ -414,7 +414,7 @@
 	}
       
       for (int i = bits-1; i >= 0; i--)
-	*bp++ = (dig & (1 << i))? '1' : '0';
+	*bp++ = (dig & (1 << i)) ? '1' : '0';
     }
   *bp++ = '"';
   *bp = '\0';
