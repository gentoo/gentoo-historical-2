Index: twisted/python/usage.py
===================================================================
--- twisted/python/usage.py	(revision 17447)
+++ twisted/python/usage.py	(revision 17448)
@@ -129,9 +129,12 @@
             self.__dispatch.update(dispatch)
 
     def __hash__(self):
-        # This is required because dicts aren't hashable by default
-        # (They define __cmp__ but no __hash__)
-        return id(self)
+        """
+        Define a custom hash function so that Options instances can be used
+        as dictionary keys.  This is an internal feature used to implement
+        the parser.  Do not rely on it in application code.
+        """
+        return int(id(self) % sys.maxint)
 
     def opt_help(self):
         """Display this help and exit."""
Index: twisted/python/failure.py
===================================================================
--- twisted/python/failure.py	(revision 17447)
+++ twisted/python/failure.py	(revision 17448)
@@ -14,6 +14,7 @@
 import sys
 import linecache
 import string
+import inspect
 from cStringIO import StringIO
 import types
 
@@ -201,7 +202,7 @@
                 globalz.items(),
                 ])
             tb = tb.tb_next
-        if isinstance(self.type, types.ClassType):
+        if inspect.isclass(self.type) and issubclass(self.type, Exception):
             parentCs = reflect.allYourBase(self.type)
             self.parents = map(reflect.qual, parentCs)
             self.parents.append(reflect.qual(self.type))
@@ -244,7 +245,7 @@
         """
         for error in errorTypes:
             err = error
-            if isinstance(error, types.ClassType) and issubclass(error, Exception):
+            if inspect.isclass(error) and issubclass(error, Exception):
                 err = reflect.qual(error)
             if err in self.parents:
                 return error
@@ -349,7 +350,7 @@
 
         # postamble, if any
         if not detail == 'brief':
-            w("%s: %s\n" % (reflect.safe_str(self.type),
+            w("%s: %s\n" % (reflect.qual(self.type),
                             reflect.safe_str(self.value)))
         # chaining
         if isinstance(self.value, Failure):
Index: twisted/python/zipstream.py
===================================================================
--- twisted/python/zipstream.py	(revision 17447)
+++ twisted/python/zipstream.py	(revision 17448)
@@ -10,6 +10,7 @@
 import os.path
 import binascii
 import zlib
+import struct
 
 class ChunkingZipFile(zipfile.ZipFile):
     """A ZipFile object which, with readfile(), also gives you access
@@ -23,7 +24,24 @@
             raise RuntimeError, \
                   "Attempt to read ZIP archive that was already closed"
         zinfo = self.getinfo(name)
-        self.fp.seek(zinfo.file_offset, 0)
+
+        self.fp.seek(zinfo.header_offset, 0)
+
+        # Skip the file header:
+        fheader = self.fp.read(30)
+        if fheader[0:4] != zipfile.stringFileHeader:
+            raise zipfile.BadZipfile, "Bad magic number for file header"
+
+        fheader = struct.unpack(zipfile.structFileHeader, fheader)
+        fname = self.fp.read(fheader[zipfile._FH_FILENAME_LENGTH])
+        if fheader[zipfile._FH_EXTRA_FIELD_LENGTH]:
+            self.fp.read(fheader[zipfile._FH_EXTRA_FIELD_LENGTH])
+
+        if fname != zinfo.orig_filename:
+            raise zipfile.BadZipfile, \
+                      'File name in directory "%s" and header "%s" differ.' % (
+                          zinfo.orig_filename, fname)
+
         if zinfo.compress_type == zipfile.ZIP_STORED:
             return ZipFileEntry(self.fp, zinfo.compress_size)
         elif zinfo.compress_type == zipfile.ZIP_DEFLATED:
Index: twisted/python/log.py
===================================================================
--- twisted/python/log.py	(revision 17447)
+++ twisted/python/log.py	(revision 17448)
@@ -74,7 +74,7 @@
 
 def showwarning(message, category, filename, lineno, file=None):
     if file is None:
-        msg(warning=message, category=category, filename=filename, lineno=lineno,
+        msg(warning=message, category=reflect.qual(category), filename=filename, lineno=lineno,
             format="%(filename)s:%(lineno)s: %(category)s: %(warning)s")
     else:
         _oldshowwarning(message, category, filename, lineno, file)
Index: twisted/test/test_failure.py
===================================================================
--- twisted/test/test_failure.py	(revision 17447)
+++ twisted/test/test_failure.py	(revision 17448)
@@ -12,7 +12,7 @@
 import StringIO
 import traceback
 
-from twisted.trial import unittest
+from twisted.trial import unittest, util
 
 
 from twisted.python import failure
@@ -105,6 +105,8 @@
             self.assertEquals(sys.exc_info()[0], "bugger off")
         else:
             raise AssertionError("Should have raised")
+    testStringExceptions.suppress = [
+        util.suppress(message='raising a string exception is deprecated')]
 
     def testBrokenStr(self):
         x = BrokenStr()
Index: twisted/test/test_pbfailure.py
===================================================================
--- twisted/test/test_pbfailure.py	(revision 17447)
+++ twisted/test/test_pbfailure.py	(revision 17448)
@@ -4,23 +4,37 @@
 
 from twisted.trial import unittest
 
-from twisted.spread import pb, flavors, jelly
+from twisted.spread import pb, flavors
 from twisted.internet import reactor, defer
 from twisted.python import log, failure
 
 ##
 # test exceptions
 ##
-class PoopError(Exception): pass
-class FailError(Exception): pass
-class DieError(Exception): pass
-class TimeoutError(Exception): pass
+class PoopError(Exception):
+    pass
 
 
+class FailError(Exception):
+    pass
+
+
+class DieError(Exception):
+    pass
+
+
+class TimeoutError(Exception):
+    pass
+
+
 #class JellyError(flavors.Jellyable, pb.Error): pass
-class JellyError(flavors.Jellyable, pb.Error, pb.RemoteCopy): pass
-class SecurityError(pb.Error, pb.RemoteCopy): pass
+class JellyError(flavors.Jellyable, pb.Error, pb.RemoteCopy):
+    pass
 
+
+class SecurityError(pb.Error, pb.RemoteCopy):
+    pass
+
 pb.setUnjellyableForClass(JellyError, JellyError)
 pb.setUnjellyableForClass(SecurityError, SecurityError)
 pb.globalSecurity.allowInstancesOf(SecurityError)
@@ -98,13 +112,94 @@
 class PBFailureTest(PBConnTestCase):
     compare = unittest.TestCase.assertEquals
 
-    def testPBFailures(self):
-        d = self.clientFactory.getRootObject()
-        d.addCallback(self.connected)
-        d.addCallback(self.cleanupLoggedErrors)
-        return d
 
+    def _addFailingCallbacks(self, remoteCall, expectedResult, eb):
+        remoteCall.addCallbacks(self.success, eb,
+                                callbackArgs=(expectedResult,))
+        return remoteCall
 
+
+    def _testImpl(self, method, expected, eb, exc=None):
+        rootDeferred = self.clientFactory.getRootObject()
+        def gotRootObj(obj):
+            failureDeferred = self._addFailingCallbacks(obj.callRemote(method), expected, eb)
+            if exc is not None:
+                def gotFailure(err):
+                    self.assertEquals(len(log.flushErrors(exc)), 1)
+                    return err
+                failureDeferred.addBoth(gotFailure)
+            return failureDeferred
+        rootDeferred.addCallback(gotRootObj)
+        return rootDeferred
+
+
+    def testPoopError(self):
+        """
+        Test that a Deferred returned by a remote method which already has a
+        Failure correctly has that error passed back to the calling side.
+        """
+        return self._testImpl('poop', 42, self.failurePoop, PoopError)
+
+
+    def testFailureFailure(self):
+        """
+        Test that a remote method which synchronously raises an exception
+        has that exception passed back to the calling side.
+        """
+        return self._testImpl('fail', 420, self.failureFail, FailError)
+
+
+    def testDieFailure(self):
+        """
+        The same as testFailureFailure (it is not clear to me why this
+        exists, but I am not deleting it as part of this refactoring.
+        -exarkun).
+        """
+        return self._testImpl('die', 4200, self.failureDie, DieError)
+
+
+    def testNoSuchFailure(self):
+        """
+        Test that attempting to call a method which is not defined correctly
+        results in an AttributeError on the calling side.
+        """
+        return self._testImpl('nosuch', 42000, self.failureNoSuch, AttributeError)
+
+
+    def testJellyFailure(self):
+        """
+        Test that an exception which is a subclass of L{pb.Error} has more
+        information passed across the network to the calling side.
+        """
+        return self._testImpl('jelly', 43, self.failureJelly)
+
+
+    def testSecurityFailure(self):
+        """
+        Test that even if an exception is not explicitly jellyable (by being
+        a L{pb.Jellyable} subclass), as long as it is an L{pb.Error}
+        subclass it receives the same special treatment.
+        """
+        return self._testImpl('security', 430, self.failureSecurity)
+
+
+    def testDeferredJellyFailure(self):
+        """
+        Test that a Deferred which fails with a L{pb.Error} is treated in
+        the same way as a synchronously raised L{pb.Error}.
+        """
+        return self._testImpl('deferredJelly', 4300, self.failureDeferredJelly, JellyError)
+
+
+    def testDeferredSecurity(self):
+        """
+        Test that a Deferred which fails with a L{pb.Error} which is not
+        also a L{pb.Jellyable} is treated in the same way as a synchronously
+        raised exception of the same type.
+        """
+        return self._testImpl('deferredSecurity', 43000, self.failureDeferredSecurity, SecurityError)
+
+
     def testCopiedFailureLogging(self):
         d = self.clientFactory.getRootObject()
 
@@ -120,12 +215,6 @@
 
         return d
 
-
-    def addFailingCallbacks(self, remoteCall, expectedResult, eb):
-        remoteCall.addCallbacks(self.success, eb,
-                                callbackArgs=(expectedResult,))
-        return remoteCall
-
     ##
     # callbacks
     ##
@@ -136,19 +225,6 @@
         self.assertEquals(len(errors), 6)
         return ignored
 
-    def connected(self, persp):
-        methods = (('poop', 42, self.failurePoop),
-                   ('fail', 420, self.failureFail),
-                   ('die', 4200, self.failureDie),
-                   ('nosuch', 42000, self.failureNoSuch),
-                   ('jelly', 43, self.failureJelly),
-                   ('security', 430, self.failureSecurity),
-                   ('deferredJelly', 4300, self.failureDeferredJelly),
-                   ('deferredSecurity', 43000, self.failureDeferredSecurity))
-        return defer.gatherResults([
-            self.addFailingCallbacks(persp.callRemote(meth), result, eb)
-            for (meth, result, eb) in methods])
-
     def success(self, result, expectedResult):
         self.assertEquals(result, expectedResult)
         return result
Index: twisted/test/test_stdio.py
===================================================================
--- twisted/test/test_stdio.py	(revision 17447)
+++ twisted/test/test_stdio.py	(revision 17448)
@@ -42,7 +42,7 @@
         return reactor.spawnProcess(
             proto,
             sys.executable,
-            ["python", filepath.FilePath(__file__).sibling(sibling).path, reactor.__class__.__module__] + list(args),
+            [sys.executable, filepath.FilePath(__file__).sibling(sibling).path, reactor.__class__.__module__] + list(args),
             env=subenv,
             )
 
Index: twisted/test/test_jelly.py
===================================================================
--- twisted/test/test_jelly.py	(revision 17447)
+++ twisted/test/test_jelly.py	(revision 17448)
@@ -62,7 +62,7 @@
     def __init__(self, x, y):
         self.x = x
         self.y = y
-        
+
     def isTheSameAs(self, other):
         return self.__dict__ == other.__dict__
 
@@ -95,7 +95,6 @@
         m = jelly.unjelly(c)
         self.failUnless(isinstance(m, NewStyle))
         self.assertIdentical(m.n2, m.n3)
-    testNewStyle.todo = "jelly does not support new-style classes yet"
 
 
     def testDateTime(self):
Index: twisted/spread/flavors.py
===================================================================
--- twisted/spread/flavors.py	(revision 17447)
+++ twisted/spread/flavors.py	(revision 17448)
@@ -27,7 +27,7 @@
 # mechanisms (like XMLRPC)
 
 # system imports
-import types
+import sys
 from zope.interface import implements
 
 # twisted imports
@@ -480,7 +480,7 @@
     def __hash__(self):
         """Hash me.
         """
-        return id(self.__dict__)
+        return int(id(self.__dict__) % sys.maxint)
 
     broker = None
     luid = None
Index: twisted/spread/jelly.py
===================================================================
--- twisted/spread/jelly.py	(revision 17447)
+++ twisted/spread/jelly.py	(revision 17448)
@@ -58,7 +58,6 @@
 # System Imports
 import string
 import pickle
-import sys
 import types
 from types import StringType
 try:
@@ -68,7 +67,6 @@
 from types import IntType
 from types import TupleType
 from types import ListType
-from types import DictType
 from types import LongType
 from types import FloatType
 from types import FunctionType
@@ -88,9 +86,9 @@
 from zope.interface import implements
 
 # Twisted Imports
-from twisted.python.reflect import namedObject, namedModule, qual
+from twisted.python.reflect import namedObject, qual
 from twisted.persisted.crefutil import NotKnown, _Tuple, _InstanceMethod, _DictKeyAndValue, _Dereference
-from twisted.python import runtime, components
+from twisted.python import runtime
 
 from twisted.spread.interfaces import IJellyable, IUnjellyable
 
@@ -416,8 +414,7 @@
                 return preRef
             return obj.jellyFor(self)
         objType = type(obj)
-        if self.taster.isTypeAllowed(
-            string.replace(objType.__name__, ' ', '_')):
+        if self.taster.isTypeAllowed(qual(objType)):
             # "Immutable" Types
             if ((objType is StringType) or
                 (objType is IntType) or
@@ -455,7 +452,7 @@
                 return ['date', '%s %s %s' % (obj.year, obj.month, obj.day)]
             elif objType is datetime.timedelta:
                 return ['timedelta', '%s %s %s' % (obj.days, obj.seconds, obj.microseconds)]
-            elif objType is ClassType or issubclass(type, objType):
+            elif objType is ClassType or issubclass(objType, type):
                 return ['class', qual(obj)]
             else:
                 preRef = self._checkMutable(obj)
@@ -475,7 +472,7 @@
                     sxp.append(dictionary_atom)
                     for key, val in obj.items():
                         sxp.append([self.jelly(key), self.jelly(val)])
-                elif objType is InstanceType:
+                else:
                     className = qual(obj.__class__)
                     persistent = None
                     if self.persistentStore:
@@ -494,11 +491,9 @@
                         self.unpersistable(
                             "instance of class %s deemed insecure" %
                             qual(obj.__class__), sxp)
-                else:
-                    raise NotImplementedError("Don't know the type: %s" % objType)
                 return self.preserve(obj, sxp)
         else:
-            if objType is types.InstanceType:
+            if objType is InstanceType:
                 raise InsecureJelly("Class not allowed for instance: %s %s" %
                                     (obj.__class__, obj))
             raise InsecureJelly("Type not allowed for object: %s %s" %
@@ -682,7 +677,7 @@
             raise InsecureJelly("module %s not allowed" % modName)
         klaus = namedObject(rest[0])
         if type(klaus) is not types.ClassType:
-            raise InsecureJelly("class %s unjellied to something that isn't a class: %s" % (repr(name), repr(klaus)))
+            raise InsecureJelly("class %s unjellied to something that isn't a class: %s" % (repr(rest[0]), repr(klaus)))
         if not self.taster.isClassAllowed(klaus):
             raise InsecureJelly("class not allowed: %s" % qual(klaus))
         return klaus
@@ -833,7 +828,9 @@
         """SecurityOptions.allowTypes(typeString): Allow a particular type, by its name.
         """
         for typ in types:
-            self.allowedTypes[string.replace(typ, ' ', '_')]=1
+            if not isinstance(typ, str):
+                typ = qual(typ)
+            self.allowedTypes[typ] = 1
 
     def allowInstancesOf(self, *classes):
         """SecurityOptions.allowInstances(klass, klass, ...): allow instances
