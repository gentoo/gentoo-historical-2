--- _kinterbasdb.c	2002-08-28 19:01:52.000000000 +0100
+++ /tmp/_kinterbasdb.c	2003-10-02 12:06:53.000000000 +0100
@@ -1626,7 +1626,7 @@
 ** YYY:DSR This normalize_double implementation should be audited for overflow
 ** issues.
  */
-static LONG_LONG normalize_double( double d, short* sqlscalePtr ) {
+static PY_LONG_LONG normalize_double( double d, short* sqlscalePtr ) {
     /* DSR: Note that my implementation could just as well receive a
     ** 'short sqlscale' as the current 'pointer to short sqlscale'.
     ** I left it as a pointer in order to adhere to the function's original
@@ -1636,7 +1636,7 @@
      */
 
     /* We iteratively build the normalized double in this variable: */
-    LONG_LONG result;
+    PY_LONG_LONG result;
 
     /* During this the bulk of this function's computations, we deal with the
     ** ABSOLUTE value of d, so we must remember the original sign: */
@@ -1654,9 +1654,9 @@
     ** fractional portion.
      */
     if (signOfD == SIGN_POSITIVE) {
-        result = (LONG_LONG) fabs(floor(d));
+        result = (PY_LONG_LONG) fabs(floor(d));
     } else {
-        result = (LONG_LONG) fabs(ceil(d));
+        result = (PY_LONG_LONG) fabs(ceil(d));
     }
 
     fractionalPartRemaining = fabs(modf(d, &wholePartRemaining));
@@ -1868,7 +1868,7 @@
         ** engine), and 10 to the 18th is less than LONG_LONG_MAX.
         ** The actual scaling is done using Python longs, will never overflow.
         */
-        LONG_LONG multiplier = 1;
+        PY_LONG_LONG multiplier = 1;
         PyObject* pyMultiplier;
         short i;
         for (i = 0; i < num_decimal_places; i++)
@@ -2000,7 +2000,7 @@
         *(LONG_LONG*)sqlvar->sqldata = (LONG_LONG) PyInt_AsLong(pyScaledN);
       } else { /* Must be PyLong */
       #endif
-        *(LONG_LONG*)sqlvar->sqldata = PyLong_AsLongLong(pyScaledN);
+        *(PY_LONG_LONG*)sqlvar->sqldata = PyLong_AsLongLong(pyScaledN);
       #if !PYTHON_2_2_OR_LATER
       }
       #endif
@@ -3164,7 +3164,7 @@
     ** values properly in imprecise mode (the 64-bit int will overflow the
     ** double).  This can be overcome by using precise mode.
     */
-    LONG_LONG conv_long_long = *(LONG_LONG*)( sqlvar->sqldata );
+    PY_LONG_LONG conv_long_long = *(PY_LONG_LONG*)( sqlvar->sqldata );
     if ( num_decimal_places == 0 || precision_mode != PRECISION_MODE_IMPRECISE ) {
       /* This is either a NUMERIC/DECIMAL field being requested in precise
       ** mode as an uninterpreted integer, or a NUMERIC/DECIMAL field being
