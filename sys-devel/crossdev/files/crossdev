#!/bin/bash
# Copyright 1999-2005 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/sys-devel/crossdev/files/crossdev,v 1.40 2005/10/20 17:47:25 vapier Exp $

cd /

if [[ ${ROOT:-/} != "/" ]] ; then
	echo "Sorry, but crossdev does not support ROOT."
	exit 2
fi

source /sbin/functions.sh || exit 1
esyslog() { :; }
die() {
	echo
	eerror $*
	eerror If you file a bug, please attach the following logfiles:
	eerror ${PORT_LOGDIR}/cross-${CTARGET}-info.log
	eerror ${logfile}
	exit 1
}

usage() {
cat << EOF
Usage: ${HILITE}crossdev${NORMAL} ${GOOD}[options]${NORMAL} ${BRACKET}--target TARGET${NORMAL}

Options:
    ${GOOD}--b, --binutils${NORMAL} ver   Specify version of binutils to use
    ${GOOD}--g, --gcc${NORMAL} ver        Specify version of gcc to use
    ${GOOD}--k, --kernel${NORMAL} ver     Specify version of kernel headers to use
    ${GOOD}--l, --libc${NORMAL} ver       Specify version of libc to use
    ${GOOD}-C, --clean${NORMAL} target    Uninstall specified target
    ${GOOD}-b, -d, -p, -v${NORMAL}        Options to pass to emerge (see emerge(1))
Stage Options:
    ${GOOD}-s0, --stage0${NORMAL}         Build just binutils
    ${GOOD}-s1, --stage1${NORMAL}         Also build a C compiler (no libc/C++)
    ${GOOD}-s2, --stage2${NORMAL}         Also build kernel headers
    ${GOOD}-s3, --stage3${NORMAL}         Also build the C library (no C++)
    ${GOOD}-s4, --stage4${NORMAL}         Also build a C++ compiler [default]
Extra Fun (must be run after above stages):
    ${GOOD}--ex-only${NORMAL}             Skip the stage steps above
    ${GOOD}--ex-gcc${NORMAL}              Build extra gcc targets (gcj/ada/etc...)
    ${GOOD}--ex-gdb${NORMAL}              Build a cross gdb

${BRACKET}Target (-t)${NORMAL}:   takes the form: ${BRACKET}ARCH-VENDOR-OS-LIBC${NORMAL}
    Run 'crossdev -t help' for examples
EOF
	exit ${1:-0}
}
STAGE_BINUTILS=0
STAGE_C_ONLY=1
STAGE_LIBC=3
STAGE_C_CPP=4
STAGE_DISP=( "binutils" "C compiler only" "kernel headers" "C compiler & libc" "C/C++ compiler" )

parse_target() {
	[[ -z $1 ]] && usage 1
	CTARGET=${1#cross-}
	local CPRE=${CTARGET%%-*} CPOST=${CTARGET#*-}

	# Did they give us just an ARCH or the full TARGET ?
	if [[ ${CTARGET/-} == ${CTARGET} || -z ${CPOST} ]] ; then
		case ${CPRE} in
			x86|i?86*|amd64|x86_64*) CPOST="pc-linux-gnu";;
			s390*) CPOST="ibm-linux-gnu";;
			*) CPOST="unknown-linux-gnu";;
		esac
	fi

	# Let's accept ARCH in both the portage and the standard forms ...
	# CTARGET is in the standard form while TARCH is in the portage form
	case ${CPRE} in

		#####################
		### linux targets ###
		alpha*)     TARCH=alpha;;
		arm*)       TARCH=arm;;
		hppa*)      TARCH=hppa;;
		parisc)     TARCH=hppa;   CPRE="hppa";;
		ia64*)      TARCH=ia64;;
		i?86*)      TARCH=x86;;
		x86)        TARCH=x86;    CPRE="i386";;
		m68*)       TARCH=m68k;;
		mips*)      TARCH=mips ;  KPKG="mips-headers";;
		powerpc64*) TARCH=ppc64;;
		ppc64)      TARCH=ppc64;  CPRE="powerpc64";;
		powerpc*)   TARCH=ppc;;
		ppc)        TARCH=ppc;    CPRE="powerpc";;
		sparc*)     TARCH=sparc;;
		s390*)      TARCH=s390;;
		sh*)        TARCH=sh;;
		x86_64*)    TARCH=amd64;;
		amd64)      TARCH=amd64;  CPRE="x86_64";;

		#####################
		### other targets ###
		avr*) TARCH=${HARCH}; CPOST="";
		      KPKG="[none]"; STAGE=${STAGE_LIBC};
		      LCAT="dev-embedded"; LPKG="avr-libc";
		      GVER="3.4.4-r1"; BVER="2.16.1";
		      GUSE="-fortran -gtk -gcj -objc";;

		msp430)
		      TARCH=${HARCH}; CPOST="";
		      STAGE=${STAGE_BINUTILS};;

		ps2*) einfo "The ps2 target is really an alias for the ee/iop/dvp targets"
		      ${CROSSDEV} -t ee  || exit 1
		      ${CROSSDEV} -t iop || exit 1
		      ${CROSSDEV} -t dvp || exit 1
		      exit 0;;
		ee*)  TARCH=${HARCH}; CPOST="";
		      KPKG="[none]"
		      GVER="3.2.2"; BVER="2.14";
		      STAGE=${STAGE_C_ONLY};
		      GUSE="-fortran -gtk -gcj -objc";;
		iop*) TARCH=${HARCH}; CPOST="";
		      GVER="3.2.2"; BVER="2.14";
		      STAGE=${STAGE_C_ONLY};
		      GUSE="-fortran -gtk -gcj -objc";;
		dvp*) TARCH=${HARCH}; CPOST="";
		      GVER="3.2.2"; BVER="2.14";
		      STAGE=${STAGE_BINUTILS};;

		############
		### help ###
		help)
			cat <<-EOF
			Supported Architectures:
			   alpha
			   arm / armeb
			   hppa (parisc)
			   ia64
			   i386 / i486 / i586 / i686 (x86)
			   m68k
			   mips / mipsel / mips64 / mips64el
			   powerpc (ppc) / powerpc64 (ppc64)
			   sparc / sparc64
			   s390 / s390x
			   sh / sh[1-5] / sh64
			   x86_64 (amd64)
			Supported C Libraries:
			   gnu (glibc)
			   klibc       [prob wont work]
			   uclibc      [not all arches are ported]
			Special Targets:
			   avr
			   msp430
			   ee / iop / dvp (ps2) [Playstation 2 targets]
			EOF
			exit 0
			;;

		#######################
		### unknown targets ###
		*) usage 1;;
	esac

	CTARGET=${CPRE}
	[[ -n ${CPOST} ]] && CTARGET=${CTARGET}-${CPOST}

	# Tweak packages based upon CTARGET
	case ${CTARGET} in
		# Normal Linux host, just diff libc
		*-dietlibc) LPKG="dietlibc";;
		*-klibc)    LPKG="klibc";;
		*-uclibc)   LPKG="uclibc";;

		# Now for the BSDs ...
		*-freebsd*)
			TARCH="${TARCH}-fbsd"
			LCAT="sys-freebsd" LPKG="freebsd-lib"
			KCAT="sys-freebsd" KPKG="freebsd-headers"
			;;
	esac
}

setup_portage_vars() {
	PORTDIR_OVERLAY=$(portageq envvar PORTDIR_OVERLAY)
	PORTDIR_OVERLAY=${PORTDIR_OVERLAY%% *}
	PORTDIR=$(portageq envvar PORTDIR)
	PORT_LOGDIR=$(portageq envvar PORT_LOGDIR)
	PORT_LOGDIR=${PORT_LOGDIR:-/var/log/portage}
	export PKGDIR=$(portageq envvar PKGDIR)/cross/${CTARGET}
	export PORTAGE_TMPDIR=$(portageq envvar PORTAGE_TMPDIR)/cross/${CTARGET}
	[[ ! -d ${PORT_LOGDIR} ]] && mkdir -p ${PORT_LOGDIR}
	[[ ! -d ${PORTAGE_TMPDIR} ]] && mkdir -p ${PORTAGE_TMPDIR}
}

uninstall() {
	setup_portage_vars

	ewarn "Uninstalling target '${CTARGET}' ..."

	[[ -d ${PORTDIR_OVERLAY}/cross-${CTARGET} ]] \
		&& rm -r ${PORTDIR_OVERLAY}/cross-${CTARGET}
	for f in mask keywords use ; do
		f="/etc/portage/package.${f}"
		[[ ! -e ${f} ]] && continue
		sed -i -e "/cross-${CTARGET}\//d" ${f}
	done

	if [[ ! -d /var/db/pkg/cross-${CTARGET} ]] ; then
		eerror "${CTARGET} is not installed."
		exit 1
	fi

	export CLEAN_DELAY=0
	cd /var/db/pkg
	for p in cross-${CTARGET}/* ; do
		emerge -C =${p} || exit 1
	done
	for b in addr2line ar as c++filt ld nm objcopy objdump ranlib readelf size strings strip ; do
		rm -f /usr/bin/${CTARGET}-${b} /usr/${CTARGET}/bin/${b}
	done
	rm -f /usr/${CTARGET}/{sys-include,usr}
	rm -f /usr/bin/${CTARGET}-{gcc,{c,g}++}
	rmdir /usr/${CTARGET}/{include/asm,include} &> /dev/null
	for d in /usr/${CTARGET} /usr/lib/gcc{,-lib}/${CTARGET} ; do
		if [[ ! -d ${d} ]] ; then
			rm -f "${d}" &> /dev/null
		else
			rmdir "${d}" &> /dev/null && continue
			rm -ri "${d}"
		fi
	done
	rm -f /etc/env.d/{binutils,gcc}/config-${CTARGET}
	rmdir /var/db/pkg/cross-${CTARGET}

	exit 0
}

is_stage() { [[ ${STAGE} -ge $1 ]] ; }
is_s0()    { is_stage 0 ; }
is_s1()    { is_stage 1 ; }
is_s2()    { is_stage 2 ; }
is_s3()    { is_stage 3 ; }
is_s4()    { is_stage 4 ; }
is_s5()    { is_stage 5 ; }

ex_fast()  { [[ ${EX_FAST} == "yes" ]] ; }
ex_gcc()   { [[ ${EX_GCC} == "yes" ]] ; }
ex_gdb()   { [[ ${EX_GDB} == "yes" ]] ; }

hr() {
	local c=${COLUMNS:-0}
	if [[ ${c} -eq 0 ]] ; then
		c=$(stty size 2> /dev/null)
		[[ -z ${c} ]] \
			&& c=50 \
			|| c=${c##* }
	fi
	local ext=${1:-  _  -  ~  -} br=""
	while [[ ${#br} -lt ${c} ]] ; do
		br=${br}${ext}
	done
	echo "${br:0:${c}}"
}

##################
### setup vars ###
CROSSDEV=$0
EOPTS=
UOPTS=
TARCH=
HARCH=$(env -uARCH portageq envvar ARCH)
CTARGET=
STAGE=COW
BCAT="sys-devel"  ; BPKG="binutils"      ; BVER="[latest]" ; BUSE=""
GCAT="sys-devel"  ; GPKG="gcc"           ; GVER="[latest]" ; GUSE=""
KCAT="sys-kernel" ; KPKG="linux-headers" ; KVER="[latest]" ; KUSE=""
LCAT="sys-libs"   ; LPKG="glibc"         ; LVER="[latest]" ; LUSE=""
EX_FAST="no"
EX_GCC="no"
EX_GDB="no"

while [[ $# -gt 0 ]] ; do
	case $1 in
	-V|--version)   echo "crossdev-GENTOO_PV"; exit 0;;
	-t|--target)    shift; parse_target $1;;
	--b|--binutils) shift; BVER=$1;;
	--g|--gcc)      shift; GVER=$1;;
	--k|--kernel)   shift; KVER=$1;;
	--l|--libc)     shift; LVER=$1;;
	-C|--clean)     shift; parse_target $1; uninstall;;
	-s?|--stage?)   [[ ${STAGE} == "COW" ]] && STAGE=${1:0-1};;
	--ex-only)      EX_FAST="yes";;
	--ex-gcc)       EX_GCC="yes";;
	--ex-gdb)       EX_GDB="yes";;
	-b|-d|-p|-v)    UOPTS="${UOPTS} $1";;
	-pv|-vp)        UOPTS="${UOPTS} -p -v";;
	-h|--help)      usage;;
	-*)             eerror "UNKNOWN OPTION: '$1'" ; usage 1;;
	*)              parse_target $1;;
	esac
	shift
done

[[ -z ${CTARGET} ]] && usage 1
[[ ${STAGE} == "COW" ]] && STAGE=${STAGE_C_CPP}

#####################
### sanity checks ###
if ! binutils-config -v &> /dev/null ; then
	eerror "Sorry, but your host system needs to have binutils-config"
	eerror "in order to keep from screwing things up."
	eerror "That means you must be running unstable versions of"
	eerror "both binutils and binutils-config."
	exit 1
fi
if ! egrep -qs 'inherit.*toolchain( |$)' /var/db/pkg/sys-devel/gcc-*/*.ebuild ; then
	eerror "Sorry, but your host system needs to have"
	eerror "an unstable version of gcc in order to"
	eerror "keep from screwing things up."
	exit 1
fi

setup_portage_vars
if [[ -z ${PORTDIR_OVERLAY} ]] ; then
	eerror "You need to set PORTDIR_OVERLAY in your make.conf."
	eerror "A standard setting is /usr/local/portage"
	exit 1
fi

if [[ $(env -u CHOST portageq envvar CHOST) == ${CTARGET} ]] ; then
	eerror "Refusing to create a cross-compiler using the same"
	eerror "target name as your host utils."
	exit 1
fi

#####################
### do the emerge ###
(
hr -
einfo "Host Portage ARCH:     ${HARCH}"
einfo "Target Portage ARCH:   ${TARCH}"
einfo "Target System:         ${CTARGET}"
einfo "Stage:                 ${STAGE} (${STAGE_DISP[${STAGE}]})"
echo
ex_fast || {
is_s0 && {
einfo "binutils:              ${BPKG}-${BVER}"
}
is_s1 && {
einfo "gcc:                   ${GPKG}-${GVER}"
}
is_s2 && {
[[ ${KPKG} != "[none]" ]] && \
einfo "headers:               ${KPKG}-${KVER}"
}
is_s3 && {
einfo "libc:                  ${LPKG}-${LVER}"
}
}
ex_gcc && {
einfo "Extra: gcc pass:       DO IT"
}
ex_gdb && {
einfo "Extra: gdb:            DO IT"
}
echo
einfo "PORTDIR_OVERLAY:       ${PORTDIR_OVERLAY}"
einfo "PORT_LOGDIR:           ${PORT_LOGDIR}"
einfo "PKGDIR:                ${PKGDIR}"
einfo "PORTAGE_TMPDIR:        ${PORTAGE_TMPDIR}"
hr
) >& ${PORT_LOGDIR}/cross-${CTARGET}-info.log || exit 1
cat ${PORT_LOGDIR}/cross-${CTARGET}-info.log
emerge info >> ${PORT_LOGDIR}/cross-${CTARGET}-info.log

####################################
### Fix up portage files / paths ###

set_keywords() {
	local pkg=$1 ver=$2
	[[ -z ${pkg} ]] && return 0
	sed -i -e "/cross-${CTARGET}\/${pkg}/d" package.keywords package.mask
	if [[ ${ver} == "[latest]" ]] || [[ -z ${ver} ]] ; then
		echo "cross-${CTARGET}/${pkg} $TARCH ~$TARCH" >> package.keywords
	else
		echo ">cross-${CTARGET}/${pkg}-${ver}" >> package.mask
		echo "cross-${CTARGET}/${pkg} * ~* -*" >> package.keywords
	fi
}
set_use() {
	local pkg=$1
	[[ -z ${pkg} ]] && return 0
	shift
	local use=$@
	[[ -z ${use} ]] && return
	sed -i -e "/cross-${CTARGET}\/${pkg}/d" package.use
	echo "cross-${CTARGET}/${pkg} ${use}" >> package.use
}
set_links() {
	local cat=$1 pkg=$2
	[[ -e ${PORTDIR_OVERLAY}/cross-${CTARGET}/${pkg} ]] \
		&& rm -f "${PORTDIR_OVERLAY}"/cross-${CTARGET}/${pkg}
	ln -s "${PORTDIR}"/${cat}/${pkg} "${PORTDIR_OVERLAY}"/cross-${CTARGET}/${pkg}
}
set_portage() {
	local cat=$1 pkg=$2 ver=$3
	shift ; shift ; shift
	local use=$@

	[[ ${pkg} == "[none]" ]] && return 0

	set_keywords ${pkg} ${ver}
	set_use ${pkg} ${use}
	set_links ${cat} ${pkg}
}

mkdir -p /etc/portage
grep -qs "^cross-${CTARGET}$" /etc/portage/categories \
	|| echo cross-${CTARGET} >> /etc/portage/categories
mkdir -p "${PORTDIR_OVERLAY}"/cross-${CTARGET}
cd /etc/portage
touch package.{keywords,mask,use}

          set_portage ${BCAT} ${BPKG} ${BVER} ${BUSE}
is_s1  && set_portage ${GCAT} ${GPKG} ${GVER} ${GUSE}
is_s2  && set_portage ${KCAT} ${KPKG} ${KVER} ${KUSE}
is_s2  && set_portage ${LCAT} ${LPKG} ${LVER} ${LUSE}
ex_gdb && set_portage sys-devel gdb

#################
doemerge() {
	[[ $1 == "[none]" ]] && return 0

	local logfile=${PORT_LOGDIR}/cross-${CTARGET}
	[[ -z $2 ]] \
		&& logfile=${logfile}-$1.log \
		|| logfile=${logfile}-$2.log

	einfo "Log: ${logfile}"
	ebegin "Emerging cross-${2:-$1}"
	if [[ ${UOPTS/-v} != ${UOPTS} ]] ; then
		emerge cross-${CTARGET}/$1 ${EOPTS} \
			2>&1 | tee ${logfile}
	else
		emerge cross-${CTARGET}/$1 ${EOPTS} \
			>& ${logfile}
	fi
	local _pipestatus=${PIPESTATUS[*]}
	[[ "${_pipestatus// /}" -eq 0 ]] || die "$1 failed :("
	eend 0
}

# we include the '-u' so that we don't re-emerge packages
EOPTS="${UOPTS} -u --nodeps"

# make sure multilib crap doesn't screw us over
export ABI=${ABI:-pos} LIBDIR_pos="lib" CFLAGS_pos="" LDFLAGS_pos=""

ex_fast || {

doemerge ${BPKG}
is_s1 || exit 0

USE="${USE} -boundschecking -fortran -gcj -objc nocxx -static" \
	doemerge ${GPKG} ${GPKG}-stage1
is_s2 || exit 0
doemerge ${KPKG}
is_s3 || exit 0
USE="${USE} $TARCH" doemerge ${LPKG}

is_s4 || exit 0
if ! type -p ${CTARGET}-g++ > /dev/null ; then
	EOPTS="${UOPTS} --nodeps"
fi
USE="${USE} -fortran -gcj -objc" \
	doemerge ${GPKG} ${GPKG}-stage2

}

ex_gcc && doemerge ${GPKG} ${GPK}-extra
ex_gdb && doemerge gdb

exit 0
