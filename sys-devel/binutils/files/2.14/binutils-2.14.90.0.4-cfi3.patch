2003-06-11  Richard Henderson  <rth@redhat.com>

	* dw2gencfi.c (struct cfi_escape_data): New.
	(cfi_add_CFA_nop): Remove.
	(CFI_escape, dot_cfi_escape): New.
	(dot_cfi): Remove nop.
	(cfi_pseudo_table): Remove nop; add escape.
	(output_cfi_insn): Likewise.
	(select_cie_for_fde): Stop on escape.
	* dw2gencfi.h (cfi_add_CFA_nop): Remove.
	* read.c, read.h (do_parse_cons_expression): New.

2003-06-07  Richard Henderson  <rth@redhat.com>

	* dw2gencfi.c (struct cfa_save_data, cfa_save_stack): New.
	(cfi_add_CFA_offset): Detect invalid offsets.
	(cfi_add_CFA_remember_state): Save cur_cfa_offset.
	(cfi_add_CFA_restore_state): Restore it.
	(CFI_rel_offset): New.
	(cfi_pseudo_table): Add it.
	(dot_cfi): Handle it.

testsuite/
2003-06-11  Richard Henderson  <rth@redhat.com>

	* gas/cfi/cfi-common-3.[ds]: New.
	* gas/cfi/cfi.exp: Run it.

2003-06-10  Alan Modra  <amodra@bigpond.net.au>

	* lib/gas-defs.exp (proc is_elf_format): Copy from ld testsuite.
	* gas/cfi/cfi.exp: Use here.  Only run tests when ELF.

2003-06-07  Richard Henderson  <rth@redhat.com>

	* gas/cfi/cfi-common-1.d, gas/cfi/cfi-common-1.s: New.
	* gas/cfi/cfi-common-2.d, gas/cfi/cfi-common-2.s: New.
	* gas/cfi/cfi-diag-1.d, gas/cfi/cfi-diag-1.s: New.
	* gas/cfi/cfi.exp: Run them.

--- gas/dw2gencfi.c	5 Jun 2003 09:23:47 -0000	1.10
+++ gas/dw2gencfi.c	11 Jun 2003 23:16:57 -0000	1.12
@@ -68,6 +68,11 @@ struct cfi_insn_data
       symbolS *lab1;
       symbolS *lab2;
     } ll;
+
+    struct cfi_escape_data {
+      struct cfi_escape_data *next;
+      expressionS exp;
+    } *esc;
   } u;
 };
 
@@ -102,6 +107,14 @@ static struct fde_entry **last_fde_data 
 /* List of CIEs so that they could be reused.  */
 static struct cie_entry *cie_root;
 
+/* Stack of old CFI data, for save/restore.  */
+struct cfa_save_data
+{
+  struct cfa_save_data *next;
+  offsetT cfa_offset;
+};
+
+static struct cfa_save_data *cfa_save_stack;
 
 /* Construct a new FDE structure and add it to the end of the fde list.  */
 
@@ -231,7 +244,14 @@ cfi_add_advance_loc (symbolS *label)
 void
 cfi_add_CFA_offset (unsigned regno, offsetT offset)
 {
+  unsigned int abs_data_align;
+
   cfi_add_CFA_insn_reg_offset (DW_CFA_offset, regno, offset);
+
+  abs_data_align = (DWARF2_CIE_DATA_ALIGNMENT < 0
+		    ? -DWARF2_CIE_DATA_ALIGNMENT : DWARF2_CIE_DATA_ALIGNMENT);
+  if (offset % abs_data_align)
+    as_bad (_("register save offset not a multiple of %u"), abs_data_align);
 }
 
 /* Add a DW_CFA_def_cfa record to the CFI data.  */
@@ -289,31 +309,45 @@ cfi_add_CFA_same_value (unsigned regno)
 void
 cfi_add_CFA_remember_state (void)
 {
+  struct cfa_save_data *p;
+
   cfi_add_CFA_insn (DW_CFA_remember_state);
+
+  p = xmalloc (sizeof (*p));
+  p->cfa_offset = cur_cfa_offset;
+  p->next = cfa_save_stack;
+  cfa_save_stack = p;
 }
 
 void
 cfi_add_CFA_restore_state (void)
 {
+  struct cfa_save_data *p;
+
   cfi_add_CFA_insn (DW_CFA_restore_state);
-}
 
-void
-cfi_add_CFA_nop (void)
-{
-  cfi_add_CFA_insn (DW_CFA_nop);
+  p = cfa_save_stack;
+  if (p)
+    {
+      cur_cfa_offset = p->cfa_offset;
+      cfa_save_stack = p->next;
+      free (p);
+    }
 }
 
 
 /* Parse CFI assembler directives.  */
 
 static void dot_cfi (int);
+static void dot_cfi_escape (int);
 static void dot_cfi_startproc (int);
 static void dot_cfi_endproc (int);
 
 /* Fake CFI type; outside the byte range of any real CFI insn.  */
 #define CFI_adjust_cfa_offset	0x100
 #define CFI_return_column	0x101
+#define CFI_rel_offset		0x102
+#define CFI_escape		0x103
 
 const pseudo_typeS cfi_pseudo_table[] =
   {
@@ -324,6 +358,7 @@ const pseudo_typeS cfi_pseudo_table[] =
     { "cfi_def_cfa_offset", dot_cfi, DW_CFA_def_cfa_offset },
     { "cfi_adjust_cfa_offset", dot_cfi, CFI_adjust_cfa_offset },
     { "cfi_offset", dot_cfi, DW_CFA_offset },
+    { "cfi_rel_offset", dot_cfi, CFI_rel_offset },
     { "cfi_register", dot_cfi, DW_CFA_register },
     { "cfi_return_column", dot_cfi, CFI_return_column },
     { "cfi_restore", dot_cfi, DW_CFA_restore },
@@ -331,7 +366,7 @@ const pseudo_typeS cfi_pseudo_table[] =
     { "cfi_same_value", dot_cfi, DW_CFA_same_value },
     { "cfi_remember_state", dot_cfi, DW_CFA_remember_state },
     { "cfi_restore_state", dot_cfi, DW_CFA_restore_state },
-    { "cfi_nop", dot_cfi, DW_CFA_nop },
+    { "cfi_escape", dot_cfi_escape, 0 },
     { NULL, NULL, 0 }
   };
 
@@ -422,6 +457,13 @@ dot_cfi (int arg)
       cfi_add_CFA_offset (reg1, offset);
       break;
 
+    case CFI_rel_offset:
+      reg1 = cfi_parse_reg ();
+      cfi_parse_separator ();
+      offset = cfi_parse_const ();
+      cfi_add_CFA_offset (reg1, offset - cur_cfa_offset);
+      break;
+
     case DW_CFA_def_cfa:
       reg1 = cfi_parse_reg ();
       cfi_parse_separator ();
@@ -479,10 +521,6 @@ dot_cfi (int arg)
       cfi_add_CFA_restore_state ();
       break;
 
-    case DW_CFA_nop:
-      cfi_add_CFA_nop ();
-      break;
-
     default:
       abort ();
     }
@@ -491,6 +529,39 @@ dot_cfi (int arg)
 }
 
 static void
+dot_cfi_escape (int ignored ATTRIBUTE_UNUSED)
+{
+  struct cfi_escape_data *head, **tail, *e;
+  struct cfi_insn_data *insn;
+
+  if (!cur_fde_data)
+    {
+      as_bad (_("CFI instruction used without previous .cfi_startproc"));
+      return;
+    }
+
+  /* If the last address was not at the current PC, advance to current.  */
+  if (symbol_get_frag (last_address) != frag_now
+      || S_GET_VALUE (last_address) != frag_now_fix ())
+    cfi_add_advance_loc (symbol_temp_new_now ());
+
+  tail = &head;
+  do
+    {
+      e = xmalloc (sizeof (*e));
+      do_parse_cons_expression (&e->exp, 1);
+      *tail = e;
+      tail = &e->next;
+    }
+  while (*input_line_pointer++ == ',');
+  *tail = NULL;
+
+  insn = alloc_cfi_insn_data ();
+  insn->insn = CFI_escape;
+  insn->u.esc = head;
+}
+
+static void
 dot_cfi_startproc (int ignored ATTRIBUTE_UNUSED)
 {
   int simple = 0;
@@ -716,10 +787,17 @@ output_cfi_insn (struct cfi_insn_data *i
 
     case DW_CFA_remember_state:
     case DW_CFA_restore_state:
-    case DW_CFA_nop:
       out_one (insn->insn);
       break;
 
+    case CFI_escape:
+      {
+	struct cfi_escape_data *e;
+	for (e = insn->u.esc; e ; e = e->next)
+	  emit_expr (&e->exp, 1);
+	break;
+      }
+
     default:
       abort ();
     }
@@ -850,6 +928,10 @@ select_cie_for_fde (struct fde_entry *fd
 	      if (i->u.i != j->u.i)
 		goto fail;
 	      break;
+
+	    case CFI_escape:
+	      /* Don't bother matching these for now.  */
+	      goto fail;
 
 	    default:
 	      abort ();
--- gas/dw2gencfi.h	5 Jun 2003 09:23:47 -0000	1.3
+++ gas/dw2gencfi.h	11 Jun 2003 23:16:57 -0000	1.4
@@ -48,6 +48,5 @@ extern void cfi_add_CFA_undefined (unsig
 extern void cfi_add_CFA_same_value (unsigned);
 extern void cfi_add_CFA_remember_state (void);
 extern void cfi_add_CFA_restore_state (void);
-extern void cfi_add_CFA_nop (void);
 
 #endif /* DW2GENCFI_H */
--- gas/read.c	2 Jun 2003 22:48:58 -0000	1.63
+++ gas/read.c	11 Jun 2003 23:16:57 -0000	1.64
@@ -3346,6 +3346,13 @@ parse_repeat_cons PARAMS ((expressionS *
 #endif
 #endif
 
+void
+do_parse_cons_expression (expressionS *exp, int nbytes)
+{
+  TC_PARSE_CONS_EXPRESSION (exp, nbytes);
+}
+
+
 /* Worker to do .byte etc statements.
    Clobbers input_line_pointer and checks end-of-line.  */
 
--- gas/read.h	3 May 2003 06:10:59 -0000	1.17
+++ gas/read.h	11 Jun 2003 23:16:57 -0000	1.18
@@ -133,6 +133,7 @@ extern void stabs_generate_asm_func PARA
 extern void stabs_generate_asm_endfunc PARAMS ((const char *, const char *));
 extern void do_repeat PARAMS((int,const char *,const char *));
 extern void end_repeat PARAMS((int));
+extern void do_parse_cons_expression PARAMS ((expressionS *, int));
 
 extern void generate_lineno_debug PARAMS ((void));
 
--- gas/testsuite/gas/cfi/cfi.exp	5 Jun 2003 03:27:03 -0000	1.4
+++ gas/testsuite/gas/cfi/cfi.exp	11 Jun 2003 23:16:58 -0000	1.7
@@ -1,21 +1,37 @@
+# ??? This probably shouldn't be replicated here...
+proc run_list_test { name opts } {
+    global srcdir subdir
+    set testname "cfi $name"
+    set file $srcdir/$subdir/$name
+    gas_run ${name}.s $opts ">&dump.out"
+    if { [regexp_diff "dump.out" "${file}.l"] } then {
+        fail $testname
+        verbose "output is [file_contents "dump.out"]" 2
+        return
+    }
+    pass $testname
+}
+
+if ![is_elf_format] then {
+    return
+}
+
 if [istarget "x86_64-*"] then {
     run_dump_test "cfi-x86_64"
-}
 
-if [istarget "i?86-*"] then {
+} elseif [istarget "i?86-*"] then {
     run_dump_test "cfi-i386"
-}
 
-if { [istarget alpha*-*-*] } then {
+} elseif { [istarget alpha*-*-*] } then {
+    run_dump_test "cfi-alpha-1"
+    run_dump_test "cfi-alpha-2"
+    run_dump_test "cfi-alpha-3"
 
-    set elf [expr [istarget *-*-elf*] \
-                  || [istarget *-*-linux*] \
-                  || [istarget *-*-freebsd*] \
-                  || [istarget *-*-netbsd*] ]
-
-    if $elf {
-	run_dump_test "cfi-alpha-1"
-	run_dump_test "cfi-alpha-2"
-	run_dump_test "cfi-alpha-3"
-    }
+} else {
+    return
 }
+
+run_list_test "cfi-diag-1" ""
+run_dump_test "cfi-common-1"
+run_dump_test "cfi-common-2"
+run_dump_test "cfi-common-3"
--- gas/testsuite/lib/gas-defs.exp	16 May 2003 16:30:25 -0000	1.12
+++ gas/testsuite/lib/gas-defs.exp	10 Jun 2003 13:31:59 -0000	1.13
@@ -182,6 +182,43 @@ proc gas_init { args } {
     return
 }
 
+#
+# is_elf_format
+#	true if the object format is known to be ELF
+#
+proc is_elf_format {} {
+    if { ![istarget *-*-sysv4*] \
+	 && ![istarget *-*-unixware*] \
+	 && ![istarget *-*-elf*] \
+	 && ![istarget *-*-eabi*] \
+	 && ![istarget hppa*64*-*-hpux*] \
+	 && ![istarget *-*-linux*] \
+	 && ![istarget *-*-irix5*] \
+	 && ![istarget *-*-irix6*] \
+	 && ![istarget *-*-netbsd*] \
+	 && ![istarget *-*-solaris2*] } {
+	return 0
+    }
+
+    if { [istarget *-*-linux*aout*] \
+	 || [istarget *-*-linux*oldld*] } {
+	return 0
+    }
+
+    if { ![istarget *-*-netbsdelf*] \
+	 && ([istarget *-*-netbsd*aout*] \
+	     || [istarget *-*-netbsdpe*] \
+	     || [istarget arm*-*-netbsd*] \
+	     || [istarget sparc-*-netbsd*] \
+	     || [istarget i*86-*-netbsd*] \
+	     || [istarget m68*-*-netbsd*] \
+	     || [istarget vax-*-netbsd*] \
+	     || [istarget ns32k-*-netbsd*]) } {
+    	return 0
+    }
+    return 1
+}
+
 
 # run_dump_test FILE (optional:) EXTRA_OPTIONS
 #
--- gas/testsuite/gas/cfi/cfi-common-1.d	2003-01-30 05:24:37.000000000 -0500
+++ gas/testsuite/gas/cfi/cfi-common-1.d	2003-06-07 23:59:44.000000000 -0400
@@ -0,0 +1,24 @@
+#readelf: -wf
+#name: CFI common 1
+The section .eh_frame contains:
+
+00000000 00000010 00000000 CIE
+  Version:               1
+  Augmentation:          "zR"
+  Code alignment factor: .*
+  Data alignment factor: .*
+  Return address column: .*
+  Augmentation data:     1b
+
+  DW_CFA_nop
+  DW_CFA_nop
+  DW_CFA_nop
+
+00000014 00000018 00000018 FDE cie=00000000 pc=.*
+  DW_CFA_advance_loc: 4 to .*
+  DW_CFA_def_cfa: r0 ofs 16
+  DW_CFA_offset: r1 at cfa-8
+  DW_CFA_advance_loc: 4 to .*
+  DW_CFA_def_cfa_offset: 32
+  DW_CFA_offset: r2 at cfa-24
+
--- gas/testsuite/gas/cfi/cfi-common-1.s	2003-01-30 05:24:37.000000000 -0500
+++ gas/testsuite/gas/cfi/cfi-common-1.s	2003-06-07 23:59:44.000000000 -0400
@@ -0,0 +1,8 @@
+	.cfi_startproc simple
+	.long 0
+	.cfi_def_cfa 0, 16
+	.cfi_rel_offset 1, 8
+	.long 0
+	.cfi_adjust_cfa_offset 16
+	.cfi_rel_offset 2, 8
+	.cfi_endproc
--- gas/testsuite/gas/cfi/cfi-common-2.d	2003-01-30 05:24:37.000000000 -0500
+++ gas/testsuite/gas/cfi/cfi-common-2.d	2003-06-07 23:59:44.000000000 -0400
@@ -0,0 +1,29 @@
+#readelf: -wf
+#name: CFI common 2
+The section .eh_frame contains:
+
+00000000 00000010 00000000 CIE
+  Version:               1
+  Augmentation:          "zR"
+  Code alignment factor: .*
+  Data alignment factor: .*
+  Return address column: .*
+  Augmentation data:     1b
+
+  DW_CFA_nop
+  DW_CFA_nop
+  DW_CFA_nop
+
+00000014 0000001c 00000018 FDE cie=00000000 pc=.*
+  DW_CFA_advance_loc: 4 to .*
+  DW_CFA_def_cfa: r0 ofs 16
+  DW_CFA_advance_loc: 4 to .*
+  DW_CFA_remember_state
+  DW_CFA_advance_loc: 4 to .*
+  DW_CFA_def_cfa_offset: 0
+  DW_CFA_advance_loc: 4 to .*
+  DW_CFA_restore_state
+  DW_CFA_advance_loc: 4 to .*
+  DW_CFA_def_cfa_offset: 0
+  DW_CFA_nop
+
--- gas/testsuite/gas/cfi/cfi-common-2.s	2003-01-30 05:24:37.000000000 -0500
+++ gas/testsuite/gas/cfi/cfi-common-2.s	2003-06-07 23:59:44.000000000 -0400
@@ -0,0 +1,12 @@
+	.cfi_startproc simple
+	.long 0
+	.cfi_def_cfa 0, 16
+	.long 0
+	.cfi_remember_state
+	.long 0
+	.cfi_adjust_cfa_offset -16
+	.long 0
+	.cfi_restore_state
+	.long 0
+	.cfi_adjust_cfa_offset -16
+	.cfi_endproc
--- gas/testsuite/gas/cfi/cfi-common-3.d	2003-01-30 05:24:37.000000000 -0500
+++ gas/testsuite/gas/cfi/cfi-common-3.d	2003-06-11 19:16:58.000000000 -0400
@@ -0,0 +1,21 @@
+#readelf: -wf
+#name: CFI common 2
+The section .eh_frame contains:
+
+00000000 00000010 00000000 CIE
+  Version:               1
+  Augmentation:          "zR"
+  Code alignment factor: .*
+  Data alignment factor: .*
+  Return address column: .*
+  Augmentation data:     1b
+
+  DW_CFA_nop
+  DW_CFA_nop
+  DW_CFA_nop
+
+00000014 00000010 00000018 FDE cie=00000000 pc=.*
+  DW_CFA_advance_loc: 4 to .*
+  DW_CFA_remember_state
+  DW_CFA_restore_state
+
--- gas/testsuite/gas/cfi/cfi-common-3.s	2003-01-30 05:24:37.000000000 -0500
+++ gas/testsuite/gas/cfi/cfi-common-3.s	2003-06-11 19:16:58.000000000 -0400
@@ -0,0 +1,4 @@
+	.cfi_startproc simple
+	.long 0
+	.cfi_escape 10, 11
+	.cfi_endproc
--- gas/testsuite/gas/cfi/cfi-diag-1.l	2003-01-30 05:24:37.000000000 -0500
+++ gas/testsuite/gas/cfi/cfi-diag-1.l	2003-06-07 23:59:44.000000000 -0400
@@ -0,0 +1,2 @@
+.*: Assembler messages:
+.*:2: Error: register save offset not a multiple of .*
--- gas/testsuite/gas/cfi/cfi-diag-1.s	2003-01-30 05:24:37.000000000 -0500
+++ gas/testsuite/gas/cfi/cfi-diag-1.s	2003-06-07 23:59:44.000000000 -0400
@@ -0,0 +1,3 @@
+	.cfi_startproc
+	.cfi_offset 0, 1
+	.cfi_endproc
