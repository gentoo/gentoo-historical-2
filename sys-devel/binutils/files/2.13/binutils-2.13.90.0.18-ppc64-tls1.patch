2003-02-09  Alan Modra  <amodra@bigpond.net.au>

bfd/ChangeLog
	* elf64-ppc.c (TLS_GD_LD): Don't define..
	(TLS_GD): ..define this instead and update all uses.
	(TLS_TPRELGD): Define.
	(ppc64_elf_link_hash_table_create): Tweak initialization of
	init_refcount and init_offset.
	(ppc64_elf_check_relocs): Add one extra element to t_symndx array.
	Mark second slot of GD or LD toc entries.
	(get_tls_type): Return an int.  Distinguish toc GD and LD entries
	from other tls types.
	(ppc64_elf_tls_setup): New function, split out from..
	(ppc64_elf_tls_optimize): ..here.  Don't optimize when symbols are
	defined in a dynamic object.  Fix LD optimization.  Don't set TLS_TPREL
	on GD->IE optimization, use TLS_TPRELGD instead.  Use get_tls_type
	return value to properly decide whether toc GD and LD entries can
	optimize away __tls_get_addr call.  Check next reloc after DTPMOD64
	to determine GD or LD rather than looking at TLS_LD flag.  Don't
	attempt to adjust got entry tls_type here..
	(allocate_dynrelocs): ..instead, adjust got entry tls_type here, and
	look for possible merges.
	(ppc64_elf_size_dynamic_sections): Adjust local got entries for
	optimization.
	(ppc64_elf_size_stubs): Tweak __tls_get_addr fudge.
	(ppc64_elf_relocate_section): Rename some vars to better reflect usage.
	Make use of return value from get_tls_type to properly detect GD and
	LD optimizations.  Split tlsld/gd hi/ha from lo/ds case.  Don't
	handle tls_get_addr removal when looking at REL24 relocs, do it when
	looking at the previous reloc.  Check reloc after DTPMOD64 to determine
	GD or LD.
	* elf64-ppc.h (ppc64_elf_tls_setup): Declare.

ld/ChangeLog
	* emultempl/ppc64elf.em: Add "no-tls-optimize" option and support code.

ld/testsuite/ChangeLog
	* ld-powerpc/tlslib.s: Give .__tls_get_addr function type.
	* ld-powerpc/tlsexe.d: Update for changed handling of (invalid) ld var
	in dynamic lib.
	* ld-powerpc/tlsexe.g: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsexe.t: Likewise.
	* ld-powerpc/tlsexetoc.d: Likewise.
	* ld-powerpc/tlsexetoc.g: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlsexetoc.t: Likewise.

--- bfd/elf64-ppc.c	5 Feb 2003 15:49:04 -0000	1.81
+++ bfd/elf64-ppc.c	9 Feb 2003 04:34:05 -0000
@@ -2635,11 +2635,12 @@ struct ppc_link_hash_entry
   /* Contexts in which symbol is used in the GOT (or TOC).
      Linker optimization will result in various transformations.  */
 #define TLS_TLS		1	/* Any TLS reloc.  */
-#define TLS_GD_LD	2	/* GD or LD reloc requiring 2 got slots. */
+#define TLS_GD		2	/* GD reloc. */
 #define TLS_LD		4	/* LD reloc. */
 #define TLS_TPREL	8	/* TPREL reloc, => IE. */
 #define TLS_DTPREL     16	/* DTPREL reloc, => LD. */
 #define TLS_EXPLICIT   32	/* Marks TOC section relocs. */
+#define TLS_TPRELGD    64	/* TPREL reloc resulting from GD->IE. */
   char tls_type;
 };
 
@@ -2767,7 +2768,7 @@ static void ppc64_elf_hide_symbol
 static bfd_boolean get_sym_h
   PARAMS ((struct elf_link_hash_entry **, Elf_Internal_Sym **, asection **,
 	   char **, Elf_Internal_Sym **, unsigned long, bfd *));
-static bfd_boolean get_tls_type
+static int get_tls_type
   PARAMS ((char **, Elf_Internal_Sym **, const Elf_Internal_Rela *, bfd *));
 static bfd_boolean allocate_dynrelocs
   PARAMS ((struct elf_link_hash_entry *, PTR));
@@ -2963,7 +2964,13 @@ ppc64_elf_link_hash_table_create (abfd)
   htab->have_undefweak = 0;
   htab->stub_iteration = 0;
   htab->sym_sec.abfd = NULL;
+  /* Initializing two fields of the union is just cosmetic.  We really
+     only care about glist, but when compiled on a 32-bit host the
+     bfd_vma fields are larger.  Setting the bfd_vma to zero makes
+     debugger inspection of these fields look nicer.  */
+  htab->elf.init_refcount.refcount = 0;
   htab->elf.init_refcount.glist = NULL;
+  htab->elf.init_offset.offset = 0;
   htab->elf.init_offset.glist = NULL;
 
   return &htab->elf.root;
@@ -3556,14 +3563,14 @@ ppc64_elf_check_relocs (abfd, info, sec,
 	case R_PPC64_GOT_TLSLD16_HI:
 	case R_PPC64_GOT_TLSLD16_HA:
 	  htab->tlsld_got.refcount += 1;
-	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
+	  tls_type = TLS_TLS | TLS_LD;
 	  goto dogottls;
 
 	case R_PPC64_GOT_TLSGD16:
 	case R_PPC64_GOT_TLSGD16_LO:
 	case R_PPC64_GOT_TLSGD16_HI:
 	case R_PPC64_GOT_TLSGD16_HA:
-	  tls_type = TLS_TLS | TLS_GD_LD;
+	  tls_type = TLS_TLS | TLS_GD;
 	  goto dogottls;
 
 	case R_PPC64_GOT_TPREL16_DS:
@@ -3727,9 +3734,9 @@ ppc64_elf_check_relocs (abfd, info, sec,
 	  if (rel + 1 < rel_end
 	      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)
 	      && rel[1].r_offset == rel->r_offset + 8)
-	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD_LD;
+	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD;
 	  else
-	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_GD_LD | TLS_LD;
+	    tls_type = TLS_EXPLICIT | TLS_TLS | TLS_LD;
 	  goto dotlstoc;
 
 	case R_PPC64_DTPREL64:
@@ -3756,7 +3763,8 @@ ppc64_elf_check_relocs (abfd, info, sec,
 
 	  if (ppc64_elf_section_data (sec)->t_symndx == NULL)
 	    {
-	      bfd_size_type amt = sec->_raw_size * sizeof (unsigned) / 8;
+	      /* One extra to simplify get_tls_type.  */
+	      bfd_size_type amt = sec->_raw_size * sizeof (unsigned) / 8 + 1;
 	      ppc64_elf_section_data (sec)->t_symndx
 		= (unsigned *) bfd_zalloc (abfd, amt);
 	      if (ppc64_elf_section_data (sec)->t_symndx == NULL)
@@ -3764,6 +3772,13 @@ ppc64_elf_check_relocs (abfd, info, sec,
 	    }
 	  BFD_ASSERT (rel->r_offset % 8 == 0);
 	  ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8] = r_symndx;
+
+	  /* Mark the second slot of a GD or LD entry.
+	     -1 to indicate GD and -2 to indicate LD.  */
+	  if (tls_type == (TLS_EXPLICIT | TLS_TLS | TLS_GD))
+	    ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8 + 1] = -1;
+	  else if (tls_type == (TLS_EXPLICIT | TLS_TLS | TLS_LD))
+	    ppc64_elf_section_data (sec)->t_symndx[rel->r_offset / 8 + 1] = -2;
 	  goto dodyn;
 
 	case R_PPC64_TPREL16:
@@ -4090,14 +4105,14 @@ ppc64_elf_gc_sweep_hook (abfd, info, sec
 	case R_PPC64_GOT_TLSLD16_HI:
 	case R_PPC64_GOT_TLSLD16_HA:
 	  htab->tlsld_got.refcount -= 1;
-	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
+	  tls_type = TLS_TLS | TLS_LD;
 	  goto dogot;
 
 	case R_PPC64_GOT_TLSGD16:
 	case R_PPC64_GOT_TLSGD16_LO:
 	case R_PPC64_GOT_TLSGD16_HI:
 	case R_PPC64_GOT_TLSGD16_HA:
-	  tls_type = TLS_TLS | TLS_GD_LD;
+	  tls_type = TLS_TLS | TLS_GD;
 	  goto dogot;
 
 	case R_PPC64_GOT_TPREL16_DS:
@@ -4768,7 +4783,11 @@ get_sym_h (hp, symp, symsecp, tlstypep, 
   return TRUE;
 }
 
-static bfd_boolean
+/* Returns TLS_TYPE for the given REL symbol.  Function return is 0 on
+   error, 2 on a toc GD type suitable for optimization, 3 on a toc LD
+   type suitable for optimization, and 1 otherwise.  */  
+
+static int
 get_tls_type (tls_type, locsymsp, rel, ibfd)
      char **tls_type;
      Elf_Internal_Sym **locsymsp;
@@ -4776,6 +4795,7 @@ get_tls_type (tls_type, locsymsp, rel, i
      bfd *ibfd;
 {
   unsigned long r_symndx;
+  unsigned int next_r;
   struct elf_link_hash_entry *h;
   Elf_Internal_Sym *sym;
   asection *sec;
@@ -4783,12 +4803,12 @@ get_tls_type (tls_type, locsymsp, rel, i
 
   r_symndx = ELF64_R_SYM (rel->r_info);
   if (!get_sym_h (&h, &sym, &sec, tls_type, locsymsp, r_symndx, ibfd))
-    return FALSE;
+    return 0;
 
   if ((*tls_type != NULL && **tls_type != 0)
       || sec == NULL
       || ppc64_elf_section_data (sec)->t_symndx == NULL)
-    return TRUE;
+    return 1;
 
   /* Look inside a TOC section too.  */
   if (h != NULL)
@@ -4801,7 +4821,21 @@ get_tls_type (tls_type, locsymsp, rel, i
   off += rel->r_addend;
   BFD_ASSERT (off % 8 == 0);
   r_symndx = ppc64_elf_section_data (sec)->t_symndx[off / 8];
-  return get_sym_h (&h, &sym, NULL, tls_type, locsymsp, r_symndx, ibfd);
+  next_r = ppc64_elf_section_data (sec)->t_symndx[off / 8 + 1];
+  if (!get_sym_h (&h, &sym, &sec, tls_type, locsymsp, r_symndx, ibfd))
+    return 0;
+  if (h == NULL
+      || h->root.type == bfd_link_hash_defined
+      || h->root.type == bfd_link_hash_defweak)
+    {
+      if (next_r == (unsigned) -1)
+	return 2;
+      if (next_r == (unsigned) -2
+	  && (h == NULL
+	      || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
+	return 3;
+    }
+  return 1;
 }
 
 bfd_boolean
@@ -5110,39 +5144,46 @@ ppc64_elf_edit_opd (obfd, info)
   return TRUE;
 }
 
-/* Run through all the TLS relocs looking for optimization
-   opportunities.  The linker has been hacked (see ppc64elf.em) to do
-   a preliminary section layout so that we know the TLS segment
-   offsets.  We can't optimize earlier because some optimizations need
-   to know the tp offset, and we need to optimize before allocating
-   dynamic relocations.  */
+/* Set htab->tls_sec.  */
 
 bfd_boolean
-ppc64_elf_tls_optimize (obfd, info)
+ppc64_elf_tls_setup (obfd, info)
      bfd *obfd;
      struct bfd_link_info *info;
 {
   asection *tls;
-  bfd *ibfd;
-  asection *sec;
   struct ppc_link_hash_table *htab;
 
-  if (info->relocateable)
-    return TRUE;
-
   for (tls = obfd->sections; tls != NULL; tls = tls->next)
     if ((tls->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
 	== (SEC_THREAD_LOCAL | SEC_LOAD))
       break;
-  if (tls == NULL)
-    return TRUE;
 
   htab = ppc_hash_table (info);
   htab->tls_sec = tls;
+  return tls != NULL;
+}
 
-  if (info->shared)
+/* Run through all the TLS relocs looking for optimization
+   opportunities.  The linker has been hacked (see ppc64elf.em) to do
+   a preliminary section layout so that we know the TLS segment
+   offsets.  We can't optimize earlier because some optimizations need
+   to know the tp offset, and we need to optimize before allocating
+   dynamic relocations.  */
+
+bfd_boolean
+ppc64_elf_tls_optimize (obfd, info)
+     bfd *obfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info;
+{
+  bfd *ibfd;
+  asection *sec;
+  struct ppc_link_hash_table *htab;
+
+  if (info->relocateable || info->shared)
     return TRUE;
 
+  htab = ppc_hash_table (info);
   for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
     {
       Elf_Internal_Sym *locsyms = NULL;
@@ -5172,7 +5213,7 @@ ppc64_elf_tls_optimize (obfd, info)
 		char *tls_type;
 		char tls_set, tls_clear, got_tls_type = 0;
 		bfd_vma value;
-		bfd_boolean ok_tprel;
+		bfd_boolean ok_tprel, is_local;
 
 		r_symndx = ELF64_R_SYM (rel->r_info);
 		if (!get_sym_h (&h, &sym, &sym_sec, &tls_type, &locsyms,
@@ -5197,9 +5238,13 @@ ppc64_elf_tls_optimize (obfd, info)
 		  }
 		else
 		  value = sym->st_value;
+
 		ok_tprel = FALSE;
-		if (sym_sec != NULL && sym_sec->output_section != NULL)
+		is_local = FALSE;
+		if (h == NULL
+		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
 		  {
+		    is_local = TRUE;
 		    value += sym_sec->output_offset;
 		    value += sym_sec->output_section->vma;
 		    value -= htab->tls_sec->vma;
@@ -5215,16 +5260,17 @@ ppc64_elf_tls_optimize (obfd, info)
 		  case R_PPC64_GOT_TLSLD16_LO:
 		  case R_PPC64_GOT_TLSLD16_HI:
 		  case R_PPC64_GOT_TLSLD16_HA:
+		    /* These relocs should never be against a symbol
+		       defined in a shared lib.  Leave them alone if
+		       that turns out to be the case.  */
+		    if (!is_local)
+		      continue;
+
 		    htab->tlsld_got.refcount -= 1;
-		    if (ok_tprel)
-		      /* LD -> LE */
-		      tls_set = 0;
-		    else
-		      /* We still need a GOT entry as the offset is
-			 too big.  ie. LD -> IE.  */
-		      tls_set = TLS_TLS | TLS_TPREL;
-		    tls_clear = TLS_GD_LD;
-		    got_tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
+		    /* LD -> LE */
+		    tls_set = 0;
+		    tls_clear = TLS_LD;
+		    got_tls_type = TLS_TLS | TLS_LD;
 		    expecting_tls_get_addr = 1;
 		    break;
 
@@ -5232,21 +5278,14 @@ ppc64_elf_tls_optimize (obfd, info)
 		  case R_PPC64_GOT_TLSGD16_LO:
 		  case R_PPC64_GOT_TLSGD16_HI:
 		  case R_PPC64_GOT_TLSGD16_HA:
-		    if (ok_tprel
-			&& (h == NULL
-			    || ((h->elf_link_hash_flags
-				 & ELF_LINK_HASH_DEF_REGULAR) != 0
-				&& ((h->elf_link_hash_flags
-				     & ELF_LINK_FORCED_LOCAL) != 0
-				    || !info->shared
-				    || info->symbolic))))
+		    if (ok_tprel)
 		      /* GD -> LE */
 		      tls_set = 0;
 		    else
 		      /* GD -> IE */
-		      tls_set = TLS_TLS | TLS_TPREL;
-		    tls_clear = TLS_GD_LD;
-		    got_tls_type = TLS_TLS | TLS_GD_LD;
+		      tls_set = TLS_TLS | TLS_TPRELGD;
+		    tls_clear = TLS_GD;
+		    got_tls_type = TLS_TLS | TLS_GD;
 		    expecting_tls_get_addr = 1;
 		    break;
 
@@ -5282,12 +5321,14 @@ ppc64_elf_tls_optimize (obfd, info)
 			  {
 			    /* Check for toc tls entries.  */
 			    char *toc_tls;
+			    int retval;
 
-			    if (!get_tls_type (&toc_tls, &locsyms,
-					       rel - 1, ibfd))
+			    retval = get_tls_type (&toc_tls, &locsyms,
+						   rel - 1, ibfd);
+			    if (retval == 0)
 			      goto err_free_rel;
 			    if (toc_tls != NULL)
-			      expecting_tls_get_addr = *toc_tls != 0;
+			      expecting_tls_get_addr = retval > 1;
 			  }
 
 			if (expecting_tls_get_addr)
@@ -5319,32 +5360,27 @@ ppc64_elf_tls_optimize (obfd, info)
 
 		  case R_PPC64_DTPMOD64:
 		    expecting_tls_get_addr = 0;
-		    if ((*tls_type & TLS_LD) == 0)
+		    if (rel + 1 < relend
+			&& (rel[1].r_info
+			    == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64))
+			&& rel[1].r_offset == rel->r_offset + 8)
 		      {
-			if ((h == NULL
-			     || ((h->elf_link_hash_flags
-				  & ELF_LINK_HASH_DEF_REGULAR) != 0
-				 && ((h->elf_link_hash_flags
-				      & ELF_LINK_FORCED_LOCAL) != 0
-				     || !info->shared
-				     || info->symbolic)))
-			    && ok_tprel)
+			if (ok_tprel)
 			  /* GD -> LE */
-			  tls_set = TLS_EXPLICIT;
+			  tls_set = TLS_EXPLICIT | TLS_GD;
 			else
 			  /* GD -> IE */
-			  tls_set = TLS_EXPLICIT | TLS_TPREL;
-			tls_clear = TLS_GD_LD;
+			  tls_set = TLS_EXPLICIT | TLS_GD | TLS_TPRELGD;
+			tls_clear = TLS_GD;
 		      }
 		    else
 		      {
-			if (ok_tprel)
-			  /* LD -> LE */
-			  tls_set = TLS_EXPLICIT;
-			else
-			  /* LD -> IE */
-			  tls_set = TLS_EXPLICIT | TLS_TPREL;
-			tls_clear = TLS_GD_LD;
+			if (!is_local)
+			  continue;
+
+			/* LD -> LE */
+			tls_set = TLS_EXPLICIT;
+			tls_clear = TLS_LD;
 		      }
 		    break;
 
@@ -5376,8 +5412,6 @@ ppc64_elf_tls_optimize (obfd, info)
 			if (ent->got.refcount > 0)
 			  ent->got.refcount -= 1;
 		      }
-		    else
-		      ent->tls_type = tls_set;
 		  }
 		else if (h != NULL)
 		  {
@@ -5395,14 +5429,9 @@ ppc64_elf_tls_optimize (obfd, info)
 			  /* If we got rid of a DTPMOD/DTPREL reloc
 			     pair then we'll lose one or two dyn
 			     relocs.  */
-			  if (tls_clear == TLS_GD_LD
-			      && rel + 1 < relend
-			      && (rel[1].r_info
-				  == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64))
-			      && rel[1].r_offset == rel->r_offset + 8)
-			    p->count -= 1;
-			  if (tls_set == TLS_EXPLICIT)
+			  if (tls_set == (TLS_EXPLICIT | TLS_GD))
 			    p->count -= 1;
+			  p->count -= 1;
 			  if (p->count == 0)
 			    *pp = p->next;
 			  break;
@@ -5515,11 +5544,39 @@ allocate_dynrelocs (h, inf)
       h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
     }
 
+  eh = (struct ppc_link_hash_entry *) h;
+  /* Run through the TLS GD got entries first if we're changing them
+     to TPREL.  */
+  if ((eh->tls_type & TLS_TPRELGD) != 0)
+    for (gent = h->got.glist; gent != NULL; gent = gent->next)
+      if (gent->got.refcount > 0
+	  && (gent->tls_type & TLS_GD) != 0)
+	{
+	  /* This was a GD entry that has been converted to TPREL.  If
+	     there happens to be a TPREL entry we can use that one.  */
+	  struct got_entry *ent;
+	  for (ent = h->got.glist; ent != NULL; ent = ent->next)
+	    if (ent->got.refcount > 0
+		&& (ent->tls_type & TLS_TPREL) != 0
+		&& ent->addend == gent->addend)
+	      {
+		gent->got.refcount = 0;
+		break;
+	      }
+
+	  /* If not, then we'll be using our own TPREL entry.  */
+	  if (gent->got.refcount != 0)
+	    gent->tls_type = TLS_TLS | TLS_TPREL;
+	}
+
   for (gent = h->got.glist; gent != NULL; gent = gent->next)
     if (gent->got.refcount > 0)
       {
+	bfd_boolean dyn;
+
 	/* Make sure this symbol is output as a dynamic symbol.
-	   Undefined weak syms won't yet be marked as dynamic.  */
+	   Undefined weak syms won't yet be marked as dynamic,
+	   nor will all TLS symbols.  */
 	if (h->dynindx == -1
 	    && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
 	  {
@@ -5528,26 +5585,24 @@ allocate_dynrelocs (h, inf)
 	  }
 
 	if ((gent->tls_type & TLS_LD) != 0)
-	  gent->got.offset = htab->tlsld_got.offset;
-	else
 	  {
-	    bfd_boolean dyn;
-
-	    s = htab->sgot;
-	    gent->got.offset = s->_raw_size;
-	    s->_raw_size += (gent->tls_type & TLS_GD_LD) != 0 ? 16 : 8;
-	    dyn = htab->elf.dynamic_sections_created;
-	    if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
-	      htab->srelgot->_raw_size
-		+= ((gent->tls_type & TLS_GD_LD) != 0
-		    ? 2 * sizeof (Elf64_External_Rela)
-		    : sizeof (Elf64_External_Rela));
+	    gent->got.offset = htab->tlsld_got.offset;
+	    continue;
 	  }
+
+	s = htab->sgot;
+	gent->got.offset = s->_raw_size;
+	s->_raw_size += (gent->tls_type & eh->tls_type & TLS_GD) ? 16 : 8;
+	dyn = htab->elf.dynamic_sections_created;
+	if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
+	  htab->srelgot->_raw_size
+	    += (gent->tls_type & eh->tls_type & TLS_GD
+		? 2 * sizeof (Elf64_External_Rela)
+		: sizeof (Elf64_External_Rela));
       }
     else
       gent->got.offset = (bfd_vma) -1;
 
-  eh = (struct ppc_link_hash_entry *) h;
   if (eh->dyn_relocs == NULL)
     return TRUE;
 
@@ -5697,6 +5752,7 @@ ppc64_elf_size_dynamic_sections (output_
     {
       struct got_entry **lgot_ents;
       struct got_entry **end_lgot_ents;
+      char *lgot_types;
       bfd_size_type locsymcount;
       Elf_Internal_Shdr *symtab_hdr;
       asection *srel;
@@ -5738,16 +5794,17 @@ ppc64_elf_size_dynamic_sections (output_
       symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
       locsymcount = symtab_hdr->sh_info;
       end_lgot_ents = lgot_ents + locsymcount;
+      lgot_types = (char *) end_lgot_ents;
       s = htab->sgot;
       srel = htab->srelgot;
-      for (; lgot_ents < end_lgot_ents; ++lgot_ents)
+      for (; lgot_ents < end_lgot_ents; ++lgot_ents, ++lgot_types)
 	{
 	  struct got_entry *ent;
 
 	  for (ent = *lgot_ents; ent != NULL; ent = ent->next)
 	    if (ent->got.refcount > 0)
 	      {
-		if ((ent->tls_type & TLS_LD) != 0)
+		if ((ent->tls_type & *lgot_types & TLS_LD) != 0)
 		  {
 		    if (htab->tlsld_got.offset == (bfd_vma) -1)
 		      {
@@ -5761,7 +5818,7 @@ ppc64_elf_size_dynamic_sections (output_
 		else
 		  {
 		    ent->got.offset = s->_raw_size;
-		    if ((ent->tls_type & TLS_GD_LD) != 0)
+		    if ((ent->tls_type & *lgot_types & TLS_GD) != 0)
 		      {
 			s->_raw_size += 16;
 			if (info->shared)
@@ -6608,8 +6665,7 @@ ppc64_elf_size_stubs (output_bfd, stub_b
 		      if (!get_tls_type (&tls_type, &local_syms,
 					 irela - 1, input_bfd))
 			goto error_ret_free_internal;
-		      if (tls_type != NULL
-			  && (*tls_type & (TLS_TLS | TLS_GD_LD)) == TLS_TLS)
+		      if (*tls_type != 0)
 			continue;
 		    }
 
@@ -6902,7 +6958,6 @@ ppc64_elf_relocate_section (output_bfd, 
   Elf_Internal_Rela *relend;
   Elf_Internal_Rela outrel;
   bfd_byte *loc;
-  unsigned int tls_get_addr_type;
   struct got_entry **local_got_ents;
   bfd_vma TOCstart;
   bfd_boolean ret = TRUE;
@@ -6938,7 +6993,6 @@ ppc64_elf_relocate_section (output_bfd, 
   sym_hashes = elf_sym_hashes (input_bfd);
   is_opd = ppc64_elf_section_data (input_section)->opd.adjust != NULL;
 
-  tls_get_addr_type = 0;
   rel = relocs;
   relend = relocs + input_section->reloc_count;
   for (; rel < relend; rel++)
@@ -6952,7 +7006,7 @@ ppc64_elf_relocate_section (output_bfd, 
       struct elf_link_hash_entry *fdh;
       const char *sym_name;
       unsigned long r_symndx;
-      char tls_type;
+      char tls_mask, tls_gd, tls_type;
       bfd_vma relocation;
       bfd_boolean unresolved_reloc;
       bfd_boolean warned;
@@ -7035,17 +7089,21 @@ ppc64_elf_relocate_section (output_bfd, 
 	    }
 	}
 
-      /* TLS optimizations.  */
-      tls_type = 0;
+      /* TLS optimizations.  Replace instruction sequences and relocs
+	 based on information we collected in tls_optimize.  We edit
+	 RELOCS so that --emit-relocs will output something sensible
+	 for the final instruction stream.  */
+      tls_mask = 0;
+      tls_gd = 0;
       if (IS_TLS_RELOC (r_type))
 	{
 	  if (h != NULL)
-	    tls_type = ((struct ppc_link_hash_entry *) h)->tls_type;
+	    tls_mask = ((struct ppc_link_hash_entry *) h)->tls_type;
 	  else if (local_got_ents != NULL)
 	    {
 	      char *lgot_types;
 	      lgot_types = (char *) (local_got_ents + symtab_hdr->sh_info);
-	      tls_type = lgot_types[r_symndx];
+	      tls_mask = lgot_types[r_symndx];
 	    }
 	}
 
@@ -7064,39 +7122,52 @@ ppc64_elf_relocate_section (output_bfd, 
       switch (r_type)
 	{
 	default:
-	  tls_get_addr_type = 0;
 	  break;
 
 	case R_PPC64_TOC16:
 	case R_PPC64_TOC16_LO:
 	case R_PPC64_TOC16_DS:
 	case R_PPC64_TOC16_LO_DS:
-	  tls_get_addr_type = 0;
 	  {
 	    /* Check for toc tls entries.  */
 	    char *toc_tls;
+	    int retval;
 
-	    if (!get_tls_type (&toc_tls, &local_syms, rel, input_bfd))
+	    retval = get_tls_type (&toc_tls, &local_syms, rel, input_bfd);
+	    if (retval == 0)
 	      return FALSE;
 
 	    if (toc_tls)
 	      {
-		tls_type = *toc_tls;
+		tls_mask = *toc_tls;
 		if (r_type == R_PPC64_TOC16_DS
 		    || r_type == R_PPC64_TOC16_LO_DS)
 		  goto toctprel;
 		else
-		  tls_get_addr_type = tls_type;
+		  {
+		    /* If we found a GD reloc pair, then we might be
+		       doing a GD->IE transition.  */
+		    if (retval == 2)
+		      {
+			tls_gd = TLS_TPRELGD;
+			if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
+			  goto tls_get_addr_check;
+		      }
+		    else if (retval == 3)
+		      {
+			if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
+			  goto tls_get_addr_check;
+		      }
+		  }
 	      }
 	  }
 	  break;
 
 	case R_PPC64_GOT_TPREL16_DS:
 	case R_PPC64_GOT_TPREL16_LO_DS:
-	  tls_get_addr_type = 0;
 	toctprel:
-	  if (tls_type != 0
-	      && (tls_type & TLS_TPREL) == 0)
+	  if (tls_mask != 0
+	      && (tls_mask & TLS_TPREL) == 0)
 	    {
 	      bfd_vma insn;
 	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - 2);
@@ -7109,8 +7180,7 @@ ppc64_elf_relocate_section (output_bfd, 
 	  break;
 
 	case R_PPC64_TLS:
-	  tls_get_addr_type = 0;
-	  if (tls_type == 0)
+	  if (tls_mask == 0)
 	    {
 	      /* Check for toc tls entries.  */
 	      char *toc_tls;
@@ -7119,10 +7189,10 @@ ppc64_elf_relocate_section (output_bfd, 
 		return FALSE;
 
 	      if (toc_tls)
-		tls_type = *toc_tls;
+		tls_mask = *toc_tls;
 	    }
-	  if (tls_type != 0
-	      && (tls_type & TLS_TPREL) == 0)
+	  if (tls_mask != 0
+	      && (tls_mask & TLS_TPREL) == 0)
 	    {
 	      bfd_vma insn, rtra;
 	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
@@ -7164,130 +7234,162 @@ ppc64_elf_relocate_section (output_bfd, 
 	    }
 	  break;
 
-	case R_PPC64_GOT_TLSGD16:
-	case R_PPC64_GOT_TLSGD16_LO:
 	case R_PPC64_GOT_TLSGD16_HI:
 	case R_PPC64_GOT_TLSGD16_HA:
-	case R_PPC64_GOT_TLSLD16:
-	case R_PPC64_GOT_TLSLD16_LO:
+	  tls_gd = TLS_TPRELGD;
+	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
+	    goto tls_gdld_hi;
+	  break;
+
 	case R_PPC64_GOT_TLSLD16_HI:
 	case R_PPC64_GOT_TLSLD16_HA:
-	  tls_get_addr_type = 0;
-	  if (tls_type != 0 && (tls_type & TLS_GD_LD) == 0)
+	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
 	    {
-	      if (r_type == R_PPC64_GOT_TLSGD16_HI
-		  || r_type == R_PPC64_GOT_TLSGD16_HA
-		  || r_type == R_PPC64_GOT_TLSLD16_HI
-		  || r_type == R_PPC64_GOT_TLSLD16_HA)
+	    tls_gdld_hi:
+	      if ((tls_mask & tls_gd) != 0)
+		r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
+			  + R_PPC64_GOT_TPREL16_DS);
+	      else
 		{
-		  if ((tls_type & TLS_LD) != 0)
-		    {
-		      bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
-		      r_type = R_PPC64_NONE;
-		      rel->r_offset -= 2;
-		    }
-		  else
-		    r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
-			      + R_PPC64_GOT_TPREL16_DS);
-		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
-		  break;
+		  bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
+		  rel->r_offset -= 2;
+		  r_type = R_PPC64_NONE;
 		}
-
-	      /* This reloc and its instruction will be replaced so there's
-		 not much point in doing anything more here.  We know the
-		 next reloc will be a REL24 to __tls_get_addr, and will
-		 be handled below.  */
-	      tls_get_addr_type = tls_type;
-	      continue;
+	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
 	    }
 	  break;
 
-	case R_PPC64_REL14:
-	case R_PPC64_REL14_BRTAKEN:
-	case R_PPC64_REL14_BRNTAKEN:
-	case R_PPC64_REL24:
-	  if (h != NULL
-	      && h == htab->tls_get_addr
-	      && tls_get_addr_type != 0
-	      && (tls_get_addr_type & TLS_GD_LD) == 0)
-	    {
-	      /* Replace the call.  */
-	      bfd_vma insn1, insn2, insn3;
-	      bfd_vma offset = rel->r_offset;
-
-	      insn1 = bfd_get_32 (output_bfd, contents + rel[-1].r_offset - 2);
-	      insn3 = bfd_get_32 (output_bfd, contents + offset + 4);
-	      if (tls_get_addr_type & TLS_TPREL)
-		{
-		  /* IE */
-		  insn1 &= (1 << 26) - (1 << 2);
-		  insn1 |= 58 << 26;	/* ld */
-		  insn2 = 0x7c636a14;	/* add 3,3,13 */
-		  /* Fix the relocs for --emit-relocs.  */
-		  r_type = ELF64_R_TYPE (rel[-1].r_info);
-		  if (tls_get_addr_type & TLS_EXPLICIT)
-		    r_type += R_PPC64_TOC16_DS - R_PPC64_TOC16;
-		  else
-		    r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
-			      + R_PPC64_GOT_TPREL16_DS);
-		  rel[-1].r_info
-		    = ELF64_R_INFO (ELF64_R_SYM (rel[-1].r_info), r_type);
-		  rel->r_info = 0;
-		}
-	      else
+	case R_PPC64_GOT_TLSGD16:
+	case R_PPC64_GOT_TLSGD16_LO:
+	  tls_gd = TLS_TPRELGD;
+	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
+	    goto tls_get_addr_check;
+	  break;
+
+	case R_PPC64_GOT_TLSLD16:
+	case R_PPC64_GOT_TLSLD16_LO:
+	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
+	    {
+	    tls_get_addr_check:
+	      if (rel + 1 < relend)
 		{
-		  /* LE */
-		  insn1 = 0x3c6d0000;	/* addis 3,13,0 */
-		  insn2 = 0x38630000;	/* addi 3,3,0 */
-		  if (tls_get_addr_type & TLS_LD)
+		  enum elf_ppc64_reloc_type r_type2;
+		  unsigned long r_symndx2;
+		  struct elf_link_hash_entry *h2;
+		  bfd_vma insn1, insn2, insn3;
+		  bfd_vma offset;
+
+		  /* The next instruction should be a call to
+		     __tls_get_addr.  Peek at the reloc to be sure.  */
+		  r_type2
+		    = (enum elf_ppc64_reloc_type) ELF64_R_TYPE (rel[1].r_info);
+		  r_symndx2 = ELF64_R_SYM (rel[1].r_info);
+		  if (r_symndx2 < symtab_hdr->sh_info
+		      || (r_type2 != R_PPC64_REL14
+			  && r_type2 != R_PPC64_REL14_BRTAKEN
+			  && r_type2 != R_PPC64_REL14_BRNTAKEN
+			  && r_type2 != R_PPC64_REL24))
+		    break;
+
+		  h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
+		  while (h2->root.type == bfd_link_hash_indirect
+			 || h2->root.type == bfd_link_hash_warning)
+		    h2 = (struct elf_link_hash_entry *) h2->root.u.i.link;
+		  if (h2 == NULL || h2 != htab->tls_get_addr)
+		    break;
+
+		  /* OK, it checks out.  Replace the call.  */
+		  offset = rel[1].r_offset;
+		  insn1 = bfd_get_32 (output_bfd,
+				      contents + rel->r_offset - 2);
+		  insn3 = bfd_get_32 (output_bfd,
+				      contents + offset + 4);
+		  if ((tls_mask & tls_gd) != 0)
 		    {
-		      r_symndx = 0;
-		      rel[-1].r_addend = htab->tls_sec->vma + DTP_OFFSET;
-		      rel->r_addend = htab->tls_sec->vma + DTP_OFFSET;
+		      /* IE */
+		      insn1 &= (1 << 26) - (1 << 2);
+		      insn1 |= 58 << 26;	/* ld */
+		      insn2 = 0x7c636a14;	/* add 3,3,13 */
+		      rel[1].r_info = ELF64_R_INFO (r_symndx2, R_PPC64_NONE);
+		      if ((tls_mask & TLS_EXPLICIT) == 0)
+			r_type = (((r_type - (R_PPC64_GOT_TLSGD16 & 3)) & 3)
+				  + R_PPC64_GOT_TPREL16_DS);
+		      else
+			r_type += R_PPC64_TOC16_DS - R_PPC64_TOC16;
+		      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
 		    }
 		  else
-		    r_symndx = ELF64_R_SYM (rel[-1].r_info);
-		  rel[-1].r_info = ELF64_R_INFO (r_symndx, R_PPC64_TPREL16_HA);
-		  rel->r_info = ELF64_R_INFO (r_symndx, R_PPC64_TPREL16_LO);
-		  rel->r_offset += 2;
-		}
-	      if (insn3 == NOP
-		  || insn3 == CROR_151515 || insn3 == CROR_313131)
-		{
-		  insn3 = insn2;
-		  insn2 = NOP;
-		  rel->r_offset += 4;
+		    {
+		      /* LE */
+		      insn1 = 0x3c6d0000;	/* addis 3,13,0 */
+		      insn2 = 0x38630000;	/* addi 3,3,0 */
+		      if (tls_gd == 0)
+			{
+			  /* Was an LD reloc.  */
+			  r_symndx = 0;
+			  rel->r_addend = htab->tls_sec->vma + DTP_OFFSET;
+			  rel[1].r_addend = htab->tls_sec->vma + DTP_OFFSET;
+			}
+		      r_type = R_PPC64_TPREL16_HA;
+		      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
+		      rel[1].r_info = ELF64_R_INFO (r_symndx,
+						    R_PPC64_TPREL16_LO);
+		      rel[1].r_offset += 2;
+		    }
+		  if (insn3 == NOP
+		      || insn3 == CROR_151515 || insn3 == CROR_313131)
+		    {
+		      insn3 = insn2;
+		      insn2 = NOP;
+		      rel[1].r_offset += 4;
+		    }
+		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - 2);
+		  bfd_put_32 (output_bfd, insn2, contents + offset);
+		  bfd_put_32 (output_bfd, insn3, contents + offset + 4);
+		  if (tls_gd == 0)
+		    {
+		      /* We changed the symbol on an LD reloc.  Start over
+			 in order to get h, sym, sec etc. right.  */ 
+		      rel--;
+		      continue;
+		    }
 		}
-	      bfd_put_32 (output_bfd, insn1, contents + rel[-1].r_offset - 2);
-	      bfd_put_32 (output_bfd, insn2, contents + offset);
-	      bfd_put_32 (output_bfd, insn3, contents + offset + 4);
-	      /* Do the relocs again.  */
-	      rel -= 2;
-	      tls_get_addr_type = 0;
-	      continue;
 	    }
-	  tls_get_addr_type = 0;
 	  break;
 
 	case R_PPC64_DTPMOD64:
-	  if ((tls_type & TLS_GD_LD) == 0)
+	  if (rel + 1 < relend
+	      && rel[1].r_info == ELF64_R_INFO (r_symndx, R_PPC64_DTPREL64)
+	      && rel[1].r_offset == rel->r_offset + 8)
 	    {
-	      if ((tls_type & TLS_TPREL) != 0)
-		r_type = R_PPC64_TPREL64;
-	      else
+	      if ((tls_mask & TLS_GD) == 0)
+		{
+		  rel[1].r_info = ELF64_R_INFO (r_symndx, R_PPC64_NONE);
+		  if ((tls_mask & TLS_TPRELGD) != 0)
+		    r_type = R_PPC64_TPREL64;
+		  else
+		    {
+		      bfd_put_64 (output_bfd, (bfd_vma) 1,
+				  contents + rel->r_offset);
+		      r_type = R_PPC64_NONE;
+		    }
+		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
+		}
+	    }
+	  else
+	    {
+	      if ((tls_mask & TLS_LD) == 0)
 		{
 		  bfd_put_64 (output_bfd, (bfd_vma) 1,
 			      contents + rel->r_offset);
 		  r_type = R_PPC64_NONE;
+		  rel->r_info = ELF64_R_INFO (r_symndx, r_type);
 		}
-	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
-	      if ((tls_type & TLS_LD) == 0)
-		rel[1].r_info = 0;
 	    }
 	  break;
 
 	case R_PPC64_TPREL64:
-	  if ((tls_type & TLS_TPREL) == 0)
+	  if ((tls_mask & TLS_TPREL) == 0)
 	    {
 	      r_type = R_PPC64_NONE;
 	      rel->r_info = ELF64_R_INFO (r_symndx, r_type);
@@ -7437,14 +7539,14 @@ ppc64_elf_relocate_section (output_bfd, 
 	case R_PPC64_GOT_TLSGD16_LO:
 	case R_PPC64_GOT_TLSGD16_HI:
 	case R_PPC64_GOT_TLSGD16_HA:
-	  tls_type = TLS_TLS | TLS_GD_LD;
+	  tls_type = TLS_TLS | TLS_GD;
 	  goto dogot;
 
 	case R_PPC64_GOT_TLSLD16:
 	case R_PPC64_GOT_TLSLD16_LO:
 	case R_PPC64_GOT_TLSLD16_HI:
 	case R_PPC64_GOT_TLSLD16_HA:
-	  tls_type = TLS_TLS | TLS_GD_LD | TLS_LD;
+	  tls_type = TLS_TLS | TLS_LD;
 	  goto dogot;
 
 	case R_PPC64_GOT_TPREL16_DS:
@@ -7530,12 +7632,12 @@ ppc64_elf_relocate_section (output_bfd, 
 		   the case of TLSLD where we'll use one entry per
 		   module.  */
 		if ((info->shared || indx != 0)
-		    && ent->tls_type != (TLS_TLS | TLS_GD_LD | TLS_LD))
+		    && tls_type != (TLS_TLS | TLS_LD))
 		  {
 		    outrel.r_offset = (htab->sgot->output_section->vma
 				       + htab->sgot->output_offset
 				       + off);
-		    if (ent->tls_type == (TLS_TLS | TLS_GD_LD))
+		    if (tls_type == (TLS_TLS | TLS_GD))
 		      {
 			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPMOD64);
 			outrel.r_addend = 0;
@@ -7546,15 +7648,15 @@ ppc64_elf_relocate_section (output_bfd, 
 			outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
 			outrel.r_offset += 8;
 		      }
-		    else if (ent->tls_type == (TLS_TLS | TLS_DTPREL))
+		    else if (tls_type == (TLS_TLS | TLS_DTPREL))
 		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_DTPREL64);
-		    else if (ent->tls_type == (TLS_TLS | TLS_TPREL))
+		    else if (tls_type == (TLS_TLS | TLS_TPREL))
 		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_TPREL64);
 		    else if (indx == 0)
 		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_RELATIVE);
 		    else
 		      outrel.r_info = ELF64_R_INFO (indx, R_PPC64_GLOB_DAT);
-		    outrel.r_addend = ent->addend;
+		    outrel.r_addend = rel->r_addend;
 		    if (indx == 0)
 		      outrel.r_addend += relocation;
 		    loc = htab->srelgot->contents;
@@ -7576,7 +7678,7 @@ ppc64_elf_relocate_section (output_bfd, 
 			  relocation += DTP_OFFSET - TP_OFFSET;
 		      }
 
-		    if ((tls_type & TLS_GD_LD) != 0)
+		    if ((tls_type & (TLS_GD | TLS_LD)) != 0)
 		      {
 			if ((tls_type & TLS_LD) != 0)
 			  relocation = - DTP_OFFSET;
--- bfd/elf64-ppc.h	4 Feb 2003 14:50:50 -0000	1.7
+++ bfd/elf64-ppc.h	9 Feb 2003 03:10:51 -0000
@@ -21,6 +21,8 @@ bfd_boolean ppc64_elf_mark_entry_syms
   PARAMS ((struct bfd_link_info *));
 bfd_boolean ppc64_elf_edit_opd
   PARAMS ((bfd *, struct bfd_link_info *));
+bfd_boolean ppc64_elf_tls_setup
+  PARAMS ((bfd *, struct bfd_link_info *));
 bfd_boolean ppc64_elf_tls_optimize
   PARAMS ((bfd *, struct bfd_link_info *));
 bfd_vma ppc64_elf_toc
--- ld/emultempl/ppc64elf.em	4 Feb 2003 14:51:35 -0000	1.12
+++ ld/emultempl/ppc64elf.em	9 Feb 2003 03:10:53 -0000
@@ -41,6 +41,9 @@ static bfd_signed_vma group_size = 1;
 /* Whether to add ".foo" entries for each "foo" in a version script.  */
 static int dotsyms = 1;
 
+/* Whether to run tls optimization.  */
+static int notlsopt = 0;
+
 static void ppc_create_output_section_statements
   PARAMS ((void));
 static void ppc_after_open
@@ -101,20 +104,23 @@ ppc_before_allocation ()
       return;
     }
 
-  /* Size the sections.  This is premature, but we want to know the
-     TLS segment layout so that certain optimizations can be done.  */
-  lang_size_sections (stat_ptr->head, abs_output_section,
-		      &stat_ptr->head, 0, (bfd_vma) 0, NULL);
-
-  if (!ppc64_elf_tls_optimize (output_bfd, &link_info))
+  if (ppc64_elf_tls_setup (output_bfd, &link_info) && !notlsopt)
     {
-      einfo ("%X%P: TLS problem %E\n");
-      return;
+      /* Size the sections.  This is premature, but we want to know the
+	 TLS segment layout so that certain optimizations can be done.  */
+      lang_size_sections (stat_ptr->head, abs_output_section,
+			  &stat_ptr->head, 0, (bfd_vma) 0, NULL);
+
+      if (!ppc64_elf_tls_optimize (output_bfd, &link_info))
+	{
+	  einfo ("%X%P: TLS problem %E\n");
+	  return;
+	}
+
+      lang_reset_memory_regions ();
     }
 
   gld${EMULATION_NAME}_before_allocation ();
-
-  lang_reset_memory_regions ();
 }
 
 struct hook_stub_info
@@ -457,6 +463,7 @@ PARSE_AND_LIST_PROLOGUE='
 #define OPTION_STUBGROUP_SIZE		301
 #define OPTION_DOTSYMS			(OPTION_STUBGROUP_SIZE + 1)
 #define OPTION_NO_DOTSYMS		(OPTION_DOTSYMS + 1)
+#define OPTION_NO_TLS_OPT		(OPTION_NO_DOTSYMS + 1)
 '
 
 # The options are repeated below so that no abbreviations are allowed.
@@ -468,6 +475,8 @@ PARSE_AND_LIST_LONGOPTS='
   { "dotsyms", no_argument, NULL, OPTION_DOTSYMS },
   { "no-dotsyms", no_argument, NULL, OPTION_NO_DOTSYMS },
   { "no-dotsyms", no_argument, NULL, OPTION_NO_DOTSYMS },
+  { "no-tls-optimize", no_argument, NULL, OPTION_NO_TLS_OPT },
+  { "no-tls-optimize", no_argument, NULL, OPTION_NO_TLS_OPT },
 '
 
 PARSE_AND_LIST_OPTIONS='
@@ -489,6 +498,9 @@ PARSE_AND_LIST_OPTIONS='
   fprintf (file, _("\
   --no-dotsyms          Don'\''t do anything special in version scripts.\n"
 		   ));
+  fprintf (file, _("\
+  --no-tls-optimize     Don'\''t try to optimize TLS accesses.\n"
+		   ));
 '
 
 PARSE_AND_LIST_ARGS_CASES='
@@ -502,15 +514,15 @@ PARSE_AND_LIST_ARGS_CASES='
       break;
 
     case OPTION_DOTSYMS:
-      {
-	dotsyms = 1;
-      }
+      dotsyms = 1;
       break;
 
     case OPTION_NO_DOTSYMS:
-      {
-	dotsyms = 0;
-      }
+      dotsyms = 0;
+      break;
+
+    case OPTION_NO_TLS_OPT:
+      notlsopt = 1;
       break;
 '
 
--- ld/testsuite/ld-powerpc/tlsexe.d	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlsexe.d	9 Feb 2003 03:10:53 -0000
@@ -8,42 +8,61 @@
 
 Disassembly of section \.text:
 
-0+10000378 <_start>:
-    10000378:	e8 62 80 10 	ld	r3,-32752\(r2\)
-    1000037c:	60 00 00 00 	nop
-    10000380:	7c 63 6a 14 	add	r3,r3,r13
-    10000384:	e8 62 80 18 	ld	r3,-32744\(r2\)
-    10000388:	60 00 00 00 	nop
-    1000038c:	7c 63 6a 14 	add	r3,r3,r13
-    10000390:	3c 6d 00 00 	addis	r3,r13,0
-    10000394:	60 00 00 00 	nop
-    10000398:	38 63 90 38 	addi	r3,r3,-28616
-    1000039c:	3c 6d 00 00 	addis	r3,r13,0
-    100003a0:	60 00 00 00 	nop
-    100003a4:	38 63 10 00 	addi	r3,r3,4096
-    100003a8:	39 23 80 40 	addi	r9,r3,-32704
-    100003ac:	3d 23 00 00 	addis	r9,r3,0
-    100003b0:	81 49 80 48 	lwz	r10,-32696\(r9\)
-    100003b4:	e9 22 80 20 	ld	r9,-32736\(r2\)
-    100003b8:	7d 49 18 2a 	ldx	r10,r9,r3
-    100003bc:	3d 2d 00 00 	addis	r9,r13,0
-    100003c0:	a1 49 90 58 	lhz	r10,-28584\(r9\)
-    100003c4:	89 4d 90 60 	lbz	r10,-28576\(r13\)
-    100003c8:	3d 2d 00 00 	addis	r9,r13,0
-    100003cc:	99 49 90 68 	stb	r10,-28568\(r9\)
+0+10000390 <_start-0x1c>:
+    10000390:	3d 82 00 00 	addis	r12,r2,0
+    10000394:	f8 41 00 28 	std	r2,40\(r1\)
+    10000398:	e9 6c 80 48 	ld	r11,-32696\(r12\)
+    1000039c:	e8 4c 80 50 	ld	r2,-32688\(r12\)
+    100003a0:	7d 69 03 a6 	mtctr	r11
+    100003a4:	e9 6c 80 58 	ld	r11,-32680\(r12\)
+    100003a8:	4e 80 04 20 	bctr
+
+0+100003ac <_start>:
+    100003ac:	e8 62 80 20 	ld	r3,-32736\(r2\)
+    100003b0:	60 00 00 00 	nop
+    100003b4:	7c 63 6a 14 	add	r3,r3,r13
+    100003b8:	38 62 80 08 	addi	r3,r2,-32760
+    100003bc:	4b ff ff d5 	bl	10000390 <le1\+0x10000328>
+    100003c0:	e8 41 00 28 	ld	r2,40\(r1\)
+    100003c4:	3c 6d 00 00 	addis	r3,r13,0
+    100003c8:	60 00 00 00 	nop
+    100003cc:	38 63 90 38 	addi	r3,r3,-28616
     100003d0:	3c 6d 00 00 	addis	r3,r13,0
     100003d4:	60 00 00 00 	nop
-    100003d8:	38 63 90 00 	addi	r3,r3,-28672
-    100003dc:	3c 6d 00 00 	addis	r3,r13,0
-    100003e0:	60 00 00 00 	nop
-    100003e4:	38 63 10 00 	addi	r3,r3,4096
-    100003e8:	f9 43 80 08 	std	r10,-32760\(r3\)
-    100003ec:	3d 23 00 00 	addis	r9,r3,0
-    100003f0:	91 49 80 10 	stw	r10,-32752\(r9\)
-    100003f4:	e9 22 80 08 	ld	r9,-32760\(r2\)
-    100003f8:	7d 49 19 2a 	stdx	r10,r9,r3
+    100003d8:	38 63 10 00 	addi	r3,r3,4096
+    100003dc:	39 23 80 40 	addi	r9,r3,-32704
+    100003e0:	3d 23 00 00 	addis	r9,r3,0
+    100003e4:	81 49 80 48 	lwz	r10,-32696\(r9\)
+    100003e8:	e9 22 80 28 	ld	r9,-32728\(r2\)
+    100003ec:	7d 49 18 2a 	ldx	r10,r9,r3
+    100003f0:	3d 2d 00 00 	addis	r9,r13,0
+    100003f4:	a1 49 90 58 	lhz	r10,-28584\(r9\)
+    100003f8:	89 4d 90 60 	lbz	r10,-28576\(r13\)
     100003fc:	3d 2d 00 00 	addis	r9,r13,0
-    10000400:	b1 49 90 58 	sth	r10,-28584\(r9\)
-    10000404:	e9 4d 90 2a 	lwa	r10,-28632\(r13\)
-    10000408:	3d 2d 00 00 	addis	r9,r13,0
-    1000040c:	a9 49 90 30 	lha	r10,-28624\(r9\)
+    10000400:	99 49 90 68 	stb	r10,-28568\(r9\)
+    10000404:	3c 6d 00 00 	addis	r3,r13,0
+    10000408:	60 00 00 00 	nop
+    1000040c:	38 63 90 00 	addi	r3,r3,-28672
+    10000410:	3c 6d 00 00 	addis	r3,r13,0
+    10000414:	60 00 00 00 	nop
+    10000418:	38 63 10 00 	addi	r3,r3,4096
+    1000041c:	f9 43 80 08 	std	r10,-32760\(r3\)
+    10000420:	3d 23 00 00 	addis	r9,r3,0
+    10000424:	91 49 80 10 	stw	r10,-32752\(r9\)
+    10000428:	e9 22 80 18 	ld	r9,-32744\(r2\)
+    1000042c:	7d 49 19 2a 	stdx	r10,r9,r3
+    10000430:	3d 2d 00 00 	addis	r9,r13,0
+    10000434:	b1 49 90 58 	sth	r10,-28584\(r9\)
+    10000438:	e9 4d 90 2a 	lwa	r10,-28632\(r13\)
+    1000043c:	3d 2d 00 00 	addis	r9,r13,0
+    10000440:	a9 49 90 30 	lha	r10,-28624\(r9\)
+    10000444:	e8 41 00 28 	ld	r2,40\(r1\)
+    10000448:	3d 82 00 00 	addis	r12,r2,0
+    1000044c:	e9 6c 80 30 	ld	r11,-32720\(r12\)
+    10000450:	e8 4c 80 38 	ld	r2,-32712\(r12\)
+    10000454:	7d 69 03 a6 	mtctr	r11
+    10000458:	e9 6c 80 40 	ld	r11,-32704\(r12\)
+    1000045c:	4e 80 04 20 	bctr
+    10000460:	60 00 00 00 	nop
+    10000464:	38 00 00 00 	li	r0,0
+    10000468:	4b ff ff dc 	b	10000444 <_start\+0x98>
--- ld/testsuite/ld-powerpc/tlsexe.g	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlsexe.g	9 Feb 2003 03:10:53 -0000
@@ -7,6 +7,6 @@
 .*: +file format elf64-powerpc
 
 Contents of section \.got:
- 10010548 00000000 10018548 ffffffff ffff8018  .*
- 10010558 00000000 00000000 00000000 00000000  .*
- 10010568 00000000 00000000                    .*
+ 100105f8 00000000 100185f8 00000000 00000000  .*
+ 10010608 00000000 00000000 ffffffff ffff8018  .*
+ 10010618 00000000 00000000 00000000 00000000  .*
--- ld/testsuite/ld-powerpc/tlsexe.r	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlsexe.r	9 Feb 2003 03:10:53 -0000
@@ -1,38 +1,40 @@
 #source: tls.s
 #source: tlslib.s
 #as: -a64
-#ld: -shared -melf64ppc
+#ld: -melf64ppc
 #readelf: -WSsrl
 #target: powerpc64*-*-*
 
-There are 20 section headers.*
+There are 22 section headers.*
 
 Section Headers:
  +\[Nr\] Name +Type +Address +Off +Size +ES Flg Lk Inf Al
  +\[ 0\] +NULL +0+ 0+ 0+ 0+ +0 +0 +0
  +\[ 1\] \.interp +PROGBITS +0+10000190 0+190 0+11 0+ +A +0 +0 +1
- +\[ 2\] \.hash +HASH +0+100001a8 0+1a8 0+3c 04 +A +3 +0 +8
- +\[ 3\] \.dynsym +DYNSYM +0+100001e8 0+1e8 0+f0 18 +A +4 +1 +8
- +\[ 4\] \.dynstr +STRTAB +0+100002d8 0+2d8 0+51 0+ +A +0 +0 +1
- +\[ 5\] \.rela\.dyn +RELA +0+10000330 0+330 0+48 18 +A +3 +0 +8
- +\[ 6\] \.text +PROGBITS +0+10000378 0+378 0+98 0+ +AX +0 +0 +4
- +\[ 7\] \.data +PROGBITS +0+10010410 0+410 0+ 0+ +WA +0 +0 +1
- +\[ 8\] \.branch_lt +PROGBITS +0+10010410 0+410 0+ 0+ +WA +0 +0 +8
- +\[ 9\] \.tdata +PROGBITS +0+10010410 0+410 0+38 0+ WAT +0 +0 +8
- +\[10\] \.tbss +NOBITS +0+10010448 0+448 0+38 0+ WAT +0 +0 +8
- +\[11\] \.dynamic +DYNAMIC +0+10010448 0+448 0+100 10 +WA +4 +0 +8
- +\[12\] \.ctors +PROGBITS +0+10010548 0+570 0+ 0+ +W +0 +0 +1
- +\[13\] \.dtors +PROGBITS +0+10010548 0+570 0+ 0+ +W +0 +0 +1
- +\[14\] \.got +PROGBITS +0+10010548 0+548 0+28 08 +WA +0 +0 +8
- +\[15\] \.sbss +PROGBITS +0+10010570 0+570 0+ 0+ +W +0 +0 +1
- +\[16\] \.bss +NOBITS +0+10010570 0+570 0+ 0+ +WA +0 +0 +1
- +\[17\] \.shstrtab +STRTAB +0+ 0+570 0+8e 0+ +0 +0 +1
- +\[18\] \.symtab +SYMTAB +0+ 0+b00 0+408 18 +19 +1b +8
- +\[19\] \.strtab +STRTAB +0+ 0+f08 0+7d 0+ +0 +0 +1
+ +\[ 2\] \.hash +HASH +0+100001a8 0+1a8 0+40 04 +A +3 +0 +8
+ +\[ 3\] \.dynsym +DYNSYM +0+100001e8 0+1e8 0+108 18 +A +4 +1 +8
+ +\[ 4\] \.dynstr +STRTAB +0+100002f0 0+2f0 0+51 0+ +A +0 +0 +1
+ +\[ 5\] \.rela\.dyn +RELA +0+10000348 0+348 0+30 18 +A +3 +0 +8
+ +\[ 6\] \.rela\.plt +RELA +0+10000378 0+378 0+18 18 +A +3 +11 +8
+ +\[ 7\] \.text +PROGBITS +0+10000390 0+390 0+dc 0+ +AX +0 +0 +4
+ +\[ 8\] \.data +PROGBITS +0+10010470 0+470 0+ 0+ +WA +0 +0 +1
+ +\[ 9\] \.branch_lt +PROGBITS +0+10010470 0+470 0+ 0+ +WA +0 +0 +8
+ +\[10\] \.tdata +PROGBITS +0+10010470 0+470 0+38 0+ WAT +0 +0 +8
+ +\[11\] \.tbss +NOBITS +0+100104a8 0+4a8 0+38 0+ WAT +0 +0 +8
+ +\[12\] \.dynamic +DYNAMIC +0+100104a8 0+4a8 0+150 10 +WA +4 +0 +8
+ +\[13\] \.ctors +PROGBITS +0+100105f8 0+628 0+ 0+ +W +0 +0 +1
+ +\[14\] \.dtors +PROGBITS +0+100105f8 0+628 0+ 0+ +W +0 +0 +1
+ +\[15\] \.got +PROGBITS +0+100105f8 0+5f8 0+30 08 +WA +0 +0 +8
+ +\[16\] \.sbss +PROGBITS +0+10010628 0+628 0+ 0+ +W +0 +0 +1
+ +\[17\] \.plt +NOBITS +0+10010628 0+628 0+30 18 +WA +0 +0 +8
+ +\[18\] \.bss +NOBITS +0+10010658 0+628 0+ 0+ +WA +0 +0 +1
+ +\[19\] \.shstrtab +STRTAB +0+ 0+628 0+98 0+ +0 +0 +1
+ +\[20\] \.symtab +SYMTAB +0+ 0+c40 0+450 18 +21 +1d +8
+ +\[21\] \.strtab +STRTAB +0+ 0+1090 0+8c 0+ +0 +0 +1
 #...
 
 Elf file type is EXEC \(Executable file\)
-Entry point 0x10000378
+Entry point 0x100003ac
 There are 6 program headers.*
 
 Program Headers:
@@ -40,81 +42,88 @@ Program Headers:
  +PHDR +0x0+40 0x0+10000040 0x0+10000040 0x0+150 0x0+150 R E 0x8
  +INTERP +0x0+190 0x0+10000190 0x0+10000190 0x0+11 0x0+11 R +0x1
  +\[Requesting program interpreter: .*\]
- +LOAD +0x0+ 0x0+10000000 0x0+10000000 0x0+410 0x0+410 R E 0x10000
- +LOAD +0x0+410 0x0+10010410 0x0+10010410 0x0+160 0x0+160 RW +0x10000
- +DYNAMIC +0x0+448 0x0+10010448 0x0+10010448 0x0+100 0x0+100 RW +0x8
- +TLS +0x0+410 0x0+10010410 0x0+10010410 0x0+38 0x0+70 R +0x8
+ +LOAD +0x0+ 0x0+10000000 0x0+10000000 0x0+46c 0x0+46c R E 0x10000
+ +LOAD +0x0+470 0x0+10010470 0x0+10010470 0x0+1b8 0x0+1e8 RW +0x10000
+ +DYNAMIC +0x0+4a8 0x0+100104a8 0x0+100104a8 0x0+150 0x0+150 RW +0x8
+ +TLS +0x0+470 0x0+10010470 0x0+10010470 0x0+38 0x0+70 R +0x8
 
  Section to Segment mapping:
  +Segment Sections\.\.\.
- +00 +
+ +0+ +
  +01 +\.interp 
- +02 +\.interp \.hash \.dynsym \.dynstr \.rela\.dyn \.text 
- +03 +\.tdata \.tbss \.dynamic \.got 
+ +02 +\.interp \.hash \.dynsym \.dynstr \.rela\.dyn \.rela\.plt \.text 
+ +03 +\.tdata \.tbss \.dynamic \.got \.plt 
  +04 +\.tbss \.dynamic 
  +05 +\.tdata \.tbss 
 
-Relocation section '\.rela\.dyn' at offset .* contains 3 entries:
+Relocation section '\.rela\.dyn' at offset .* contains 2 entries:
  +Offset +Info +Type +Symbol's Value +Symbol's Name \+ Addend
-0+10010558 +0+200000049 R_PPC64_TPREL64 +0+ gd \+ 0
-0+10010560 +0+400000049 R_PPC64_TPREL64 +0+ ld \+ 0
-0+10010568 +0+60000004e R_PPC64_DTPREL64 +0+50 ld2 \+ 0
+0+10010618 +0+200000049 R_PPC64_TPREL64 +0+ gd \+ 0
+0+10010620 +0+70000004e R_PPC64_DTPREL64 +0+50 ld2 \+ 0
 
-Symbol table '\.dynsym' contains 10 entries:
+Relocation section '\.rela\.plt' at offset .* contains 1 entries:
+ +Offset +Info +Type +Symbol's Value +Symbol's Name \+ Addend
+0+10010640 +0+300000015 R_PPC64_JMP_SLOT +0+ __tls_get_addr \+ 0
+
+Symbol table '\.dynsym' contains 11 entries:
  +Num: +Value +Size Type +Bind +Vis +Ndx Name
  +0: 0+ +0 NOTYPE +LOCAL +DEFAULT +UND 
- +1: 0+10010448 +0 OBJECT +GLOBAL DEFAULT +ABS _DYNAMIC
+ +1: 0+100104a8 +0 OBJECT +GLOBAL DEFAULT +ABS _DYNAMIC
  +2: 0+ +0 TLS +GLOBAL DEFAULT +UND gd
- +3: 0+ +0 NOTYPE +GLOBAL DEFAULT +UND \.__tls_get_addr
- +4: 0+ +0 TLS +GLOBAL DEFAULT +UND ld
- +5: 0+10010570 +0 NOTYPE +GLOBAL DEFAULT +ABS __end
- +6: 0+50 +0 TLS +GLOBAL DEFAULT +10 ld2
- +7: 0+10010570 +0 NOTYPE +GLOBAL DEFAULT +ABS __bss_start
- +8: 0+10010570 +0 NOTYPE +GLOBAL DEFAULT +ABS _edata
- +9: 0+10010570 +0 NOTYPE +GLOBAL DEFAULT +ABS _end
+ +3: 0+ +0 NOTYPE +GLOBAL DEFAULT +UND __tls_get_addr
+ +4: 0+ +0 FUNC +GLOBAL DEFAULT +UND \.__tls_get_addr
+ +5: 0+ +0 TLS +GLOBAL DEFAULT +UND ld
+ +6: 0+10010658 +0 NOTYPE +GLOBAL DEFAULT +ABS __end
+ +7: 0+50 +0 TLS +GLOBAL DEFAULT +11 ld2
+ +8: 0+10010628 +0 NOTYPE +GLOBAL DEFAULT +ABS __bss_start
+ +9: 0+10010628 +0 NOTYPE +GLOBAL DEFAULT +ABS _edata
+ +10: 0+10010658 +0 NOTYPE +GLOBAL DEFAULT +ABS _end
 
-Symbol table '\.symtab' contains 43 entries:
+Symbol table '\.symtab' contains 46 entries:
  +Num: +Value +Size Type +Bind +Vis +Ndx Name
  +0: 0+ +0 NOTYPE +LOCAL +DEFAULT +UND 
  +1: 0+10000190 +0 SECTION LOCAL +DEFAULT +1 
  +2: 0+100001a8 +0 SECTION LOCAL +DEFAULT +2 
  +3: 0+100001e8 +0 SECTION LOCAL +DEFAULT +3 
- +4: 0+100002d8 +0 SECTION LOCAL +DEFAULT +4 
- +5: 0+10000330 +0 SECTION LOCAL +DEFAULT +5 
+ +4: 0+100002f0 +0 SECTION LOCAL +DEFAULT +4 
+ +5: 0+10000348 +0 SECTION LOCAL +DEFAULT +5 
  +6: 0+10000378 +0 SECTION LOCAL +DEFAULT +6 
- +7: 0+10010410 +0 SECTION LOCAL +DEFAULT +7 
- +8: 0+10010410 +0 SECTION LOCAL +DEFAULT +8 
- +9: 0+10010410 +0 SECTION LOCAL +DEFAULT +9 
- +10: 0+10010448 +0 SECTION LOCAL +DEFAULT +10 
- +11: 0+10010448 +0 SECTION LOCAL +DEFAULT +11 
- +12: 0+10010548 +0 SECTION LOCAL +DEFAULT +12 
- +13: 0+10010548 +0 SECTION LOCAL +DEFAULT +13 
- +14: 0+10010548 +0 SECTION LOCAL +DEFAULT +14 
- +15: 0+10010570 +0 SECTION LOCAL +DEFAULT +15 
- +16: 0+10010570 +0 SECTION LOCAL +DEFAULT +16 
- +17: 0+ +0 SECTION LOCAL +DEFAULT +17 
- +18: 0+ +0 SECTION LOCAL +DEFAULT +18 
+ +7: 0+10000390 +0 SECTION LOCAL +DEFAULT +7 
+ +8: 0+10010470 +0 SECTION LOCAL +DEFAULT +8 
+ +9: 0+10010470 +0 SECTION LOCAL +DEFAULT +9 
+ +10: 0+10010470 +0 SECTION LOCAL +DEFAULT +10 
+ +11: 0+100104a8 +0 SECTION LOCAL +DEFAULT +11 
+ +12: 0+100104a8 +0 SECTION LOCAL +DEFAULT +12 
+ +13: 0+100105f8 +0 SECTION LOCAL +DEFAULT +13 
+ +14: 0+100105f8 +0 SECTION LOCAL +DEFAULT +14 
+ +15: 0+100105f8 +0 SECTION LOCAL +DEFAULT +15 
+ +16: 0+10010628 +0 SECTION LOCAL +DEFAULT +16 
+ +17: 0+10010628 +0 SECTION LOCAL +DEFAULT +17 
+ +18: 0+10010658 +0 SECTION LOCAL +DEFAULT +18 
  +19: 0+ +0 SECTION LOCAL +DEFAULT +19 
- +20: 0+ +0 TLS +LOCAL +DEFAULT +9 gd4
- +21: 0+8 +0 TLS +LOCAL +DEFAULT +9 ld4
- +22: 0+10 +0 TLS +LOCAL +DEFAULT +9 ld5
- +23: 0+18 +0 TLS +LOCAL +DEFAULT +9 ld6
- +24: 0+20 +0 TLS +LOCAL +DEFAULT +9 ie4
- +25: 0+28 +0 TLS +LOCAL +DEFAULT +9 le4
- +26: 0+30 +0 TLS +LOCAL +DEFAULT +9 le5
- +27: 0+10010448 +0 OBJECT +GLOBAL DEFAULT +ABS _DYNAMIC
- +28: 0+ +0 TLS +GLOBAL DEFAULT +UND gd
- +29: 0+60 +0 TLS +GLOBAL DEFAULT +10 le0
- +30: 0+ +0 NOTYPE +GLOBAL DEFAULT +UND \.__tls_get_addr
- +31: 0+40 +0 TLS +GLOBAL DEFAULT +10 ld0
- +32: 0+68 +0 TLS +GLOBAL DEFAULT +10 le1
- +33: 0+ +0 TLS +GLOBAL DEFAULT +UND ld
- +34: 0+10000378 +0 NOTYPE +GLOBAL DEFAULT +6 _start
- +35: 0+10010570 +0 NOTYPE +GLOBAL DEFAULT +ABS __end
- +36: 0+50 +0 TLS +GLOBAL DEFAULT +10 ld2
- +37: 0+48 +0 TLS +GLOBAL DEFAULT +10 ld1
- +38: 0+10010570 +0 NOTYPE +GLOBAL DEFAULT +ABS __bss_start
- +39: 0+10010570 +0 NOTYPE +GLOBAL DEFAULT +ABS _edata
- +40: 0+10010570 +0 NOTYPE +GLOBAL DEFAULT +ABS _end
- +41: 0+38 +0 TLS +GLOBAL DEFAULT +10 gd0
- +42: 0+58 +0 TLS +GLOBAL DEFAULT +10 ie0
+ +20: 0+ +0 SECTION LOCAL +DEFAULT +20 
+ +21: 0+ +0 SECTION LOCAL +DEFAULT +21 
+ +22: 0+ +0 TLS +LOCAL +DEFAULT +10 gd4
+ +23: 0+8 +0 TLS +LOCAL +DEFAULT +10 ld4
+ +24: 0+10 +0 TLS +LOCAL +DEFAULT +10 ld5
+ +25: 0+18 +0 TLS +LOCAL +DEFAULT +10 ld6
+ +26: 0+20 +0 TLS +LOCAL +DEFAULT +10 ie4
+ +27: 0+28 +0 TLS +LOCAL +DEFAULT +10 le4
+ +28: 0+30 +0 TLS +LOCAL +DEFAULT +10 le5
+ +29: 0+100104a8 +0 OBJECT +GLOBAL DEFAULT +ABS _DYNAMIC
+ +30: 0+ +0 TLS +GLOBAL DEFAULT +UND gd
+ +31: 0+60 +0 TLS +GLOBAL DEFAULT +11 le0
+ +32: 0+ +0 NOTYPE +GLOBAL DEFAULT +UND __tls_get_addr
+ +33: 0+ +0 FUNC +GLOBAL DEFAULT +UND \.__tls_get_addr
+ +34: 0+40 +0 TLS +GLOBAL DEFAULT +11 ld0
+ +35: 0+68 +0 TLS +GLOBAL DEFAULT +11 le1
+ +36: 0+ +0 TLS +GLOBAL DEFAULT +UND ld
+ +37: 0+100003ac +0 NOTYPE +GLOBAL DEFAULT +7 _start
+ +38: 0+10010658 +0 NOTYPE +GLOBAL DEFAULT +ABS __end
+ +39: 0+50 +0 TLS +GLOBAL DEFAULT +11 ld2
+ +40: 0+48 +0 TLS +GLOBAL DEFAULT +11 ld1
+ +41: 0+10010628 +0 NOTYPE +GLOBAL DEFAULT +ABS __bss_start
+ +42: 0+10010628 +0 NOTYPE +GLOBAL DEFAULT +ABS _edata
+ +43: 0+10010658 +0 NOTYPE +GLOBAL DEFAULT +ABS _end
+ +44: 0+38 +0 TLS +GLOBAL DEFAULT +11 gd0
+ +45: 0+58 +0 TLS +GLOBAL DEFAULT +11 ie0
--- ld/testsuite/ld-powerpc/tlsexe.t	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlsexe.t	9 Feb 2003 03:10:53 -0000
@@ -7,7 +7,7 @@
 .*: +file format elf64-powerpc
 
 Contents of section \.tdata:
- 10010410 12345678 9abcdef0 23456789 abcdef01  .*
- 10010420 3456789a bcdef012 456789ab cdef0123  .*
- 10010430 56789abc def01234 6789abcd ef012345  .*
- 10010440 789abcde f0123456                    .*
+ 10010470 12345678 9abcdef0 23456789 abcdef01  .*
+ 10010480 3456789a bcdef012 456789ab cdef0123  .*
+ 10010490 56789abc def01234 6789abcd ef012345  .*
+ 100104a0 789abcde f0123456                    .*
--- ld/testsuite/ld-powerpc/tlsexetoc.d	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlsexetoc.d	9 Feb 2003 03:10:53 -0000
@@ -8,26 +8,45 @@
 
 Disassembly of section \.text:
 
-0+10000338 <_start>:
-    10000338:	e8 62 80 08 	ld	r3,-32760\(r2\)
-    1000033c:	60 00 00 00 	nop
-    10000340:	7c 63 6a 14 	add	r3,r3,r13
-    10000344:	e8 62 80 18 	ld	r3,-32744\(r2\)
-    10000348:	60 00 00 00 	nop
-    1000034c:	7c 63 6a 14 	add	r3,r3,r13
-    10000350:	3c 6d 00 00 	addis	r3,r13,0
-    10000354:	60 00 00 00 	nop
-    10000358:	38 63 91 40 	addi	r3,r3,-28352
-    1000035c:	3c 6d 00 00 	addis	r3,r13,0
-    10000360:	60 00 00 00 	nop
-    10000364:	38 63 10 00 	addi	r3,r3,4096
-    10000368:	39 23 80 40 	addi	r9,r3,-32704
-    1000036c:	3d 23 00 00 	addis	r9,r3,0
-    10000370:	81 49 80 48 	lwz	r10,-32696\(r9\)
-    10000374:	3d 2d 00 00 	addis	r9,r13,0
-    10000378:	7d 49 18 2a 	ldx	r10,r9,r3
-    1000037c:	3d 2d 00 00 	addis	r9,r13,0
-    10000380:	a1 49 91 88 	lhz	r10,-28280\(r9\)
-    10000384:	89 4d 90 60 	lbz	r10,-28576\(r13\)
-    10000388:	3d 2d 00 00 	addis	r9,r13,0
-    1000038c:	99 49 90 68 	stb	r10,-28568\(r9\)
+0+10000370 <_start-0x1c>:
+    10000370:	3d 82 00 00 	addis	r12,r2,0
+    10000374:	f8 41 00 28 	std	r2,40\(r1\)
+    10000378:	e9 6c 80 70 	ld	r11,-32656\(r12\)
+    1000037c:	e8 4c 80 78 	ld	r2,-32648\(r12\)
+    10000380:	7d 69 03 a6 	mtctr	r11
+    10000384:	e9 6c 80 80 	ld	r11,-32640\(r12\)
+    10000388:	4e 80 04 20 	bctr
+
+0+1000038c <_start>:
+    1000038c:	e8 62 80 08 	ld	r3,-32760\(r2\)
+    10000390:	60 00 00 00 	nop
+    10000394:	7c 63 6a 14 	add	r3,r3,r13
+    10000398:	38 62 80 18 	addi	r3,r2,-32744
+    1000039c:	4b ff ff d5 	bl	10000370 <le1\+0x10000308>
+    100003a0:	e8 41 00 28 	ld	r2,40\(r1\)
+    100003a4:	3c 6d 00 00 	addis	r3,r13,0
+    100003a8:	60 00 00 00 	nop
+    100003ac:	38 63 91 90 	addi	r3,r3,-28272
+    100003b0:	3c 6d 00 00 	addis	r3,r13,0
+    100003b4:	60 00 00 00 	nop
+    100003b8:	38 63 10 00 	addi	r3,r3,4096
+    100003bc:	39 23 80 40 	addi	r9,r3,-32704
+    100003c0:	3d 23 00 00 	addis	r9,r3,0
+    100003c4:	81 49 80 48 	lwz	r10,-32696\(r9\)
+    100003c8:	3d 2d 00 00 	addis	r9,r13,0
+    100003cc:	7d 49 18 2a 	ldx	r10,r9,r3
+    100003d0:	3d 2d 00 00 	addis	r9,r13,0
+    100003d4:	a1 49 91 d8 	lhz	r10,-28200\(r9\)
+    100003d8:	89 4d 90 60 	lbz	r10,-28576\(r13\)
+    100003dc:	3d 2d 00 00 	addis	r9,r13,0
+    100003e0:	99 49 90 68 	stb	r10,-28568\(r9\)
+    100003e4:	e8 41 00 28 	ld	r2,40\(r1\)
+    100003e8:	3d 82 00 00 	addis	r12,r2,0
+    100003ec:	e9 6c 80 58 	ld	r11,-32680\(r12\)
+    100003f0:	e8 4c 80 60 	ld	r2,-32672\(r12\)
+    100003f4:	7d 69 03 a6 	mtctr	r11
+    100003f8:	e9 6c 80 68 	ld	r11,-32664\(r12\)
+    100003fc:	4e 80 04 20 	bctr
+    10000400:	60 00 00 00 	nop
+    10000404:	38 00 00 00 	li	r0,0
+    10000408:	4b ff ff dc 	b	100003e4 <_start\+0x58>
--- ld/testsuite/ld-powerpc/tlsexetoc.g	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlsexetoc.g	9 Feb 2003 03:10:53 -0000
@@ -7,8 +7,8 @@
 .*: +file format elf64-powerpc
 
 Contents of section \.toc:
- 100104d0 00000000 00000000 00000000 00000000  .*
- 100104e0 00000000 00000000 00000000 00000000  .*
- 100104f0 00000000 00000001 00000000 00000000  .*
- 10010500 00000000 00000001 00000000 00000000  .*
- 10010510 ffffffff ffff8050 00000000 00000000  .*
+ 100105a0 00000000 00000000 00000000 00000000  .*
+ 100105b0 00000000 00000000 00000000 00000000  .*
+ 100105c0 00000000 00000001 00000000 00000000  .*
+ 100105d0 00000000 00000001 00000000 00000000  .*
+ 100105e0 ffffffff ffff8050 00000000 00000000  .*
--- ld/testsuite/ld-powerpc/tlsexetoc.r	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlsexetoc.r	9 Feb 2003 03:10:53 -0000
@@ -1,39 +1,41 @@
 #source: tlslib.s
 #source: tlstoc.s
 #as: -a64
-#ld: -shared -melf64ppc
+#ld: -melf64ppc
 #readelf: -WSsrl
 #target: powerpc64*-*-*
 
-There are 21 section headers.*
+There are 23 section headers.*
 
 Section Headers:
  +\[Nr\] Name +Type +Address +Off +Size +ES Flg Lk Inf Al
  +\[ 0\] +NULL +0+ 0+ 0+ 0+ +0 +0 +0
- +\[ 1\] .interp +PROGBITS +0+10000190 0+190 0+11 0+ +A +0 +0 +1
- +\[ 2\] .hash +HASH +0+100001a8 0+1a8 0+38 04 +A +3 +0 +8
- +\[ 3\] .dynsym +DYNSYM +0+100001e0 0+1e0 0+d8 18 +A +4 +1 +8
- +\[ 4\] .dynstr +STRTAB +0+100002b8 0+2b8 0+4d 0+ +A +0 +0 +1
- +\[ 5\] .rela.dyn +RELA +0+10000308 0+308 0+30 18 +A +3 +0 +8
- +\[ 6\] .text +PROGBITS +0+10000338 0+338 0+58 0+ +AX +0 +0 +4
- +\[ 7\] .data +PROGBITS +0+10010390 0+390 0+ 0+ +WA +0 +0 +1
- +\[ 8\] .branch_lt +PROGBITS +0+10010390 0+390 0+ 0+ +WA +0 +0 +8
- +\[ 9\] .tdata +PROGBITS +0+10010390 0+390 0+38 0+ WAT +0 +0 +8
- +\[10\] .tbss +NOBITS +0+100103c8 0+3c8 0+38 0+ WAT +0 +0 +8
- +\[11\] .dynamic +DYNAMIC +0+100103c8 0+3c8 0+100 10 +WA +4 +0 +8
- +\[12\] .ctors +PROGBITS +0+100104c8 0+520 0+ 0+ +W +0 +0 +1
- +\[13\] .dtors +PROGBITS +0+100104c8 0+520 0+ 0+ +W +0 +0 +1
- +\[14\] .got +PROGBITS +0+100104c8 0+4c8 0+8 08 +WA +0 +0 +8
- +\[15\] .toc +PROGBITS +0+100104d0 0+4d0 0+50 0+ +WA +0 +0 +1
- +\[16\] .sbss +PROGBITS +0+10010520 0+520 0+ 0+ +W +0 +0 +1
- +\[17\] .bss +NOBITS +0+10010520 0+520 0+ 0+ +WA +0 +0 +1
- +\[18\] .shstrtab +STRTAB +0+ 0+520 0+93 0+ +0 +0 +1
- +\[19\] .symtab +SYMTAB +0+ 0+af8 0+438 18 +20 +1d +8
- +\[20\] .strtab +STRTAB +0+ 0+f30 0+83 0+ +0 +0 +1
+ +\[ 1\] \.interp +PROGBITS +0+10000190 0+190 0+11 0+ +A +0 +0 +1
+ +\[ 2\] \.hash +HASH +0+100001a8 0+1a8 0+3c 04 +A +3 +0 +8
+ +\[ 3\] \.dynsym +DYNSYM +0+100001e8 0+1e8 0+f0 18 +A +4 +1 +8
+ +\[ 4\] \.dynstr +STRTAB +0+100002d8 0+2d8 0+4d 0+ +A +0 +0 +1
+ +\[ 5\] \.rela\.dyn +RELA +0+10000328 0+328 0+30 18 +A +3 +0 +8
+ +\[ 6\] \.rela\.plt +RELA +0+10000358 0+358 0+18 18 +A +3 +12 +8
+ +\[ 7\] \.text +PROGBITS +0+10000370 0+370 0+9c 0+ +AX +0 +0 +4
+ +\[ 8\] \.data +PROGBITS +0+10010410 0+410 0+ 0+ +WA +0 +0 +1
+ +\[ 9\] \.branch_lt +PROGBITS +0+10010410 0+410 0+ 0+ +WA +0 +0 +8
+ +\[10\] \.tdata +PROGBITS +0+10010410 0+410 0+38 0+ WAT +0 +0 +8
+ +\[11\] \.tbss +NOBITS +0+10010448 0+448 0+38 0+ WAT +0 +0 +8
+ +\[12\] \.dynamic +DYNAMIC +0+10010448 0+448 0+150 10 +WA +4 +0 +8
+ +\[13\] \.ctors +PROGBITS +0+10010598 0+5f0 0+ 0+ +W +0 +0 +1
+ +\[14\] \.dtors +PROGBITS +0+10010598 0+5f0 0+ 0+ +W +0 +0 +1
+ +\[15\] \.got +PROGBITS +0+10010598 0+598 0+8 08 +WA +0 +0 +8
+ +\[16\] \.toc +PROGBITS +0+100105a0 0+5a0 0+50 0+ +WA +0 +0 +1
+ +\[17\] \.sbss +PROGBITS +0+100105f0 0+5f0 0+ 0+ +W +0 +0 +1
+ +\[18\] \.plt +NOBITS +0+100105f0 0+5f0 0+30 18 +WA +0 +0 +8
+ +\[19\] \.bss +NOBITS +0+10010620 0+5f0 0+ 0+ +WA +0 +0 +1
+ +\[20\] \.shstrtab +STRTAB +0+ 0+5f0 0+9d 0+ +0 +0 +1
+ +\[21\] \.symtab +SYMTAB +0+ 0+c50 0+480 18 +22 +1f +8
+ +\[22\] \.strtab +STRTAB +0+ 0+10d0 0+92 0+ +0 +0 +1
 #...
 
 Elf file type is EXEC \(Executable file\)
-Entry point 0x10000338
+Entry point 0x1000038c
 There are 6 program headers.*
 
 Program Headers:
@@ -41,81 +43,89 @@ Program Headers:
  +PHDR +0x0+40 0x0+10000040 0x0+10000040 0x0+150 0x0+150 R E 0x8
  +INTERP +0x0+190 0x0+10000190 0x0+10000190 0x0+11 0x0+11 R +0x1
  +\[Requesting program interpreter: .*\]
- +LOAD +0x0+ 0x0+10000000 0x0+10000000 0x0+390 0x0+390 R E 0x10000
- +LOAD +0x0+390 0x0+10010390 0x0+10010390 0x0+190 0x0+190 RW +0x10000
- +DYNAMIC +0x0+3c8 0x0+100103c8 0x0+100103c8 0x0+100 0x0+100 RW +0x8
- +TLS +0x0+390 0x0+10010390 0x0+10010390 0x0+38 0x0+70 R +0x8
+ +LOAD +0x0+ 0x0+10000000 0x0+10000000 0x0+40c 0x0+40c R E 0x10000
+ +LOAD +0x0+410 0x0+10010410 0x0+10010410 0x0+1e0 0x0+210 RW +0x10000
+ +DYNAMIC +0x0+448 0x0+10010448 0x0+10010448 0x0+150 0x0+150 RW +0x8
+ +TLS +0x0+410 0x0+10010410 0x0+10010410 0x0+38 0x0+70 R +0x8
 
  Section to Segment mapping:
  +Segment Sections\.\.\.
- +00 +
+ +0+ +
  +01 +\.interp 
- +02 +\.interp \.hash \.dynsym \.dynstr \.rela\.dyn \.text 
- +03 +\.tdata \.tbss \.dynamic \.got \.toc 
+ +02 +\.interp \.hash \.dynsym \.dynstr \.rela\.dyn \.rela\.plt \.text 
+ +03 +\.tdata \.tbss \.dynamic \.got \.toc \.plt 
  +04 +\.tbss \.dynamic 
  +05 +\.tdata \.tbss 
 
 Relocation section '\.rela\.dyn' at offset .* contains 2 entries:
  +Offset +Info +Type +Symbol's Value +Symbol's Name \+ Addend
-0+100104d0 +0+200000049 R_PPC64_TPREL64 +0+ gd \+ 0
-0+100104e0 +0+400000049 R_PPC64_TPREL64 +0+ ld \+ 0
+0+100105a0 +0+200000049 R_PPC64_TPREL64 +0+ gd \+ 0
+0+100105b0 +0+500000044 R_PPC64_DTPMOD64 +0+ ld \+ 0
 
-Symbol table '\.dynsym' contains 9 entries:
+Relocation section '\.rela\.plt' at offset .* contains 1 entries:
+ +Offset +Info +Type +Symbol's Value +Symbol's Name \+ Addend
+0+10010608 +0+300000015 R_PPC64_JMP_SLOT +0+ __tls_get_addr \+ 0
+
+Symbol table '\.dynsym' contains 10 entries:
  +Num: +Value +Size Type +Bind +Vis +Ndx Name
  +0: 0+ +0 NOTYPE +LOCAL +DEFAULT +UND 
- +1: 0+100103c8 +0 OBJECT +GLOBAL DEFAULT +ABS _DYNAMIC
+ +1: 0+10010448 +0 OBJECT +GLOBAL DEFAULT +ABS _DYNAMIC
  +2: 0+ +0 TLS +GLOBAL DEFAULT +UND gd
- +3: 0+ +0 NOTYPE +GLOBAL DEFAULT +UND \.__tls_get_addr
- +4: 0+ +0 TLS +GLOBAL DEFAULT +UND ld
- +5: 0+10010520 +0 NOTYPE +GLOBAL DEFAULT +ABS __end
- +6: 0+10010520 +0 NOTYPE +GLOBAL DEFAULT +ABS __bss_start
- +7: 0+10010520 +0 NOTYPE +GLOBAL DEFAULT +ABS _edata
- +8: 0+10010520 +0 NOTYPE +GLOBAL DEFAULT +ABS _end
+ +3: 0+ +0 NOTYPE +GLOBAL DEFAULT +UND __tls_get_addr
+ +4: 0+ +0 FUNC +GLOBAL DEFAULT +UND \.__tls_get_addr
+ +5: 0+ +0 TLS +GLOBAL DEFAULT +UND ld
+ +6: 0+10010620 +0 NOTYPE +GLOBAL DEFAULT +ABS __end
+ +7: 0+100105f0 +0 NOTYPE +GLOBAL DEFAULT +ABS __bss_start
+ +8: 0+100105f0 +0 NOTYPE +GLOBAL DEFAULT +ABS _edata
+ +9: 0+10010620 +0 NOTYPE +GLOBAL DEFAULT +ABS _end
 
-Symbol table '\.symtab' contains 45 entries:
+Symbol table '\.symtab' contains 48 entries:
  +Num: +Value +Size Type +Bind +Vis +Ndx Name
  +0: 0+ +0 NOTYPE +LOCAL +DEFAULT +UND 
  +1: 0+10000190 +0 SECTION LOCAL +DEFAULT +1 
  +2: 0+100001a8 +0 SECTION LOCAL +DEFAULT +2 
- +3: 0+100001e0 +0 SECTION LOCAL +DEFAULT +3 
- +4: 0+100002b8 +0 SECTION LOCAL +DEFAULT +4 
- +5: 0+10000308 +0 SECTION LOCAL +DEFAULT +5 
- +6: 0+10000338 +0 SECTION LOCAL +DEFAULT +6 
- +7: 0+10010390 +0 SECTION LOCAL +DEFAULT +7 
- +8: 0+10010390 +0 SECTION LOCAL +DEFAULT +8 
- +9: 0+10010390 +0 SECTION LOCAL +DEFAULT +9 
- +10: 0+100103c8 +0 SECTION LOCAL +DEFAULT +10 
- +11: 0+100103c8 +0 SECTION LOCAL +DEFAULT +11 
- +12: 0+100104c8 +0 SECTION LOCAL +DEFAULT +12 
- +13: 0+100104c8 +0 SECTION LOCAL +DEFAULT +13 
- +14: 0+100104c8 +0 SECTION LOCAL +DEFAULT +14 
- +15: 0+100104d0 +0 SECTION LOCAL +DEFAULT +15 
- +16: 0+10010520 +0 SECTION LOCAL +DEFAULT +16 
- +17: 0+10010520 +0 SECTION LOCAL +DEFAULT +17 
- +18: 0+ +0 SECTION LOCAL +DEFAULT +18 
- +19: 0+ +0 SECTION LOCAL +DEFAULT +19 
+ +3: 0+100001e8 +0 SECTION LOCAL +DEFAULT +3 
+ +4: 0+100002d8 +0 SECTION LOCAL +DEFAULT +4 
+ +5: 0+10000328 +0 SECTION LOCAL +DEFAULT +5 
+ +6: 0+10000358 +0 SECTION LOCAL +DEFAULT +6 
+ +7: 0+10000370 +0 SECTION LOCAL +DEFAULT +7 
+ +8: 0+10010410 +0 SECTION LOCAL +DEFAULT +8 
+ +9: 0+10010410 +0 SECTION LOCAL +DEFAULT +9 
+ +10: 0+10010410 +0 SECTION LOCAL +DEFAULT +10 
+ +11: 0+10010448 +0 SECTION LOCAL +DEFAULT +11 
+ +12: 0+10010448 +0 SECTION LOCAL +DEFAULT +12 
+ +13: 0+10010598 +0 SECTION LOCAL +DEFAULT +13 
+ +14: 0+10010598 +0 SECTION LOCAL +DEFAULT +14 
+ +15: 0+10010598 +0 SECTION LOCAL +DEFAULT +15 
+ +16: 0+100105a0 +0 SECTION LOCAL +DEFAULT +16 
+ +17: 0+100105f0 +0 SECTION LOCAL +DEFAULT +17 
+ +18: 0+100105f0 +0 SECTION LOCAL +DEFAULT +18 
+ +19: 0+10010620 +0 SECTION LOCAL +DEFAULT +19 
  +20: 0+ +0 SECTION LOCAL +DEFAULT +20 
- +21: 0+ +0 TLS +LOCAL +DEFAULT +9 gd4
- +22: 0+8 +0 TLS +LOCAL +DEFAULT +9 ld4
- +23: 0+10 +0 TLS +LOCAL +DEFAULT +9 ld5
- +24: 0+18 +0 TLS +LOCAL +DEFAULT +9 ld6
- +25: 0+20 +0 TLS +LOCAL +DEFAULT +9 ie4
- +26: 0+28 +0 TLS +LOCAL +DEFAULT +9 le4
- +27: 0+30 +0 TLS +LOCAL +DEFAULT +9 le5
- +28: 0+10010518 +0 NOTYPE +LOCAL +DEFAULT +15 \.Lie0
- +29: 0+100103c8 +0 OBJECT +GLOBAL DEFAULT +ABS _DYNAMIC
- +30: 0+ +0 TLS +GLOBAL DEFAULT +UND gd
- +31: 0+60 +0 TLS +GLOBAL DEFAULT +10 le0
- +32: 0+ +0 NOTYPE +GLOBAL DEFAULT +UND \.__tls_get_addr
- +33: 0+40 +0 TLS +GLOBAL DEFAULT +10 ld0
- +34: 0+68 +0 TLS +GLOBAL DEFAULT +10 le1
- +35: 0+ +0 TLS +GLOBAL DEFAULT +UND ld
- +36: 0+10000338 +0 NOTYPE +GLOBAL DEFAULT +6 _start
- +37: 0+10010520 +0 NOTYPE +GLOBAL DEFAULT +ABS __end
- +38: 0+50 +0 TLS +GLOBAL DEFAULT +10 ld2
- +39: 0+48 +0 TLS +GLOBAL DEFAULT +10 ld1
- +40: 0+10010520 +0 NOTYPE +GLOBAL DEFAULT +ABS __bss_start
- +41: 0+10010520 +0 NOTYPE +GLOBAL DEFAULT +ABS _edata
- +42: 0+10010520 +0 NOTYPE +GLOBAL DEFAULT +ABS _end
- +43: 0+38 +0 TLS +GLOBAL DEFAULT +10 gd0
- +44: 0+58 +0 TLS +GLOBAL DEFAULT +10 ie0
+ +21: 0+ +0 SECTION LOCAL +DEFAULT +21 
+ +22: 0+ +0 SECTION LOCAL +DEFAULT +22 
+ +23: 0+ +0 TLS +LOCAL +DEFAULT +10 gd4
+ +24: 0+8 +0 TLS +LOCAL +DEFAULT +10 ld4
+ +25: 0+10 +0 TLS +LOCAL +DEFAULT +10 ld5
+ +26: 0+18 +0 TLS +LOCAL +DEFAULT +10 ld6
+ +27: 0+20 +0 TLS +LOCAL +DEFAULT +10 ie4
+ +28: 0+28 +0 TLS +LOCAL +DEFAULT +10 le4
+ +29: 0+30 +0 TLS +LOCAL +DEFAULT +10 le5
+ +30: 0+100105e8 +0 NOTYPE +LOCAL +DEFAULT +16 \.Lie0
+ +31: 0+10010448 +0 OBJECT +GLOBAL DEFAULT +ABS _DYNAMIC
+ +32: 0+ +0 TLS +GLOBAL DEFAULT +UND gd
+ +33: 0+60 +0 TLS +GLOBAL DEFAULT +11 le0
+ +34: 0+ +0 NOTYPE +GLOBAL DEFAULT +UND __tls_get_addr
+ +35: 0+ +0 FUNC +GLOBAL DEFAULT +UND \.__tls_get_addr
+ +36: 0+40 +0 TLS +GLOBAL DEFAULT +11 ld0
+ +37: 0+68 +0 TLS +GLOBAL DEFAULT +11 le1
+ +38: 0+ +0 TLS +GLOBAL DEFAULT +UND ld
+ +39: 0+1000038c +0 NOTYPE +GLOBAL DEFAULT +7 _start
+ +40: 0+10010620 +0 NOTYPE +GLOBAL DEFAULT +ABS __end
+ +41: 0+50 +0 TLS +GLOBAL DEFAULT +11 ld2
+ +42: 0+48 +0 TLS +GLOBAL DEFAULT +11 ld1
+ +43: 0+100105f0 +0 NOTYPE +GLOBAL DEFAULT +ABS __bss_start
+ +44: 0+100105f0 +0 NOTYPE +GLOBAL DEFAULT +ABS _edata
+ +45: 0+10010620 +0 NOTYPE +GLOBAL DEFAULT +ABS _end
+ +46: 0+38 +0 TLS +GLOBAL DEFAULT +11 gd0
+ +47: 0+58 +0 TLS +GLOBAL DEFAULT +11 ie0
--- ld/testsuite/ld-powerpc/tlsexetoc.t	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlsexetoc.t	9 Feb 2003 03:10:53 -0000
@@ -7,7 +7,7 @@
 .*: +file format elf64-powerpc
 
 Contents of section \.tdata:
- 10010390 12345678 9abcdef0 23456789 abcdef01  .*
- 100103a0 3456789a bcdef012 456789ab cdef0123  .*
- 100103b0 56789abc def01234 6789abcd ef012345  .*
- 100103c0 789abcde f0123456                    .*
+ 10010410 12345678 9abcdef0 23456789 abcdef01  .*
+ 10010420 3456789a bcdef012 456789ab cdef0123  .*
+ 10010430 56789abc def01234 6789abcd ef012345  .*
+ 10010440 789abcde f0123456                    .*
--- ld/testsuite/ld-powerpc/tlslib.s	4 Feb 2003 14:52:11 -0000	1.1
+++ ld/testsuite/ld-powerpc/tlslib.s	9 Feb 2003 03:10:53 -0000
@@ -1,4 +1,5 @@
 	.global .__tls_get_addr,__tls_get_addr,gd,ld
+	.type .__tls_get_addr,@function
 
 	.section ".opd","aw",@progbits
 __tls_get_addr:

