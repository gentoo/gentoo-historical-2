2002-11-29  Jakub Jelinek  <jakub@redhat.com>

	* elfxx-ia64.c (elfNN_ia64_obj_tdata): New struct.
	(elfNN_ia64_tdata): New macro.
	(elfNN_ia64_mkobject, elfNN_ia64_object_p): New functions.
	(get_local_sym_hash): Assign keys to input bfds instead of using
	their pointer addresses for hashing purposes.
	(bfd_elfNN_mkobject, elf_backend_object_p): Define.

--- bfd/elfxx-ia64.c.jj	2002-11-28 15:49:52.000000000 +0100
+++ bfd/elfxx-ia64.c	2002-11-29 01:38:39.000000000 +0100
@@ -152,6 +152,15 @@ struct elfNN_ia64_link_hash_table
   struct elfNN_ia64_local_hash_table loc_hash_table;
 };
 
+struct elfNN_ia64_obj_tdata
+{
+  struct elf_obj_tdata root;
+  unsigned long key;
+};
+
+#define elfNN_ia64_tdata(abfd) \
+  ((struct elfNN_ia64_obj_tdata *) (abfd)->tdata.any)
+
 #define elfNN_ia64_hash_table(p) \
   ((struct elfNN_ia64_link_hash_table *) ((p)->hash))
 
@@ -317,6 +326,8 @@ static boolean elfNN_ia64_print_private_
   PARAMS ((bfd *abfd, PTR ptr));
 static enum elf_reloc_type_class elfNN_ia64_reloc_type_class
   PARAMS ((const Elf_Internal_Rela *));
+static boolean elfNN_ia64_mkobject PARAMS ((bfd *));
+static boolean elfNN_ia64_object_p PARAMS ((bfd *));
 static boolean elfNN_ia64_hpux_vec
   PARAMS ((const bfd_target *vec));
 static void elfNN_hpux_post_process_headers
@@ -1834,26 +1845,22 @@ get_local_sym_hash (ia64_info, abfd, rel
      const Elf_Internal_Rela *rel;
      boolean create;
 {
-  char *addr_name;
-  size_t len;
+  char *addr_name [2 * sizeof (unsigned long) + 2];
   struct elfNN_ia64_local_hash_entry *ret;
+  static unsigned long key;
+
+  if (! elfNN_ia64_tdata (abfd)->key)
+    elfNN_ia64_tdata (abfd)->key = ++key;
 
   /* Construct a string for use in the elfNN_ia64_local_hash_table.
      name describes what was once anonymous memory.  */
 
-  len = sizeof (void*)*2 + 1 + sizeof (bfd_vma)*4 + 1 + 1;
-  len += 10;	/* %p slop */
-
-  addr_name = bfd_malloc (len);
-  if (addr_name == NULL)
-    return 0;
-  sprintf (addr_name, "%p:%lx",
-	   (void *) abfd, (unsigned long) ELFNN_R_SYM (rel->r_info));
+  sprintf (addr_name, "%lx:%lx", elfNN_ia64_tdata (abfd)->key,
+	   (unsigned long) ELFNN_R_SYM (rel->r_info));
 
   /* Collect the canonical entry data for this address.  */
   ret = elfNN_ia64_local_hash_lookup (&ia64_info->loc_hash_table,
 				      addr_name, create, create);
-  free (addr_name);
   return ret;
 }
 
@@ -4660,6 +4667,32 @@ elfNN_ia64_reloc_type_class (rela)
 }
 
 static boolean
+elfNN_ia64_mkobject (abfd)
+     bfd *abfd;
+{
+  bfd_size_type amt = sizeof (struct elfNN_ia64_obj_tdata);
+  abfd->tdata.any = bfd_zalloc (abfd, amt);
+  if (abfd->tdata.any == NULL)
+    return false;
+  return true;
+}
+
+static boolean
+elfNN_ia64_object_p (abfd)
+     bfd *abfd;
+{
+  /* Allocate our special target data.  */
+  struct elfNN_ia64_obj_tdata *new_tdata;
+  bfd_size_type amt = sizeof (struct elfNN_ia64_obj_tdata);
+  new_tdata = bfd_zalloc (abfd, amt);
+  if (new_tdata == NULL)
+    return false;
+  new_tdata->root = *abfd->tdata.elf_obj_data;
+  abfd->tdata.any = new_tdata;
+  return true;
+}
+
+static boolean
 elfNN_ia64_hpux_vec (const bfd_target *vec)
 {
   extern const bfd_target bfd_elfNN_ia64_hpux_big_vec;
@@ -4718,6 +4751,9 @@ elfNN_hpux_backend_section_from_bfd_sect
 #define elf_info_to_howto \
 	elfNN_ia64_info_to_howto
 
+#define bfd_elfNN_mkobject	elfNN_ia64_mkobject
+#define elf_backend_object_p	elfNN_ia64_object_p
+
 #define bfd_elfNN_bfd_reloc_type_lookup \
 	elfNN_ia64_reloc_type_lookup
 #define bfd_elfNN_bfd_is_local_label_name \
