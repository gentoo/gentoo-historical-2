--- gcc/config/i386/i386.c.jj	2002-11-15 19:50:05.000000000 +0100
+++ gcc/config/i386/i386.c	2002-12-08 22:09:30.000000000 +0100
@@ -707,6 +707,7 @@ struct ix86_address
 };
 
 static int ix86_decompose_address PARAMS ((rtx, struct ix86_address *));
+static bool ix86_cannot_force_const_mem PARAMS ((rtx));
 
 struct builtin_description;
 static rtx ix86_expand_sse_comi PARAMS ((const struct builtin_description *,
@@ -837,6 +838,8 @@ static enum x86_64_reg_class merge_class
 #undef TARGET_HAVE_TLS
 #define TARGET_HAVE_TLS true
 #endif
+#undef TARGET_CANNOT_FORCE_CONST_MEM
+#define TARGET_CANNOT_FORCE_CONST_MEM ix86_cannot_force_const_mem
 
 struct gcc_target targetm = TARGET_INITIALIZER;
 
@@ -4952,6 +4955,13 @@ legitimate_constant_p (x)
   return true;
 }
 
+static bool
+ix86_cannot_force_const_mem (x)
+     rtx x;
+{
+  return !legitimate_constant_p (x);
+}
+
 /* Determine if a given RTX is a valid constant address.  */
 
 bool
@@ -7568,29 +7578,6 @@ ix86_expand_move (mode, operands)
   op0 = operands[0];
   op1 = operands[1];
 
-  /* ??? We have a slight problem.  We need to say that tls symbols are
-     not legitimate constants so that reload does not helpfully reload
-     these constants from a REG_EQUIV, which we cannot handle.  (Recall
-     that general- and local-dynamic address resolution requires a
-     function call.)
-
-     However, if we say that tls symbols are not legitimate constants,
-     then emit_move_insn helpfully drop them into the constant pool.
-
-     It is far easier to work around emit_move_insn than reload.  Recognize
-     the MEM that we would have created and extract the symbol_ref.  */
-
-  if (mode == Pmode
-      && GET_CODE (op1) == MEM
-      && RTX_UNCHANGING_P (op1))
-    {
-      tmp = maybe_get_pool_constant (op1);
-      /* Note that we only care about symbolic constants here, which
-	 unlike CONST_INT will always have a proper mode.  */
-      if (tmp && GET_MODE (tmp) == Pmode)
-	op1 = tmp;
-    }
-
   if (tls_symbolic_operand (op1, Pmode))
     {
       op1 = legitimize_address (op1, op1, VOIDmode);
--- gcc/testsuite/gcc.dg/tls/opt-4.c.jj	2002-12-08 22:09:30.000000000 +0100
+++ gcc/testsuite/gcc.dg/tls/opt-4.c	2002-12-08 22:09:30.000000000 +0100
@@ -0,0 +1,53 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+struct A
+{
+  int a1;
+  int a2;
+};
+
+extern __thread const unsigned char *tcc1, **tcc2;
+
+extern inline const unsigned char ** __attribute__ ((const))
+foo (void)
+{
+  const unsigned char **a = &tcc1;
+  if (*a == 0)
+    *a = *tcc2 + 128;
+  return a;
+}
+
+extern inline int
+bar (const struct A *x)
+{
+  int a;
+
+  if (x->a2 & 8)
+    return 0;
+  a = x->a1;
+  return a > 0 && ((*foo ())[a] & 64);
+}
+
+int
+baz (const struct A *x, char *y)
+{
+  const struct A *a;
+
+  for (a = x; !!a->a1; a++)
+    if (! (x->a2 & 8))
+      if (bar (a))
+	{
+	  *y++ = a->a1;
+	  if (x->a1)
+	    *y++ = ':';
+	  *y = '\0';
+	}
+  return 0;
+}
+
+/* Verify tcc1 and tcc2 variables show up only in the TLS access sequences.  */
+/* { dg-final { scan-assembler "tcc1@" { target i?86-*-* x86_64-*-* } } } */
+/* { dg-final { scan-assembler "tcc2@" { target i?86-*-* x86_64-*-* } } } */
+/* { dg-final { scan-assembler-not "tcc1\[^@\]" { target i?86-*-* x86_64-*-* } } } */
+/* { dg-final { scan-assembler-not "tcc2\[^@\]" { target i?86-*-* x86_64-*-* } } } */
--- gcc/expr.c.jj	2002-11-09 18:38:42.000000000 +0100
+++ gcc/expr.c	2002-12-08 22:15:02.000000000 +0100
@@ -2782,6 +2782,12 @@ emit_move_insn (x, y)
     {
       y_cst = y;
       y = force_const_mem (mode, y);
+
+      /* If the target's cannot_force_const_mem prevented the spill,
+	 assume that the target's move expanders will also take care
+	 of the non-legitimate constant.  */
+      if (!y)
+	y = y_cst;
     }
 
   /* If X or Y are memory references, verify that their addresses are valid
--- gcc/hooks.c.jj	2002-11-09 18:38:45.000000000 +0100
+++ gcc/hooks.c	2002-12-08 22:09:29.000000000 +0100
@@ -46,3 +46,10 @@ hook_tree_bool_false (a)
 {
   return false;
 }
+
+bool
+hook_bool_rtx_false (a)
+     rtx a ATTRIBUTE_UNUSED;
+{
+  return false;
+}
--- gcc/hooks.h.jj	2002-11-09 18:38:45.000000000 +0100
+++ gcc/hooks.h	2002-12-08 22:16:51.000000000 +0100
@@ -25,5 +25,6 @@ Foundation, 59 Temple Place - Suite 330,
 bool hook_void_bool_false PARAMS ((void));
 void hook_void_void PARAMS ((void));
 bool hook_tree_bool_false PARAMS ((tree));
+bool hook_bool_rtx_false PARAMS ((rtx));
 
 #endif
--- gcc/reload1.c.jj	2002-10-16 16:10:07.000000000 +0200
+++ gcc/reload1.c	2002-12-08 22:09:29.000000000 +0100
@@ -820,8 +820,12 @@ reload (first, global)
 		      else if (LEGITIMATE_CONSTANT_P (x))
 			reg_equiv_constant[i] = x;
 		      else
-			reg_equiv_memory_loc[i]
-			  = force_const_mem (GET_MODE (SET_DEST (set)), x);
+			{
+			  reg_equiv_memory_loc[i]
+			    = force_const_mem (GET_MODE (SET_DEST (set)), x);
+			  if (!reg_equiv_memory_loc[i])
+			    continue;
+			}
 		    }
 		  else
 		    continue;
--- gcc/target-def.h.jj	2002-09-24 15:07:32.000000000 +0200
+++ gcc/target-def.h	2002-12-08 22:18:20.000000000 +0100
@@ -181,6 +181,7 @@ Foundation, 59 Temple Place - Suite 330,
 
 /* In hook.c.  */
 #define TARGET_CANNOT_MODIFY_JUMPS_P hook_void_bool_false
+#define TARGET_CANNOT_FORCE_CONST_MEM hook_bool_rtx_false
 
 /* The whole shebang.  */
 #define TARGET_INITIALIZER			\
@@ -199,6 +200,7 @@ Foundation, 59 Temple Place - Suite 330,
   TARGET_EXPAND_BUILTIN,			\
   TARGET_SECTION_TYPE_FLAGS,			\
   TARGET_CANNOT_MODIFY_JUMPS_P,			\
+  TARGET_CANNOT_FORCE_CONST_MEM,		\
   TARGET_HAVE_NAMED_SECTIONS,			\
   TARGET_HAVE_CTORS_DTORS,			\
   TARGET_HAVE_TLS				\
--- gcc/target.h.jj	2002-09-24 15:07:32.000000000 +0200
+++ gcc/target.h	2002-12-08 22:17:34.000000000 +0100
@@ -182,6 +182,9 @@ struct gcc_target
      not, at the current point in the compilation.  */
   bool (* cannot_modify_jumps_p) PARAMS ((void));
 
+  /* True if the constant X cannot be placed in the constant pool.  */
+  bool (* cannot_force_const_mem) PARAMS ((rtx));
+
   /* True if arbitrary sections are supported.  */
   bool have_named_sections;
 
--- gcc/varasm.c.jj	2002-11-26 17:23:47.000000000 +0100
+++ gcc/varasm.c	2002-12-08 22:09:30.000000000 +0100
@@ -3789,6 +3789,10 @@ force_const_mem (mode, x)
   struct pool_constant *pool;
   unsigned int align;
 
+  /* If we're not allowed to drop X into the constant pool, don't.  */
+  if ((*targetm.cannot_force_const_mem) (x))
+    return NULL_RTX;
+
   /* Compute hash code of X.  Search the descriptors for that hash code
      to see if any of them describes X.  If yes, we have an rtx to use.  */
   hash = const_hash_rtx (mode, x);
