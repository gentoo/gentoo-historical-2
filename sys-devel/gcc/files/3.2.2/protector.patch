Index: gcc/Makefile.in
===================================================================
RCS file: /home/cvsroot/gcc/gcc/Makefile.in,v
retrieving revision 1.1.1.12
retrieving revision 1.1.1.12.2.1
diff -c -3 -p -r1.1.1.12 -r1.1.1.12.2.1
*** gcc/Makefile.in	2003/02/19 07:11:06	1.1.1.12
--- gcc/Makefile.in	2003/02/26 08:01:00	1.1.1.12.2.1
*************** INSTALL_LIBGCC = install-libgcc
*** 358,364 ****
  # Options to use when compiling libgcc2.a.
  #
  LIBGCC2_DEBUG_CFLAGS = -g
! LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED @inhibit_libc@
  
  # Additional options to use when compiling libgcc2.a.
  # Some targets override this to -isystem include
--- 358,364 ----
  # Options to use when compiling libgcc2.a.
  #
  LIBGCC2_DEBUG_CFLAGS = -g
! LIBGCC2_CFLAGS = -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2 -D__GCC_FLOAT_NOT_NEEDED @inhibit_libc@ -fno-stack-protector
  
  # Additional options to use when compiling libgcc2.a.
  # Some targets override this to -isystem include
*************** OBJS = alias.o bb-reorder.o bitmap.o bui
*** 728,734 ****
   sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o	\
   stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-dump.o 	\
   tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \
!  $(GGC) $(out_object_file) $(EXTRA_OBJS)
  
  BACKEND = main.o libbackend.a
  
--- 728,734 ----
   sibcall.o simplify-rtx.o ssa.o ssa-ccp.o ssa-dce.o stmt.o	\
   stor-layout.o stringpool.o timevar.o toplev.o tree.o tree-dump.o 	\
   tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \
!  protector.o $(GGC) $(out_object_file) $(EXTRA_OBJS)
  
  BACKEND = main.o libbackend.a
  
*************** LIB2FUNCS_1 = _muldi3 _negdi2 _lshrdi3 _
*** 769,775 ****
  
  LIB2FUNCS_2 = _floatdixf _fixunsxfsi _fixtfdi _fixunstfdi _floatditf \
      _clear_cache _trampoline __main _exit _absvsi2 _absvdi2 _addvsi3 \
!     _addvdi3 _subvsi3 _subvdi3 _mulvsi3 _mulvdi3 _negvsi2 _negvdi2 _ctors
  
  # Defined in libgcc2.c, included only in the static library.
  LIB2FUNCS_ST = _eprintf _bb __gcc_bcmp
--- 769,775 ----
  
  LIB2FUNCS_2 = _floatdixf _fixunsxfsi _fixtfdi _fixunstfdi _floatditf \
      _clear_cache _trampoline __main _exit _absvsi2 _absvdi2 _addvsi3 \
!     _addvdi3 _subvsi3 _subvdi3 _mulvsi3 _mulvdi3 _negvsi2 _negvdi2 _ctors _stack_smash_handler
  
  # Defined in libgcc2.c, included only in the static library.
  LIB2FUNCS_ST = _eprintf _bb __gcc_bcmp
*************** toplev.o : toplev.c $(CONFIG_H) $(SYSTEM
*** 1360,1366 ****
     ssa.h $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) halfpic.h \
     langhooks.h insn-flags.h options.h
  	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
! 	  -DTARGET_NAME=\"$(target_alias)\" \
  	  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)
  main.o : main.c $(CONFIG_H) $(SYSTEM_H) toplev.h
  
--- 1360,1366 ----
     ssa.h $(PARAMS_H) $(TM_P_H) reload.h dwarf2asm.h $(TARGET_H) halfpic.h \
     langhooks.h insn-flags.h options.h
  	$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
! 	  -DSTACK_PROTECTOR -DTARGET_NAME=\"$(target_alias)\" \
  	  -c $(srcdir)/toplev.c $(OUTPUT_OPTION)
  main.o : main.c $(CONFIG_H) $(SYSTEM_H) toplev.h
  
Index: gcc/calls.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/calls.c,v
retrieving revision 1.1.1.9
retrieving revision 1.1.1.9.2.1
diff -c -3 -p -r1.1.1.9 -r1.1.1.9.2.1
*** gcc/calls.c	2003/02/19 07:11:08	1.1.1.9
--- gcc/calls.c	2003/02/26 08:01:00	1.1.1.9.2.1
*************** expand_call (exp, target, ignore)
*** 2300,2306 ****
  	    /* For variable-sized objects, we must be called with a target
  	       specified.  If we were to allocate space on the stack here,
  	       we would have no way of knowing when to free it.  */
! 	    rtx d = assign_temp (TREE_TYPE (exp), 1, 1, 1);
  
  	    mark_temp_addr_taken (d);
  	    structure_value_addr = XEXP (d, 0);
--- 2300,2306 ----
  	    /* For variable-sized objects, we must be called with a target
  	       specified.  If we were to allocate space on the stack here,
  	       we would have no way of knowing when to free it.  */
! 	    rtx d = assign_temp (TREE_TYPE (exp), 5, 1, 1);
  
  	    mark_temp_addr_taken (d);
  	    structure_value_addr = XEXP (d, 0);
Index: gcc/combine.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/combine.c,v
retrieving revision 1.1.1.9
retrieving revision 1.1.1.9.2.2
diff -c -3 -p -r1.1.1.9 -r1.1.1.9.2.2
*** gcc/combine.c	2003/02/19 07:11:08	1.1.1.9
--- gcc/combine.c	2003/03/11 05:51:10	1.1.1.9.2.2
*************** combine_simplify_rtx (x, op0_mode, last,
*** 3819,3825 ****
  	  rtx inner_op0 = XEXP (XEXP (x, 0), 1);
  	  rtx inner_op1 = XEXP (x, 1);
  	  rtx inner;
! 
  	  /* Make sure we pass the constant operand if any as the second
  	     one if this is a commutative operation.  */
  	  if (CONSTANT_P (inner_op0) && GET_RTX_CLASS (code) == 'c')
--- 3819,3835 ----
  	  rtx inner_op0 = XEXP (XEXP (x, 0), 1);
  	  rtx inner_op1 = XEXP (x, 1);
  	  rtx inner;
! 	  
! #ifndef FRAME_GROWS_DOWNWARD
! 	  if (flag_propolice_protection
! 	      && code == PLUS
! 	      && other == frame_pointer_rtx
! 	      && GET_CODE (inner_op0) == CONST_INT
! 	      && GET_CODE (inner_op1) == CONST_INT
! 	      && INTVAL (inner_op0) > 0
! 	      && INTVAL (inner_op0) + INTVAL (inner_op1) <= 0)
! 	    return x;
! #endif
  	  /* Make sure we pass the constant operand if any as the second
  	     one if this is a commutative operation.  */
  	  if (CONSTANT_P (inner_op0) && GET_RTX_CLASS (code) == 'c')
*************** combine_simplify_rtx (x, op0_mode, last,
*** 4193,4198 ****
--- 4203,4213 ----
  	 they are now checked elsewhere.  */
        if (GET_CODE (XEXP (x, 0)) == PLUS
  	  && CONSTANT_ADDRESS_P (XEXP (XEXP (x, 0), 1)))
+ #ifndef FRAME_GROWS_DOWNWARD
+ 	if (! (flag_propolice_protection
+ 	       && XEXP (XEXP (x, 0), 0) == frame_pointer_rtx
+ 	       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT))
+ #endif
  	return gen_binary (PLUS, mode,
  			   gen_binary (PLUS, mode, XEXP (XEXP (x, 0), 0),
  				       XEXP (x, 1)),
Index: gcc/cse.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/cse.c,v
retrieving revision 1.1.1.6
retrieving revision 1.1.1.6.8.2
diff -c -3 -p -r1.1.1.6 -r1.1.1.6.8.2
*** gcc/cse.c	2002/07/29 05:12:14	1.1.1.6
--- gcc/cse.c	2003/02/28 06:27:19	1.1.1.6.8.2
*************** fold_rtx (x, insn)
*** 4274,4280 ****
  
  	      if (new_const == 0)
  		break;
! 
  	      /* If we are associating shift operations, don't let this
  		 produce a shift of the size of the object or larger.
  		 This could occur when we follow a sign-extend by a right
--- 4274,4287 ----
  
  	      if (new_const == 0)
  		break;
! #ifndef FRAME_GROWS_DOWNWARD
! 	      if (flag_propolice_protection
! 		  && GET_CODE (y) == PLUS
! 		  && XEXP (y, 0) == frame_pointer_rtx
! 		  && INTVAL (inner_const) > 0
! 		  && INTVAL (new_const) <= 0)
! 		break;
! #endif
  	      /* If we are associating shift operations, don't let this
  		 produce a shift of the size of the object or larger.
  		 This could occur when we follow a sign-extend by a right
*************** cse_insn (insn, libcall_insn)
*** 4801,4806 ****
--- 4808,4820 ----
        if (SET_DEST (x) == pc_rtx
  	  && GET_CODE (SET_SRC (x)) == LABEL_REF)
  	;
+       /* cut the reg propagation of stack-protected argument */
+       else if (x->volatil) {
+ 	rtx x1 = SET_DEST (x);
+ 	if (GET_CODE (x1) == SUBREG && GET_CODE (SUBREG_REG (x1)) == REG)
+ 	  x1 = SUBREG_REG (x1);
+ 	make_new_qty (REGNO (x1), GET_MODE (x1));
+       }
  
        /* Don't count call-insns, (set (reg 0) (call ...)), as a set.
  	 The hard function value register is used only once, to copy to
Index: gcc/explow.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/explow.c,v
retrieving revision 1.1.1.5
retrieving revision 1.1.1.5.4.1
diff -c -3 -p -r1.1.1.5 -r1.1.1.5.4.1
*** gcc/explow.c	2002/12/18 00:55:39	1.1.1.5
--- gcc/explow.c	2003/02/26 08:01:01	1.1.1.5.4.1
*************** plus_constant_wide (x, c)
*** 82,88 ****
    rtx tem;
    int all_constant = 0;
  
!   if (c == 0)
      return x;
  
   restart:
--- 82,89 ----
    rtx tem;
    int all_constant = 0;
  
!   if (c == 0
!       && !(flag_propolice_protection && x == virtual_stack_vars_rtx))
      return x;
  
   restart:
*************** plus_constant_wide (x, c)
*** 183,189 ****
        break;
      }
  
!   if (c != 0)
      x = gen_rtx_PLUS (mode, x, GEN_INT (c));
  
    if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)
--- 184,191 ----
        break;
      }
  
!   if (c != 0
!       || (flag_propolice_protection && x == virtual_stack_vars_rtx))
      x = gen_rtx_PLUS (mode, x, GEN_INT (c));
  
    if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)
*************** memory_address (mode, x)
*** 526,531 ****
--- 528,548 ----
  	 in certain cases.  This is not necessary since the code
  	 below can handle all possible cases, but machine-dependent
  	 transformations can make better code.  */
+       if (flag_propolice_protection)
+ 	{
+ #define FRAMEADDR_P(X) (GET_CODE (X) == PLUS				\
+ 			&& XEXP (X, 0) == virtual_stack_vars_rtx	\
+ 			&& GET_CODE (XEXP (X, 1)) == CONST_INT)
+ 	  rtx y;
+ 	  if (FRAMEADDR_P (x)) goto win;
+ 	  for (y=x; y!=0 && GET_CODE (y)==PLUS; y = XEXP (y, 0))
+ 	    {
+ 	      if (FRAMEADDR_P (XEXP (y, 0)))
+ 		XEXP (y, 0) = force_reg (GET_MODE (XEXP (y, 0)), XEXP (y, 0));
+ 	      if (FRAMEADDR_P (XEXP (y, 1)))
+ 		XEXP (y, 1) = force_reg (GET_MODE (XEXP (y, 1)), XEXP (y, 1));
+ 	    }
+ 	}
        LEGITIMIZE_ADDRESS (x, oldx, mode, win);
  
        /* PLUS and MULT can appear in special ways
Index: gcc/expr.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/expr.c,v
retrieving revision 1.1.1.11
retrieving revision 1.1.1.11.2.2
diff -c -3 -p -r1.1.1.11 -r1.1.1.11.2.2
*** gcc/expr.c	2003/02/19 07:11:13	1.1.1.11
--- gcc/expr.c	2003/04/07 02:36:16	1.1.1.11.2.2
*************** Software Foundation, 59 Temple Place - S
*** 45,50 ****
--- 45,51 ----
  #include "langhooks.h"
  #include "intl.h"
  #include "tm_p.h"
+ #include "protector.h"
  
  /* Decide whether a function's arguments should be processed
     from first to last or from last to first.
*************** move_by_pieces (to, from, len, align)
*** 1448,1454 ****
  
        if (USE_LOAD_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_from)
  	{
! 	  data.from_addr = copy_addr_to_reg (plus_constant (from_addr, len));
  	  data.autinc_from = 1;
  	  data.explicit_inc_from = -1;
  	}
--- 1449,1455 ----
  
        if (USE_LOAD_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_from)
  	{
! 	  data.from_addr = copy_addr_to_reg (plus_constant (from_addr, len-GET_MODE_SIZE (mode)));
  	  data.autinc_from = 1;
  	  data.explicit_inc_from = -1;
  	}
*************** move_by_pieces (to, from, len, align)
*** 1462,1468 ****
  	data.from_addr = copy_addr_to_reg (from_addr);
        if (USE_STORE_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_to)
  	{
! 	  data.to_addr = copy_addr_to_reg (plus_constant (to_addr, len));
  	  data.autinc_to = 1;
  	  data.explicit_inc_to = -1;
  	}
--- 1463,1469 ----
  	data.from_addr = copy_addr_to_reg (from_addr);
        if (USE_STORE_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_to)
  	{
! 	  data.to_addr = copy_addr_to_reg (plus_constant (to_addr, len-GET_MODE_SIZE (mode)));
  	  data.autinc_to = 1;
  	  data.explicit_inc_to = -1;
  	}
*************** move_by_pieces_1 (genfun, mode, data)
*** 1579,1589 ****
  	from1 = adjust_address (data->from, mode, data->offset);
  
        if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)
! 	emit_insn (gen_add2_insn (data->to_addr,
! 				  GEN_INT (-(HOST_WIDE_INT)size)));
        if (HAVE_PRE_DECREMENT && data->explicit_inc_from < 0)
! 	emit_insn (gen_add2_insn (data->from_addr,
! 				  GEN_INT (-(HOST_WIDE_INT)size)));
  
        if (data->to)
  	emit_insn ((*genfun) (to1, from1));
--- 1580,1592 ----
  	from1 = adjust_address (data->from, mode, data->offset);
  
        if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)
! 	if (data->explicit_inc_to < -1)
! 	  emit_insn (gen_add2_insn (data->to_addr,
! 				    GEN_INT (-(HOST_WIDE_INT)size)));
        if (HAVE_PRE_DECREMENT && data->explicit_inc_from < 0)
! 	if (data->explicit_inc_from < -1)
! 	  emit_insn (gen_add2_insn (data->from_addr,
! 				    GEN_INT (-(HOST_WIDE_INT)size)));
  
        if (data->to)
  	emit_insn ((*genfun) (to1, from1));
*************** store_by_pieces_1 (data, align)
*** 2480,2486 ****
  
        if (USE_STORE_PRE_DECREMENT (mode) && data->reverse && ! data->autinc_to)
  	{
! 	  data->to_addr = copy_addr_to_reg (plus_constant (to_addr, data->len));
  	  data->autinc_to = 1;
  	  data->explicit_inc_to = -1;
  	}
--- 2483,2489 ----
  
        if (USE_STORE_PRE_DECREMENT (mode) && data->reverse && ! data->autinc_to)
  	{
! 	  data->to_addr = copy_addr_to_reg (plus_constant (to_addr, data->len-GET_MODE_SIZE (mode)));
  	  data->autinc_to = 1;
  	  data->explicit_inc_to = -1;
  	}
*************** store_by_pieces_2 (genfun, mode, data)
*** 2551,2558 ****
  	to1 = adjust_address (data->to, mode, data->offset);
  
        if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)
! 	emit_insn (gen_add2_insn (data->to_addr,
! 				  GEN_INT (-(HOST_WIDE_INT) size)));
  
        cst = (*data->constfun) (data->constfundata, data->offset, mode);
        emit_insn ((*genfun) (to1, cst));
--- 2554,2562 ----
  	to1 = adjust_address (data->to, mode, data->offset);
  
        if (HAVE_PRE_DECREMENT && data->explicit_inc_to < 0)
! 	if (data->explicit_inc_to < -1)
! 	  emit_insn (gen_add2_insn (data->to_addr,
! 				    GEN_INT (-(HOST_WIDE_INT) size)));
  
        cst = (*data->constfun) (data->constfundata, data->offset, mode);
        emit_insn ((*genfun) (to1, cst));
*************** force_operand (value, target)
*** 5474,5480 ****
  	  && GET_CODE (XEXP (value, 0)) == PLUS
  	  && GET_CODE (XEXP (XEXP (value, 0), 0)) == REG
  	  && REGNO (XEXP (XEXP (value, 0), 0)) >= FIRST_VIRTUAL_REGISTER
! 	  && REGNO (XEXP (XEXP (value, 0), 0)) <= LAST_VIRTUAL_REGISTER)
  	{
  	  rtx temp = expand_simple_binop (GET_MODE (value), code,
  					  XEXP (XEXP (value, 0), 0), op2,
--- 5478,5486 ----
  	  && GET_CODE (XEXP (value, 0)) == PLUS
  	  && GET_CODE (XEXP (XEXP (value, 0), 0)) == REG
  	  && REGNO (XEXP (XEXP (value, 0), 0)) >= FIRST_VIRTUAL_REGISTER
! 	  && REGNO (XEXP (XEXP (value, 0), 0)) <= LAST_VIRTUAL_REGISTER
! 	  && (!flag_propolice_protection
! 	      || XEXP (XEXP (value, 0), 0) != virtual_stack_vars_rtx))
  	{
  	  rtx temp = expand_simple_binop (GET_MODE (value), code,
  					  XEXP (XEXP (value, 0), 0), op2,
*************** expand_expr (exp, target, tmode, modifie
*** 7614,7620 ****
        /* If adding to a sum including a constant,
  	 associate it to put the constant outside.  */
        if (GET_CODE (op1) == PLUS
! 	  && CONSTANT_P (XEXP (op1, 1)))
  	{
  	  rtx constant_term = const0_rtx;
  
--- 7620,7627 ----
        /* If adding to a sum including a constant,
  	 associate it to put the constant outside.  */
        if (GET_CODE (op1) == PLUS
! 	  && CONSTANT_P (XEXP (op1, 1))
! 	  && !(flag_propolice_protection && (contains_fp (op0) || contains_fp (op1))))
  	{
  	  rtx constant_term = const0_rtx;
  
Index: gcc/flags.h
===================================================================
RCS file: /home/cvsroot/gcc/gcc/flags.h,v
retrieving revision 1.1.1.5
retrieving revision 1.1.1.5.4.1
diff -c -3 -p -r1.1.1.5 -r1.1.1.5.4.1
*** gcc/flags.h	2002/12/18 00:55:41	1.1.1.5
--- gcc/flags.h	2003/02/26 08:01:02	1.1.1.5.4.1
*************** extern int flag_detailed_statistics;
*** 645,648 ****
--- 645,656 ----
  /* Nonzero means enable synchronous exceptions for non-call instructions.  */
  extern int flag_non_call_exceptions;
  
+ /* Nonzero means use propolice as a stack protection method */
+ 
+ extern int flag_propolice_protection;
+ 
+ /* Warn when not issuing stack smashing protection for some reason */
+ 
+ extern int warn_stack_protector;
+ 
  #endif /* ! GCC_FLAGS_H */
Index: gcc/function.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/function.c,v
retrieving revision 1.1.1.9
retrieving revision 1.1.1.9.2.1
diff -c -3 -p -r1.1.1.9 -r1.1.1.9.2.1
*** gcc/function.c	2003/02/19 07:11:14	1.1.1.9
--- gcc/function.c	2003/02/26 08:01:02	1.1.1.9.2.1
*************** Software Foundation, 59 Temple Place - S
*** 60,65 ****
--- 60,66 ----
  #include "tm_p.h"
  #include "integrate.h"
  #include "langhooks.h"
+ #include "protector.h"
  
  #ifndef TRAMPOLINE_ALIGNMENT
  #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY
*************** static varray_type epilogue;
*** 156,161 ****
--- 157,166 ----
  /* Array of INSN_UIDs to hold the INSN_UIDs for each sibcall epilogue
     in this function.  */
  static varray_type sibcall_epilogue;
+ 
+ /* Current boundary mark for character arrays.  */
+ int temp_boundary_mark = 0;
+ 
  
  /* In order to evaluate some expressions, such as function calls returning
     structures in memory, we need to temporarily allocate stack locations.
*************** struct temp_slot
*** 209,214 ****
--- 214,221 ----
    /* The size of the slot, including extra space for alignment.  This
       info is for combine_temp_slots.  */
    HOST_WIDE_INT full_size;
+   /* Boundary mark of a character array and the others. This info is for propolice */
+   int boundary_mark;
  };
  
  /* This structure is used to record MEMs or pseudos used to replace VAR, any
*************** assign_stack_local (mode, size, align)
*** 655,660 ****
--- 662,668 ----
     whose lifetime is controlled by CLEANUP_POINT_EXPRs.  KEEP is 3
     if we are to allocate something at an inner level to be treated as
     a variable in the block (e.g., a SAVE_EXPR).
+    KEEP is 5 if we allocate a place to return structure.
  
     TYPE is the type that will be used for the stack slot.  */
  
*************** assign_stack_temp_for_type (mode, size, 
*** 668,673 ****
--- 676,683 ----
    unsigned int align;
    struct temp_slot *p, *best_p = 0;
    rtx slot;
+   int char_array = (flag_propolice_protection
+ 		    && keep == 1 && search_string_def (type));
  
    /* If SIZE is -1 it means that somebody tried to allocate a temporary
       of a variable size.  */
*************** assign_stack_temp_for_type (mode, size, 
*** 693,699 ****
  	&& ! p->in_use
  	&& objects_must_conflict_p (p->type, type)
  	&& (best_p == 0 || best_p->size > p->size
! 	    || (best_p->size == p->size && best_p->align > p->align)))
        {
  	if (p->align == align && p->size == size)
  	  {
--- 703,710 ----
  	&& ! p->in_use
  	&& objects_must_conflict_p (p->type, type)
  	&& (best_p == 0 || best_p->size > p->size
! 	    || (best_p->size == p->size && best_p->align > p->align))
! 	&& (! char_array || p->boundary_mark != 0))
        {
  	if (p->align == align && p->size == size)
  	  {
*************** assign_stack_temp_for_type (mode, size, 
*** 728,733 ****
--- 739,745 ----
  	      p->address = 0;
  	      p->rtl_expr = 0;
  	      p->type = best_p->type;
+ 	      p->boundary_mark = best_p->boundary_mark;
  	      p->next = temp_slots;
  	      temp_slots = p;
  
*************** assign_stack_temp_for_type (mode, size, 
*** 788,793 ****
--- 800,806 ----
        p->full_size = frame_offset - frame_offset_old;
  #endif
        p->address = 0;
+       p->boundary_mark = char_array?++temp_boundary_mark:0;
        p->next = temp_slots;
        temp_slots = p;
      }
*************** combine_temp_slots ()
*** 958,971 ****
  	    int delete_q = 0;
  	    if (! q->in_use && GET_MODE (q->slot) == BLKmode)
  	      {
! 		if (p->base_offset + p->full_size == q->base_offset)
  		  {
  		    /* Q comes after P; combine Q into P.  */
  		    p->size += q->size;
  		    p->full_size += q->full_size;
  		    delete_q = 1;
  		  }
! 		else if (q->base_offset + q->full_size == p->base_offset)
  		  {
  		    /* P comes after Q; combine P into Q.  */
  		    q->size += p->size;
--- 971,986 ----
  	    int delete_q = 0;
  	    if (! q->in_use && GET_MODE (q->slot) == BLKmode)
  	      {
! 		if (p->base_offset + p->full_size == q->base_offset &&
! 		    p->boundary_mark == q->boundary_mark)
  		  {
  		    /* Q comes after P; combine Q into P.  */
  		    p->size += q->size;
  		    p->full_size += q->full_size;
  		    delete_q = 1;
  		  }
! 		else if (q->base_offset + q->full_size == p->base_offset &&
! 			 p->boundary_mark == q->boundary_mark)
  		  {
  		    /* P comes after Q; combine P into Q.  */
  		    q->size += p->size;
*************** put_reg_into_stack (function, reg, type,
*** 1519,1525 ****
      new = func->x_parm_reg_stack_loc[regno];
  
    if (new == 0)
!     new = assign_stack_local_1 (decl_mode, GET_MODE_SIZE (decl_mode), 0, func);
  
    PUT_CODE (reg, MEM);
    PUT_MODE (reg, decl_mode);
--- 1534,1542 ----
      new = func->x_parm_reg_stack_loc[regno];
  
    if (new == 0)
!     new = function ?
! 	assign_stack_local_1 (decl_mode, GET_MODE_SIZE (decl_mode), 0, func):
! 	assign_stack_local_for_pseudo_reg (decl_mode, GET_MODE_SIZE (decl_mode), 0);
  
    PUT_CODE (reg, MEM);
    PUT_MODE (reg, decl_mode);
*************** instantiate_virtual_regs_1 (loc, object,
*** 3950,3956 ****
  		 constant with that register.  */
  	      temp = gen_reg_rtx (Pmode);
  	      XEXP (x, 0) = new;
! 	      if (validate_change (object, &XEXP (x, 1), temp, 0))
  		emit_insn_before (gen_move_insn (temp, new_offset), object);
  	      else
  		{
--- 3967,3974 ----
  		 constant with that register.  */
  	      temp = gen_reg_rtx (Pmode);
  	      XEXP (x, 0) = new;
! 	      if (validate_change (object, &XEXP (x, 1), temp, 0)
! 		  && ! flag_propolice_protection)
  		emit_insn_before (gen_move_insn (temp, new_offset), object);
  	      else
  		{
Index: gcc/gcse.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/gcse.c,v
retrieving revision 1.1.1.4
retrieving revision 1.1.1.4.8.1
diff -c -3 -p -r1.1.1.4 -r1.1.1.4.8.1
*** gcc/gcse.c	2002/07/29 05:12:18	1.1.1.4
--- gcc/gcse.c	2003/02/26 08:01:02	1.1.1.4.8.1
*************** cprop_insn (bb, insn, alter_jumps)
*** 4193,4199 ****
        /* Find an assignment that sets reg_used and is available
  	 at the start of the block.  */
        set = find_avail_set (regno, insn);
!       if (! set)
  	continue;
    
        pat = set->expr;
--- 4193,4199 ----
        /* Find an assignment that sets reg_used and is available
  	 at the start of the block.  */
        set = find_avail_set (regno, insn);
!       if (! set || set->expr->volatil)
  	continue;
    
        pat = set->expr;
Index: gcc/integrate.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/integrate.c,v
retrieving revision 1.1.1.7
retrieving revision 1.1.1.7.2.1
diff -c -3 -p -r1.1.1.7 -r1.1.1.7.2.1
*** gcc/integrate.c	2003/02/19 07:11:16	1.1.1.7
--- gcc/integrate.c	2003/02/26 08:01:02	1.1.1.7.2.1
*************** copy_decl_for_inlining (decl, from_fn, t
*** 388,393 ****
--- 388,397 ----
    /* These args would always appear unused, if not for this.  */
    TREE_USED (copy) = 1;
  
+   /* The inlined variable is marked as INLINE not to sweep by propolice */
+   if (flag_propolice_protection && TREE_CODE (copy) == VAR_DECL)
+     DECL_INLINE (copy) = 1;
+ 
    /* Set the context for the new declaration.  */
    if (!DECL_CONTEXT (decl))
      /* Globals stay global.  */
*************** copy_rtx_and_substitute (orig, map, for_
*** 1950,1955 ****
--- 1954,1963 ----
  
  	      seq = gen_sequence ();
  	      end_sequence ();
+ #ifdef FRAME_GROWS_DOWNWARD
+ 	      if (flag_propolice_protection && GET_CODE (seq) == SET)
+ 		RTX_INTEGRATED_P (SET_SRC (seq)) = 1;
+ #endif
  	      emit_insn_after (seq, map->insns_at_start);
  	      return temp;
  	    }
Index: gcc/libgcc-std.ver
===================================================================
RCS file: /home/cvsroot/gcc/gcc/libgcc-std.ver,v
retrieving revision 1.1.1.4
retrieving revision 1.1.1.4.12.1
diff -c -3 -p -r1.1.1.4 -r1.1.1.4.12.1
*** gcc/libgcc-std.ver	2001/06/19 04:54:26	1.1.1.4
--- gcc/libgcc-std.ver	2003/02/26 08:01:02	1.1.1.4.12.1
*************** GCC_3.0 {
*** 174,177 ****
--- 174,181 ----
    _Unwind_SjLj_RaiseException
    _Unwind_SjLj_ForcedUnwind
    _Unwind_SjLj_Resume
+ 
+   # stack smash handler symbols
+   __guard
+   __stack_smash_handler
  }
Index: gcc/libgcc2.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/libgcc2.c,v
retrieving revision 1.1.1.7
retrieving revision 1.1.1.7.4.3
diff -c -3 -p -r1.1.1.7 -r1.1.1.7.4.3
*** gcc/libgcc2.c	2002/12/18 00:55:44	1.1.1.7
--- gcc/libgcc2.c	2003/04/07 02:03:19	1.1.1.7.4.3
*************** atexit (func_ptr func)
*** 2050,2052 ****
--- 2050,2151 ----
  #endif /* NEED_ATEXIT */
  
  #endif /* L_exit */
+ 
+ #ifdef L_stack_smash_handler
+ #include <stdio.h>
+ #include <string.h>
+ #include <fcntl.h>
+ #include <unistd.h>
+ 
+ #ifdef _POSIX_SOURCE
+ #include <signal.h>
+ #endif
+ 
+ #if defined(HAVE_SYSLOG)
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ #include <sys/un.h>
+ 
+ #include <sys/syslog.h>
+ #ifndef _PATH_LOG
+ #define _PATH_LOG "/dev/log"
+ #endif
+ #endif
+ 
+ long __guard[8] = {0,0,0,0,0,0,0,0};
+ static void __guard_setup (void) __attribute__ ((constructor)) ;
+ static void __guard_setup (void)
+ {
+   int fd;
+   if (__guard[0]!=0) return;
+   fd = open ("/dev/urandom", 0);
+   if (fd != -1) {
+     ssize_t size = read (fd, (char*)&__guard, sizeof(__guard));
+     close (fd) ;
+     if (size == sizeof(__guard)) return;
+   }
+   /* If a random generator can't be used, the protector switches the guard
+      to the "terminator canary" */
+   ((char*)__guard)[0] = 0; ((char*)__guard)[1] = 0;
+   ((char*)__guard)[2] = '\n'; ((char*)__guard)[3] = 255;
+ }
+ void __stack_smash_handler (char func[], int damaged ATTRIBUTE_UNUSED)
+ {
+ #if defined (__GNU_LIBRARY__)
+   extern char * __progname;
+ #endif
+   const char message[] = ": stack smashing attack in function ";
+   int bufsz = 256, len;
+   char buf[bufsz];
+ #if defined(HAVE_SYSLOG)
+   int LogFile;
+   struct sockaddr_un SyslogAddr;  /* AF_UNIX address of local logger */
+ #endif
+ #ifdef _POSIX_SOURCE
+   {
+     sigset_t mask;
+     sigfillset(&mask);
+     sigdelset(&mask, SIGABRT);	/* Block all signal handlers */
+     sigprocmask(SIG_BLOCK, &mask, NULL); /* except SIGABRT */
+   }
+ #endif
+ 
+   strcpy(buf, "<2>"); len=3;	/* send LOG_CRIT */
+ #if defined (__GNU_LIBRARY__)
+   strncat(buf, __progname, bufsz-len-1); len = strlen(buf);
+ #endif
+   if (bufsz>len) {strncat(buf, message, bufsz-len-1); len = strlen(buf);}
+   if (bufsz>len) {strncat(buf, func, bufsz-len-1); len = strlen(buf);}
+ 
+   /* print error message */
+   write (STDERR_FILENO, buf+3, len-3);
+ #if defined(HAVE_SYSLOG)
+   if ((LogFile = socket(AF_UNIX, SOCK_DGRAM, 0)) != -1) {
+ 
+     /*
+      * Send "found" message to the "/dev/log" path
+      */
+     SyslogAddr.sun_family = AF_UNIX;
+     (void)strncpy(SyslogAddr.sun_path, _PATH_LOG,
+ 		  sizeof(SyslogAddr.sun_path) - 1);
+     SyslogAddr.sun_path[sizeof(SyslogAddr.sun_path) - 1] = '\0';
+     sendto(LogFile, buf, len, 0, (struct sockaddr *)&SyslogAddr,
+ 	   sizeof(SyslogAddr));
+   }
+ #endif
+ 
+ #ifdef _POSIX_SOURCE
+   { /* Make sure the default handler is associated with SIGABRT */
+     struct sigaction sa;
+     
+     memset(&sa, 0, sizeof(struct sigaction));
+     sigfillset(&sa.sa_mask);	/* Block all signals */
+     sa.sa_flags = 0;
+     sa.sa_handler = SIG_DFL;
+     sigaction(SIGABRT, &sa, NULL);
+     (void)kill(getpid(), SIGABRT);
+   }
+ #endif
+   _exit(127);
+ }
+ #endif
Index: gcc/loop.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/loop.c,v
retrieving revision 1.1.1.9
retrieving revision 1.1.1.9.2.2
diff -c -3 -p -r1.1.1.9 -r1.1.1.9.2.2
*** gcc/loop.c	2003/02/19 07:11:17	1.1.1.9
--- gcc/loop.c	2003/03/11 05:50:50	1.1.1.9.2.2
*************** general_induction_var (loop, x, src_reg,
*** 6385,6390 ****
--- 6385,6398 ----
    if (GET_CODE (*mult_val) == USE)
      *mult_val = XEXP (*mult_val, 0);
  
+ #ifndef FRAME_GROWS_DOWNWARD
+   if (flag_propolice_protection
+       && GET_CODE (*add_val) == PLUS
+       && (XEXP (*add_val, 0) == frame_pointer_rtx
+ 	  || XEXP (*add_val, 1) == frame_pointer_rtx))
+     return 0;
+ #endif
+ 
    if (is_addr)
      *pbenefit += address_cost (orig_x, addr_mode) - reg_address_cost;
    else
Index: gcc/optabs.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/optabs.c,v
retrieving revision 1.1.1.8
retrieving revision 1.1.1.8.2.1
diff -c -3 -p -r1.1.1.8 -r1.1.1.8.2.1
*** gcc/optabs.c	2003/02/19 07:11:17	1.1.1.8
--- gcc/optabs.c	2003/02/26 08:01:03	1.1.1.8.2.1
*************** expand_binop (mode, binoptab, op0, op1, 
*** 670,675 ****
--- 670,695 ----
    if (target)
      target = protect_from_queue (target, 1);
  
+   if (flag_propolice_protection
+       && binoptab->code == PLUS
+       && op0 == virtual_stack_vars_rtx
+       && GET_CODE(op1) == CONST_INT)
+     {
+       int icode = (int) binoptab->handlers[(int) mode].insn_code;
+       if (target)
+ 	temp = target;
+       else
+ 	temp = gen_reg_rtx (mode);
+ 
+       if (! (*insn_data[icode].operand[0].predicate) (temp, mode)
+ 	  || GET_CODE (temp) != REG)
+ 	temp = gen_reg_rtx (mode);
+ 
+       emit_insn (gen_rtx_SET (VOIDmode, temp,
+ 			      gen_rtx_PLUS (GET_MODE (op0), op0, op1)));
+       return temp;
+     }
+ 
    if (flag_force_mem)
      {
        op0 = force_not_mem (op0);
Index: gcc/reload1.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/reload1.c,v
retrieving revision 1.1.1.7
retrieving revision 1.1.1.7.4.1
diff -c -3 -p -r1.1.1.7 -r1.1.1.7.4.1
*** gcc/reload1.c	2002/12/18 00:55:47	1.1.1.7
--- gcc/reload1.c	2003/02/26 08:01:03	1.1.1.7.4.1
*************** Software Foundation, 59 Temple Place - S
*** 42,47 ****
--- 42,48 ----
  #include "toplev.h"
  #include "except.h"
  #include "tree.h"
+ #include "protector.h"
  
  /* This file contains the reload pass of the compiler, which is
     run after register allocation has been done.  It checks that
*************** alter_reg (i, from_reg)
*** 1985,1991 ****
        if (from_reg == -1)
  	{
  	  /* No known place to spill from => no slot to reuse.  */
! 	  x = assign_stack_local (GET_MODE (regno_reg_rtx[i]), total_size,
  				  inherent_size == total_size ? 0 : -1);
  	  if (BYTES_BIG_ENDIAN)
  	    /* Cancel the  big-endian correction done in assign_stack_local.
--- 1986,1992 ----
        if (from_reg == -1)
  	{
  	  /* No known place to spill from => no slot to reuse.  */
! 	  x = assign_stack_local_for_pseudo_reg (GET_MODE (regno_reg_rtx[i]), total_size,
  				  inherent_size == total_size ? 0 : -1);
  	  if (BYTES_BIG_ENDIAN)
  	    /* Cancel the  big-endian correction done in assign_stack_local.
Index: gcc/simplify-rtx.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/simplify-rtx.c,v
retrieving revision 1.1.1.2
retrieving revision 1.1.1.2.8.1
diff -c -3 -p -r1.1.1.2 -r1.1.1.2.8.1
*** gcc/simplify-rtx.c	2002/07/29 05:12:24	1.1.1.2
--- gcc/simplify-rtx.c	2003/02/26 08:01:04	1.1.1.2.8.1
*************** simplify_plus_minus (code, mode, op0, op
*** 1763,1769 ****
    int n_ops = 2, input_ops = 2, input_consts = 0, n_consts;
    int first, negate, changed;
    int i, j;
! 
    memset ((char *) ops, 0, sizeof ops);
    
    /* Set up the two operands and then expand them until nothing has been
--- 1763,1770 ----
    int n_ops = 2, input_ops = 2, input_consts = 0, n_consts;
    int first, negate, changed;
    int i, j;
!   HOST_WIDE_INT fp_offset = 0;
!   
    memset ((char *) ops, 0, sizeof ops);
    
    /* Set up the two operands and then expand them until nothing has been
*************** simplify_plus_minus (code, mode, op0, op
*** 1788,1793 ****
--- 1789,1798 ----
  	  switch (this_code)
  	    {
  	    case PLUS:
+ 	    if (flag_propolice_protection
+ 		&& XEXP (this_op, 0) == virtual_stack_vars_rtx
+ 		&& GET_CODE (XEXP (this_op, 1)) == CONST_INT)
+ 	      fp_offset = INTVAL (XEXP (this_op, 1));
  	    case MINUS:
  	      if (n_ops == 7)
  		return NULL_RTX;
*************** simplify_plus_minus (code, mode, op0, op
*** 1942,1951 ****
        && GET_CODE (ops[n_ops - 1].op) == CONST_INT
        && CONSTANT_P (ops[n_ops - 2].op))
      {
!       rtx value = ops[n_ops - 1].op;
        if (ops[n_ops - 1].neg ^ ops[n_ops - 2].neg)
! 	value = neg_const_int (mode, value);
!       ops[n_ops - 2].op = plus_constant (ops[n_ops - 2].op, INTVAL (value));
        n_ops--;
      }
  
--- 1947,1956 ----
        && GET_CODE (ops[n_ops - 1].op) == CONST_INT
        && CONSTANT_P (ops[n_ops - 2].op))
      {
!       int value = INTVAL (ops[n_ops - 1].op);
        if (ops[n_ops - 1].neg ^ ops[n_ops - 2].neg)
! 	value = -value;
!       ops[n_ops - 2].op = plus_constant (ops[n_ops - 2].op, value);
        n_ops--;
      }
  
*************** simplify_plus_minus (code, mode, op0, op
*** 1963,1968 ****
--- 1968,2021 ----
        && (n_ops + n_consts > input_ops
            || (n_ops + n_consts == input_ops && n_consts <= input_consts)))
      return NULL_RTX;
+ 
+   if (flag_propolice_protection)
+     {
+       /* keep the addressing style of local variables
+ 	 as (plus (virtual_stack_vars_rtx) (CONST_int x))
+ 	 (1) inline function is expanded, (+ (+VFP c1) -c2)=>(+ VFP c1-c2)
+ 	 (2) the case ary[r-1], (+ (+VFP c1) (+r -1))=>(+ R (+r -1))
+       */
+       for (i = 0; i < n_ops; i++)
+ #ifdef FRAME_GROWS_DOWNWARD
+ 	if (ops[i].op == virtual_stack_vars_rtx)
+ #else
+ 	if (ops[i].op == virtual_stack_vars_rtx
+ 	    || ops[i].op == frame_pointer_rtx)
+ #endif
+ 	  {
+ 	    if (GET_CODE (ops[n_ops - 1].op) == CONST_INT)
+ 	      {
+ 		HOST_WIDE_INT value = INTVAL (ops[n_ops - 1].op);
+ 		if (n_ops < 3 || value >= fp_offset)
+ 		  {
+ 		    ops[i].op = plus_constant (ops[i].op, value);
+ 		    n_ops--;
+ 		  }
+ 		else
+ 		  {
+ 		    if (!force
+ 			&& (n_ops+1 + n_consts > input_ops
+ 			    || (n_ops+1 + n_consts == input_ops && n_consts <= input_consts)))
+ 		      return NULL_RTX;
+ 		    ops[n_ops - 1].op = GEN_INT (value-fp_offset);
+ 		    ops[i].op = plus_constant (ops[i].op, fp_offset);
+ 		  }
+ 	      }
+ 	    /* buf[BUFSIZE]: buf is the first local variable (+ (+ fp -S) S) 
+ 	       or (+ (fp 0) r) ==> ((+ (+fp 1) r) -1) */
+ 	    else if (fp_offset != 0)
+ 	      return NULL_RTX;
+ #ifndef FRAME_GROWS_DOWNWARD
+ 	    /*
+ 	     * For the case of buf[i], i: REG, buf: (plus fp 0),
+ 	     */
+ 	    else if (fp_offset == 0)
+ 	      return NULL_RTX;
+ #endif
+ 	    break;
+ 	  }
+     }
  
    /* Put a non-negated operand first.  If there aren't any, make all
       operands positive and negate the whole thing later.  */
Index: gcc/toplev.c
===================================================================
RCS file: /home/cvsroot/gcc/gcc/toplev.c,v
retrieving revision 1.1.1.10
retrieving revision 1.1.1.10.4.1
diff -c -3 -p -r1.1.1.10 -r1.1.1.10.4.1
*** gcc/toplev.c	2002/12/18 00:55:48	1.1.1.10
--- gcc/toplev.c	2003/02/26 08:01:04	1.1.1.10.4.1
*************** int align_functions_log;
*** 883,888 ****
--- 883,895 ----
     minimum function alignment.  Zero means no alignment is forced.  */
  int force_align_functions_log;
  
+ #if defined(STACK_PROTECTOR) && defined(STACK_GROWS_DOWNWARD)
+ /* Nonzero means use propolice as a stack protection method */
+ int flag_propolice_protection = 1;
+ #else
+ int flag_propolice_protection = 0;
+ #endif
+ 
  /* Table of supported debugging formats.  */
  static const struct
  {
*************** static const lang_independent_options f_
*** 1154,1159 ****
--- 1161,1170 ----
     N_("Report on permanent memory allocation at end of run") },
    { "trapv", &flag_trapv, 1,
     N_("Trap for signed overflow in addition / subtraction / multiplication") },
+   {"stack-protector", &flag_propolice_protection, 1,
+    N_("Enables stack protection") },
+   {"no-stack-protector", &flag_propolice_protection, 0,
+    N_("Disables stack protection") },
  };
  
  /* Table of language-specific options.  */
*************** static const lang_independent_options W_
*** 1495,1501 ****
    {"deprecated-declarations", &warn_deprecated_decl, 1,
     N_("Warn about uses of __attribute__((deprecated)) declarations") },
    {"missing-noreturn", &warn_missing_noreturn, 1,
!    N_("Warn about functions which might be candidates for attribute noreturn") }
  };
  
  void
--- 1506,1514 ----
    {"deprecated-declarations", &warn_deprecated_decl, 1,
     N_("Warn about uses of __attribute__((deprecated)) declarations") },
    {"missing-noreturn", &warn_missing_noreturn, 1,
!    N_("Warn about functions which might be candidates for attribute noreturn") },
!   {"stack-protector", &warn_stack_protector, 1,
!    N_("Warn when disabling stack protector for some reason")}
  };
  
  void
*************** rest_of_compilation (decl)
*** 2446,2451 ****
--- 2459,2466 ----
  
        insns = get_insns ();
  
+       if (flag_propolice_protection) prepare_stack_protection (inlinable);
+   
        /* Dump the rtl code if we are dumping rtl.  */
  
        if (open_dump_file (DFI_rtl, decl))
Index: gcc/config/t-linux
===================================================================
RCS file: /home/cvsroot/gcc/gcc/config/t-linux,v
retrieving revision 1.1.1.6
retrieving revision 1.1.1.6.8.1
diff -c -3 -p -r1.1.1.6 -r1.1.1.6.8.1
*** gcc/config/t-linux	2002/07/29 05:12:32	1.1.1.6
--- gcc/config/t-linux	2003/02/26 08:01:04	1.1.1.6.8.1
*************** STMP_FIXPROTO =
*** 4,10 ****
  # Compile crtbeginS.o and crtendS.o with pic.
  CRTSTUFF_T_CFLAGS_S = -fPIC
  # Compile libgcc2.a with pic.
! TARGET_LIBGCC2_CFLAGS = -fPIC
  
  # Override t-slibgcc-elf-ver to export some libgcc symbols with
  # the symbol versions that glibc used.
--- 4,10 ----
  # Compile crtbeginS.o and crtendS.o with pic.
  CRTSTUFF_T_CFLAGS_S = -fPIC
  # Compile libgcc2.a with pic.
! TARGET_LIBGCC2_CFLAGS = -fPIC -DHAVE_SYSLOG
  
  # Override t-slibgcc-elf-ver to export some libgcc symbols with
  # the symbol versions that glibc used.
