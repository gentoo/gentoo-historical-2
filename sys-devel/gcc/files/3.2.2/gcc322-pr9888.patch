Index:. gcc/config/i386/i386.md
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/i386/i386.md,v
retrieving revision 1.339.2.13.2.2
diff -u -p -r1.339.2.13.2.2 i386.md
--- gcc/config/i386/i386.md	24 Oct 2002 17:11:54 -0000	1.339.2.13.2.2
+++ gcc/config/i386/i386.md	10 Mar 2003 20:24:35 -0000
@@ -131,7 +131,7 @@
 
 ;; The (bounding maximum) length of an instruction immediate.
 (define_attr "length_immediate" ""
-  (cond [(eq_attr "type" "incdec,setcc,icmov,ibr,str,cld,lea,other,multi,idiv,sse,mmx")
+  (cond [(eq_attr "type" "incdec,setcc,icmov,str,cld,lea,other,multi,idiv,sse,mmx")
 	   (const_int 0)
 	 (eq_attr "i387" "1")
 	   (const_int 0)
@@ -147,13 +147,10 @@
 	   (if_then_else (match_operand 1 "constant_call_address_operand" "")
 	     (const_int 4)
 	     (const_int 0))
+	 ;; We don't know the size before shorten_branches.  Expect
+	 ;; the instruction to fit for better scheduling.
 	 (eq_attr "type" "ibr")
-	   (if_then_else (and (ge (minus (match_dup 0) (pc))
-				  (const_int -128))
-			      (lt (minus (match_dup 0) (pc))
-				  (const_int 124)))
-	     (const_int 1)
-	     (const_int 4))
+	   (const_int 1)
 	 ]
 	 (symbol_ref "/* Update immediate_length and other attributes! */ abort(),1")))
 
@@ -162,7 +159,7 @@
   (cond [(eq_attr "type" "str,cld,other,multi,fxch")
 	   (const_int 0)
 	 (and (eq_attr "type" "call")
-	      (match_operand 1 "constant_call_address_operand" ""))
+	      (match_operand 0 "constant_call_address_operand" ""))
 	     (const_int 0)
 	 (and (eq_attr "type" "callv")
 	      (match_operand 1 "constant_call_address_operand" ""))
@@ -205,6 +202,12 @@
 	      (and (match_operand 0 "register_operand" "")
 	           (match_operand 1 "immediate_operand" "")))
 	   (const_int 0)
+	 (and (eq_attr "type" "call")
+	      (match_operand 0 "constant_call_address_operand" ""))
+	     (const_int 0)
+	 (and (eq_attr "type" "callv")
+	      (match_operand 1 "constant_call_address_operand" ""))
+	     (const_int 0)
 	 ]
 	 (const_int 1)))
 
@@ -1733,14 +1736,9 @@
    (set_attr "mode" "SI")
    (set_attr "length_immediate" "1")])
 
-; The first alternative is used only to compute proper length of instruction.
-; Reload's algorithm does not take into account the cost of spill instructions
-; needed to free register in given class, so avoid it from choosing the first
-; alternative when eax is not available.
-
 (define_insn "*movsi_1"
-  [(set (match_operand:SI 0 "nonimmediate_operand" "=*?a,r,*?a,m,!*y,!rm,!*y,!*Y,!rm,!*Y")
-	(match_operand:SI 1 "general_operand" "im,rinm,rinm,rin,rm,*y,*y,rm,*Y,*Y"))]
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,m,!*y,!rm,!*y,!*Y,!rm,!*Y")
+	(match_operand:SI 1 "general_operand" "rinm,rin,rm,*y,*y,rm,*Y,*Y"))]
   "GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM"
 {
   switch (get_attr_type (insn))
@@ -1765,17 +1763,16 @@
     }
 }
   [(set (attr "type")
-     (cond [(eq_attr "alternative" "4,5,6")
+     (cond [(eq_attr "alternative" "2,3,4")
 	      (const_string "mmx")
-	    (eq_attr "alternative" "7,8,9")
+	    (eq_attr "alternative" "5,6,7")
 	      (const_string "sse")
 	    (and (ne (symbol_ref "flag_pic") (const_int 0))
 		 (match_operand:SI 1 "symbolic_operand" ""))
 	      (const_string "lea")
 	   ]
 	   (const_string "imov")))
-   (set_attr "modrm" "0,*,0,*,*,*,*,*,*,*")
-   (set_attr "mode" "SI,SI,SI,SI,SI,SI,DI,TI,SI,SI")])
+   (set_attr "mode" "SI,SI,SI,SI,DI,TI,SI,SI")])
 
 ;; Stores and loads of ax to arbitary constant address.
 ;; We fake an second form of instruction to force reload to load address
@@ -1848,14 +1845,9 @@
   [(set_attr "type" "push")
    (set_attr "mode" "QI")])
 
-; The first alternative is used only to compute proper length of instruction.
-; Reload's algorithm does not take into account the cost of spill instructions
-; needed to free register in given class, so avoid it from choosing the first
-; alternative when eax is not available.
-
 (define_insn "*movhi_1"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=*?a,r,r,*?a,r,m")
-	(match_operand:HI 1 "general_operand" "i,r,rn,rm,rm,rn"))]
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,m")
+	(match_operand:HI 1 "general_operand" "r,rn,rm,rn"))]
   "GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM"
 {
   switch (get_attr_type (insn))
@@ -1872,36 +1864,35 @@
     }
 }
   [(set (attr "type")
-     (cond [(and (eq_attr "alternative" "0,1")
+     (cond [(and (eq_attr "alternative" "0")
 		 (ior (eq (symbol_ref "TARGET_PARTIAL_REG_STALL")
 			  (const_int 0))
 		      (eq (symbol_ref "TARGET_HIMODE_MATH")
 			  (const_int 0))))
 	      (const_string "imov")
-	    (and (eq_attr "alternative" "2,3,4")
+	    (and (eq_attr "alternative" "1,2")
 		 (match_operand:HI 1 "aligned_operand" ""))
 	      (const_string "imov")
 	    (and (ne (symbol_ref "TARGET_MOVX")
 		     (const_int 0))
-		 (eq_attr "alternative" "0,1,3,4"))
+		 (eq_attr "alternative" "0,2"))
 	      (const_string "imovx")
 	   ]
 	   (const_string "imov")))
     (set (attr "mode")
       (cond [(eq_attr "type" "imovx")
 	       (const_string "SI")
-	     (and (eq_attr "alternative" "2,3,4")
+	     (and (eq_attr "alternative" "1,2")
 		  (match_operand:HI 1 "aligned_operand" ""))
 	       (const_string "SI")
-	     (and (eq_attr "alternative" "0,1")
+	     (and (eq_attr "alternative" "0")
 		  (ior (eq (symbol_ref "TARGET_PARTIAL_REG_STALL")
 			   (const_int 0))
 		       (eq (symbol_ref "TARGET_HIMODE_MATH")
 			   (const_int 0))))
 	       (const_string "SI")
 	    ]
-	    (const_string "HI")))
-   (set_attr "modrm" "0,*,*,0,*,*")])
+	    (const_string "HI")))])
 
 ;; Stores and loads of ax to arbitary constant address.
 ;; We fake an second form of instruction to force reload to load address
@@ -12961,13 +12952,14 @@
   ""
   "%+j%C1\t%l0"
   [(set_attr "type" "ibr")
-   (set (attr "prefix_0f")
+   (set_attr "modrm" "0")
+   (set (attr "length")
 	   (if_then_else (and (ge (minus (match_dup 0) (pc))
-				  (const_int -128))
+				  (const_int -126))
 			      (lt (minus (match_dup 0) (pc))
-				  (const_int 124)))
-	     (const_int 0)
-	     (const_int 1)))])
+				  (const_int 128)))
+	     (const_int 2)
+	     (const_int 6)))])
 
 (define_insn "*jcc_2"
   [(set (pc)
@@ -12978,13 +12970,14 @@
   ""
   "%+j%c1\t%l0"
   [(set_attr "type" "ibr")
-   (set (attr "prefix_0f")
+   (set_attr "modrm" "0")
+   (set (attr "length")
 	   (if_then_else (and (ge (minus (match_dup 0) (pc))
-				  (const_int -128))
+				  (const_int -126))
 			      (lt (minus (match_dup 0) (pc))
-				  (const_int 124)))
-	     (const_int 0)
-	     (const_int 1)))])
+				  (const_int 128)))
+	     (const_int 2)
+	     (const_int 6)))])
 
 ;; In general it is not safe to assume too much about CCmode registers,
 ;; so simplify-rtx stops when it sees a second one.  Under certain 
@@ -13244,7 +13237,15 @@
 	(label_ref (match_operand 0 "" "")))]
   ""
   "jmp\t%l0"
-  [(set_attr "type" "ibr")])
+  [(set_attr "type" "ibr")
+   (set (attr "length")
+	   (if_then_else (and (ge (minus (match_dup 0) (pc))
+				  (const_int -126))
+			      (lt (minus (match_dup 0) (pc))
+				  (const_int 128)))
+	     (const_int 2)
+	     (const_int 5)))
+   (set_attr "modrm" "0")])
 
 (define_expand "indirect_jump"
   [(set (pc) (match_operand 0 "nonimmediate_operand" "rm"))]
@@ -13357,14 +13358,17 @@
     return "dec{l}\t%1\;%+jne\t%l0";
 }
   [(set_attr "ppro_uops" "many")
-   (set (attr "type")
+   (set (attr "length")
 	(if_then_else (and (eq_attr "alternative" "0")
 			   (and (ge (minus (match_dup 0) (pc))
-			            (const_int -128))
+			            (const_int -126))
 			        (lt (minus (match_dup 0) (pc))
-			            (const_int 124))))
-		      (const_string "ibr")
-		      (const_string "multi")))])
+			            (const_int 128))))
+		      (const_int 2)
+		      (const_int 16)))
+   ;; We don't know the type before shorten branches.  Optimistically expect
+   ;; the loop instruction to match.
+   (set (attr "type") (const_string "ibr"))])
 
 (define_split
   [(set (pc)
@@ -13879,7 +13883,6 @@
   [(set_attr "length_immediate" "0")
    (set_attr "length" "1")
    (set_attr "modrm" "0")
-   (set_attr "modrm" "0")
    (set_attr "athlon_decode" "vector")
    (set_attr "ppro_uops" "few")])
 
@@ -13891,7 +13894,6 @@
   "leave"
   [(set_attr "length_immediate" "0")
    (set_attr "length" "1")
-   (set_attr "modrm" "0")
    (set_attr "modrm" "0")
    (set_attr "athlon_decode" "vector")
    (set_attr "ppro_uops" "few")])
Index:. gcc/config/i386/i386.c
===================================================================
RCS file: /cvs/gcc/gcc/gcc/config/i386/i386.c,v
retrieving revision 1.368.2.19.2.11
diff -u -p -r1.368.2.19.2.11 i386.c
--- gcc/config/i386/i386.c	28 Feb 2003 17:31:34 -0000	1.368.2.19.2.11
+++ gcc/config/i386/i386.c	10 Mar 2003 20:26:37 -0000
@@ -9939,7 +9939,8 @@ memory_address_length (addr)
       if (disp)
 	{
 	  if (GET_CODE (disp) == CONST_INT
-	      && CONST_OK_FOR_LETTER_P (INTVAL (disp), 'K'))
+	      && CONST_OK_FOR_LETTER_P (INTVAL (disp), 'K')
+	      && base)
 	    len = 1;
 	  else
 	    len = 4;
@@ -10002,6 +10003,26 @@ ix86_attr_length_address_default (insn)
      rtx insn;
 {
   int i;
+
+  if (get_attr_type (insn) == TYPE_LEA)
+    {
+      rtx set = PATTERN (insn);
+      if (GET_CODE (set) == SET)
+	;
+      else if (GET_CODE (set) == PARALLEL
+	       && GET_CODE (XVECEXP (set, 0, 0)) == SET)
+	set = XVECEXP (set, 0, 0);
+      else
+	{
+#ifdef ENABLE_CHECKING
+	  abort ();
+#endif
+	  return 0;
+	}
+
+      return memory_address_length (SET_SRC (set));
+    }
+
   extract_insn_cached (insn);
   for (i = recog_data.n_operands - 1; i >= 0; --i)
     if (GET_CODE (recog_data.operand[i]) == MEM)
