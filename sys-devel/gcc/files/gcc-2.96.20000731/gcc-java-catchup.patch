2000-09-09  Geoffrey Keating  <geoffk@cygnus.com>

	* typeck.c (build_java_array_type): Correct first parameter
	in ADJUST_FIELD_ALIGN invocation.

2000-09-06  Tom Tromey  <tromey@cygnus.com>

	* lang-specs.h: Also recognize `-femit-class-files'.

2000-09-05  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* verify.c (merge_types): Load the types to merge if necessary.

2000-09-02  Anthony Green  <green@redhat.com>

	* jcf-io.c: Include zlib.h.
	(open_in_zip): Read compressed class file archives.
	* zipfile.h (ZipDirectory): Add uncompressed_size and
	compression_method fields.
	* zextract.c (read_zip_archive): Collect file compression info.

2000-08-11  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* parse.y (do_merge_string_cste): New locals. Create new
	STRING_CSTs each time, use memcpy. Fixes gcj/311.

2000-08-07  Hans Boehm  <boehm@acm.org>

	* boehm.c (mark_reference_fields): Set marking bits for all words in
	a multiple-word record.
	(get_boehm_type_descriptor): Use the procedure marking descriptor for
	java.lang.Class.
	
2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>

	* jcf-parse.c (set_source_filename): Constify a char *.
	* jcf-write.c (append_innerclasses_attribute,
	make_class_file_name): Constify a char *.  Don't recycle a
	variable for an unrelated purpose.
	* parse.y: (build_alias_initializer_parameter_list): Constify a char *.
	(breakdown_qualified): Do not modify IDENTIFIER_POINTER strings.

2000-08-29  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* expr.c (can_widen_reference_to): Fixed indentation.
	* java-tree.h (CLASS_METHOD_CHECKED_P): Added leading comment.
	* parse.y: `finit$' replaces `$finit$' in comments.
	(try_builtin_assignconv): Fixed leading comment.

2000-08-22  Andrew Haley  <aph@cygnus.com>

	* javaop.h (WORD_TO_INT): Mask lower 32 bits of a jword before
	sign extending. Fixes gcj/321.
	* jcf-parse.c (get_constant): Mask lower 32 bits of a jint before
	combining to make a jlong. Fixes gcj/321.

2000-08-21  Nix  <nix@esperi.demon.co.uk>
        
	* lang-specs.h: Do not process -o or run the assembler if
	-fsyntax-only.

2000-08-16  Andrew Haley  <aph@cygnus.com>

	* typeck.c (build_java_array_type): Rewrite code to do array
	alignment.  Take into account back-end macros when aligning array
	data.  Remove setting of TYPE_USER_ALIGN; Java doesn't allow the
	user to set alignment. Fixes gcj/252 and 160.

2000-08-09  Tom Tromey  <tromey@cygnus.com>

	* parse.y (check_abstract_method_definitions): Now return `int'.
	Check implemented interfaces.  Fixes PR gcj/305.

	* parse.y (patch_switch_statement): Disallow `long' in switch
	expressions.  Fixes PR gcj/310.

2000-08-15  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* decl.c (finit_leg_identifier_node): New global.
	(init_decl_processing): Use `finit$' to initialize
	finit_identifier_node. Use `$finit$' to initialize
	finit_leg_identifier_node.
	* expr.c (expand_java_field_op): Use ID_FINIT_P.
	* java-tree.h (finit_identifier_node): Changed attached comment.
	(finit_leg_identifier_node): New declaration.
	(ID_FINIT_P): Take finit_identifier_node and
	finit_leg_identifier_node into account. This is a backward
	compatibility hack.

2000-08-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* java-tree.h (flag_extraneous_semicolon): New extern.
	* lang-options.h: (-Wextraneous-semicolon): New option.
	* lang.c (flag_redundant): Fixed typo in leading comment.
	(flag_extraneous_semicolon): New global.
	(lang_decode_option): Set `flag_extraneous_semicolon' when
	-Wall. Decode `-Wextraneous-semicolon'.
	* parse.y (type_declaration:): Removed `SC_TK' hack, added
	`empty_statement' rule.
	(class_body_declaration): Likewise.
	(method_body:): Accept `;' as a method body.
	(static_initializer:): Removed `SC_TK' hack.
	(constructor_block_end:): Likewise.
	(empty_statement:): Report deprecated empty declaration. Fixes
	gcj/295

2000-08-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* parse.y (build_dot_class_method_invocation): Changed parameter
	name to `type.' Build signature from `type' and convert it to a
	STRING_CST if it's an array.
	(patch_incomplete_class_ref): `build_dot_class_method_invocation'
	to use `ref_type' directly.

Sun Aug  6 00:47:24 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>

	* lang-options.h: Added a comma after the last element to avoid
	syntax errors when other languages define additional options.

2000-08-02  Zack Weinberg  <zack@wolery.cumb.org>

	* class.c (build_dtable_decl): Initialize dummy.

2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* parse.y (maybe_yank_clinit): When generating bytecode: non empty
	method bodies not to rule out discarding `<clinit>'; don't use
	<clinit> to initialize static fields with constant initializers.

2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* gjavah.c (print_method_info): Added `synth' parameter. Skip
	synthetic methods.
	(method_synthetic): New global.
	(HANDLE_METHOD): Recognize synthetic method and tell
	`print_method_info' about it.
	(HANDLE_END_METHOD): Do not issue an additional `;\n' if we're
	processing a synthetic method.
	* jcf-reader.c (skip_attribute): New function.
	( skip_attribute): Likewise.

2000-08-01  Alexandre Petit-Bianco  <apbianco@cygnus.com>
	* parse.y (build_outer_field_access): Fixed comments.
	(fix_constructors): Emit the initialization of this$<n> before
	calling $finit$.
	(resolve_qualified_expression_name): Build an access to `decl' if
	necessary.

2000-07-31  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* parse-scan.y (curent_class): Non longer const.
	(inner_qualifier, inner_qualifier_length): Deleted.
	(current_class_length): New global.
	(bracket_count): Fixed typo in leading comment.
	(anonymous_count): New global.
	(class_instance_creation_expression:): Handle anonymous classes.
	(anonymous_class_creation:): New rule.
	(push_class_context): Rewritten.
	(pop_class_context): Likewise.
	(INNER_QUALIFIER): Macro deleted.
	(report_class_declaration): call `push_class_context' when
	entering the function. `fprintf' format modified not to use
	INNER_QUALIFIER.
	(report_class_declaration): Assign `package_name' and
	`current_class' to NULL separatly.

2000-07-31  Alexandre Petit-Bianco  <apbianco@cygnus.com>

	* expr.c (build_invokeinterface): Call layout_class_methods on
	target interface.


--- gcc/java/boehm.c	2000/09/10 04:41:33	1.1.1.1
+++ gcc/java/boehm.c	2000/09/10 13:56:44
@@ -95,17 +95,21 @@
   for (; field != NULL_TREE; field = TREE_CHAIN (field))
     {
       HOST_WIDE_INT offset;
+      HOST_WIDE_INT size_bytes;
 
       if (FIELD_STATIC (field))
 	continue;
 
       offset = int_byte_position (field);
+      size_bytes = int_size_in_bytes (TREE_TYPE (field));
       if (JREFERENCE_TYPE_P (TREE_TYPE (field))
 	  /* An `object' of type gnu.gcj.RawData is actually non-Java
 	     data.  */
 	  && TREE_TYPE (field) != rawdata_ptr_type_node)
 	{
 	  unsigned int count;
+	  unsigned int size_words;
+	  unsigned int i;
 
 	  /* If this reference slot appears to overlay a slot we think
 	     we already covered, then we are doomed.  */
@@ -113,11 +117,19 @@
 	    abort ();
 
 	  count = offset * BITS_PER_UNIT / POINTER_SIZE;
+	  size_words = size_bytes * BITS_PER_UNIT / POINTER_SIZE;
 
 	  *last_set_index = count;
-	  /* First word in object corresponds to most significant byte
-	     of bitmap.  */
-	  set_bit (low, high, ubit - count - 1);
+	     
+	  /* First word in object corresponds to most significant byte of 
+	     bitmap. 
+	     
+	     In the case of a multiple-word record, we set pointer 
+	     bits for all words in the record. This is conservative, but the 
+	     size_words != 1 case is impossible in regular java code. */
+	  for (i = 0; i < size_words; ++i)
+	    set_bit (low, high, ubit - count - i - 1);
+
 	  if (count > ubit - 2)
 	    *pointer_after_end = 1;
 
@@ -172,6 +184,9 @@
 
   /* Warning avoidance.  */
   ubit = (unsigned int) bit;
+
+  if (type == class_type_node)
+    return PROCEDURE_OBJECT_DESCRIPTOR;
 
   field = TYPE_FIELDS (type);
   mark_reference_fields (field, &low, &high, ubit,
--- gcc/java/class.c	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/class.c	2000/09/10 13:56:44
@@ -1698,7 +1698,7 @@
      TYPE. */
   if (current_class == type)
     {
-      tree dummy, aomt, n;
+      tree dummy = NULL_TREE, aomt, n;
 
       dtype = make_node (RECORD_TYPE);
       PUSH_FIELD (dtype, dummy, "class", class_ptr_type);
--- gcc/java/decl.c	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/decl.c	2000/09/10 13:56:44
@@ -360,6 +360,7 @@
 tree init_identifier_node;
 tree clinit_identifier_node;
 tree finit_identifier_node;
+tree finit_leg_identifier_node;
 tree void_signature_node;
 tree length_identifier_node;
 tree this_identifier_node;
@@ -646,7 +647,12 @@
   TYPE_identifier_node = get_identifier ("TYPE");
   init_identifier_node = get_identifier ("<init>");
   clinit_identifier_node = get_identifier ("<clinit>");
-  finit_identifier_node = get_identifier ("$finit$");
+  /* Legacy `$finit$' special method identifier. This needs to be
+     recognized as equivalent to `finit$' but isn't generated anymore.  */
+  finit_leg_identifier_node = get_identifier ("$finit$");
+  /* The new `finit$' special method identifier. This one is now
+     generated in place of `$finit$'.  */
+  finit_identifier_node = get_identifier ("finit$");
   void_signature_node = get_identifier ("()V");
   length_identifier_node = get_identifier ("length");
   this_identifier_node = get_identifier ("this");
--- gcc/java/expr.c	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/expr.c	2000/09/10 13:56:44
@@ -406,8 +406,8 @@
 		    (TREE_TYPE (TREE_VEC_ELT (basetype_vec, i)),
 		     target_type))
 		  return 1;
-		if (n == 0)
-		  return 0;
+	      if (n == 0)
+		return 0;
 	    }
 
 	  for ( ; source_depth > target_depth;  source_depth--) 
@@ -1783,6 +1783,7 @@
 		  lookup_field (&dtable_type, class_ident));
 
   interface = DECL_CONTEXT (method);
+  layout_class_methods (interface);
   
   i = 1;
   for (meth = TYPE_METHODS (interface); ; meth = TREE_CHAIN (meth), i++)
@@ -2209,7 +2210,7 @@
 	    {
 	      tree cfndecl_name = DECL_NAME (current_function_decl);
 	      if (! DECL_CONSTRUCTOR_P (current_function_decl)
-		  && (cfndecl_name != finit_identifier_node))
+		  && !ID_FINIT_P (cfndecl_name))
 		error_with_decl (field_decl, "assignment to final field `%s' not in constructor");
 	    }
 	}
--- gcc/java/gjavah.c	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/gjavah.c	2000/09/10 14:44:10
@@ -116,7 +116,7 @@
 static void print_field_info PARAMS ((FILE*, JCF*, int, int, JCF_u2));
 static void print_mangled_classname PARAMS ((FILE*, JCF*, const char*, int));
 static int  print_cxx_classname PARAMS ((FILE*, const char*, JCF*, int));
-static void print_method_info PARAMS ((FILE*, JCF*, int, int, JCF_u2));
+static void print_method_info PARAMS ((FILE*, JCF*, int, int, JCF_u2, int));
 static void print_c_decl PARAMS ((FILE*, JCF*, int, int, int, const char *,
 				  int));
 static void print_stub_or_jni PARAMS ((FILE*, JCF*, int, int, int,
@@ -182,26 +182,45 @@
 static int method_declared = 0;
 static int method_access = 0;
 static int method_printed = 0;
-#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT)	      \
-  if (method_pass)							      \
-    {									      \
-      decompiled = 0; method_printed = 0;				      \
-      if (out)								      \
-        print_method_info (out, jcf, NAME, SIGNATURE, ACCESS_FLAGS);	      \
-    }									      \
-  else                                                                       \
-    {                                                                        \
-      print_method_info (NULL, jcf, NAME, SIGNATURE, ACCESS_FLAGS);          \
-      if (! stubs && ! flag_jni)                                             \
-       add_class_decl (out, jcf, SIGNATURE);                                 \
-    }
+static int method_synthetic = 0;
+#define HANDLE_METHOD(ACCESS_FLAGS, NAME, SIGNATURE, ATTRIBUTE_COUNT)	\
+  {									\
+    method_synthetic = 0;						\
+    if (ATTRIBUTE_COUNT)						\
+      method_synthetic = peek_attribute (jcf, ATTRIBUTE_COUNT,		\
+				  (const char *)"Synthetic", 9);	\
+    /* If a synthetic methods have been declared, its attribute aren't	\
+       worth reading (and triggering side-effects). We skip them an	\
+       set ATTRIBUTE_COUNT to zero so that they'll be skipped in	\
+       jcf_parse_one_method.  */					\
+    if (method_synthetic)						\
+      {									\
+	skip_attribute (jcf, ATTRIBUTE_COUNT);				\
+	ATTRIBUTE_COUNT = 0;						\
+      } 								\
+    if (method_pass && !method_synthetic)				\
+      {									\
+	decompiled = 0; method_printed = 0;				\
+	if (out)							\
+	  print_method_info (out, jcf, NAME, SIGNATURE,			\
+			     ACCESS_FLAGS, method_synthetic);		\
+      }									\
+    else if (!method_synthetic)						\
+      {									\
+	print_method_info (NULL, jcf, NAME, SIGNATURE,			\
+			   ACCESS_FLAGS, method_synthetic);		\
+	if (! stubs && ! flag_jni)					\
+	  add_class_decl (out, jcf, SIGNATURE);				\
+      }									\
+  }
 
-#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH) \
+#define HANDLE_CODE_ATTRIBUTE(MAX_STACK, MAX_LOCALS, CODE_LENGTH)	\
   if (out && method_declared) decompile_method (out, jcf, CODE_LENGTH);
 
 static int decompiled = 0;
-#define HANDLE_END_METHOD() \
-  if (out && method_printed) fputs (decompiled || stubs ? "\n" : ";\n", out);
+#define HANDLE_END_METHOD()				\
+  if (out && method_printed && !method_synthetic) 	\
+    fputs (decompiled || stubs ? "\n" : ";\n", out);
 
 #include "jcf-reader.c"
 
@@ -670,9 +689,9 @@
 
 
 static void
-DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),
+DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags, synth),
       FILE *stream AND JCF* jcf
-      AND int name_index AND int sig_index AND JCF_u2 flags)
+      AND int name_index AND int sig_index AND JCF_u2 flags AND int synth)
 {
   const unsigned char *str;
   int length, is_init = 0;
@@ -684,10 +703,15 @@
     fprintf (stream, "<not a UTF8 constant>");
   str = JPOOL_UTF_DATA (jcf, name_index);
   length = JPOOL_UTF_LENGTH (jcf, name_index);
-  if (str[0] == '<' || str[0] == '$')
+
+  /* Ignore synthetic methods. */
+  if (synth)
+    return;
+
+  if (str[0] == '<')
     {
-      /* Ignore internally generated methods like <clinit> and
-	 $finit$.  However, treat <init> as a constructor.  */
+      /* Ignore the internally generated method <clinit>. However,
+         treat <init> as a constructor.  */
       if (! utf8_cmp (str, length, "<init>"))
 	is_init = 1;
       else if (! METHOD_IS_FINAL (jcf->access_flags, flags)
--- gcc/java/javaop.h	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/javaop.h	2000/09/10 13:56:44
@@ -1,6 +1,6 @@
 /* Utility macros to handle Java(TM) byte codes.
 
-   Copyright (C) 1996, 1998, 1999, 2000  Free Software Foundation, Inc.
+   Copyright (C) 1996, 1998, 1999  Free Software Foundation, Inc.
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -33,7 +33,7 @@
 typedef unsigned int16	uint16;
 
 #ifndef int32
-#define int32 int
+#define int32 long
 #endif
 typedef unsigned int32	uint32;
 
@@ -62,7 +62,7 @@
 #define jfloat float
 #endif
 
-/* A 64-bit IEEE double-precision float. */
+/* A 32-bit IEEE double-precision float. */
 #ifndef jdouble
 #define jdouble double
 #endif
@@ -79,11 +79,7 @@
 
 
 #ifndef jword
-#if !defined(__alpha__) && (!defined (_ARCH_PPC) || !defined (__64BIT__)) && (!defined(__sparc__) || (!defined(__sparcv9) && !defined(__arch64__))) && (!defined(__ia64__) || !defined(__LP64__))
 #define jword uint32
-#else
-#define jword uint64
-#endif
 #endif
 
 #ifndef IMMEDIATE_u1
@@ -113,13 +109,16 @@
   return wu.f;
 } 
 
-/* Sign extend w. */
+/* Sign extend w.  If the host on which this cross-compiler runs uses
+   a 64-bit type for jword the appropriate sign extension is
+   performed; if it's a 32-bit type the arithmetic does nothing but is
+   harmless.  */
 static inline jint
 WORD_TO_INT(jword w)
 {
-  jint n = w;
+  jint n = w & 0xffffffff; /* Mask lower 32 bits.  */
   n ^= (jint)1 << 31;
-  n -= (jint)1 << 31;
+  n -= (jint)1 << 31; /* Sign extend lower 32 bits to upper.  */
   return n;
 } 
 
--- gcc/java/java-tree.h	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/java-tree.h	2000/09/10 13:56:44
@@ -141,6 +141,10 @@
 
 extern int flag_jni;
 
+/* When non zero, report the now deprecated empty statements.  */
+
+extern int flag_extraneous_semicolon;
+
 /* When non zero, we emit xref strings. Values of the flag for xref
    backends are defined in xref.h.  */
 
@@ -253,7 +257,8 @@
 extern tree TYPE_identifier_node;      /* "TYPE" */
 extern tree init_identifier_node;      /* "<init>" */
 extern tree clinit_identifier_node;      /* "<clinit>" */
-extern tree finit_identifier_node;      /* "$finit$" */
+extern tree finit_identifier_node;      /* "finit$" */
+extern tree finit_leg_identifier_node;  /* "$finit$" */
 extern tree void_signature_node;       /* "()V" */
 extern tree length_identifier_node;  /* "length" */
 extern tree this_identifier_node;  /* "this" */
@@ -821,7 +826,12 @@
 /* Predicates on method identifiers. Kept close to other macros using
    them  */
 #define ID_INIT_P(ID)   ((ID) == init_identifier_node)
-#define ID_FINIT_P(ID)  ((ID) == finit_identifier_node)
+/* Match ID to either `$finit$' or `finit$', so that `$finit$'
+   continues to be recognized as an equivalent to `finit$' which is
+   now the prefered name used for the field initialization special
+   method.  */
+#define ID_FINIT_P(ID)  ((ID) == finit_identifier_node \
+			 || (ID) == finit_leg_identifier_node)
 #define ID_CLINIT_P(ID) ((ID) == clinit_identifier_node)
 
 /* Access flags etc for a variable/field (a FIELD_DECL): */
@@ -1001,6 +1011,8 @@
    initialization during its declaration */
 #define MODIFY_EXPR_FROM_INITIALIZATION_P(EXPR) TREE_LANG_FLAG_2 (EXPR)
 
+/* True if EXPR (a TREE_TYPE denoting a class type) has its methods
+   already checked (for redifitions, etc, see java_check_regular_methods.) */
 #define CLASS_METHOD_CHECKED_P(EXPR) TREE_LANG_FLAG_2 (EXPR)
 
 /* True if EXPR (a WFL in that case) resolves into an expression name */
--- gcc/java/jcf-io.c	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/jcf-io.c	2000/09/10 13:56:44
@@ -30,6 +30,8 @@
 #include "toplev.h"
 #include "java-tree.h"
 
+#include "zlib.h"
+
 /* DOS brain-damage */
 #ifndef O_BINARY
 #define O_BINARY 0 /* MS-DOS brain-damage */
@@ -149,6 +151,7 @@
   ZipDirectory *zipd;
   int i, len;
   ZipFile *zipf = opendir_in_zip (zipfile, is_system);
+  z_stream d_stream; /* decompression stream */
 
   if (zipf == NULL)
     return -2;
@@ -156,6 +159,10 @@
   if (!zipmember)
     return 0;
 
+  d_stream.zalloc = (alloc_func) 0;
+  d_stream.zfree = (free_func) 0;
+  d_stream.opaque = (voidpf) 0;
+
   len = strlen (zipmember);
   
   zipd = (struct ZipDirectory*) zipf->central_directory;
@@ -165,17 +172,45 @@
 	  strncmp (ZIPDIR_FILENAME (zipd), zipmember, len) == 0)
 	{
 	  JCF_ZERO (jcf);
-	  jcf->buffer = ALLOC (zipd->size);
-	  jcf->buffer_end = jcf->buffer + zipd->size;
-	  jcf->read_ptr = jcf->buffer;
-	  jcf->read_end = jcf->buffer_end;
+
 	  jcf->filbuf = jcf_unexpected_eof;
 	  jcf->filename = xstrdup (zipfile);
 	  jcf->classname = xstrdup (zipmember);
 	  jcf->zipd = (void *)zipd;
-	  if (lseek (zipf->fd, zipd->filestart, 0) < 0
-	      || read (zipf->fd, jcf->buffer, zipd->size) != zipd->size)
-	    return -2;
+
+	  if (zipd->compression_method == Z_NO_COMPRESSION)
+	    {
+	      jcf->buffer = ALLOC (zipd->size);
+	      jcf->buffer_end = jcf->buffer + zipd->size;
+	      jcf->read_ptr = jcf->buffer;
+	      jcf->read_end = jcf->buffer_end;
+	      if (lseek (zipf->fd, zipd->filestart, 0) < 0
+		  || read (zipf->fd, jcf->buffer, zipd->size) != zipd->size)
+	        return -2;
+	    }
+	  else
+	    {
+	      char *buffer;
+	      jcf->buffer = ALLOC (zipd->uncompressed_size);
+	      d_stream.next_out = jcf->buffer;
+	      d_stream.avail_out = zipd->uncompressed_size;
+	      jcf->buffer_end = jcf->buffer + zipd->uncompressed_size;
+	      jcf->read_ptr = jcf->buffer;
+	      jcf->read_end = jcf->buffer_end;
+	      buffer = ALLOC (zipd->size);
+	      d_stream.next_in = buffer;
+	      d_stream.avail_in = zipd->size;
+	      if (lseek (zipf->fd, zipd->filestart, 0) < 0
+		  || read (zipf->fd, buffer, zipd->size) != zipd->size)
+		return -2;
+	      /* Handle NO_HEADER using undocumented zlib feature.
+                 This is a very common hack.  */
+	      inflateInit2 (&d_stream, -MAX_WBITS);
+	      inflate (&d_stream, Z_NO_FLUSH);
+	      inflateEnd (&d_stream);
+	      FREE (buffer);
+	    }
+
 	  return 0;
 	}
     }
--- gcc/java/jcf-parse.c	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/jcf-parse.c	2000/09/10 13:56:44
@@ -99,7 +99,7 @@
      int index;
 {
   tree sfname_id = get_name_constant (jcf, index);
-  char *sfname = IDENTIFIER_POINTER (sfname_id);
+  const char *sfname = IDENTIFIER_POINTER (sfname_id);
   if (input_filename != NULL)
     {
       int old_len = strlen (input_filename);
@@ -270,8 +270,8 @@
 	jint num = JPOOL_INT (jcf, index);
 	HOST_WIDE_INT lo, hi;
 	lshift_double (num, 0, 32, 64, &lo, &hi, 0);
-	num = JPOOL_INT (jcf, index+1);
-	add_double (lo, hi, (uint32)num, 0, &lo, &hi);
+	num = JPOOL_INT (jcf, index+1) & 0xffffffff;
+	add_double (lo, hi, num, 0, &lo, &hi);
 	value = build_int_2 (lo, hi);
 	TREE_TYPE (value) = long_type_node;
 	force_fit_type (value, 0);
--- gcc/java/jcf-reader.c	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/jcf-reader.c	2000/09/10 13:56:44
@@ -27,6 +27,8 @@
 #include "zipfile.h"
 
 static int get_attribute PARAMS ((JCF *));
+static int peek_attribute PARAMS ((JCF *, int, const char *, int));
+static void skip_attribute PARAMS ((JCF *, int));
 static int jcf_parse_preamble PARAMS ((JCF *));
 static int jcf_parse_constant_pool PARAMS ((JCF *));
 static void jcf_parse_class PARAMS ((JCF *));
@@ -34,6 +36,64 @@
 static int jcf_parse_one_method PARAMS ((JCF *));
 static int jcf_parse_methods PARAMS ((JCF *));
 static int jcf_parse_final_attributes PARAMS ((JCF *));
+
+/* Go through all available attribute (ATTRIBUTE_NUMER) and try to
+   identify PEEKED_NAME.  Return 1 if PEEKED_NAME was found, 0
+   otherwise. JCF is restored to its initial position before
+   returning.  */
+
+static int
+peek_attribute (jcf, attribute_number, peeked_name, peeked_name_length)
+      JCF *jcf;
+      int attribute_number;
+      const char *peeked_name;
+      int peeked_name_length;
+{
+  int to_return = 0;
+  long absolute_offset = (long)JCF_TELL (jcf);
+  int i;
+
+  for (i = 0; !to_return && i < attribute_number; i++)
+    {
+      uint16 attribute_name = (JCF_FILL (jcf, 6), JCF_readu2 (jcf));
+      uint32 attribute_length = JCF_readu4 (jcf);
+      int name_length;
+      const unsigned char *name_data; 
+
+      JCF_FILL (jcf, (long) attribute_length);
+      if (attribute_name <= 0 || attribute_name >= JPOOL_SIZE(jcf)
+	  || JPOOL_TAG (jcf, attribute_name) != CONSTANT_Utf8)
+	continue;
+
+      name_length = JPOOL_UTF_LENGTH (jcf, attribute_name);
+      name_data = JPOOL_UTF_DATA (jcf, attribute_name);
+
+      if (name_length == peeked_name_length 
+	  && ! memcmp (name_data, peeked_name, peeked_name_length)) 
+	{
+	  to_return = 1; 
+	  break;
+	}
+      
+      JCF_SKIP (jcf, attribute_length);
+    }
+
+  JCF_SEEK (jcf, absolute_offset);
+  return to_return;
+}
+
+static void
+skip_attribute (jcf, number_of_attribute)
+     JCF *jcf;
+     int number_of_attribute;
+{
+  while (number_of_attribute--)
+    {
+      JCF_FILL (jcf, 6);
+      (void) JCF_readu2 (jcf);
+      JCF_SKIP (jcf, JCF_readu4 (jcf));
+    }
+}
 
 static int
 DEFUN(get_attribute, (jcf),
--- gcc/java/jcf-write.c	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/jcf-write.c	2000/09/10 13:56:44
@@ -3161,7 +3161,7 @@
      process: itself, up and down. */
   while (class && INNER_CLASS_TYPE_P (class))
     {
-      char *n;
+      const char *n;
 
       decl = TYPE_NAME (class);
       n = IDENTIFIER_POINTER (DECL_NAME (decl)) + 
@@ -3218,8 +3218,8 @@
 make_class_file_name (clas)
      tree clas;
 {
-  const char *dname, *slash;
-  char *cname, *r;
+  const char *dname, *cname, *slash;
+  char *r;
   struct stat sb;
 
   cname = IDENTIFIER_POINTER (identifier_subst (DECL_NAME (TYPE_NAME (clas)),
@@ -3261,10 +3261,10 @@
   dname = r + (slash - dname) + 1;
   while (1)
     {
-      cname = strchr (dname, DIR_SEPARATOR);
-      if (cname == NULL)
+      char *s = strchr (dname, DIR_SEPARATOR);
+      if (s == NULL)
 	break;
-      *cname = '\0';
+      *s = '\0';
       if (stat (r, &sb) == -1)
 	{
 	  /* Try to make it.  */
@@ -3275,9 +3275,9 @@
 	      return NULL;
 	    }
 	}
-      *cname = DIR_SEPARATOR;
+      *s = DIR_SEPARATOR;
       /* Skip consecutive separators.  */
-      for (dname = cname + 1; *dname && *dname == DIR_SEPARATOR; ++dname)
+      for (dname = s + 1; *dname && *dname == DIR_SEPARATOR; ++dname)
 	;
     }
 
--- gcc/java/jvspec.c	2000/09/10 04:41:32	1.1.1.1
+++ gcc/java/jvspec.c	2000/09/10 15:02:09
@@ -181,7 +181,7 @@
   int argc;
 
   /* The argument list.  */
-  char **argv;
+  char *const *argv;
 
   /* The number of libraries added in.  */
   int added_libraries;
@@ -392,6 +392,7 @@
   if (saw_g + saw_O == 0)
     num_args++;
   num_args++;
+
   arglist = (const char **)
     (real_arglist = (char **) xmalloc ((num_args + 1) * sizeof (char *)));
 
--- gcc/java/lang.c	2000/09/10 04:41:32	1.1.1.1
+++ gcc/java/lang.c	2000/09/10 14:44:45
@@ -98,7 +98,7 @@
 /* When non zero, -Wall was turned on.  */
 int flag_wall = 0;
 
-/* When non zero,  check for redundant modifier uses.  */
+/* When non zero, check for redundant modifier uses.  */
 int flag_redundant = 0;
 
 /* When non zero, warns about overridings that don't occur.  */
@@ -121,6 +121,9 @@
    JNI, not CNI.  */
 int flag_jni = 0;
 
+/* When non zero, report the now deprecated empty statements.  */
+int flag_extraneous_semicolon;
+
 /* From gcc/flags.h, and indicates if exceptions are turned on or not.  */
 
 extern int flag_new_exceptions;
@@ -256,6 +259,7 @@
     {
       flag_wall = 1;
       flag_redundant = 1;
+      flag_extraneous_semicolon = 1;
       /* When -Wall given, enable -Wunused.  We do this because the C
 	 compiler does it, and people expect it.  */
       set_Wunused (1);
@@ -271,6 +275,12 @@
   if (strcmp (p, "-Wredundant-modifiers") == 0)
     {
       flag_redundant = 1;
+      return 1;
+    }
+
+  if (strcmp (p, "-Wextraneous-semicolon") == 0)
+    {
+      flag_extraneous_semicolon = 1;
       return 1;
     }
 
--- gcc/java/lang-options.h	2000/09/10 04:41:32	1.1.1.1
+++ gcc/java/lang-options.h	2000/09/10 13:56:44
@@ -50,4 +50,5 @@
   { "-fno-use-divide-subroutine", "Use built-in instructions for division" },
   { "-Wredundant-modifiers", 
     "Warn if modifiers are specified when not necessary"},
-  { "-Wunsupported-jdk11", "Warn if `final' local variables are specified"}
+  { "-Wunsupported-jdk11", "Warn if `final' local variables are specified"},
+  { "-Wextraneous-semicolon", "Warn if deprecated empty statements are found"},
--- gcc/java/lang-specs.h	2000/09/10 04:41:32	1.1.1.1
+++ gcc/java/lang-specs.h	2000/09/10 13:56:44
@@ -30,7 +30,8 @@
   {".zip",    "@java" },
   {".jar",    "@java" },
   {"@java",
-   "%{fjni:%{femit-class-file:%e-fjni and -femit-class-file are incompatible}}\
+   "%{fjni:%{femit-class-files:%e-fjni and -femit-class-files are incompatible}}\
+    %{fjni:%{femit-class-file:%e-fjni and -femit-class-file are incompatible}}\
     %{!E:jc1 %i %(jc1) %(cc1_options) %{+e*} %{I*} %{MD} %{MMD} %{M} %{MM}\
-             %{!S:-o %{|!pipe:%g.s} |\n\
-    as %(asm_options) %{!pipe:%g.s} %A }}"},
+             %{!fsyntax-only:%{!S:-o %{|!pipe:%g.s} |\n\
+    as %(asm_options) %{!pipe:%g.s} %A }}}"},
--- gcc/java/Makefile.in	2000/09/10 04:41:30	1.1.1.1
+++ gcc/java/Makefile.in	2000/09/10 14:48:00
@@ -148,9 +148,12 @@
 # This is where we get libiberty.a from.
 LIBIBERTY = ../../libiberty/libiberty.a
 
+# As a special hack for this RPM, always use the system zlib.
+ZLIB = -lz
+
 # How to link with both our special library facilities
 # and the system's installed libraries.
-LIBS = $(INTLLIBS) $(LIBIBERTY) $(CLIB)
+LIBS = $(ZLIB) $(INTLLIBS) $(LIBIBERTY) $(CLIB)
 LIBDEPS = $(INTLLIBS) $(LIBIBERTY) ../errors.o
 
 # Specify the directories to be searched for header files.
--- gcc/java/parse-scan.y	2000/09/10 04:41:32	1.1.1.1
+++ gcc/java/parse-scan.y	2000/09/10 13:56:44
@@ -63,12 +63,11 @@
 #define USE_ABSORBER absorber = 0
 
 /* Keep track of the current class name and package name.  */
-static const char *current_class;
+static char *current_class;
 static const char *package_name;
 
 /* Keep track of the current inner class qualifier. */
-static char *inner_qualifier;
-static int   inner_qualifier_length;
+static int current_class_length;
 
 /* Keep track of whether things have be listed before.  */
 static int previous_output;
@@ -76,10 +75,13 @@
 /* Record modifier uses  */
 static int modifier_value;
 
-/* Keep track of number of bracket pairs after a variable declarator
+/* Keeps track of number of bracket pairs after a variable declarator
    id.  */
 static int bracket_count; 
 
+/* Numbers anonymous classes */
+static int anonymous_count;
+
 /* Record a method declaration  */
 struct method_declarator {
   const char *method_name;
@@ -897,20 +899,22 @@
 class_instance_creation_expression:
 	NEW_TK class_type OP_TK argument_list CP_TK
 |	NEW_TK class_type OP_TK CP_TK
-        /* Added, JDK1.1 inner classes but modified to use
-           'class_type' instead of 'TypeName' (type_name) mentionned
-           in the documentation but doesn't exist. */
-|	NEW_TK class_type OP_TK argument_list CP_TK class_body
-|	NEW_TK class_type OP_TK CP_TK class_body         
-        /* Added, JDK1.1 inner classes, modified to use name or
-	   primary instead of primary solely which couldn't work in
-	   all situations.  */
+|	anonymous_class_creation
 |	something_dot_new identifier OP_TK CP_TK
 |	something_dot_new identifier OP_TK CP_TK class_body
 |	something_dot_new identifier OP_TK argument_list CP_TK
 |	something_dot_new identifier OP_TK argument_list CP_TK class_body
 ;
 
+anonymous_class_creation:
+	NEW_TK class_type OP_TK CP_TK
+		{ report_class_declaration (NULL); }
+	class_body         
+|	NEW_TK class_type OP_TK argument_list CP_TK
+		{ report_class_declaration (NULL); }
+	class_body
+;
+
 something_dot_new:		/* Added, not part of the specs. */
 	name DOT_TK NEW_TK
 		{ USE_ABSORBER; }
@@ -1128,29 +1132,61 @@
 push_class_context (name)
     const char *name;
 {
-  size_t name_length = strlen (name);
-  inner_qualifier = xrealloc (inner_qualifier, 
-                             inner_qualifier_length + name_length+2);
-  memcpy (inner_qualifier+inner_qualifier_length, name, name_length);
-  inner_qualifier_length += name_length;
-  inner_qualifier [inner_qualifier_length] = '$';
-  inner_qualifier [++inner_qualifier_length] = '\0';
+  /* If we already have CURRENT_CLASS set, we're in an inter
+     class. Mangle its name. */
+  if (current_class)
+    {
+      const char *p;
+      char anonymous [3];
+      int additional_length;
+      
+      /* NAME set to NULL indicates an anonymous class, which are named by
+	 numbering them. */
+      if (!name)
+	{
+	  sprintf (anonymous, "%d", ++anonymous_count);
+	  p = anonymous;
+	}
+      else
+	p = name;
+      
+      additional_length = strlen (p)+1; /* +1 for `$' */
+      current_class = xrealloc (current_class, 
+				current_class_length + additional_length + 1);
+      current_class [current_class_length] = '$';
+      strcpy (&current_class [current_class_length+1], p);
+      current_class_length += additional_length;
+    }
+  else
+    {
+      if (!name)
+	return;
+      current_class_length = strlen (name);
+      current_class = xmalloc (current_class_length+1);
+      strcpy (current_class, name);
+    }
 }
 
 static void
 pop_class_context ()
 {
-  while (--inner_qualifier_length > 0
-        && inner_qualifier [inner_qualifier_length-1] != '$')
+  /* Go back to the last `$' and cut. */
+  while (--current_class_length > 0
+        && current_class [current_class_length] != '$')
     ;
-  inner_qualifier = xrealloc (inner_qualifier, inner_qualifier_length+1);
-  if (inner_qualifier_length == -1)
-    inner_qualifier_length = 0;
-  inner_qualifier [inner_qualifier_length] = '\0';
+  if (current_class_length)
+    {
+      current_class = xrealloc (current_class, current_class_length+1);
+      current_class [current_class_length] = '\0';
+    }
+  else
+    {
+      current_class = NULL;
+      anonymous_count = 0;
+    }
 }
 
 /* Actions defined here */
-#define INNER_QUALIFIER (inner_qualifier ? inner_qualifier : "")
 
 static void
 report_class_declaration (name)
@@ -1158,6 +1194,7 @@
 {
   extern int flag_dump_class, flag_list_filename;
 
+  push_class_context (name);
   if (flag_dump_class)
     {
       if (!previous_output)
@@ -1168,13 +1205,10 @@
 	}
 	
       if (package_name)
-	fprintf (out, "%s.%s%s ", package_name, INNER_QUALIFIER, name);
+	fprintf (out, "%s.%s ", package_name, current_class);
       else
-	fprintf (out, "%s%s ", INNER_QUALIFIER, name);
+	fprintf (out, "%s ", current_class);
     }
-
-  push_class_context (name);
-  current_class = name;
 }
 
 static void
@@ -1208,7 +1242,8 @@
 void reset_report ()
 {
   previous_output = 0;
-  current_class = package_name = NULL;
+  package_name = NULL;
+  current_class = NULL;
 }
 
 void
--- gcc/java/parse.y	2000/09/10 04:41:32	1.1.1.1
+++ gcc/java/parse.y	2000/09/10 14:45:33
@@ -276,7 +276,7 @@
 static int binop_compound_p PARAMS ((enum tree_code));
 static tree search_loop PARAMS ((tree));
 static int labeled_block_contains_loop_p PARAMS ((tree, tree));
-static void check_abstract_method_definitions PARAMS ((int, tree, tree));
+static int check_abstract_method_definitions PARAMS ((int, tree, tree));
 static void java_check_abstract_method_definitions PARAMS ((tree));
 static void java_debug_context_do PARAMS ((int));
 static void java_parser_context_push_initialized_field PARAMS ((void));
@@ -755,8 +755,7 @@
 		{ end_class_declaration (0); }
 |	interface_declaration
 		{ end_class_declaration (0); }
-|	SC_TK
-		{ $$ = NULL; }
+|	empty_statement
 |	error
 		{
 		  YYERROR_NOW;
@@ -880,13 +879,12 @@
 
 class_member_declaration:
 	field_declaration
-|	field_declaration SC_TK
-		{ $$ = $1; }
 |	method_declaration
 |	class_declaration	/* Added, JDK1.1 inner classes */
 		{ end_class_declaration (1); }
 |	interface_declaration	/* Added, JDK1.1 inner interfaces */
 		{ end_class_declaration (1); }
+|	empty_statement
 ;
 
 /* 19.8.2 Productions from 8.3: Field Declarations  */
@@ -1085,9 +1083,7 @@
 
 method_body:
 	block
-|	block SC_TK
-|	SC_TK
-		{ $$ = NULL_TREE; } /* Probably not the right thing to do. */
+|	SC_TK { $$ = NULL_TREE; }
 ;
 
 /* 19.8.4 Productions from 8.5: Static Initializers  */
@@ -1097,11 +1093,6 @@
 		  TREE_CHAIN ($2) = CPC_STATIC_INITIALIZER_STMT (ctxp);
 		  SET_CPC_STATIC_INITIALIZER_STMT (ctxp, $2);
 		}
-|	static block SC_TK	/* Shouldn't be here. FIXME */
-		{
-		  TREE_CHAIN ($2) = CPC_STATIC_INITIALIZER_STMT (ctxp);
-		  SET_CPC_STATIC_INITIALIZER_STMT (ctxp, $2);
-		}
 ;
 
 static:				/* Test lval.sub_token here */
@@ -1166,7 +1157,7 @@
 
 constructor_block_end:
 	block_end
-|	block_end SC_TK
+;
 
 /* Error recovery for that rule moved down expression_statement: rule.  */
 explicit_constructor_invocation:
@@ -1397,7 +1388,14 @@
 
 empty_statement:
 	SC_TK
-		{ $$ = empty_stmt_node; }
+		{ 
+		  if (flag_extraneous_semicolon)
+		    {
+		      EXPR_WFL_SET_LINECOL (wfl_operator, lineno, -1);
+		      parse_warning_context (wfl_operator, "An empty declaration is a deprecated feature that should not be used");
+		    }
+		  $$ = empty_stmt_node;
+		}
 ;
 
 label_decl:
@@ -2767,7 +2765,7 @@
 }
 
 /* Pop the lists of initialized field. If this lists aren't empty,
-   remember them so we can use it to create and populate the $finit$
+   remember them so we can use it to create and populate the finit$
    or <clinit> functions. */
 
 static void
@@ -3861,7 +3859,7 @@
 }
 
 /* End a class declaration: register the statements used to create
-   $finit$ and <clinit>, pop the current class and resume the prior
+   finit$ and <clinit>, pop the current class and resume the prior
    parser context if necessary.  */
 
 static void
@@ -3919,9 +3917,9 @@
 	  wfl = build_wfl_node (get_identifier (name));
 	  init = build_wfl_node (get_identifier (pname));
 	  /* Build an initialization for the field: it will be
-	     initialized by a parameter added to $finit$, bearing a
+	     initialized by a parameter added to finit$, bearing a
 	     mangled name of the field itself (param$<n>.) The
-	     parameter is provided to $finit$ by the constructor
+	     parameter is provided to finit$ by the constructor
 	     invoking it (hence the constructor will also feature a
 	     hidden parameter, set to the value of the outer context
 	     local at the time the inner class is created.)
@@ -3930,7 +3928,7 @@
 	     be accessed by the inner class. It's actually not trivial
 	     to minimize these aliases down to the ones really
 	     used. One way to do that would be to expand all regular
-	     methods first, then $finit$ to get a picture of what's
+	     methods first, then finit$ to get a picture of what's
 	     used.  It works with the exception that we would have to
 	     go back on all constructor invoked in regular methods to
 	     have their invokation reworked (to include the right amount
@@ -3942,7 +3940,7 @@
 	     use.
 	     
 	     On the other hand, it only affect local inner classes,
-	     whose constructors (and $finit$ call) will be featuring
+	     whose constructors (and finit$ call) will be featuring
 	     unecessary arguments. It's easy for a developper to keep
 	     this number of parameter down by using the `final'
 	     keyword only when necessary. For the time being, we can
@@ -4148,7 +4146,7 @@
 
       /* If the couple initializer/initialized is marked ARG_FINAL_P, we
 	 mark the created field FIELD_LOCAL_ALIAS, so that we can 
-	 hide parameters to this inner class $finit$ and constructors. */
+	 hide parameters to this inner class finit$ and constructors. */
       if (ARG_FINAL_P (current))
 	FIELD_LOCAL_ALIAS (field_decl) = 1;
       
@@ -4189,8 +4187,8 @@
   lineno = saved_lineno;
 }
 
-/* Generate $finit$, using the list of initialized fields to populate
-   its body. $finit$'s parameter(s) list is adjusted to include the
+/* Generate finit$, using the list of initialized fields to populate
+   its body. finit$'s parameter(s) list is adjusted to include the
    one(s) used to initialized the field(s) caching outer context
    local(s). */
 
@@ -5003,7 +5001,7 @@
    count is kept of the number of crafted parameters. MODE governs
    what eventually gets created: something suitable for a function
    creation or a function invocation, either the constructor or
-   $finit$.  */
+   finit$.  */
 
 static tree
 build_alias_initializer_parameter_list (mode, class_type, parm, artificial)
@@ -5017,7 +5015,7 @@
   for (field = TYPE_FIELDS (class_type); field; field = TREE_CHAIN (field))
     if (FIELD_LOCAL_ALIAS (field))
       {
-	char *buffer = IDENTIFIER_POINTER (DECL_NAME (field));
+	const char *buffer = IDENTIFIER_POINTER (DECL_NAME (field));
 	tree purpose = NULL_TREE, value = NULL_TREE, name = NULL_TREE;
 
 	switch (mode)
@@ -5798,7 +5796,7 @@
   tree redef, name;
   tree cl = DECL_NAME (method);
   tree sig = TYPE_ARGUMENT_SIGNATURE (TREE_TYPE (method));
-  /* decl name of artificial <clinit> and $finit$ doesn't need to be
+  /* decl name of artificial <clinit> and finit$ doesn't need to be
      fixed and checked */
 
   /* Reset the method name before running the check. If it returns 1,
@@ -5825,13 +5823,15 @@
   return 0;
 }
 
-static void
+/* Return 1 if check went ok, 0 otherwise.  */
+static int
 check_abstract_method_definitions (do_interface, class_decl, type)
      int do_interface;
      tree class_decl, type;
 {
   tree class = TREE_TYPE (class_decl);
   tree method, end_type;
+  int ok = 1;
 
   end_type = (do_interface ? object_type_node : type);
   for (method = TYPE_METHODS (type); method; method = TREE_CHAIN (method))
@@ -5904,13 +5904,27 @@
 	     IDENTIFIER_POINTER (ccn),
 	     (CLASS_INTERFACE (class_decl) ? "interface" : "class"),
 	     IDENTIFIER_POINTER (DECL_NAME (class_decl)));
-	  
+	  ok = 0;
 	  free (t);
-	  
+
 	  if (saved_wfl)
 	    DECL_NAME (method) = saved_wfl;
 	}
     }
+
+  if (ok && do_interface)
+    {
+      /* Check for implemented interfaces. */
+      int i;
+      tree vector = TYPE_BINFO_BASETYPES (type);
+      for (i = 1; ok && vector && i < TREE_VEC_LENGTH (vector); i++)
+	{
+	  tree super = BINFO_TYPE (TREE_VEC_ELT (vector, i));
+	  ok = check_abstract_method_definitions (1, class_decl, super);
+	}
+    }
+
+  return ok;
 }
 
 /* Check that CLASS_DECL somehow implements all inherited abstract
@@ -7380,7 +7394,7 @@
    we expand regular methods first. This allows us get an estimate on
    how outer context local alias fields are really used so we can add
    to the constructor just enough code to initialize them properly (it
-   also lets us generate $finit$ correctly.) Then we expand the
+   also lets us generate finit$ correctly.) Then we expand the
    constructors and then <clinit>.  */
 
 static void
@@ -7401,7 +7415,7 @@
   first_decl = TYPE_METHODS (current_class);
   clinit = maybe_generate_pre_expand_clinit (current_class);
 
-  /* Then generate $finit$ (if we need to) because constructor will
+  /* Then generate finit$ (if we need to) because constructor will
    try to use it.*/
   if (TYPE_FINIT_STMT_LIST (current_class))
     {
@@ -7550,12 +7564,14 @@
   
   if (!DECL_CLINIT_P (mdecl))
     return 0;
-  
-  /* If the body isn't empty, then we keep <clinit> */
+
+  /* If the body isn't empty, then we keep <clinit>. Note that if
+     we're emitting classfiles, this isn't enough not to rule it
+     out. */
   fbody = DECL_FUNCTION_BODY (mdecl);
   if ((bbody = BLOCK_EXPR_BODY (fbody)))
     bbody = BLOCK_EXPR_BODY (bbody);
-  if (bbody && bbody != empty_stmt_node)
+  if (bbody && ! flag_emit_class_files && bbody != empty_stmt_node)
     return 0;
   
   type = DECL_CONTEXT (mdecl);
@@ -7563,10 +7579,35 @@
 
   for (current = (current ? TREE_CHAIN (current) : current); 
        current; current = TREE_CHAIN (current))
-    if (!(FIELD_STATIC (current) && FIELD_FINAL (current)
-	  && DECL_INITIAL (current) && TREE_CONSTANT (DECL_INITIAL (current))))
-      break;
+    {
+      tree f_init;
+
+      /* We're not interested in non static field */
+      if (!FIELD_STATIC (current))
+	continue;
 
+      /* Anything that isn't String or a basic type is ruled out -- or
+	 if we now how to deal with it (when doing things natively) we
+	 should generated an empty <clinit> so that SUID are computed
+	 correctly. */
+      if (! JSTRING_TYPE_P (TREE_TYPE (current))
+	  && ! JNUMERIC_TYPE_P (TREE_TYPE (current)))
+	break;
+	  
+      f_init = DECL_INITIAL (current);
+      /* If we're emitting native code, we want static final fields to
+	 have constant initializers. If we don't meet these
+	 conditions, we keep <clinit> */
+      if (!flag_emit_class_files
+	  && !(FIELD_FINAL (current) && f_init && TREE_CONSTANT (f_init)))
+	break;
+      /* If we're emitting bytecode, we want static fields to have
+	 constant initializers or no initializer. If we don't meet
+	 these conditions, we keep <clinit> */
+      if (flag_emit_class_files && f_init && !TREE_CONSTANT (f_init))
+	break;
+    }
+
   if (current)
     return 0;
 
@@ -7688,7 +7729,7 @@
   tree ctx = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current_class)));
 
   /* If decl's class is the direct outer class of the current_class,
-     build the access as `this$<n>.<field>'. Not that we will break
+     build the access as `this$<n>.<field>'. Note that we will break
      the `private' barrier if we're not emitting bytecodes. */
   if (ctx == DECL_CONTEXT (decl) 
       && (!FIELD_PRIVATE (decl) || !flag_emit_class_files ))
@@ -7704,7 +7745,7 @@
       int lc = EXPR_WFL_LINECOL (id);
 
       /* Now we chain the required number of calls to the access$0 to
-	 get a hold to the enclosing instance we need, and the we
+	 get a hold to the enclosing instance we need, and then we
 	 build the field access. */
       access = build_access_to_thisn (ctx, DECL_CONTEXT (decl), lc);
 
@@ -8296,14 +8337,21 @@
 }
 
 static tree
-build_dot_class_method_invocation (name)
-     tree name;
+build_dot_class_method_invocation (type)
+     tree type;
 {
-  tree s = make_node (STRING_CST);
-  TREE_STRING_LENGTH (s) = IDENTIFIER_LENGTH (name);
+  tree sig_id, s;
+
+  if (TYPE_ARRAY_P (type))
+    sig_id = build_java_signature (type);
+  else
+    sig_id = DECL_NAME (TYPE_NAME (type));
+
+  s = make_node (STRING_CST);
+  TREE_STRING_LENGTH (s) = IDENTIFIER_LENGTH (sig_id);
   TREE_STRING_POINTER (s) = obstack_alloc (expression_obstack,
 					   TREE_STRING_LENGTH (s)+1);
-  strcpy (TREE_STRING_POINTER (s), IDENTIFIER_POINTER (name));
+  strcpy (TREE_STRING_POINTER (s), IDENTIFIER_POINTER (sig_id));
   return build_method_invocation (build_wfl_node (get_identifier ("class$")),
 				  build_tree_list (NULL_TREE, s));
 }
@@ -8345,6 +8393,11 @@
 	 CLASSNAME() constructor */
       start_artificial_method_body (mdecl);
       
+      /* Insert an assignment to the this$<n> hidden field, if
+         necessary */
+      if ((thisn_assign = build_thisn_assign ()))
+	java_method_add_stmt (mdecl, thisn_assign);
+
       /* We don't generate a super constructor invocation if we're
 	 compiling java.lang.Object. build_super_invocation takes care
 	 of that. */
@@ -8354,11 +8407,6 @@
          super invocation. */
       add_instance_initializer (mdecl);
 
-      /* Insert an assignment to the this$<n> hidden field, if
-         necessary */
-      if ((thisn_assign = build_thisn_assign ()))
-	java_method_add_stmt (mdecl, thisn_assign);
-
       end_artificial_method_body (mdecl);
     }
   /* Search for an explicit constructor invocation */
@@ -8390,14 +8438,14 @@
 	compound = add_stmt_to_compound (compound, NULL_TREE,
                                          build_super_invocation (mdecl));
       
-      /* Insert the instance initializer block right here, after the
-         super invocation. */
-      add_instance_initializer (mdecl);
-
       /* Generate the assignment to this$<n>, if necessary */
       if ((thisn_assign = build_thisn_assign ()))
         compound = add_stmt_to_compound (compound, NULL_TREE, thisn_assign);
 
+      /* Insert the instance initializer block right here, after the
+         super invocation. */
+      add_instance_initializer (mdecl);
+
       /* Fix the constructor main block if we're adding extra stmts */
       if (compound)
 	{
@@ -9199,6 +9247,8 @@
 					  current_class);
 			  return 1;
 			}
+                      if (outer_field_access_p (current_class, decl))
+                        decl = build_outer_field_access (qual_wfl, decl);
 		    }
 		  else
 		    {
@@ -9835,7 +9885,7 @@
     {
       tree finit_parms, finit_call;
       
-      /* Prepare to pass hidden parameters to $finit$, if any. */
+      /* Prepare to pass hidden parameters to finit$, if any. */
       finit_parms = build_alias_initializer_parameter_list 
 	(AIPL_FUNCTION_FINIT_INVOCATION, current_class, NULL_TREE, NULL);
 
@@ -10697,12 +10747,14 @@
 breakdown_qualified (left, right, source)
     tree *left, *right, source;
 {
-  char *p = IDENTIFIER_POINTER (source), *base;
+  char *p, *base;
   int   l = IDENTIFIER_LENGTH (source);
 
+  base = alloca (l + 1);
+  memcpy (base, IDENTIFIER_POINTER (source), l + 1);
+
   /* Breakdown NAME into REMAINDER . IDENTIFIER */
-  base = p;
-  p += (l-1);
+  p = base + l - 1;
   while (*p != '.' && p != base)
     p--;
 
@@ -10713,8 +10765,7 @@
   *p = '\0';
   if (right)
     *right = get_identifier (p+1);
-  *left = get_identifier (IDENTIFIER_POINTER (source));
-  *p = '.';
+  *left = get_identifier (base);
   
   return 0;
 }
@@ -12124,7 +12175,7 @@
 }
 
 /* Return 1 if RHS_TYPE can be converted to LHS_TYPE by identity
-   conversion (5.1.1) or widening primitve conversion (5.1.2).  Return
+   conversion (5.1.1) or widening primitive conversion (5.1.2).  Return
    0 is the conversion test fails.  This implements parts the method
    invocation convertion (5.3).  */
 
@@ -12842,20 +12893,26 @@
      const char *string;
      int string_len, after;
 {
-  int len = TREE_STRING_LENGTH (cste) + string_len;
   const char *old = TREE_STRING_POINTER (cste);
+  int old_len = TREE_STRING_LENGTH (cste);
+  int len = old_len + string_len;
+  char *new;
+  
+  cste = make_node (STRING_CST);
   TREE_STRING_LENGTH (cste) = len;
-  TREE_STRING_POINTER (cste) = obstack_alloc (expression_obstack, len+1);
+  new = TREE_STRING_POINTER (cste) = obstack_alloc (expression_obstack, len+1);
+
   if (after)
     {
-      strcpy (TREE_STRING_POINTER (cste), string);
-      strcat (TREE_STRING_POINTER (cste), old);
+      memcpy (new, string, string_len);
+      memcpy (&new [string_len], old, old_len);
     }
   else
     {
-      strcpy (TREE_STRING_POINTER (cste), old);
-      strcat (TREE_STRING_POINTER (cste), string);
+      memcpy (new, old, old_len);
+      memcpy (&new [old_len], string, string_len);
     }
+  new [len] = '\0';
   return cste;
 }
 
@@ -13158,8 +13215,7 @@
      synthetic static method `class$'. */
   if (!TYPE_DOT_CLASS (current_class))
       build_dot_class_method (current_class);
-  ref_type = 
-    build_dot_class_method_invocation (DECL_NAME (TYPE_NAME (ref_type)));
+  ref_type = build_dot_class_method_invocation (ref_type);
   return java_complete_tree (ref_type);
 }
 
@@ -14378,7 +14434,7 @@
   se_type = TREE_TYPE (se);
   /* The type of the switch expression must be char, byte, short or
      int */
-  if (!JINTEGRAL_TYPE_P (se_type))
+  if (! JINTEGRAL_TYPE_P (se_type) || se_type == long_type_node)
     {
       EXPR_WFL_LINECOL (wfl_operator) = EXPR_WFL_LINECOL (node);
       parse_error_context (wfl_operator,
--- gcc/java/typeck.c	2000/09/10 04:41:32	1.1.1.1
+++ gcc/java/typeck.c	2000/09/10 13:56:44
@@ -417,13 +417,34 @@
     {
       tree atype = build_prim_array_type (element_type, length);
       tree arfld = build_decl (FIELD_DECL, get_identifier ("data"), atype);
+      
       DECL_CONTEXT (arfld) = t;
       TREE_CHAIN (fld) = arfld;
+
+      /* We need to force the data field to begin at an alignment at
+       least equal to the biggest alignment in an object type node
+       in order to be compatible with the way that JArray is defined
+       in CNI.  However, we can't exceed BIGGEST_FIELD_ALIGNMENT. */
+      {
+      unsigned desired_align = TYPE_ALIGN (object_type_node);
+      desired_align = MAX (desired_align, TYPE_ALIGN (element_type));
+#ifdef BIGGEST_FIELD_ALIGNMENT
+      desired_align = MIN (desired_align, 
+                           (unsigned) BIGGEST_FIELD_ALIGNMENT);
+#endif
+#ifdef ADJUST_FIELD_ALIGN
+      desired_align = ADJUST_FIELD_ALIGN (fld, desired_align);
+#endif
+      DECL_ALIGN (arfld) = desired_align;
+      }
     }
   else
     {
-      TYPE_ALIGN (t) = TYPE_ALIGN (element_type);
-      TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (element_type);
+      unsigned desired_align = TYPE_ALIGN (element_type);
+#ifdef BIGGEST_FIELD_ALIGNMENT
+      desired_align = MIN (desired_align, (unsigned) BIGGEST_FIELD_ALIGNMENT);
+#endif
+      TYPE_ALIGN (t) = desired_align;
     }
   pop_obstacks ();
 
--- gcc/java/verify.c	2000/09/10 04:41:33	1.1.1.1
+++ gcc/java/verify.c	2000/09/10 13:56:44
@@ -131,6 +131,20 @@
       tt1 = HANDLE_TO_CLASS_TYPE (TREE_TYPE (type1));
       tt2 = HANDLE_TO_CLASS_TYPE (TREE_TYPE (type2));
 
+      /* If tt{1,2} haven't been properly loaded, now is a good time
+         to do it. */
+      if (!TYPE_SIZE (tt1))
+	{
+	  load_class (tt1, 1);
+	  safe_layout_class (tt1);
+	}
+
+      if (!TYPE_SIZE (tt2))
+	{
+	  load_class (tt2, 1);
+	  safe_layout_class (tt2);
+	}
+
       if (TYPE_ARRAY_P (tt1) || TYPE_ARRAY_P (tt2))
 	{
 	  if (TYPE_ARRAY_P (tt1) == TYPE_ARRAY_P (tt2))
--- gcc/java/zextract.c	2000/09/10 04:41:33	1.1.1.1
+++ gcc/java/zextract.c	2000/09/10 13:56:44
@@ -318,6 +318,8 @@
   for (i = 0; i < zipf->count; i++)
     {
       ZipDirectory *zipd = (ZipDirectory*)(dir_ptr + dir_last_pad);
+      int compression_method = (int) dir_ptr[4+C_COMPRESSION_METHOD];
+      long size = makelong (&dir_ptr[4+C_COMPRESSED_SIZE]);
       long uncompressed_size = makelong (&dir_ptr[4+C_UNCOMPRESSED_SIZE]);
       long filename_length = makeword (&dir_ptr[4+C_FILENAME_LENGTH]);
       long extra_field_length = makeword (&dir_ptr[4+C_EXTRA_FIELD_LENGTH]);
@@ -326,7 +328,9 @@
 	return -1;
 
       zipd->filename_length = filename_length;
-      zipd->size = uncompressed_size;
+      zipd->compression_method = compression_method;
+      zipd->size = size;
+      zipd->uncompressed_size = uncompressed_size;
 #ifdef __GNUC__
 #define DIR_ALIGN __alignof__(ZipDirectory)
 #else
--- gcc/java/zipfile.h	2000/09/10 04:41:33	1.1.1.1
+++ gcc/java/zipfile.h	2000/09/10 13:56:44
@@ -34,7 +34,9 @@
 struct ZipDirectory {
   int direntry_size;
   int filename_offset;
+  int compression_method;
   long size; /* length of file */
+  long uncompressed_size; /* length of uncompressed data */
   long filestart;  /* start of file in archive */
   long filename_length;
   /* char mid_padding[...]; */
