Only tested the q3 example but this patch stopped it from segfaulting ;).

--- source/Irrlicht/CSceneManager.h
+++ source/Irrlicht/CSceneManager.h
@@ -321,13 +321,13 @@
 				textureValue = 0;
 
 				if (n->getMaterialCount())
-					textureValue = (s32)(n->getMaterial(0).Texture1);
+					textureValue = (unsigned long)(n->getMaterial(0).Texture1);
 
 				node = n;
 			}
 
 			ISceneNode* node;
-			s32 textureValue;
+			unsigned long textureValue;
 
 			bool operator < (const DefaultNodeEntry& other) const
 			{
--- source/Irrlicht/CQ3LevelMesh.cpp
+++ source/Irrlicht/CQ3LevelMesh.cpp
@@ -352,15 +352,15 @@
 }
 
 // helper method for creating curved surfaces, sent in by Dean P. Macri.
-inline f32 CQ3LevelMesh::Blend( f32 s[3], f32 t[3], tBSPVertex *v[9], int offset)
+inline f32 CQ3LevelMesh::Blend( f32 s[3], f32 t[3], tBSPVertex *v[9], unsigned long offset)
 {
 	f32 res = 0.0f;
-	f32 *ptr;
+	unsigned long *ptr;
 
 	for( int i=0; i<3; i++ )
 		for( int j=0; j<3; j++ )
 		{
-			ptr = (f32 *)( (int)v[i*3+j] + offset );
+			ptr = (unsigned long *)( (unsigned long)v[i*3+j] + offset );
 			res += s[i] * t[j] *  (*ptr);
 		}
 	return res;
@@ -429,52 +429,52 @@
 
 					// Vert 1
 					currentVertex[0].Color.set(255,255,255,255);
-					currentVertex[0].Pos.X = Blend( cs, ct, v, (int)&v[0]->vPosition[0] - (int)v[0]);
-					currentVertex[0].Pos.Y = Blend( cs, ct, v, (int)&v[0]->vPosition[2] - (int)v[0]);
-					currentVertex[0].Pos.Z = Blend( cs, ct, v, (int)&v[0]->vPosition[1] - (int)v[0]);
-					currentVertex[0].Normal.X = Blend( cs, ct, v, (int)&v[0]->vNormal[0] - (int)v[0]);
-					currentVertex[0].Normal.Y = Blend( cs, ct, v, (int)&v[0]->vNormal[2] - (int)v[0]);
-					currentVertex[0].Normal.Z = Blend( cs, ct, v, (int)&v[0]->vNormal[1] - (int)v[0]);
-					currentVertex[0].TCoords.X = Blend( cs, ct, v, (int)&v[0]->vTextureCoord[0] - (int)v[0]);
-					currentVertex[0].TCoords.Y = Blend( cs, ct, v, (int)&v[0]->vTextureCoord[1] - (int)v[0]);
-					currentVertex[0].TCoords2.X = Blend( cs, ct, v, (int)&v[0]->vLightmapCoord[0] - (int)v[0]);
-					currentVertex[0].TCoords2.Y = Blend( cs, ct, v, (int)&v[0]->vLightmapCoord[1] - (int)v[0]);
+					currentVertex[0].Pos.X = Blend( cs, ct, v, (unsigned long)&v[0]->vPosition[0] - (unsigned long)v[0]);
+					currentVertex[0].Pos.Y = Blend( cs, ct, v, (unsigned long)&v[0]->vPosition[2] - (unsigned long)v[0]);
+					currentVertex[0].Pos.Z = Blend( cs, ct, v, (unsigned long)&v[0]->vPosition[1] - (unsigned long)v[0]);
+					currentVertex[0].Normal.X = Blend( cs, ct, v, (unsigned long)&v[0]->vNormal[0] - (unsigned long)v[0]);
+					currentVertex[0].Normal.Y = Blend( cs, ct, v, (unsigned long)&v[0]->vNormal[2] - (unsigned long)v[0]);
+					currentVertex[0].Normal.Z = Blend( cs, ct, v, (unsigned long)&v[0]->vNormal[1] - (unsigned long)v[0]);
+					currentVertex[0].TCoords.X = Blend( cs, ct, v, (unsigned long)&v[0]->vTextureCoord[0] - (unsigned long)v[0]);
+					currentVertex[0].TCoords.Y = Blend( cs, ct, v, (unsigned long)&v[0]->vTextureCoord[1] - (unsigned long)v[0]);
+					currentVertex[0].TCoords2.X = Blend( cs, ct, v, (unsigned long)&v[0]->vLightmapCoord[0] - (unsigned long)v[0]);
+					currentVertex[0].TCoords2.Y = Blend( cs, ct, v, (unsigned long)&v[0]->vLightmapCoord[1] - (unsigned long)v[0]);
 					// Vert 2
 					currentVertex[1].Color.set(255,255,255,255);
-					currentVertex[1].Pos.X = Blend( cs, nxt, v, (int)&v[0]->vPosition[0] - (int)v[0]);
-					currentVertex[1].Pos.Y = Blend( cs, nxt, v, (int)&v[0]->vPosition[2] - (int)v[0]);
-					currentVertex[1].Pos.Z = Blend( cs, nxt, v, (int)&v[0]->vPosition[1] - (int)v[0]);
-					currentVertex[1].Normal.X = Blend( cs, nxt, v, (int)&v[0]->vNormal[0] - (int)v[0]);
-					currentVertex[1].Normal.Y = Blend( cs, nxt, v, (int)&v[0]->vNormal[2] - (int)v[0]);
-					currentVertex[1].Normal.Z = Blend( cs, nxt, v, (int)&v[0]->vNormal[1] - (int)v[0]);
-					currentVertex[1].TCoords.X = Blend( cs, nxt, v, (int)&v[0]->vTextureCoord[0] - (int)v[0]);
-					currentVertex[1].TCoords.Y = Blend( cs, nxt, v, (int)&v[0]->vTextureCoord[1] - (int)v[0]);
-					currentVertex[1].TCoords2.X = Blend( cs, nxt, v, (int)&v[0]->vLightmapCoord[0] - (int)v[0]);
-					currentVertex[1].TCoords2.Y = Blend( cs, nxt, v, (int)&v[0]->vLightmapCoord[1] - (int)v[0]);
+					currentVertex[1].Pos.X = Blend( cs, nxt, v, (unsigned long)&v[0]->vPosition[0] - (unsigned long)v[0]);
+					currentVertex[1].Pos.Y = Blend( cs, nxt, v, (unsigned long)&v[0]->vPosition[2] - (unsigned long)v[0]);
+					currentVertex[1].Pos.Z = Blend( cs, nxt, v, (unsigned long)&v[0]->vPosition[1] - (unsigned long)v[0]);
+					currentVertex[1].Normal.X = Blend( cs, nxt, v, (unsigned long)&v[0]->vNormal[0] - (unsigned long)v[0]);
+					currentVertex[1].Normal.Y = Blend( cs, nxt, v, (unsigned long)&v[0]->vNormal[2] - (unsigned long)v[0]);
+					currentVertex[1].Normal.Z = Blend( cs, nxt, v, (unsigned long)&v[0]->vNormal[1] - (unsigned long)v[0]);
+					currentVertex[1].TCoords.X = Blend( cs, nxt, v, (unsigned long)&v[0]->vTextureCoord[0] - (unsigned long)v[0]);
+					currentVertex[1].TCoords.Y = Blend( cs, nxt, v, (unsigned long)&v[0]->vTextureCoord[1] - (unsigned long)v[0]);
+					currentVertex[1].TCoords2.X = Blend( cs, nxt, v, (unsigned long)&v[0]->vLightmapCoord[0] - (unsigned long)v[0]);
+					currentVertex[1].TCoords2.Y = Blend( cs, nxt, v, (unsigned long)&v[0]->vLightmapCoord[1] - (unsigned long)v[0]);
 					// Vert 3
 					currentVertex[2].Color.set(255,255,255,255);
-					currentVertex[2].Pos.X = Blend( nxs, ct, v, (int)&v[0]->vPosition[0] - (int)v[0]);
-					currentVertex[2].Pos.Y = Blend( nxs, ct, v, (int)&v[0]->vPosition[2] - (int)v[0]);
-					currentVertex[2].Pos.Z = Blend( nxs, ct, v, (int)&v[0]->vPosition[1] - (int)v[0]);
-					currentVertex[2].Normal.X = Blend( nxs, ct, v, (int)&v[0]->vNormal[0] - (int)v[0]);
-					currentVertex[2].Normal.Y = Blend( nxs, ct, v, (int)&v[0]->vNormal[2] - (int)v[0]);
-					currentVertex[2].Normal.Z = Blend( nxs, ct, v, (int)&v[0]->vNormal[1] - (int)v[0]);
-					currentVertex[2].TCoords.X = Blend( nxs, ct, v, (int)&v[0]->vTextureCoord[0] - (int)v[0]);
-					currentVertex[2].TCoords.Y = Blend( nxs, ct, v, (int)&v[0]->vTextureCoord[1] - (int)v[0]);
-					currentVertex[2].TCoords2.X = Blend( nxs, ct, v, (int)&v[0]->vLightmapCoord[0] - (int)v[0]);
-					currentVertex[2].TCoords2.Y = Blend( nxs, ct, v, (int)&v[0]->vLightmapCoord[1] - (int)v[0]);
+					currentVertex[2].Pos.X = Blend( nxs, ct, v, (unsigned long)&v[0]->vPosition[0] - (unsigned long)v[0]);
+					currentVertex[2].Pos.Y = Blend( nxs, ct, v, (unsigned long)&v[0]->vPosition[2] - (unsigned long)v[0]);
+					currentVertex[2].Pos.Z = Blend( nxs, ct, v, (unsigned long)&v[0]->vPosition[1] - (unsigned long)v[0]);
+					currentVertex[2].Normal.X = Blend( nxs, ct, v, (unsigned long)&v[0]->vNormal[0] - (unsigned long)v[0]);
+					currentVertex[2].Normal.Y = Blend( nxs, ct, v, (unsigned long)&v[0]->vNormal[2] - (unsigned long)v[0]);
+					currentVertex[2].Normal.Z = Blend( nxs, ct, v, (unsigned long)&v[0]->vNormal[1] - (unsigned long)v[0]);
+					currentVertex[2].TCoords.X = Blend( nxs, ct, v, (unsigned long)&v[0]->vTextureCoord[0] - (unsigned long)v[0]);
+					currentVertex[2].TCoords.Y = Blend( nxs, ct, v, (unsigned long)&v[0]->vTextureCoord[1] - (unsigned long)v[0]);
+					currentVertex[2].TCoords2.X = Blend( nxs, ct, v, (unsigned long)&v[0]->vLightmapCoord[0] - (unsigned long)v[0]);
+					currentVertex[2].TCoords2.Y = Blend( nxs, ct, v, (unsigned long)&v[0]->vLightmapCoord[1] - (unsigned long)v[0]);
 					// Vert 4
 					currentVertex[3].Color.set(255,255,255,255);
-					currentVertex[3].Pos.X = Blend( nxs, nxt, v, (int)&v[0]->vPosition[0] - (int)v[0]);
-					currentVertex[3].Pos.Y = Blend( nxs, nxt, v, (int)&v[0]->vPosition[2] - (int)v[0]);
-					currentVertex[3].Pos.Z = Blend( nxs, nxt, v, (int)&v[0]->vPosition[1] - (int)v[0]);
-					currentVertex[3].Normal.X = Blend( nxs, nxt, v, (int)&v[0]->vNormal[0] - (int)v[0]);
-					currentVertex[3].Normal.Y = Blend( nxs, nxt, v, (int)&v[0]->vNormal[2] - (int)v[0]);
-					currentVertex[3].Normal.Z = Blend( nxs, nxt, v, (int)&v[0]->vNormal[1] - (int)v[0]);
-					currentVertex[3].TCoords.X = Blend( nxs, nxt, v, (int)&v[0]->vTextureCoord[0] - (int)v[0]);
-					currentVertex[3].TCoords.Y = Blend( nxs, nxt, v, (int)&v[0]->vTextureCoord[1] - (int)v[0]);
-					currentVertex[3].TCoords2.X = Blend( nxs, nxt, v, (int)&v[0]->vLightmapCoord[0] - (int)v[0]);
-					currentVertex[3].TCoords2.Y = Blend( nxs, nxt, v, (int)&v[0]->vLightmapCoord[1] - (int)v[0]);
+					currentVertex[3].Pos.X = Blend( nxs, nxt, v, (unsigned long)&v[0]->vPosition[0] - (unsigned long)v[0]);
+					currentVertex[3].Pos.Y = Blend( nxs, nxt, v, (unsigned long)&v[0]->vPosition[2] - (unsigned long)v[0]);
+					currentVertex[3].Pos.Z = Blend( nxs, nxt, v, (unsigned long)&v[0]->vPosition[1] - (unsigned long)v[0]);
+					currentVertex[3].Normal.X = Blend( nxs, nxt, v, (unsigned long)&v[0]->vNormal[0] - (unsigned long)v[0]);
+					currentVertex[3].Normal.Y = Blend( nxs, nxt, v, (unsigned long)&v[0]->vNormal[2] - (unsigned long)v[0]);
+					currentVertex[3].Normal.Z = Blend( nxs, nxt, v, (unsigned long)&v[0]->vNormal[1] - (unsigned long)v[0]);
+					currentVertex[3].TCoords.X = Blend( nxs, nxt, v, (unsigned long)&v[0]->vTextureCoord[0] - (unsigned long)v[0]);
+					currentVertex[3].TCoords.Y = Blend( nxs, nxt, v, (unsigned long)&v[0]->vTextureCoord[1] - (unsigned long)v[0]);
+					currentVertex[3].TCoords2.X = Blend( nxs, nxt, v, (unsigned long)&v[0]->vLightmapCoord[0] - (unsigned long)v[0]);
+					currentVertex[3].TCoords2.Y = Blend( nxs, nxt, v, (unsigned long)&v[0]->vLightmapCoord[1] - (unsigned long)v[0]);
 					// Put the vertices in the mesh buffer
 					meshBuffer->Vertices.push_back(currentVertex[0]);
 					meshBuffer->Vertices.push_back(currentVertex[2]);
--- source/Irrlicht/CQ3LevelMesh.h
+++ source/Irrlicht/CQ3LevelMesh.h
@@ -214,7 +214,7 @@
 
 		// second parameter i is the zero based index of the current face.
 		void createCurvedSurface(SMeshBufferLightMap* meshBuffer, s32 i);
-		f32 Blend( f32 s[3], f32 t[3], tBSPVertex *v[9], int offset);
+		f32 Blend( f32 s[3], f32 t[3], tBSPVertex *v[9], unsigned long offset);
 
 		tBSPLump Lumps[kMaxLumps];
 
