diff -Nur irrlicht-0.6/include/matrix4.h irrlicht-0.6_new/include/matrix4.h
--- irrlicht-0.6/include/matrix4.h	2004-08-17 23:18:27.372459013 +0200
+++ irrlicht-0.6_new/include/matrix4.h	2004-08-17 23:21:56.520925016 +0200
@@ -186,7 +186,7 @@
 		newMatrix[8] = m1[0]*m2[8] + m1[4]*m2[9] + m1[8]*m2[10] + m1[12]*m2[11];
 		newMatrix[9] = m1[1]*m2[8] + m1[5]*m2[9] + m1[9]*m2[10] + m1[13]*m2[11];
 		newMatrix[10] = m1[2]*m2[8] + m1[6]*m2[9] + m1[10]*m2[10] + m1[14]*m2[11];
-		newMatrix[11] = m1[3]*m2[8] + m1[7]*m2[10] + m1[11]*m2[10] + m1[15]*m2[11];
+		newMatrix[11] = m1[3]*m2[8] + m1[7]*m2[9] + m1[11]*m2[10] + m1[15]*m2[11];
 		
 		newMatrix[12] = m1[0]*m2[12] + m1[4]*m2[13] + m1[8]*m2[14] + m1[12]*m2[15];
 		newMatrix[13] = m1[1]*m2[12] + m1[5]*m2[13] + m1[9]*m2[14] + m1[13]*m2[15];
@@ -308,7 +308,7 @@
 
 		f32 rotx, roty, X, Z;
  
-		if (fabs(Y)>0.0005f) 
+		if (fabs(C)>0.0005f) 
 		{ 
 			rotx = mat(2,2) / C; 
 			roty = mat(2,1)  / C; 
@@ -320,16 +320,16 @@
 		else 
 		{
 			X  = 0.0f; 
-			rotx = -mat(1,1); 
-			roty = mat(1,0); 
+			rotx = mat(1,1); 
+			roty = -mat(0,1); 
 			Z  = atan2f( roty, rotx ) * (f32)GRAD_PI; 
 		} 
  
-		if (fabs(X)>=360.00f) X=0.00f; 
-		if (fabs(Y)>=360.00f) Y=0.00f; 
-		if (fabs(Z)>=360.00f) Z=0.00f; 
+		if (X<0.00f) X+=360.00f; 
+		if (Y<0.00f) Y+=360.00f; 
+		if (Z<0.00f) Z+=360.00f; 
  
-		return vector3df(X,Y,Z); 
+		return vector3df((f32)X,(f32)Y,(f32)Z); 
 	}
 
 	inline void matrix4::setInverseRotationRadians( const vector3df& rotation )
