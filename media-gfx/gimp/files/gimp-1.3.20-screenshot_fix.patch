--- plug-ins/common/screenshot.c.org	2003-09-26 23:35:11.000000000 +0200
+++ plug-ins/common/screenshot.c	2003-09-26 23:35:13.000000000 +0200
@@ -1,10 +1,13 @@
-/*
+/*  
  *  ScreenShot plug-in
  *  Copyright 1998-2000 Sven Neumann <sven@gimp.org>
- *  Copyright 2003      Henrik Brix Andersen <brix@gimp.org>
  *
  *  Any suggestions, bug-reports or patches are very welcome.
- *
+ * 
+ *  This plug-in uses the X-utility xwd to grab an image from the screen
+ *  and the xwd-plug-in created by Peter Kirchgessner (pkirchg@aol.com)
+ *  to load this image into the gimp.
+ *  Hence its nothing but a simple frontend to those utilities.
  */
 
 /* The GIMP -- an image manipulation program
@@ -27,59 +30,56 @@
 
 #include "config.h"
 
+#include <stdio.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#ifdef __EMX__
+#include <process.h>
+#endif
+
 #include <gtk/gtk.h>
 
 #include <libgimp/gimp.h>
 #include <libgimp/gimpui.h>
 
-#if defined(GDK_WINDOWING_X11)
-#include <gdk/gdkx.h>
-#elif defined(GDK_WINDOWING_WIN32)
-#include <windows.h>
-#endif
-
 #include "libgimp/stdplugins-intl.h"
 
 
 /* Defines */
 #define PLUG_IN_NAME "plug_in_screenshot"
 
-#ifdef __GNUC__
-#ifdef GDK_NATIVE_WINDOW_POINTER
-#if GLIB_SIZEOF_VOID_P != 4
-#warning window_id does not fit in PDB_INT32
-#endif
-#endif
+#ifndef XWD
+#define XWD "xwd"
 #endif
 
 typedef struct
 {
-  gboolean         root;
-  guint            window_id;
-  guint            delay;
+  gboolean   root;
+  gchar     *window_id;
+  guint      delay;
+  gboolean   decor;
 } ScreenShotValues;
 
-static ScreenShotValues shootvals =
-{
+static ScreenShotValues shootvals = 
+{ 
   FALSE,     /* root window */
-  0,         /* window ID   */
-  0,         /* delay       */
+  NULL,      /* window ID */
+  0,         /* delay */
+  TRUE,      /* decorations */
 };
 
 
 static void      query (void);
 static void      run   (const gchar      *name,
 			gint              nparams,
-			const GimpParam  *param,
+			const GimpParam  *param, 
 			gint             *nreturn_vals,
 			GimpParam       **return_vals);
 
-static GdkNativeWindow select_window  (const GdkScreen *screen);
-static gint32          create_image   (const GdkPixbuf *pixbuf);
-
 static void      shoot                (void);
 static gboolean  shoot_dialog         (void);
-static void      shoot_ok_callback    (GtkWidget *widget,
+static void      shoot_ok_callback    (GtkWidget *widget, 
 				       gpointer   data);
 static void      shoot_delay          (gint32     delay);
 static gboolean  shoot_delay_callback (gpointer   data);
@@ -95,15 +95,10 @@
 };
 
 /* the image that will be returned */
-gint32     image_ID = -1;
+gint32    image_ID = -1;
 
-gboolean   run_flag = FALSE;
+gboolean  run_flag = FALSE;
 
-/* the screen on which we are running */
-GdkScreen *cur_screen = NULL;
-
-/* the window the user selected */
-GdkNativeWindow selected_native;
 
 /* Functions */
 
@@ -114,9 +109,9 @@
 {
   static GimpParamDef args[] =
   {
-    { GIMP_PDB_INT32, "run_mode",  "Interactive, non-interactive" },
-    { GIMP_PDB_INT32, "root",      "Root window { TRUE, FALSE }" },
-    { GIMP_PDB_INT32, "window_id", "Window id" }
+    { GIMP_PDB_INT32,  "run_mode",  "Interactive, non-interactive" },
+    { GIMP_PDB_INT32,  "root",      "Root window { TRUE, FALSE }" },
+    { GIMP_PDB_STRING, "window_id", "Window id" }
   };
 
   static GimpParamDef return_vals[] =
@@ -126,14 +121,17 @@
 
   gimp_install_procedure (PLUG_IN_NAME,
 			  "Creates a screenshot of a single window or the whole screen",
-                          "After specifying some options the user selects a window and "
-                          "a time out is started. At the end of the time out the window "
-                          "is grabbed and the image is loaded into The GIMP. Alternatively "
-                          "the whole screen can be grabbed. When called non-interactively "
-                          "it may grab the root window or use the window-id passed as a parameter.",
-			  "Sven Neumann <sven@gimp.org>, Henrik Brix Andersen <brix@gimp.org>",
-			  "1998 - 2003",
-			  "v0.9.6 (2003/08/28)",
+			  "This extension serves as a simple frontend to the "
+			  "X-window utility xwd and the xwd-file-plug-in. "
+			  "After specifying some options, xwd is called, the "
+			  "user selects a window, and the resulting image is "
+			  "loaded into the gimp. Alternatively the whole "
+			  "screen can be grabbed. When called non-interactively "
+			  "it may grab the root window or use the window-id "
+			  "passed as a parameter.",
+			  "Sven Neumann <sven@gimp.org>",
+			  "1998 - 2000",
+			  "v0.9.5 (2000/10/29)",
 			  N_("<Toolbox>/File/Acquire/_Screen Shot..."),
 			  NULL,
 			  GIMP_PLUGIN,
@@ -142,7 +140,7 @@
 			  args, return_vals);
 }
 
-static void
+static void 
 run (const gchar      *name,
      gint             nparams,
      const GimpParam  *param,
@@ -150,17 +148,17 @@
      GimpParam       **return_vals)
 {
   /* Get the runmode from the in-parameters */
-  GimpRunMode run_mode = param[0].data.d_int32;
+  GimpRunMode run_mode = param[0].data.d_int32;	
 
-  /* status variable, use it to check for errors in invocation usually only
+  /* status variable, use it to check for errors in invocation usualy only 
    * during non-interactive calling
    */
-  GimpPDBStatusType status = GIMP_PDB_SUCCESS;
+  GimpPDBStatusType status = GIMP_PDB_SUCCESS;	 
 
   /* always return at least the status to the caller. */
   static GimpParam values[2];
 
-  /* initialize the return of the status */
+  /* initialize the return of the status */ 	
   values[0].type          = GIMP_PDB_STATUS;
   values[0].data.d_status = status;
   *nreturn_vals = 1;
@@ -174,7 +172,7 @@
     case GIMP_RUN_INTERACTIVE:
       /* Possibly retrieve data from a previous run */
       gimp_get_data (PLUG_IN_NAME, &shootvals);
-      shootvals.window_id = 0;
+      shootvals.window_id = NULL;
 
      /* Get information from the dialog */
       if (!shoot_dialog ())
@@ -182,17 +180,15 @@
       break;
 
     case GIMP_RUN_NONINTERACTIVE:
-      if (nparams == 3)
+      if (nparams == 3) 
 	{
 	  shootvals.root      = param[1].data.d_int32;
-	  shootvals.window_id = param[2].data.d_int32;
+	  shootvals.window_id = (gchar*) param[2].data.d_string;
 	  shootvals.delay     = 0;
+	  shootvals.decor     = FALSE;
 	}
       else
 	status = GIMP_PDB_CALLING_ERROR;
-
-      if (!gdk_init_check (0, NULL))
-	status = GIMP_PDB_CALLING_ERROR;
       break;
 
     case GIMP_RUN_WITH_LAST_VALS:
@@ -229,264 +225,139 @@
       values[1].data.d_image = image_ID;
     }
 
-  values[0].data.d_status = status;
-}
-
-/* Allow the user to select a window with the mouse */
-
-static GdkNativeWindow
-select_window (const GdkScreen *screen)
-{
-#if defined(GDK_WINDOWING_X11)
-  /* X11 specific code */
-
-#define MASK (ButtonPressMask | ButtonReleaseMask)
-
-  Display    *x_dpy;
-  Cursor      x_cursor;
-  XEvent      x_event;
-  Window      x_win;
-  Window      x_root;
-  gint        x_scr;
-  gint        status;
-  gint        buttons;
-
-  x_dpy = GDK_SCREEN_XDISPLAY (GDK_SCREEN (screen));
-  x_scr = GDK_SCREEN_XNUMBER (GDK_SCREEN (screen));
-
-  x_win    = None;
-  x_root   = RootWindow (x_dpy, x_scr);
-  x_cursor = XCreateFontCursor (x_dpy, GDK_CROSSHAIR);
-  buttons  = 0;
-
-  status = XGrabPointer (x_dpy, x_root, False,
-                         MASK, GrabModeSync, GrabModeAsync,
-                         x_root, x_cursor, CurrentTime);
-
-  if (status != GrabSuccess)
-    {
-      g_message (_("Error grabbing the pointer"));
-      return 0;
-    }
-
-  while ((x_win == None) || (buttons != 0))
-    {
-      XAllowEvents (x_dpy, SyncPointer, CurrentTime);
-      XWindowEvent (x_dpy, x_root, MASK, &x_event);
-
-      switch (x_event.type)
-        {
-        case ButtonPress:
-          if (x_win == None)
-            {
-              x_win = x_event.xbutton.subwindow;
-              if (x_win == None)
-                x_win = x_root;
-            }
-          buttons++;
-          break;
-
-        case ButtonRelease:
-          if (buttons > 0)
-            buttons--;
-          break;
-
-        default:
-          g_assert_not_reached ();
-        }
-    }
-
-  XUngrabPointer (x_dpy, CurrentTime);
-  XFreeCursor (x_dpy, x_cursor);
-
-  return x_win;
-#elif defined(GDK_WINDOWING_WIN32)
-  /* MS Windows specific code goes here (yet to be written) */
-
-  /* basically the code should grab the pointer using a crosshair
-     cursor, allow the user to click on a window and return the
-     obtained HWND (as a GdkNativeWindow) - for more details consult
-     the X11 specific code below */
-
-  /* note to self: take a look at the winsnap plug-in for example
-     code */
-
-#warning Win32 screenshot window chooser not implemented yet
-  return 0;
-#else /* GDK_WINDOWING_WIN32 */
-#warning screenshot window chooser not implemented yet for this GDK backend
-  return 0;
-#endif
+  values[0].data.d_status = status; 
 }
 
-/* Create a GimpImage from a GdkPixbuf */
-
-static gint32
-create_image (const GdkPixbuf *pixbuf)
-{
-  GimpPixelRgn	pr;
-  GimpDrawable *drawable;
-  GimpParasite *parasite;
-  gint32        image;
-  gint32        layer;
-  gdouble       xres, yres;
-  gchar        *comment;
-  gint          width, height;
-  gint          rowstride;
-  gboolean      status;
-  gchar        *buf;
-  gint          i;
-
-  width  = gdk_pixbuf_get_width (GDK_PIXBUF (pixbuf));
-  height = gdk_pixbuf_get_height (GDK_PIXBUF (pixbuf));
-
-  image = gimp_image_new (width, height, GIMP_RGB);
-  layer = gimp_layer_new (image, _("Background"),
-                          width, height,
-                          GIMP_RGB_IMAGE, 100, GIMP_NORMAL_MODE);
-
-  gimp_image_add_layer (image, layer, 0);
-
-  drawable = gimp_drawable_get (layer);
-
-  gimp_tile_cache_ntiles ((width / gimp_tile_width ()) + 1);
-
-  gimp_pixel_rgn_init (&pr, drawable,
-                       0, 0, width, height,
-                       TRUE, FALSE);
-
-  /* copy the contents of the GdkPixbuf to the GimpDrawable */
-  rowstride = gdk_pixbuf_get_rowstride (GDK_PIXBUF (pixbuf));
-  buf       = gdk_pixbuf_get_pixels (GDK_PIXBUF (pixbuf));
-  status    = gimp_progress_init (_("Loading Screen Shot..."));
-
-  for (i = 0; i < height; i++)
-    {
-      gimp_pixel_rgn_set_row (&pr, buf, 0, i, width);
-      buf += rowstride;
-      /* update progress every 10 percent */
-      if (status && ((i + 1) * 100 / height) % 10 == 0)
-        status = gimp_progress_update ((i + 1.0) / height);
-    }
-
-  gimp_progress_update (1.0);
-
-  /*  figure out the monitor resolution and set the image to it  */
-  gimp_get_monitor_resolution (&xres, &yres);
-  gimp_image_set_resolution (image, xres, yres);
-
-  /* Set the default comment parasite */
-  comment = gimp_get_default_comment ();
-
-  if (comment)
-    {
-      parasite = gimp_parasite_new ("gimp-comment",
-                                    GIMP_PARASITE_PERSISTENT,
-                                    g_utf8_strlen (comment, -1) + 1,
-                                    comment);
-
-      gimp_image_parasite_attach (image_ID, parasite);
-      gimp_parasite_free (parasite);
-      g_free (comment);
-    }
-
-  return image;
-}
 
 /* The main ScreenShot function */
-
-static void
+static void 
 shoot (void)
 {
-  GdkWindow    *window;
-  GdkPixbuf    *screenshot;
-  GdkRectangle  clip;
-  GdkPoint      origin;
-  gint          screen_w, screen_h;
-
-  /* use default screen if we are running non-interactively */
-  if (cur_screen == NULL)
-    cur_screen = gdk_screen_get_default ();
-
-  screen_w = gdk_screen_get_width (GDK_SCREEN (cur_screen));
-  screen_h = gdk_screen_get_height (GDK_SCREEN (cur_screen));
-  clip.x   = 0;
-  clip.y   = 0;
-
-  if (shootvals.root)
-    {
-      /* entire screen */
-      window = gdk_screen_get_root_window (GDK_SCREEN (cur_screen));
+  GimpParam *params;
+  gint       retvals;
+  gchar     *tmpname;
+  gchar     *xwdargv[7];    /*  need a maximum of 7 arguments to xwd  */
+  gdouble    xres, yres;
+  gint       pid;
+  gint       wpid;
+  gint       status;
+  gint       i = 0;
+
+  /*  get a temp name with the right extension  */
+  tmpname = gimp_temp_name ("xwd");
+
+  /*  construct the xwd arguments  */
+  xwdargv[i++] = XWD;
+  xwdargv[i++] = "-out";
+  xwdargv[i++] = tmpname;
+  if ( shootvals.root == TRUE )
+    xwdargv[i++] = "-root";
+  else 
+    {
+      if (shootvals.decor == TRUE )
+	xwdargv[i++] = "-frame";
+      if (shootvals.window_id != NULL)
+	{
+	  xwdargv[i++] = "-id";
+	  xwdargv[i++] = shootvals.window_id;
+	}
     }
-  else
+  xwdargv[i] = NULL;
+  
+#ifndef __EMX__
+  /*  fork off a xwd process  */
+  if ((pid = fork ()) < 0)
     {
-      /* single window */
-      if (shootvals.window_id)
-        {
-          window = gdk_window_foreign_new (shootvals.window_id);
-        }
-      else
-        {
-          window = gdk_window_foreign_new (selected_native);
-        }
+      g_message ("fork() failed: %s", g_strerror (errno));
+      return;
     }
-
-  if (!window)
+  else if (pid == 0)
     {
-      g_message (_("Specified window not found"));
+      execvp (XWD, xwdargv);
+      /*  What are we doing here? exec must have failed  */
+      g_message ("exec failed: xwd: %s", g_strerror (errno));
       return;
     }
-
-  gdk_drawable_get_size (GDK_WINDOW (window), &clip.width, &clip.height);
-  gdk_window_get_origin (GDK_WINDOW (window), &origin.x, &origin.y);
-
-  /* do clipping */
-  if (origin.x < 0)
+  else
+#else /* __EMX__ */
+  pid = spawnvp (P_NOWAIT, XWD, xwdargv);
+  if (pid == -1)
     {
-      clip.x = -origin.x;
-      clip.width += origin.x;
+      g_message ("spawn failed: %s", g_strerror (errno));
+      return;
     }
-  if (origin.y < 0)
+#endif
     {
-      clip.y = -origin.y;
-      clip.height += origin.y;
+      status = -1;
+      wpid = waitpid (pid, &status, 0);
+
+      if ((wpid < 0) || !WIFEXITED (status))
+	{
+	  /*  the tmpfile may have been created even if xwd failed  */
+	  unlink (tmpname);
+	  g_free (tmpname);
+	  g_message ("xwd didn't work");
+	  return;
+	}
     }
-  if (origin.x + clip.width > screen_w)
-    clip.width -= origin.x + clip.width - screen_w;
-  if (origin.y + clip.height > screen_h)
-    clip.height -= origin.y + clip.height - screen_h;
-
-  screenshot = gdk_pixbuf_get_from_drawable (NULL, GDK_WINDOW (window),
-                                             NULL, clip.x, clip.y, 0, 0,
-                                             clip.width, clip.height);
 
-  gdk_display_beep (gdk_screen_get_display (GDK_SCREEN (cur_screen)));
-  gdk_flush ();
+  /*  now load the tmpfile using the xwd-plug-in  */
+  params = gimp_run_procedure ("file_xwd_load",
+			       &retvals,
+			       GIMP_PDB_INT32, 1,
+			       GIMP_PDB_STRING, tmpname,
+			       GIMP_PDB_STRING, tmpname,
+			       GIMP_PDB_END);
+  if (params[0].data.d_status == GIMP_PDB_SUCCESS)
+    {
+      image_ID = params[1].data.d_image;
+    }
+  gimp_destroy_params (params, retvals);
+
+  /*  get rid of the tmpfile  */
+  unlink (tmpname);
+  g_free (tmpname);
+
+  if (image_ID != -1)
+    {
+      GimpParasite *parasite;
+      gchar *comment;
+      
+      /*  figure out the monitor resolution and set the image to it  */
+      gimp_get_monitor_resolution (&xres, &yres);      
+      gimp_image_set_resolution (image_ID, xres, yres);
+
+      /*  unset the image filename  */
+      gimp_image_set_filename (image_ID, "");
+
+      
+      /* Set the default comment parasite */
+      comment = gimp_get_default_comment ();
+      
+      if (comment != NULL)
+        {
+          parasite = gimp_parasite_new ("gimp-comment", 
+                                        GIMP_PARASITE_PERSISTENT,
+                                        g_utf8_strlen (comment, -1) + 1,
+                                        comment);
 
-  if (!screenshot)
-    {
-      g_message (_("Error obtaining screenshot"));
-      return;
+          gimp_image_parasite_attach (image_ID, parasite);
+          gimp_parasite_free(parasite);
+        }
     }
-
-  image_ID = create_image (GDK_PIXBUF (screenshot));
+  
+  return;
 }
 
+
 /*  ScreenShot dialog  */
 
 static void
-shoot_ok_callback (GtkWidget *widget,
+shoot_ok_callback (GtkWidget *widget, 
 		   gpointer   data)
 {
   run_flag = TRUE;
-
-  /* get the screen on which we are running */
-  cur_screen = gtk_widget_get_screen (GTK_WIDGET (widget));
-
   gtk_widget_destroy (GTK_WIDGET (data));
-
-  if (!shootvals.root && !shootvals.window_id)
-    selected_native = select_window (GDK_SCREEN (cur_screen));
 }
 
 static gboolean
@@ -499,7 +370,9 @@
   GtkWidget *hbox;
   GtkWidget *label;
   GtkWidget *button;
+  GtkWidget *decor_button;
   GtkWidget *spinner;
+  GtkWidget *sep;
   GSList    *radio_group = NULL;
   GtkObject *adj;
 
@@ -514,7 +387,6 @@
 
 			    GTK_STOCK_CANCEL, gtk_widget_destroy,
 			    NULL, 1, NULL, FALSE, TRUE,
-
 			    GTK_STOCK_OK, shoot_ok_callback,
 			    NULL, NULL, NULL, TRUE, FALSE,
 
@@ -539,9 +411,9 @@
   gtk_container_set_border_width (GTK_CONTAINER (vbox), 4);
   gtk_container_add (GTK_CONTAINER (frame), vbox);
 
-  button = gtk_radio_button_new_with_mnemonic (radio_group,
-					       _("a _Single Window"));
-  radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (button));
+  button = gtk_radio_button_new_with_mnemonic (radio_group, 
+					       _("_Single Window"));
+  radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (button));  
   gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button), ! shootvals.root);
   gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
   gtk_widget_show (button);
@@ -553,10 +425,32 @@
                     G_CALLBACK (gimp_radio_button_update),
                     &shootvals.root);
 
+  /*  with decorations  */
+  hbox = gtk_hbox_new (FALSE, 2);
+  gtk_box_pack_start (GTK_BOX (vbox), hbox, TRUE, TRUE, 0);
+  decor_button =
+    gtk_check_button_new_with_mnemonic (_("With _Decorations"));
+  gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (decor_button), 
+				shootvals.decor);
+  gtk_box_pack_end (GTK_BOX (hbox), decor_button, FALSE, FALSE, 0);
+  gtk_widget_show (decor_button);
+
+  g_object_set_data (G_OBJECT (button), "set_sensitive", decor_button);
+
+  g_signal_connect (decor_button, "toggled",
+                    G_CALLBACK (gimp_toggle_button_update),
+                    &shootvals.decor);
+
+  gtk_widget_show (hbox);
+
+  sep = gtk_hseparator_new ();
+  gtk_box_pack_start (GTK_BOX (vbox), sep, FALSE, FALSE, 0);
+  gtk_widget_show (sep);
+
   /*  root window  */
   button = gtk_radio_button_new_with_mnemonic (radio_group,
-					       _("the _Whole Screen"));
-  radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (button));
+					       _("_Whole Screen"));
+  radio_group = gtk_radio_button_get_group (GTK_RADIO_BUTTON (button));  
   gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (button), shootvals.root);
   gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
 
@@ -577,14 +471,14 @@
   label = gtk_label_new_with_mnemonic (_("_after"));
   gtk_box_pack_start (GTK_BOX (hbox), label, FALSE, FALSE, 0);
   gtk_widget_show (label);
-
+ 
   adj = gtk_adjustment_new (shootvals.delay, 0.0, 100.0, 1.0, 5.0, 0.0);
   spinner = gtk_spin_button_new (GTK_ADJUSTMENT (adj), 0, 0);
   gtk_box_pack_start (GTK_BOX (hbox), spinner, FALSE, FALSE, 0);
   gtk_widget_show (spinner);
 
   g_signal_connect (adj, "value_changed",
-                    G_CALLBACK (gimp_int_adjustment_update),
+                    G_CALLBACK (gimp_int_adjustment_update), 
                     &shootvals.delay);
 
   label = gtk_label_new (_("Seconds Delay"));
@@ -611,12 +505,12 @@
 gboolean
 shoot_delay_callback (gpointer data)
 {
-  gint *seconds_left = data;
+  gint *seconds_left = (gint *)data;
 
   (*seconds_left)--;
 
-  if (!*seconds_left)
-    gtk_main_quit ();
+  if (!*seconds_left) 
+    gtk_main_quit();
 
   return *seconds_left;
 }
