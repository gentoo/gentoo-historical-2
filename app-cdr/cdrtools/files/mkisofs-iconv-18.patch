diff -urp cdrtools-2.01.01.orig/include/schily/unls.h cdrtools-2.01.01/include/schily/unls.h
--- cdrtools-2.01.01.orig/include/schily/unls.h	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/include/schily/unls.h	2006-10-28 11:24:22.000000000 +0200
@@ -23,6 +23,10 @@
 #include <schily/mconfig.h>
 #endif
 
+#ifdef USE_ICONV
+#include <iconv.h>
+#endif
+
 #ifdef	__cplusplus
 extern "C" {
 #endif
@@ -37,6 +41,9 @@ struct unls_table {
 	unsigned char 	**unls_uni2cs;		/* Unicode -> Charset	*/
 	struct unls_unicode *unls_cs2uni;	/* Charset -> Unicode	*/
 	struct unls_table *unls_next;		/* Next table		*/
+#ifdef USE_ICONV
+	iconv_t iconv_d;
+#endif
 };
 
 extern int		init_unls		__PR((void));
@@ -48,6 +55,9 @@ extern struct unls_table *load_unls		__P
 extern void 		unload_unls		__PR((struct unls_table *));
 extern struct unls_table *load_unls_default	__PR((void));
 extern int		init_unls_file		__PR((char * name));
+#ifdef USE_ICONV
+extern int		init_unls_iconv		__PR((char * name));
+#endif
 
 #ifdef	__cplusplus
 }
Only in cdrtools-2.01.01/include/schily: unls.h.orig
diff -urp cdrtools-2.01.01.orig/libunls/Targets cdrtools-2.01.01/libunls/Targets
--- cdrtools-2.01.01.orig/libunls/Targets	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/libunls/Targets	2006-10-28 11:24:22.000000000 +0200
@@ -39,4 +39,5 @@ CFILES=	nls_base.c \
 	nls_cp10029.c \
 	nls_cp10079.c \
 	nls_cp10081.c \
-	nls_file.c
+	nls_file.c \
+	nls_iconv.c
diff -urp cdrtools-2.01.01.orig/libunls/libunls.mk cdrtools-2.01.01/libunls/libunls.mk
--- cdrtools-2.01.01.orig/libunls/libunls.mk	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/libunls/libunls.mk	2006-10-28 11:24:22.000000000 +0200
@@ -8,6 +8,7 @@ include		$(SRCROOT)/$(RULESDIR)/rules.to
 INSDIR=		lib
 TARGETLIB=	unls
 #CPPOPTS +=	-Istdio
+CPPOPTS +=	-DUSE_ICONV
 include		Targets
 LIBS=		
 
diff -urp cdrtools-2.01.01.orig/libunls/nls.h cdrtools-2.01.01/libunls/nls.h
--- cdrtools-2.01.01.orig/libunls/nls.h	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/libunls/nls.h	2006-10-28 11:24:22.000000000 +0200
@@ -110,5 +110,8 @@ extern int init_unls_cp10029	__PR((void)
 extern int init_unls_cp10079	__PR((void));
 extern int init_unls_cp10081	__PR((void));
 extern int init_unls_file	__PR((char * name));
+#ifdef USE_ICONV
+extern int init_unls_iconv	__PR((char * name));
+#endif
 
 #endif	/* _NLS_H */
Only in cdrtools-2.01.01/libunls: nls_iconv.c
diff -urp cdrtools-2.01.01.orig/mkisofs/Makefile cdrtools-2.01.01/mkisofs/Makefile
--- cdrtools-2.01.01.orig/mkisofs/Makefile	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/mkisofs/Makefile	2006-10-28 11:24:22.000000000 +0200
@@ -33,6 +33,7 @@ CPPOPTS +=	-DAPPLE_HYB
 CPPOPTS +=	-DUDF
 CPPOPTS +=	-DDVD_VIDEO
 CPPOPTS +=	-DSORTING
+CPPOPTS +=	-DUSE_ICONV
 CPPOPTS +=	-I../libhfs_iso/
 CPPOPTS	+=	-DUSE_SCG \
 		'-DAPPID_DEFAULT="MKISOFS ISO 9660/HFS FILESYSTEM BUILDER & CDRECORD CD-R/DVD CREATOR (C) 1993 E.YOUNGDALE (C) 1997 J.PEARSON/J.SCHILLING"' \
Only in cdrtools-2.01.01/mkisofs: Makefile.orig
diff -urp cdrtools-2.01.01.orig/mkisofs/joliet.c cdrtools-2.01.01/mkisofs/joliet.c
--- cdrtools-2.01.01.orig/mkisofs/joliet.c	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/mkisofs/joliet.c	2006-10-28 11:24:22.000000000 +0200
@@ -90,6 +90,11 @@ static	char sccsid[] =
 #include <schily/unls.h>	/* For UNICODE translation */
 #include <schily/schily.h>
 
+#ifdef USE_ICONV
+#include <iconv.h>
+#include <errno.h>
+#endif
+
 static Uint	jpath_table_index;
 static struct directory **jpathlist;
 static int	next_jpath_index = 1;
@@ -103,13 +108,23 @@ static	char	ucs_codes[] = {
 };
 
 #ifdef	UDF
-	void	convert_to_unicode	__PR((unsigned char *buffer,
+#	ifdef USE_ICONV
+	size_t
+#	else
+	void
+#	endif
+		convert_to_unicode	__PR((unsigned char *buffer,
 		int size, char *source, struct unls_table *inls));
-	int	joliet_strlen		__PR((const char *string));
+	int	joliet_strlen		__PR((const char *string, struct unls_table *inls));
 #else
-static void	convert_to_unicode	__PR((unsigned char *buffer,
+#	ifdef USE_ICONV
+	static size_t
+#	else
+	static void
+#endif
+		convert_to_unicode	__PR((unsigned char *buffer,
 		int size, char *source, struct unls_table *inls));
-static int	joliet_strlen		__PR((const char *string));
+static int	joliet_strlen		__PR((const char *string, struct unls_table *inls));
 #endif
 static void	get_joliet_vol_desc	__PR((struct iso_primary_descriptor *jvol_desc));
 static void	assign_joliet_directory_addresses __PR((struct directory *node));
@@ -161,6 +176,20 @@ conv_charset(c, inls, onls)
 	if (inls == onls)
 		return (c);
 
+#ifdef USE_ICONV
+	if(inls->unls_cs2uni == NULL || onls->unls_uni2cs == NULL) {
+		/*
+		 * This shouldn't be reached
+		 */
+		static BOOL iconv_warned = FALSE;
+		if(!iconv_warned) {
+			error("Warning: Iconv conversion not supported in conv_charset.\n");
+			iconv_warned = TRUE;
+		}
+		return (c);
+	}
+#endif
+
 	/* get high and low UNICODE bytes */
 	uh = inls->unls_cs2uni[c].unls_high;
 	ul = inls->unls_cs2uni[c].unls_low;
@@ -186,10 +215,18 @@ conv_charset(c, inls, onls)
  *
  * Notes:
  */
-#ifdef	UDF
-void
+#ifdef USE_ICONV
+#	if	UDF
+size_t
+#	else
+static size_t
+#	endif
 #else
+#	if	UDF
+void
+#	else
 static void
+#	endif
 #endif
 convert_to_unicode(buffer, size, source, inls)
 	unsigned char	*buffer;
@@ -216,6 +253,51 @@ convert_to_unicode(buffer, size, source,
 		tmpbuf = (Uchar *) source;
 	}
 
+#ifdef USE_ICONV
+	if (inls->iconv_d && inls->unls_cs2uni==NULL &&
+			inls->unls_uni2cs==NULL) {
+		char *inptr = tmpbuf;
+		char *outptr = buffer;
+		size_t inleft = strlen(tmpbuf);
+		size_t inlen = inleft;
+		size_t outleft = size;
+
+		iconv(inls->iconv_d, NULL, NULL, NULL, NULL);
+		if(iconv(inls->iconv_d, &inptr, &inleft, &outptr, &outleft) ==
+				(size_t)-1 && errno == EILSEQ) {
+			fprintf(stderr, "Incorrectly encoded string (%s) "
+				"encountered.\nPossibly creating an invalid "
+				"Joliet extension. Aborting.\n", source);
+			exit(1);
+		}
+
+	  	for (i = 0; (i + 1) < size - outleft; i += 2) {	/* Size may be odd!!!*/
+			if (buffer[i]=='\0') {
+				switch (buffer[i+1]) {   /* Invalid characters for Joliet */
+					case '*':
+					case '/':
+					case ':':
+					case ';':
+					case '?':
+					case '\\':
+						buffer[i+1]='_';
+					default:
+						if (buffer[i+1] == 0x7f ||
+							    buffer[i+1] < 0x20)
+							buffer[i+1]='_';
+				}
+			}
+		}
+		if (size & 1) {	/* beautification */
+	  		buffer[size - 1] = 0;
+		}
+		if (source == NULL) {
+			free(tmpbuf);
+		}
+		return (inlen - inleft);
+	}
+#endif
+
 	/*
 	 * Now start copying characters.  If the size was specified to be 0,
 	 * then assume the input was 0 terminated.
@@ -271,6 +353,9 @@ convert_to_unicode(buffer, size, source,
 	if (source == NULL) {
 		free(tmpbuf);
 	}
+#ifdef USE_ICONV
+	return j;
+#endif
 }
 
 /*
@@ -287,12 +372,50 @@ int
 #else
 static int
 #endif
-joliet_strlen(string)
+joliet_strlen(string, inls)
 	const char	*string;
+	struct unls_table *inls;
 {
 	int		rtn;
 
+#ifdef USE_ICONV
+	if (inls->iconv_d && inls->unls_cs2uni==NULL &&
+			inls->unls_uni2cs==NULL) {
+		/*
+		 * we const-cast since we're sure iconv won't change
+		 * the string itself
+		 */
+		char *string_ptr = (char *)string;
+		size_t string_len = strlen(string);
+
+		/*
+		 * iconv has no way of finding out the required size
+		 * in the target
+		 */
+
+		char *tmp, *tmp_ptr;
+		/* we assume that the maximum length is 2 * jlen */
+		size_t tmp_len = (size_t)jlen * 2 + 1;
+		tmp = e_malloc(tmp_len);
+		tmp_ptr = tmp;
+
+		iconv(inls->iconv_d, NULL, NULL, NULL, NULL);
+		iconv(inls->iconv_d, &string_ptr, &string_len, &tmp_ptr,
+			&tmp_len);
+
+		/*
+		 * iconv advanced the tmp pointer with as many chars
+		 * as it has written to it, so we add up the delta
+		 */
+		rtn = (tmp_ptr - tmp);
+
+		free(tmp);
+	} else {
+		rtn = strlen(string) << 1;
+	}
+#else
 	rtn = strlen(string) << 1;
+#endif
 
 	/*
 	 * We do clamp the maximum length of a Joliet string to be the
@@ -481,16 +604,33 @@ joliet_compare_paths(r, l)
 	/* compare the Unicode names */
 
 	while (*rpnt && *lpnt) {
+#ifdef USE_ICONV
+		size_t ri, li;
+
+		ri = convert_to_unicode(rtmp, 2, rpnt, rinls);
+		li = convert_to_unicode(ltmp, 2, lpnt, linls);
+		rpnt += ri;
+		lpnt += li;
+		if(!ri && !li)
+			return (0);
+		else if(ri && !li)
+			return (1);
+		else if(!ri && li)
+			return (-1);
+#else
 		convert_to_unicode(rtmp, 2, rpnt, rinls);
 		convert_to_unicode(ltmp, 2, lpnt, linls);
+#endif
 
 		if (a_to_u_2_byte(rtmp) < a_to_u_2_byte(ltmp))
 			return (-1);
 		if (a_to_u_2_byte(rtmp) > a_to_u_2_byte(ltmp))
 			return (1);
 
+#ifndef USE_ICONV
 		rpnt++;
 		lpnt++;
+#endif
 	}
 
 	if (*rpnt)
@@ -564,10 +704,10 @@ generate_joliet_path_tables()
 		}
 #ifdef APPLE_HYB
 		if (USE_MAC_NAME(de))
-			namelen = joliet_strlen(de->hfs_ent->name);
+			namelen = joliet_strlen(de->hfs_ent->name, hfs_inls);
 		else
 #endif	/* APPLE_HYB */
-			namelen = joliet_strlen(de->name);
+			namelen = joliet_strlen(de->name, in_nls);
 
 		if (dpnt == root) {
 			jpath_table_l[jpath_table_index] = 1;
@@ -712,10 +852,10 @@ generate_one_joliet_directory(dpnt, outf
 #ifdef APPLE_HYB
 		/* Use the HFS name if it exists */
 		if (USE_MAC_NAME(s_entry1))
-			cvt_len = joliet_strlen(s_entry1->hfs_ent->name);
+			cvt_len = joliet_strlen(s_entry1->hfs_ent->name, hfs_inls);
 		else
 #endif	/* APPLE_HYB */
-			cvt_len = joliet_strlen(s_entry1->name);
+			cvt_len = joliet_strlen(s_entry1->name, in_nls);
 
 		/*
 		 * Fix the record length
@@ -849,12 +989,12 @@ joliet_sort_n_finish(this_dir)
 				if (USE_MAC_NAME(s_entry))
 					/* Use the HFS name if it exists */
 					jpath_table_size +=
-						joliet_strlen(s_entry->hfs_ent->name) +
+						joliet_strlen(s_entry->hfs_ent->name, hfs_inls) +
 						offsetof(struct iso_path_table, name[0]);
 				else
 #endif	/* APPLE_HYB */
 					jpath_table_size +=
-						joliet_strlen(s_entry->name) +
+						joliet_strlen(s_entry->name, in_nls) +
 						offsetof(struct iso_path_table, name[0]);
 				if (jpath_table_size & 1) {
 					jpath_table_size++;
@@ -876,13 +1016,13 @@ joliet_sort_n_finish(this_dir)
 				/* Use the HFS name if it exists */
 				s_entry->jreclen =
 				offsetof(struct iso_directory_record, name[0])
-					+ joliet_strlen(s_entry->hfs_ent->name)
+					+ joliet_strlen(s_entry->hfs_ent->name, hfs_inls)
 					+ 1;
 			else
 #endif	/* APPLE_HYB */
 				s_entry->jreclen =
 				offsetof(struct iso_directory_record, name[0])
-					+ joliet_strlen(s_entry->name)
+					+ joliet_strlen(s_entry->name, in_nls)
 					+ 1;
 		} else {
 			/*
@@ -1024,6 +1164,9 @@ joliet_compare_dirs(rr, ll)
 #endif
 
 	while (*rpnt && *lpnt) {
+#ifdef USE_ICONV
+		size_t ri, li;
+#endif
 		if (*rpnt == ';' && *lpnt != ';')
 			return (-1);
 		if (*rpnt != ';' && *lpnt == ';')
@@ -1044,16 +1187,32 @@ joliet_compare_dirs(rr, ll)
 			return (1);
 #endif
 
+#ifdef USE_ICONV
+
+		ri = convert_to_unicode(rtmp, 2, rpnt, rinls);
+		li = convert_to_unicode(ltmp, 2, lpnt, linls);
+		rpnt += ri;
+		lpnt += li;
+		if(!ri && !li)
+			return (0);
+		else if(ri && !li)
+			return (1);
+		else if(!ri && li)
+			return (-1);
+#else
 		convert_to_unicode(rtmp, 2, rpnt, rinls);
 		convert_to_unicode(ltmp, 2, lpnt, linls);
+#endif
 
 		if (a_to_u_2_byte(rtmp) < a_to_u_2_byte(ltmp))
 			return (-1);
 		if (a_to_u_2_byte(rtmp) > a_to_u_2_byte(ltmp))
 			return (1);
 
+#ifndef USE_ICONV
 		rpnt++;
 		lpnt++;
+#endif
 	}
 	if (*rpnt)
 		return (1);
Only in cdrtools-2.01.01/mkisofs: joliet.c.orig
diff -urp cdrtools-2.01.01.orig/mkisofs/mkisofs.c cdrtools-2.01.01/mkisofs/mkisofs.c
--- cdrtools-2.01.01.orig/mkisofs/mkisofs.c	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/mkisofs/mkisofs.c	2006-10-28 11:24:22.000000000 +0200
@@ -64,6 +64,11 @@ static	char sccsid[] =
 #endif
 #endif	/* no_more_needed */
 
+#ifdef USE_ICONV
+#include <locale.h>
+#include <langinfo.h>
+#endif
+
 struct directory *root = NULL;
 int		path_ind;
 
@@ -297,6 +302,10 @@ UInt32_t null_inodes = NULL_INO_MAX;
 BOOL	correct_inodes = TRUE;	/* TRUE: add a "correct inodes" fingerprint */
 BOOL	rrip112 = TRUE;		/* TRUE: create Rock Ridge V 1.12	    */
 
+#ifdef USE_ICONV
+int iconv_possible;
+#endif
+
 struct unls_table *in_nls = NULL;  /* input UNICODE conversion table */
 struct unls_table *out_nls = NULL; /* output UNICODE conversion table */
 #ifdef APPLE_HYB
@@ -1969,6 +1978,37 @@ args_ok:
 	init_unls_file(hfs_ocharset);
 #endif /* APPLE_HYB */
 
+#ifdef USE_ICONV
+	iconv_possible = !(iso9660_level >= 4 || ((ocharset &&
+		strcmp(ocharset, icharset ? icharset : "")) &&
+		use_RockRidge) || apple_ext || apple_hyb);
+
+	setlocale(LC_CTYPE, "");
+	
+  	if (icharset == NULL && iconv_possible) {
+		char *charset = nl_langinfo(CODESET);
+		/* set to detected value but only if it is not pure US-ASCII */
+		if(strcmp(charset, "ANSI_X3.4-1968") != 0)
+			icharset = charset;
+
+		if(icharset && verbose > 0)
+			fprintf(stderr, "INFO:\t"
+			"%s character encoding detected by locale settings."
+			"\n\tAssuming %s encoded filenames on source "
+			"filesystem,\n"
+			"\tuse -input-charset to override.\n",
+			icharset, icharset);
+	}
+
+	if(iconv_possible) {
+		/*
+		 * don't care if initialization fails
+		 */
+		init_unls_iconv(icharset);
+		init_unls_iconv(ocharset);
+	}
+#endif
+
 	if (icharset == NULL) {
 #if	(defined(__CYGWIN32__) || defined(__CYGWIN__) || defined(__DJGPP__)) && !defined(IS_CYGWIN_1)
 		in_nls = load_unls("cp437");
@@ -1996,6 +2036,12 @@ args_ok:
 	if (in_nls == NULL || out_nls == NULL) { /* Unknown charset specified */
 		fprintf(stderr, "Unknown charset\nKnown charsets are:\n");
 		list_unls();	/* List all known charset names */
+#ifdef USE_ICONV
+		if(!iconv_possible)
+			fprintf(stderr, "Iconv charsets cannot be used with "
+				"Apple extension, HFS, ISO9660 version 2 or\n"
+				"Rock Ridge.\n");
+#endif
 		exit(1);
 	}
 
Only in cdrtools-2.01.01/mkisofs: mkisofs.c.orig
diff -urp cdrtools-2.01.01.orig/mkisofs/mkisofs.h cdrtools-2.01.01/mkisofs/mkisofs.h
--- cdrtools-2.01.01.orig/mkisofs/mkisofs.h	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/mkisofs/mkisofs.h	2006-10-28 11:24:22.000000000 +0200
@@ -513,9 +513,14 @@ extern int get_session_start __PR((int *
 
 /* joliet.c */
 #ifdef	UDF
+#	ifdef USE_ICONV
+extern	size_t	convert_to_unicode	__PR((unsigned char *buffer,
+			int size, char *source, struct unls_table *inls));
+#	else
 extern	void	convert_to_unicode	__PR((unsigned char *buffer,
 			int size, char *source, struct unls_table *inls));
-extern	int	joliet_strlen		__PR((const char *string));
+#	endif
+extern	int joliet_strlen		__PR((const char *string, struct unls_table *inls));
 #endif
 extern unsigned char conv_charset __PR((unsigned char, struct unls_table *,
 				struct unls_table *));
Only in cdrtools-2.01.01/mkisofs: mkisofs.h.orig
diff -urp cdrtools-2.01.01.orig/mkisofs/udf.c cdrtools-2.01.01/mkisofs/udf.c
--- cdrtools-2.01.01.orig/mkisofs/udf.c	2006-10-28 11:24:03.000000000 +0200
+++ cdrtools-2.01.01/mkisofs/udf.c	2006-10-28 11:24:22.000000000 +0200
@@ -439,7 +439,7 @@ set_ostaunicode(dst, dst_size, src)
 	int i;
 	int expanded_length;
 
-	expanded_length = joliet_strlen(src);
+	expanded_length = joliet_strlen(src, in_nls);
 	if (expanded_length > 1024)
 		expanded_length = 1024;
 	if (expanded_length > (dst_size-1)*2)
Only in cdrtools-2.01.01/mkisofs: udf.c.orig
