#!/bin/bash
# Copyright 2006 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

# /etc/pdnsd/pdnsd.conf updater
# Written by Oldrich Jedlicka (oldium.pro@seznam.cz)

# Implementation notes:
# * The assumptions are same as for other scripts like bind and dnsmasq:
#   - We assume that we are a local dns cache - after all, why would a server
#     use resolvconf?
#   - Now that we have assumed this, we also assume that generic DHCP clients
#     will enter their domains and search domains ONLY in the "search" field
#     in their resolv.confs and VPN clients will put the domain they are for
#     into the domain field only.
#   - This allows pdnsd to forward domains for a specific VPN domain to the
#     VPN nameserver and everything else to the standard name servers.
#
# HOW-TO CONFIGURE:
#
# To get this working, you need to do only two steps
#
# 1. Create a basic configuration of /etc/pdnsd/pdnsd.conf, you can use
#    /etc/pdnsd/pdnsd.conf.example to start.
#
#    Additional configuration will be created automatically be resolvconf.
#    The generated server sections has labels starting with "resolvconf", so
#
#        DO NOT USE "resolvconf" IN YOUR LABELS!
#
#    Check if the status_ctl is set to "on", otherwise the configuration
#    will not be automatically reloaded - see sample config file.
#
#    You are free to edit automatically created server sections, but always
#    write one option per line. There are few options that are always recreated
#    and your changes in them will be lost. Here is the list (with example
#    values):
#
#        preset=on;
#        ip="192.168.0.1","192.168.0.2";
#        include=".net",".com";'
#
#    The sample configuration file /etc/pdnsd/pdnsd.conf prepared to work
#    with resolvconf would look like this:
#
#global {
#	perm_cache=2048;
#	run_as="pdnsd";
#	status_ctl = on;   # Important to enable status control
#	run_ipv4=on;
#	par_queries=2;     # How many servers are probed in parallel
#	interface = "lo";  # Interface on which the pdnsd listens
#}
#
# 2. The last step is to configure dns configuration for /etc/resolv.conf
#    for the lo interface. In Gentoo we set it up like so in /etc/conf.d/net
#
#      dns_servers_lo=( "127.0.0.1" )

# Load generic Gentoo functions
source /etc/init.d/functions.sh

# pdnsd config file
PDNSDCONFIG="/etc/pdnsd/pdnsd.conf"

# Backup suffix
BACKUPSUFFIX=".backup"

# Load our variables from resolvconf
VARS="$(resolvconf -v)"
eval "${VARS}"

COMMENT='
# Automatically generated by resolvconf.
#
# Following server sections are automatically enabled and disabled.
#
# !!! WARNING !!!
# DO NOT RENAME LABELS!
#
# No section will be deleted and only some options are automatically changed.
# Feel free to add your own options, but do not use pair comments /* */ as they
# are not recognised.
#
# DO NOT USE resolvconf ANYWHERE IN YOUR LABELS!
#
# Automatically changed options are (with examples):
#   preset=on;
#   ip="192.168.0.1","192.168.0.2";
#   include=".net",".com";
#   policy=excluded;
#'
BASIC_SETTINGS='server {
	label="resolvconf";
	preset=off;
}'

INSTALLATION_CHECK='^[[:space:]]*label[[:space:]]*=[[:space:]]*"resolvconf"'

###
# Sed script configuration
#
# Composed sequence of lines:
#
# (1) SED_LOOP with @MATCH_LABELS@ substituted by several SED_MATCH_ONE_LABEL
# (2) SED_EDIT_ONE_SERVER several times
# (3) SED_ADDING with new servers
#
# Notes:
#
# * @LABEL@ is a string "resolvconf-<domain>" or "resolvconf" for global
#   section
# * @RULE@ is @LABEL@ with translated characters '-' and '.' into '_'.
###

###
# Main loop with label match - it will redirect the processing to
# SED_EDIT_ONE_SERVER, when the label match is found. Special match is
# for "resolvconf" label - the control flow is redirected to SED_ADDING to
# allow adding new sections.
#
# To summarize: Old sections are edited as they appear in the file and new
# sections are added before the "resolvconf" section.
SED_LOOP=\
'/^[[:space:]]*server[[:space:]]*[\{]/ b server;
p; d;
:server; h;
:server_loop; n;
/^[[:space:]]*server[[:space:]]*[\{]/ { x; p; b server_loop; };
@MATCH_LABELS@
/^[[:space:]]*label[[:space:]]*=[[:space:]]*"resolvconf"/ { H; b adding; };
/^[[:space:]]*[\}]/ { H; x; p; d; };
H;
b server_loop;
'

###
# Match for one label with a jump to SED_EDIT_ONE_SERVER
SED_MATCH_ONE_LABEL=\
'/^[[:space:]]*label[[:space:]]*=[[:space:]]*"@LABEL@"/ { H; x; b main_@RULE@; };
'

###
# Editing one server. New lines are put into @SETUP@, lines are composed
# in function compose_lines(). After the new lines are added, all "preset",
# "ip" and "include" options are removed (not printed).
#
# Sanity checks: Check if there is a second label or another server directive.
# In both cases, there is some error in the file, so go to the beginning by
# jumping to SED_LOOP's :server.
SED_EDIT_ONE_SERVER=\
':main_@RULE@;
p; @SETUP@
:loop_@RULE@;
n;
/^[[:space:]]*server[[:space:]]*[\{]/ b server;
/^[[:space:]]*label[[:space:]]*=/ b server;
/^[[:space:]]*preset[[:space:]]*=/ b loop_@RULE@;
/^[[:space:]]*ip[[:space:]]*=/ b loop_@RULE@;
/^[[:space:]]*include[[:space:]]*=/ b loop_@RULE@;
/^[[:space:]]*policy[[:space:]]*=/ b loop_@RULE@;
p;
/^[[:space:]]*[\}]/ d;
b loop_@RULE@;
'

###
# Add new servers. All lines composed by function compose_lines() are put into
# @SETUP@. Then the control flow is returned to one special SED_EDIT_ONE_SERVER
# section with label "resolvconf".
SED_ADDING=\
':adding;
@SETUP@
x; b main_resolvconf;
'

################################################################################
# Functions

###
# char *make_pdnsd_label(char *domain)
#
# Translate domain name into pdnsd's label
make_pdnsd_label() {
	local domain=$1
	if [[ -n ${domain} ]] ; then
		echo -n "resolvconf-${domain}"
	else
		echo -n "resolvconf"
	fi
}

###
# char *make_sed_label(char *pdnsd_label)
#
# Translate pdnsd's label into sed's label
make_sed_label() {
	local label="$1"
	label="${label//-/_}"
	label="${label//./_}"
	echo -n "${label}"
}

# char *compose_lines(...)
#
# Compose a sed command that prints lines
compose_lines() {
	local line result
	for line in "$@" ; do
		result="${result}i\\\\\\n${line//	/\\t}\\n"
	done
	echo "${result}"
}

###
# char *build_settings(char *nameservers, char *domain)
#
# Builds configuration part @SETUP@ of sed script. This involves options like
#
# (1) preset=off;
#
# (2) preset=on;
#     ip="address","address"...;
#
# (3) preset=on;
#     ip="address","address"...;
#     include=".domain.",".domain."...;
#
# Note: Currently the will always be only one domain in "include" option.
#
build_settings() {
	local ns="$1" domain="$2"
	if [[ -n ${ns} ]] ; then
		local x list_ns list_domain
		for x in ${ns} ; do
			list_ns="${list_ns},\"${x}\""
		done
		if [[ -n ${domain} ]] ; then
			for x in ${domain} ; do
				list_domain="${list_domain},\".${x}.\""
			done
			compose_lines \
				"	preset=on;" \
				"	ip=${list_ns#,};" \
				"	include=${list_domain#,};" \
				"	policy=excluded;"
		else
			compose_lines \
				"	preset=on;" \
				"	ip=${list_ns#,};"
		fi
	else
		compose_lines \
			"	preset=off;"
	fi
}

###
# char *build_match_labels(char *domains)
#
# Build the label match part of the sed script
#
build_match_labels() {
	local domain result label destination new_match
	for domain in "$@" ; do
		label="$(make_pdnsd_label "${domain}")"
		rule="$(make_sed_label "${label}")"
		new_match="${SED_MATCH_ONE_LABEL//@LABEL@/${label}}"
		new_match="${new_match//@RULE@/${rule}}"
		result="${result}${new_match}"
	done
	echo "${result}"
}

###
# char *build_one_domain(char *domain, char *domains...)
#
# Parse the list of domains and build settings for one particular domain for
# the sed script.
#
build_one_domain() {
	local domain="$1" ip_list
	shift
	for x in "$@" ; do
		if [[ ${x} == *","* ]] ; then
			if [[ ${x%,*} == ${domain} ]] ; then
				ip_list="${ip_list} ${x#*,}"
			fi
		else
			ip_list="${ip_list} ${x}"
		fi
	done
	ip_list="$(uniqify ${ip_list})"
	build_settings "${ip_list}" "${domain}"
}

###
# char *build_edit_part(char *domain, char *domains...)
#
# Build edit part of the sed script for one particular domain.
#
build_edit_part() {
	local domain="$1" x setup result label rule
	shift
	setup="$(build_one_domain "${domain}" "$@")"
	label="$(make_pdnsd_label "${domain}")"
	rule="$(make_sed_label "${label}")"
	result="${SED_EDIT_ONE_SERVER//@SETUP@/${setup}}"
	result="${result//@RULE@/${rule}}"
	echo -n "${result}"
}


###
# char *build_add_part(char *add, char *domains)
#
# Build add part of the sed script for all domains that needs to be added
#
build_add_part() {
	local add="$1" x label rule add_part new_part result
	shift
	for x in ${add} ; do
		label="$(make_pdnsd_label "${x}")"
		rule="$(make_sed_label ${label})"
		new_part="$(compose_lines "server {" "	label=\"${label}\";")"
		new_part="${new_part}$(build_one_domain "${x}" "$@")"
		new_part="${new_part}$(compose_lines "}" "")"
		add_part="${add_part}${new_part}"
	done
	result="${SED_ADDING//@SETUP@/${add_part}}"
	echo -n "${result}"
}

###
# char *build_sed_script(char *nameservers, char *domains, 
#                        char *change, char *add)
#
# Build the full sed script.
#
build_sed_script() {
	local ns="$1" domains="$2" change="$3" add="$4"

	local match_labels="$(build_match_labels ${change})"
	
	local edit_changed x
	for x in ${change} ; do
		edit_changed="${edit_changed}$(build_edit_part ${x} ${domains})"
	done
	edit_changed="${edit_changed}$(build_edit_part '' ${ns})"
	
	local added
	added="$(build_add_part "${add}" ${domains})"
	
	local full
	full="${SED_LOOP//@MATCH_LABELS@/${match_labels}}"
	echo -ne "${full}"
	echo -ne "${edit_changed}"
	echo -ne "${added}"
}

###
# char *read_configured_domains(char *config_file)
#
# Reads labels of servers starting with resolvconf* from the configuration file.
#
read_configured_domains() {
	local config_file="$1" result
	result="\
		$(sed -nre 's/^[[:space:]]+label=\"?resolvconf-([^;\"]*)\";.*/\1/p' \
		${config_file})"
	echo -n "${result}"
}

###
# void installation_check(char *config_file)
#
# Check if the pdnsd is installed and can be configured. Prepare also the file
# for resolvconf.
#
installation_check() {
	local config_file="$1"
	if [[ -e ${config_file} ]] ; then
		if ! grep ${INSTALLATION_CHECK} ${config_file} &>/dev/null ; then
			echo -e "${COMMENT}" >> ${config_file}
			echo -e "\n${BASIC_SETTINGS}" >> ${config_file}
		fi
		return 0
	else
		return 1
	fi
}

###
# void initialization(char *config_file)
#
# Setup basic variables NAMESERVERS, DOMAINS an CONFIGURED_DOMAINS
#
initialization() {
	local config_file="$1"
	
	for N in ${NEWNS} ; do
		NAMESERVERS="${NAMESERVERS} ${N}"
	done
	
	for N in ${NEWSEARCH} ; do
		NAMESERVERS="${NAMESERVERS} ${N#*,}"
	done
	
	for DN in ${NEWDOMAIN} ; do
		DOMAINS="${DOMAINS} ${DN%,*}"
	done

	CONFIGURED_DOMAINS=$(read_configured_domains ${config_file})

	NAMESERVERS=$(uniqify ${NAMESERVERS})
	DOMAINS=$(uniqify ${DOMAINS})
	CONFIGURED_DOMAINS=$(uniqify ${CONFIGURED_DOMAINS})
}

###
# void find_changed_and_added(char *configured, char *domains)
#
# Find already configured and newly added domains. Sets variables
# CHANGE_DOMAINS and ADD_DOMAINS
#
find_changed_and_added() {
	local configured="$1" domains="$2" x
	# Find what has to be disabled
	for x in ${configured} ; do
		if [[ " ${domains} " != *" ${x} "* ]] ; then
			CHANGE_DOMAINS="${CHANGE_DOMAINS} ${x}"
		fi
	done

	# Find what has to be added
	for x in ${domains} ; do
		if [[ " ${configured} " != *" ${x} "* ]] ; then
			ADD_DOMAINS="${ADD_DOMAINS} ${x}"
			else
			CHANGE_DOMAINS="${CHANGE_DOMAINS} ${x}"
		fi
	done

	ADD_DOMAINS=$(uniqify ${ADD_DOMAINS})
	CHANGE_DOMAINS=$(uniqify ${CHANGE_DOMAINS})
}

###
# bool make_configuration_change(char *config_file, char *backup_suffix,
#                                char *sed_script)
#
# Applies any configuration change. Returns true, if there was a change.
#
make_configuration_change() {
	local config_file="$1" backup_suffix="$2" sed_script="$3"
	local old_config new_config

	old_config=$(< ${config_file})
	
	# Sanity check: add '}' at the end of the file
	new_config=$( (echo -n "${old_config}" && echo -ne "\n}" ) | \
		sed -nre "${sed_script}")
	# Now remove what we added
	new_config=${new_config%?\}}

	if [[ "${old_config}" != "${new_config}" ]] ; then
		cp ${config_file} ${config_file}${backup_suffix}
		echo "${new_config}" > "${config_file}"
		return 0
	else
		return 1
	fi
}

################################################################################
# Main part

# Check, if pdnsd configuration file is installed and possibly prepare it
installation_check "${PDNSDCONFIG}" || exit 0

# Basic initialization of NAMESERVERS, DOMAINS and CONFIGURED_DOMAINS
initialization "${PDNSDCONFIG}"

find_changed_and_added "${CONFIGURED_DOMAINS}" "${DOMAINS}"

sed_script="$(build_sed_script "${NAMESERVERS}" "${NEWDOMAIN}" \
	"${CHANGE_DOMAINS}" "${ADD_DOMAINS}")"

# Check if the config changed
if make_configuration_change "${PDNSDCONFIG}" "${BACKUPSUFFIX}" "${sed_script}" ; then
	# Checks for running pdnsd
	[ -x /usr/sbin/pdnsd-ctl ] || exit 0
	[ -e /var/cache/pdnsd/pdnsd.status ] || exit 0

	# Reload config files
	/usr/sbin/pdnsd-ctl config &>/dev/null
fi

exit 0
