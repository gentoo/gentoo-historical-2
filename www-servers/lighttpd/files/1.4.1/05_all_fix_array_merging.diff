--- branches/lighttpd-merge-1.4.x/src/configfile-glue.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/configfile-glue.c	(revision 616)
@@ -42,7 +42,7 @@
 						data_string *ds = data_string_init();
 						
 						buffer_copy_string_buffer(ds->value, ((data_string *)(da->value->data[j]))->value);
-						if (!da->value->is_array) {
+						if (!da->is_index_key) {
 							/* the id's were generated automaticly, as we copy now we might have to renumber them
 							 * this is used to prepend server.modules by mod_indexfiles as it has to be loaded 
 							 * before mod_fastcgi and friends */
--- branches/lighttpd-merge-1.4.x/src/configparser.y	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/configparser.y	(revision 616)
@@ -70,7 +70,7 @@
 /* op1 is to be eat/return by this function, op1->key is not cared
    op2 is left untouch, unreferenced
  */
-data_unset *configparser_merge_data(config_t *ctx, data_unset *op1, const data_unset *op2) {
+data_unset *configparser_merge_data(data_unset *op1, const data_unset *op2) {
   /* type mismatch */
   if (op1->type != op2->type) {
     if (op1->type == TYPE_STRING && op2->type == TYPE_INTEGER) {
@@ -85,7 +85,6 @@
       return (data_unset *)ds;
     } else {
       fprintf(stderr, "data type mismatch, cannot be merge\n");
-      ctx->ok = 0;
       op1->free(op1);
       return NULL;
     }
@@ -179,13 +178,23 @@
 
   if (NULL != (du = array_get_element(vars, A->ptr))) {
     /* exists in current block */
-    du = configparser_merge_data(ctx, du, B);
-    buffer_copy_string_buffer(du->key, A);
-    array_replace(vars, du);
+    du = configparser_merge_data(du, B);
+    if (NULL == du) {
+      ctx->ok = 0;
+    }
+    else {
+      buffer_copy_string_buffer(du->key, A);
+      array_replace(vars, du);
+    }
   } else if (NULL != (du = configparser_get_variable(ctx, A))) {
-    du = configparser_merge_data(ctx, du, B);
-    buffer_copy_string_buffer(du->key, A);
-    array_insert_unique(ctx->current->value, du);
+    du = configparser_merge_data(du, B);
+    if (NULL == du) {
+      ctx->ok = 0;
+    }
+    else {
+      buffer_copy_string_buffer(du->key, A);
+      array_insert_unique(ctx->current->value, du);
+    }
   } else {
     fprintf(stderr, "Undefined config variable in conditional 1 %s: %s\n", 
             ctx->current->key->ptr, A->ptr);
@@ -210,7 +219,10 @@
 }
 
 expression(A) ::= expression(B) PLUS value(C). {
-  A = configparser_merge_data(ctx, B, C);
+  A = configparser_merge_data(B, C);
+  if (NULL == A) {
+    ctx->ok = 0;
+  }
   B = NULL;
   C->free(C);
   C = NULL;
--- branches/lighttpd-merge-1.4.x/src/array.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/array.c	(revision 616)
@@ -28,7 +28,6 @@
 	a->size = src->size;
 	a->next_power_of_2 = src->next_power_of_2;
 	a->unique_ndx = src->unique_ndx;
-	a->is_array = src->is_array;
 
 	a->data = malloc(sizeof(*src->data) * src->size);
 	for (i = 0; i < src->size; i++) {
@@ -167,9 +166,9 @@
 	size_t j;
 	
 	/* generate unique index if neccesary */
-	if (str->key->used == 0) {
+	if (str->key->used == 0 || str->is_index_key) {
 		buffer_copy_long(str->key, a->unique_ndx++);
-		a->is_array = 1;
+		str->is_index_key = 1;
 	}
 	
 	/* try to find the string */
@@ -251,12 +250,6 @@
 	return maxlen;
 }
 
-static inline int str_int_equal(const char *str, int i) {
-	char buf[16];
-	snprintf(buf, sizeof(buf), "%d", i);
-	return strcmp(str, buf) == 0;
-}
-
 int array_print(array *a, int depth) {
 	size_t i;
 	size_t maxlen;
@@ -267,7 +260,7 @@
 	}
 	for (i = 0; i < a->used && oneline; i++) {
 		data_unset *du = a->data[i];
-		if (!str_int_equal(du->key->ptr, i)) {
+		if (!du->is_index_key) {
 			oneline = 0;
 			break;
 		}
@@ -299,7 +292,7 @@
 	for (i = 0; i < a->used; i++) {
 		data_unset *du = a->data[i];
 		array_print_indent(depth + 1);
-		if (!str_int_equal(du->key->ptr, i)) {
+		if (!du->is_index_key) {
 			int j;
 
 			if (i && (i % 5) == 0) {
--- branches/lighttpd-merge-1.4.x/src/array.h	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/array.h	(revision 616)
@@ -14,6 +14,7 @@
 #define DATA_UNSET \
 	data_type_t type; \
 	buffer *key; \
+	int is_index_key; /* 1 if key is a array index (autogenerated keys) */ \
 	struct data_unset *(*copy)(const struct data_unset *src); \
 	void (* free)(struct data_unset *p); \
 	void (* reset)(struct data_unset *p); \
@@ -33,7 +34,6 @@
 	size_t size;
 	
 	size_t unique_ndx;
-	int is_array; /* 0 if it is a hash, 1 for array (autogenerated keys) */
 	
 	size_t next_power_of_2;
 	int is_weakref; /* data is weakref, don't bother the data */
--- branches/lighttpd-merge-1.4.x/src/data_integer.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/data_integer.c	(revision 616)
@@ -9,6 +9,7 @@
 	data_integer *ds = data_integer_init();
 
 	buffer_copy_string_buffer(ds->key, src->key);
+	ds->is_index_key = src->is_index_key;
 	ds->value = src->value;
 	return (data_unset *)ds;
 }
--- branches/lighttpd-merge-1.4.x/src/mod_staticfile.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/mod_staticfile.c	(revision 616)
@@ -2,6 +2,8 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#define _XOPEN_SOURCE /* glibc 2.0 */
+#define __USE_XOPEN /* glibc 2.3 */
 #include <time.h>
 
 #include "base.h"
--- branches/lighttpd-merge-1.4.x/src/configfile.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/configfile.c	(revision 616)
@@ -26,7 +26,6 @@
 	size_t i;
 	int ret = 0;
 	buffer *stat_cache_string;
-	data_string *ds;
 	
 	config_values_t cv[] = { 
 		{ "server.bind",                 NULL, T_CONFIG_STRING, T_CONFIG_SCOPE_SERVER },      /* 0 */
@@ -117,13 +116,6 @@
 
 	assert(srv->config_storage);
 	
-	/* prepend default modules */
-	if (NULL == array_get_element(srv->srvconf.modules, "mod_indexfile")) {
-		ds = data_string_init();
-		buffer_copy_string(ds->value, "mod_indexfile");
-		array_insert_unique(srv->srvconf.modules, (data_unset *)ds);
-	}
-	
 	for (i = 0; i < srv->config_context->used; i++) {
 		specific_config *s;
 		
@@ -211,21 +203,6 @@
 	
 	buffer_free(stat_cache_string);
 	
-	srv->srvconf.modules->unique_ndx = srv->srvconf.modules->used;
-	
-	/* append default modules */
-	if (NULL == array_get_element(srv->srvconf.modules, "mod_dirlisting")) {
-		ds = data_string_init();
-		buffer_copy_string(ds->value, "mod_dirlisting");
-		array_insert_unique(srv->srvconf.modules, (data_unset *)ds);
-	}
-	
-	if (NULL == array_get_element(srv->srvconf.modules, "mod_staticfile")) {
-		ds = data_string_init();
-		buffer_copy_string(ds->value, "mod_staticfile");
-		array_insert_unique(srv->srvconf.modules, (data_unset *)ds);
-	}
-	
 	return ret;
 								 
 }
@@ -923,6 +900,7 @@
 	data_config *dc;
 	int ret;
 	char *pos;
+	data_array *modules;
 
 	context_init(srv, &context);
 	context.all_configs = srv->config_context;
@@ -960,16 +938,55 @@
 		return ret;
 	}
 
-	if (0 != config_insert(srv)) {
-		return -1;
-	}
-	
 	if (NULL != (dc = (data_config *)array_get_element(srv->config_context, "global"))) {
 		srv->config = dc->value;
 	} else {
 		return -1;
 	}
 	
+	if (NULL != (modules = (data_array *)array_get_element(srv->config, "server.modules"))) {
+		data_string *ds;
+		data_array *prepends;
+
+		if (modules->type != TYPE_ARRAY) {
+			fprintf(stderr, "server.modules must be an array");
+			return -1;
+		}
+
+		prepends = data_array_init();
+
+		/* prepend default modules */
+		if (NULL == array_get_element(modules->value, "mod_indexfile")) {
+			ds = data_string_init();
+			buffer_copy_string(ds->value, "mod_indexfile");
+			array_insert_unique(prepends->value, (data_unset *)ds);
+		}
+
+		prepends = (data_array *)configparser_merge_data((data_unset *)prepends, (data_unset *)modules);
+		buffer_copy_string_buffer(prepends->key, modules->key);
+		array_replace(srv->config, (data_unset *)prepends);
+		modules->free((data_unset *)modules);
+		modules = prepends;
+
+		/* append default modules */
+		if (NULL == array_get_element(modules->value, "mod_dirlisting")) {
+			ds = data_string_init();
+			buffer_copy_string(ds->value, "mod_dirlisting");
+			array_insert_unique(modules->value, (data_unset *)ds);
+		}
+
+		if (NULL == array_get_element(modules->value, "mod_staticfile")) {
+			ds = data_string_init();
+			buffer_copy_string(ds->value, "mod_staticfile");
+			array_insert_unique(modules->value, (data_unset *)ds);
+		}
+	}
+	
+
+	if (0 != config_insert(srv)) {
+		return -1;
+	}
+	
 	return 0;
 }
 
--- branches/lighttpd-merge-1.4.x/src/configfile.h	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/configfile.h	(revision 616)
@@ -19,5 +19,6 @@
 void configparser(void *yyp, int yymajor, buffer *yyminor, config_t *ctx);
 int config_parse_file(server *srv, config_t *context, const char *fn);
 int config_parse_cmd(server *srv, config_t *context, const char *cmd);
+data_unset *configparser_merge_data(data_unset *op1, const data_unset *op2);
 
 #endif
--- branches/lighttpd-merge-1.4.x/src/data_count.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/data_count.c	(revision 616)
@@ -10,6 +10,7 @@
 
 	buffer_copy_string_buffer(ds->key, src->key);
 	ds->count = src->count;
+	ds->is_index_key = src->is_index_key;
 	return (data_unset *)ds;
 }
 
--- branches/lighttpd-merge-1.4.x/src/data_string.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/data_string.c	(revision 616)
@@ -11,6 +11,7 @@
 
 	buffer_copy_string_buffer(ds->key, src->key);
 	buffer_copy_string_buffer(ds->value, src->value);
+	ds->is_index_key = src->is_index_key;
 	return (data_unset *)ds;
 }
 
--- branches/lighttpd-merge-1.4.x/src/data_fastcgi.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/data_fastcgi.c	(revision 616)
@@ -11,6 +11,7 @@
 
 	buffer_copy_string_buffer(ds->key, src->key);
 	buffer_copy_string_buffer(ds->host, src->host);
+	ds->is_index_key = src->is_index_key;
 	return (data_unset *)ds;
 }
 
--- branches/lighttpd-merge-1.4.x/src/data_array.c	(revision 615)
+++ branches/lighttpd-merge-1.4.x/src/data_array.c	(revision 616)
@@ -11,6 +11,7 @@
 	buffer_copy_string_buffer(ds->key, src->key);
 	array_free(ds->value);
 	ds->value = array_init_array(src->value);
+	ds->is_index_key = src->is_index_key;
 	return (data_unset *)ds;
 }
 
