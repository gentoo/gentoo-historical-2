diff -uNr lilo-21.7.4.patched1/Makefile lilo-21.7.4.patched2/Makefile
--- lilo-21.7.4.patched1/Makefile	Mon Apr 30 01:57:25 2001
+++ lilo-21.7.4.patched2/Makefile	Mon Apr 30 02:14:31 2001
@@ -132,15 +132,15 @@
 first.s:	first.S read.S lilo.h version.h lilo mylilo.h
 		$(CPP) $(PCONFIG) $(AFLAGS) `./lilo -X` first.S -o first.s
 
-second.s:	second.S read.S lilo.h version.h lilo mylilo.h
+second.s:	second.S gfxlogo.S read.S lilo.h version.h lilo mylilo.h
 		$(CPP) $(PCONFIG) $(AFLAGS) `./lilo -X` second.S -o second.s
 
-third.s:	second.S read.S lilo.h version.h lilo mylilo.h \
+third.s:	second.S gfxlogo.S read.S lilo.h version.h lilo mylilo.h \
 			graph.S menu.S strlen.S crt.S
 		$(CPP) $(PCONFIG) $(AFLAGS) `./lilo -X` \
 		-DMENU second.S -o third.s
 
-temp2.s:	second.S read.S lilo.h version.h \
+temp2.s:	second.S gfxlogo.S read.S lilo.h version.h \
 			graph.S menu.S strlen.S crt.S
 		$(CPP) $(PCONFIG) $(LILOX) -DMENU second.S -o temp2.s
 
diff -uNr lilo-21.7.4.patched1/bsect.c lilo-21.7.4.patched2/bsect.c
--- lilo-21.7.4.patched1/bsect.c	Thu Feb 22 23:34:04 2001
+++ lilo-21.7.4.patched2/bsect.c	Mon Apr 30 02:14:31 2001
@@ -148,8 +148,9 @@
 	if (st.st_size > MAX_MESSAGE)
 	    die("%s is too big (> %d bytes)",message,MAX_MESSAGE);
 	map_begin_section();
-	map_add(&geo,0,((bsect.par_1.msg_len = st.st_size)+SECTOR_SIZE-1)/
-	  SECTOR_SIZE);
+	map_add(&geo,0,(st.st_size+SECTOR_SIZE-1)/SECTOR_SIZE);
+	/* allow pictures to be > 64k; text messages shoud be < 64k */
+	bsect.par_1.msg_len = st.st_size > 0xffff ? 0xffff : st.st_size;
 	sectors = map_end_section(&bsect.par_1.msg,0);
 	if (verbose > 1)
 	    printf("Message: %d sector%s.\n",sectors,sectors == 1 ?  "" : "s");
@@ -296,7 +297,7 @@
 {
     struct stat st;
     char *here,*root,*ram_disk,*vga,*password;
-    char *literal,*append,*fback;
+    char *literal,*append,*fback, *image;
     char fallback_buf[SECTOR_SIZE];
 
     *descr->password = 0;
@@ -333,7 +334,8 @@
     if ((vga = cfg_get_strg(cf_kernel,"vga")) || (vga = cfg_get_strg(cf_options,
       "vga"))) {
 #ifndef NORMAL_VGA
-	die("VGA mode presetting is not supported by your kernel.");
+        fprintf(stderr,"Warning: VGA mode presetting is not supported by your kernel, skipping the 'vga=' option."); /* -ecki */
+        /*die("VGA mode presetting is not supported by your kernel.");*/
 #else
 	descr->flags |= FLAG_VGA;
 	     if (!strcasecmp(vga,"normal")) descr->vga_mode = NORMAL_VGA;
@@ -356,6 +358,11 @@
     }
     if (cfg_get_flag(cf_all,"single-key") ||
       cfg_get_flag(cf_options,"single-key")) descr->flags |= FLAG_SINGLE;
+    if ((image = cfg_get_strg(cf_top, "image"))) {
+       strcat(options, "BOOT_FILE=");
+       strcat(options, image);
+       strcat(options, " ");
+    }
     if ((append = cfg_get_strg(cf_kernel,"append")) || (append =
       cfg_get_strg(cf_options,"append"))) strcat(options,append);
     literal = cfg_get_strg(cf_kernel,"literal");
diff -uNr lilo-21.7.4.patched1/gfxlogo.S lilo-21.7.4.patched2/gfxlogo.S
--- lilo-21.7.4.patched1/gfxlogo.S	Thu Jan  1 01:00:00 1970
+++ lilo-21.7.4.patched2/gfxlogo.S	Mon Apr 30 02:14:31 2001
@@ -0,0 +1,481 @@
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; gfx stuff
+;
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+; != 0 -> everything is fine
+gfx_ok:			.byte 0
+
+; the memory area we are working with
+gfx_mem:		.long 0		; linear address
+gfx_mem_max:		.long 0		; end address
+gfx_mem_free:		.long 0		; start of free area for malloc (after pcx image)
+
+; interface to loadable gfx extension (seg:ofs values)
+gfx_bc_jt:		.long 0
+
+gfx_bc_init:		.long 0
+gfx_bc_done:		.long 0
+gfx_bc_input:		.long 0
+gfx_bc_menu_init:	.long 0
+gfx_bc_infobox_init:	.long 0
+gfx_bc_infobox_done:	.long 0
+gfx_bc_progress_init:	.long 0
+gfx_bc_progress_done:	.long 0
+gfx_bc_progress_update:	.long 0
+gfx_bc_progress_limit:	.long 0
+gfx_bc_password_init:	.long 0
+gfx_bc_password_done:	.long 0
+
+; system config data
+gfx_sysconfig:
+gfx_sc_vmode:		.byte 0
+gfx_sc_modes:		.byte 0
+
+gfx_password_buf:	.blkb 32
+gfx_msg_wrong_image:	.ascii "Could not find kernel image: "
+			.byte 0
+gfx_msg_wrong_password:	.ascii "Sorry, incorrect password."
+			.byte 0
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; I really have no idea how to get as86 to do this properly
+
+		macro farcall
+		.byte 0xff
+		.byte 0x1e
+		.word ?1
+		mend
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_get_sysconfig:
+		xor ax,ax
+		ret
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_set_sysconfig:
+		ret
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; Initialize graphics code. Load and display graphics data.
+;
+;  edi		file length
+;
+;  return:	[gfx_ok] = 0/1
+;
+gfx_init:
+		push es
+
+		cld
+
+		mov byte gfx_ok,#0
+
+		; define our memory area
+		; gfx_mem _must_ be 16-byte aligned
+		mov dword gfx_mem,#0x10000
+		add edi,gfx_mem
+		mov gfx_mem_free,edi
+		mov dword gfx_mem_max,#0x80000
+
+		sub edi,gfx_mem_max
+		neg edi
+		cmp edi,#0x1000		; we need some minimum space
+		jc near gfx_init_80
+
+		; align 4
+		mov eax,gfx_mem_free
+		add eax,#3
+		and eax,#~3
+		mov gfx_mem_free,eax
+
+		push dword gfx_mem
+		call gfx_l2so
+		pop bx
+		pop es
+
+		seg es
+		cmp dword (bx),#0x0b2d97f00	; header.magic_id
+		jnz near gfx_init_80
+		seg es
+		cmp byte (bx+4),#1		; header.version
+		jnz near gfx_init_80
+
+		seg es
+		mov eax,(bx+8)
+		or eax,eax
+		jz near gfx_init_80
+		add eax,gfx_mem
+		test al,#0xf
+		jnz near gfx_init_80
+		shr eax,4
+		mov gfx_bc_jt+2,ax
+
+
+		; setup jump table
+		les bx,gfx_bc_jt
+
+		seg es
+		mov ax,(bx)
+		mov gfx_bc_init,ax
+		mov gfx_bc_init+2,es
+
+		seg es
+		mov ax,(bx+2)
+		mov gfx_bc_done,ax
+		mov gfx_bc_done+2,es
+
+		seg es
+		mov ax,(bx+4)
+		mov gfx_bc_input,ax
+		mov gfx_bc_input+2,es
+
+		seg es
+		mov ax,(bx+6)
+		mov gfx_bc_menu_init,ax
+		mov gfx_bc_menu_init+2,es
+
+		seg es
+		mov ax,(bx+8)
+		mov gfx_bc_infobox_init,ax
+		mov gfx_bc_infobox_init+2,es
+
+		seg es
+		mov ax,(bx+10)
+		mov gfx_bc_infobox_done,ax
+		mov gfx_bc_infobox_done+2,es
+
+		seg es
+		mov ax,(bx+12)
+		mov gfx_bc_progress_init,ax
+		mov gfx_bc_progress_init+2,es
+
+		seg es
+		mov ax,(bx+14)
+		mov gfx_bc_progress_done,ax
+		mov gfx_bc_progress_done+2,es
+
+		seg es
+		mov ax,(bx+16)
+		mov gfx_bc_progress_update,ax
+		mov gfx_bc_progress_update+2,es
+
+		seg es
+		mov ax,(bx+18)
+		mov gfx_bc_progress_limit,ax
+		mov gfx_bc_progress_limit+2,es
+
+		seg es
+		mov ax,(bx+20)
+		mov gfx_bc_password_init,ax
+		mov gfx_bc_password_init+2,es
+
+		seg es
+		mov ax,(bx+22)
+		mov gfx_bc_password_done,ax
+		mov gfx_bc_password_done+2,es
+
+		mov eax,gfx_mem
+		mov ebx,gfx_mem_free
+		mov ecx,gfx_mem_max
+		mov dx,cs
+		mov si,#gfx_sysconfig
+
+		; eax	memory start
+		; ebx	free memory start
+		; ecx	memory end
+		; dx	boot loader code segment
+		; si	gfx_sysconfig offset
+
+		farcall(gfx_bc_init)
+
+		jc gfx_init_80
+
+		mov byte gfx_ok,#1
+
+		jmp gfx_init_90
+
+gfx_init_80:
+		mov byte gfx_ok,#0
+gfx_init_90:
+		pop es
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; Back to text mode.
+;
+;  return:	[gfx_ok] = 0
+;
+gfx_done:
+		cmp byte gfx_ok,#0
+		jz gfx_done_90
+		farcall(gfx_bc_done)
+		mov byte gfx_ok,#0
+		call gfx_set_sysconfig
+gfx_done_90:
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_input:
+		cmp byte gfx_ok,#0
+		jz gfx_input_90
+		call gfx_get_sysconfig
+
+		mov ax,#0xffff
+		seg fs
+		xchg ax,DSC_OFF-10+SSDIFF
+
+		; map 0xffff -> 0
+		add ax,#1
+		cmc
+		sbb ax,#0
+
+gfx_input_20:
+		mov di,#cmdline
+		mov cx,#CL_LENGTH
+
+		; di	buffer  ( 0 --> no buffer )
+		; cx	buffer size
+		; ax	timeout value (0 --> no timeout)
+
+		farcall(gfx_bc_input)
+
+		pushf
+		call gfx_set_sysconfig
+		popf
+		jnc gfx_input_50
+		mov ax,#1
+gfx_input_50:
+		cmp ax,#1
+		jz gfx_input_80
+
+		call find_boot_image
+		jnc gfx_input_90
+
+		mov si,#gfx_msg_wrong_image
+		mov di,#cmdline
+
+		mov al,#0
+		call gfx_infobox 
+
+		xor ax,ax
+		jmp gfx_input_20
+gfx_input_80:
+		push ax
+		call gfx_done
+		pop ax
+gfx_input_90:
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_setup_menu:
+		cmp byte gfx_ok,#0
+		jz gfx_setup_menu_90
+
+		mov si,#DESCR+2
+		mov di,si
+		xor ax,ax
+		mov cx,#IMAGES
+gfx_setup_menu_20:
+		cmp byte (si),#0
+		jz gfx_setup_menu_30
+		inc ax
+		add si,#DESCR_SIZE
+		loop gfx_setup_menu_20
+gfx_setup_menu_30:
+		mov si,di
+		mov dx,#DESCR_SIZE
+
+		; al	menu entries
+		; dx	menu entry size
+		; di	menu entry list
+		; si	default menu entry
+
+		farcall(gfx_bc_menu_init)
+gfx_setup_menu_90:
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_infobox:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_infobox_90
+		farcall(gfx_bc_infobox_init)
+		xor di,di
+		xor ax,ax
+		farcall(gfx_bc_input)
+		farcall(gfx_bc_infobox_done)
+gfx_infobox_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_progress_init:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_progress_init_90
+		movzx eax,ax
+		farcall(gfx_bc_progress_init)
+gfx_progress_init_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_progress_done:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_progress_done_90
+		farcall(gfx_bc_progress_done)
+gfx_progress_done_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_progress_update:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_progress_update_90
+		movzx eax,cx
+		farcall(gfx_bc_progress_update)
+gfx_progress_update_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_progress_limit:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_progress_limit_90
+		movzx eax,ax
+		farcall(gfx_bc_progress_limit)
+gfx_progress_limit_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_password:
+		pushad
+		cmp byte gfx_ok,#0
+		stc
+		jz gfx_password_90
+		farcall(gfx_bc_password_init)
+		mov di,#gfx_password_buf
+		mov cx,#32
+		xor ax,ax
+		farcall(gfx_bc_input)
+		mov si,#gfx_password_buf
+		farcall(gfx_bc_password_done)
+		jnc gfx_password_90
+		mov si,#gfx_msg_wrong_password
+		xor di,di
+		mov al,#0
+		farcall(gfx_bc_infobox_init)
+		xor di,di
+		xor ax,ax
+		farcall(gfx_bc_input)
+		farcall(gfx_bc_infobox_done)
+		stc
+gfx_password_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; Convert 32bit linear address to seg:ofs.
+;
+;  dword [esp + 2]:	linear address
+;
+; return:
+;  dword [esp + 2]:	seg:ofs
+;
+; Notes:
+;  - changes no regs
+;
+gfx_l2so:
+		push eax
+		mov eax,(esp + 6)
+		shr eax,4
+		mov (esp + 8),ax
+		and word (esp + 6),#0xf
+		pop eax
+		ret
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; locate the boot image
+;
+; return:
+;   bx		boot image index
+;   CF		error (image not found)
+;
+find_boot_image:
+		mov dx,#DESCR+2
+		mov cx,#IMAGES
+
+		xor bx,bx
+
+find_boot_image_10:
+		mov si,dx
+		mov di,#cmdline
+find_boot_image_20:
+		mov al,(si)
+		or al,al
+		jz find_boot_image_60
+		cmp al,(di)
+		jnz find_boot_image_30
+		inc si
+		inc di
+		jmp find_boot_image_20
+find_boot_image_30:
+		inc bx
+		add dx,#DESCR_SIZE
+		cmp bx,cx
+		jb find_boot_image_10
+		; not found, strip options for fancy error message
+
+		mov si,#cmdline
+		mov cx,#MAX_IMAGE_NAME+1
+find_boot_image_40:
+		cmp byte (si),#0x20+1
+		inc si
+		jb find_boot_image_50
+		loop find_boot_image_40
+find_boot_image_50:
+		mov byte (si-1),#0
+		jmp find_boot_image_80
+find_boot_image_60:
+		mov al,(di)
+		cmp al,#0x20
+		ja find_boot_image_30
+		imul bx,bx,#DESCR_SIZE
+		add bx,#DESCR+2
+		jmp find_boot_image_90
+find_boot_image_80:
+		stc
+find_boot_image_90:
+		ret
+
+
diff -uNr lilo-21.7.4.patched1/lilo.h lilo-21.7.4.patched2/lilo.h
--- lilo-21.7.4.patched1/lilo.h	Mon Apr 30 02:12:11 2001
+++ lilo-21.7.4.patched2/lilo.h	Mon Apr 30 02:14:31 2001
@@ -59,7 +59,7 @@
 #define MAX_IMAGE_NAME	15 /* maximum name length (w/o terminating NUL) */
 #define MAX_PW		15 /* maximum password length */
 
-#define MAX_SECONDARY 12
+#define MAX_SECONDARY 14
 
 #define SECTOR_SIZE	512 /* disk sector size */
 #ifndef BLOCK_SIZE /* may also come from linux/fs.h */
@@ -157,7 +157,7 @@
 #define DC_MAGIC	0xf4f2	/* magic number of default cmd. line sector */
 #define DC_MGOFF	0x6b6d	/* magic number for disabled line */
 
-#define MAX_MESSAGE	65535	/* maximum message length */
+#define MAX_MESSAGE	8*64*1024-1	/* maximum message length (512k) */
 
 #define NEW_HDR_SIG	"HdrS"	/* setup header signature */
 #define NEW_HDR_VERSION	0x200	/* header version number */
diff -uNr lilo-21.7.4.patched1/second.S lilo-21.7.4.patched2/second.S
--- lilo-21.7.4.patched1/second.S	Mon Apr 30 01:55:01 2001
+++ lilo-21.7.4.patched2/second.S	Mon Apr 30 02:20:43 2001
@@ -439,6 +439,7 @@
 
 dokay:	mov	bx,#ospc	! display 'O '
 	call	say
+!	call	flamme		! display flame hack
 	mov	ospc,#0		! disable the message
 	mov	word ptr vgaovr,#VGA_NOCOVR ! disable VGA override
 	mov	word ptr memlim,#0 ! no memory limit
@@ -479,7 +480,8 @@
 	seg	es
 	cmp	byte ptr (si),#0 ! empty ?
 	je	iloop		! yes -> enter interactive mode
-	jmp	niloop		! enter non-interactive mode
+niloop0:
+	br	niloop		! enter non-interactive mode
 
 ! No external parameters after timeout -> boot first image
 
@@ -487,7 +489,7 @@
 	pop	es
 	mov	si,#DFLCMD+2	! default command line ?
 	cmp	byte ptr (si),#0
-	jne	niloop		! yes -> use it
+	jne	niloop0		! yes -> use it
 	mov	ax,nodfl	! no idea how to tell as86 to do jmp (addr) :-(
 	jmp	ax		! fall through
 
@@ -495,12 +497,16 @@
 ! Command input processor
 
 iloop:
-#ifdef MENU
-	call	menu_setup
-#endif
+	cmp	byte gfx_ok,#0
+	jnz	iloop_gfx
+
+	; load message before doing anything else
+	; the graphics/text stuff is mixed in a rather messy way...
+
 	seg	fs		! message disabled ?
 	cmp	MSG_OFF+SSDIFF,#0
-	je	nomsg		! yes -> skip this
+	; _must_ be 'jz'!
+	jz	iloop_20	! yes -> skip this
 	call	crlf
 	seg	fs		! load the message file
 	mov	cx,MSG_OFF+SSDIFF+2
@@ -512,6 +518,16 @@
 	call	sread
 	call	loadfile
 
+	; es:bx points to file end
+	movzx	ebx,bx
+	xor	edi,edi
+	mov	di,es
+	shl	edi,4
+	add	edi,ebx
+	sub	edi,#SYSSEG * 16
+
+	; edi -> message file size
+
 	push	#SYSSEG
 	pop	ds
 
@@ -519,7 +535,76 @@
 				! messages
 	seg	fs
 	xchg	bx,MSG_OFF+SSDIFF
-	mov	byte ptr (bx),#0
+
+	cmp	dword ptr 0,#0x0b2d97f00		; magic header
+	; _must_ be 'jnz'!
+	jnz	iloop_10
+
+	push	cs
+	pop	ds
+
+	; graphical message
+#if 0
+; no alternative text message for now
+	mov	dword showit,message_offset_relative_to_SYSSEG
+#endif
+	call	gfx_init
+	push	cs
+	pop	es
+	cmp	byte gfx_ok,#0
+	jz	iloop
+	call	gfx_setup_menu
+iloop_gfx:
+	push	cs
+	pop	es
+	call	gfx_input
+	cmp	ax,#1
+	jz	iloop		; text mode
+	jmp	near boot
+
+	; normal text message
+iloop_10:
+	; keep the zero flag!
+	mov     byte ptr (bx),#0
+	push	cs
+	pop	ds
+
+iloop_20:
+#ifdef MENU
+	pushf
+	call	menu_setup
+	popf
+#endif
+	jnz	totxt
+
+	mov	ax,showit
+	mov	dx,showit+2
+	mov	bx,ax
+	or	bx,dx
+	jz	iloop_40
+	push	ds
+	shl	dx,12
+	mov	bx,ax
+	and	bx,#0xf
+	shr 	ax,4
+	add	ax,dx
+	add	ax,#SYSSEG
+	mov	ds,ax
+	call	say
+	pop	ds
+	xor	ax,ax
+	mov	showit,ax
+	mov	showit+2,ax
+iloop_40:
+
+	jmp nomsg
+
+showit:
+	.long	0
+
+totxt:
+	push	#SYSSEG
+	pop	ds
 	xor	bx,bx		! display the message
 	call	say
 
@@ -554,7 +639,6 @@
 	inc	si
 	jmp	gotinp		! go on
 	
-tolist:	br	list		! ...
 
 kbinp:	mov	cx,#brto	! get a key
 	call	getkey
@@ -575,18 +659,29 @@
 	je	tolist		! yes -> list images
 	or	al,al		! NUL ?
 	je	nul		! yes -> go on
-	cmp	al,#13		! CR ?
-	je	cr		! yes -> go on
 	cmp	al,#8		! BS ?
 	je	todelch		! yes -> erase one character
 	cmp	al,#127		! DEL ?
 	je	todelch		! yes -> erase one character
 	ja	input		! non-printable -> ignore it
+	cmp	al,#13		! CR ?
+	je	cr		! yes -> go on
 	cmp	al,#21		! ^U ?
 	je	todell		! yes -> erase the line
-	cmp	al,#24		! ^X ?
-	je	todell		! yes -> erase the line
-	cmp	al,#32		! ignore non-printable characters except space
+!	cmp	al,#27		! Esc?
+!	jne	nogrph		! No -> continue
+	
+!	seg	cs
+!	cmp	grphmode, #$FF	! Yes -> check if graphics mode
+!	jne	nogrph		!
+!	br	togrph		! If graphics mode, go back to screen
+	
+nogrph:		cmp al,#24	! ^X?
+	jne	suitek		! yes -> flame mode
+!	call	flamme
+	br	toinput
+	
+suitek:		cmp al,#32	! ignore non-printable chars except space
 	jb	input
 	ja	noblnk		! no space -> go on
 	cmp	(bx-1),al	! second space in a row ?
@@ -626,6 +721,7 @@
 
 todelch:br	delch		! ...
 todell:	br	delline		! ...
+tolist:	br	list		! ...
 
 ! End of input, process the command line
 
@@ -869,11 +965,19 @@
 	jz	dopw		! no -> get the password
 	cmp	byte ptr (si),#0! are there any options ?
 	jne	dopw		! yes -> password required
-toboot:	jmp	doboot		! ...
+toboot:	jmp	near doboot	! ...
 dopw:	push	bx		! save the image descriptor
 	lea	si,(bx+MAX_IMAGE_NAME+1) ! get a pointer to the password string
 	seg	fs		! disable timeout
 	mov	DSC_OFF-10+SSDIFF,#0xffff
+	cmp	byte gfx_ok,#0
+	jz	dopw_nogfx
+	mov	di,bx
+	call	gfx_password
+	pop	bx
+	jnc	toboot
+	jmp	near iloop
+dopw_nogfx:
 	mov	bx,#msg_pw	! display a prompt
 	call	say
 pwagain:xor	cl,cl		! CL counts characters after a mismatch
@@ -932,7 +1036,9 @@
 
 ! Boot the image BX points to
 
-doboot:	mov	byte ptr prechr,#61 ! switch to equal sign
+doboot:
+	call	gfx_done
+	mov	byte ptr prechr,#61 ! switch to equal sign
 	push	bx		! save image descr
 	mov	bx,#msg_l	! say hi
 	call	say
@@ -2188,7 +2294,9 @@
 	je	mldivl		! yes -> divide
 	cmp	byte ptr (si),#32
 ;;;	je	mldivl		! yes -> divide
-	jne	s2lbad		! trouble
+;	jne	s2lbad		! trouble
+	je	mldivl
+	br	s2lbad
 mldivl:	shr	dx,1		! shr DX:AX,1
 	rcr	ax,1
 	loop	mldivl		! ten times
@@ -2205,6 +2313,8 @@
 	pop	si		! restore SI
 	ret			! done
 
+
+#include	"gfxlogo.S"
 
 strtoul:          /* string to unsigned long in DX:AX */
 	xor     ax,ax
--- lilo-21.7.5/gfxlogo.S	Sun Sep  9 13:50:36 2001
+++ lilo-21.7.5.new/gfxlogo.S	Sun Sep  9 13:35:10 2001
@@ -32,6 +32,7 @@
 gfx_sysconfig:
 gfx_sc_vmode:		.byte 0
 gfx_sc_modes:		.byte 0
+gfx_bootloader:		.byte 0
 
 gfx_password_buf:	.blkb 32
 gfx_msg_wrong_image:	.ascii "Could not find kernel image: "
@@ -102,8 +103,11 @@
 		cmp dword (bx),#0x0b2d97f00	; header.magic_id
 		jnz near gfx_init_80
 		seg es
-		cmp byte (bx+4),#1		; header.version
-		jnz near gfx_init_80
+		mov al,(bx+4)			; header.version
+		cmp al,#1
+		jb near gfx_init_80
+		cmp al,#2
+		ja near gfx_init_80
 
 		seg es
 		mov eax,(bx+8)
--- lilo-21.7.5/gfxlogo.S	Mon Sep 10 17:41:24 2001
+++ lilo-21.7.5.new/gfxlogo.S	Mon Sep 10 17:35:07 2001
@@ -76,6 +76,11 @@
 
 		mov byte gfx_ok,#0
 
+		; no gfx if we use a serial line
+		seg fs
+		cmp byte DSC_OFF-6+SSDIFF,#0
+		jnz near gfx_init_90
+
 		; define our memory area
 		; gfx_mem _must_ be 16-byte aligned
 		mov dword gfx_mem,#0x10000
