diff -N -u -r procps-2.0.7.orig/Makefile procps-2.0.7/Makefile
--- procps-2.0.7.orig/Makefile	Thu Jul 13 22:22:58 2000
+++ procps-2.0.7/Makefile	Wed Aug 29 21:12:04 2001
@@ -4,7 +4,7 @@
 export PREFIX     =  #proc# prefix for program names
 
 export DESTDIR    = /
-export MANDIR     =  /usr/man
+export MANDIR     =  /usr/share/man
 export MAN1DIR    =  $(DESTDIR)$(MANDIR)/man1
 export MAN5DIR    =  $(DESTDIR)$(MANDIR)/man5
 export MAN8DIR    =  $(DESTDIR)$(MANDIR)/man8
diff -N -u -r procps-2.0.7.orig/kill.1 procps-2.0.7/kill.1
--- procps-2.0.7.orig/kill.1	Tue Jul 11 19:22:44 2000
+++ procps-2.0.7/kill.1	Wed Aug 29 21:10:20 2001
@@ -1,4 +1,4 @@
-,\" t
+'\" t
 .\" (The preceding line is a note to broken versions of man to tell
 .\" them to pre-process this man page with tbl)
 .\" Man page for kill.
@@ -16,7 +16,6 @@
 kill signal pid ...	Send a signal to every process listed.
 kill -s signal pid ...	Send a signal to every process listed.
 kill -l	List all signal names.
-kill -L	List all signal names in a nice table.
 kill -l signal	Convert a signal number into a name.
 .TE
 
@@ -81,8 +80,6 @@
 kill -9 -1
 .br
 kill -l 11
-.br
-kill -L
 .br
 kill 123 543 2341 3453
 
diff -N -u -r procps-2.0.7.orig/oldps.c procps-2.0.7/oldps.c
--- procps-2.0.7.orig/oldps.c	Wed Mar 17 00:06:38 1999
+++ procps-2.0.7/oldps.c	Wed Aug 29 21:25:02 2001
@@ -422,7 +422,8 @@
 }
 
 void show_user(char *s, proc_t *p) {
-    long pmem, total_time, seconds;
+    long pmem, total_time;
+    long long seconds;
     time_t start;
     unsigned int pcpu;
 
diff -N -u -r procps-2.0.7.orig/pgrep.c procps-2.0.7/pgrep.c
--- procps-2.0.7.orig/pgrep.c	Tue Jul 11 19:18:30 2000
+++ procps-2.0.7/pgrep.c	Wed Aug 29 21:10:20 2001
@@ -70,9 +70,9 @@
 usage (int opt)
 {
 	if (i_am_pkill)
-		fprintf (stderr, "Usage: pgrep [-flnvx] [-d DELIM] ");
-	else
 		fprintf (stderr, "Usage: pkill [-SIGNAL] [-fnvx] ");
+	else
+		fprintf (stderr, "Usage: pgrep [-flnvx] [-d DELIM] ");
 	fprintf (stderr, "[-P PPIDLIST] [-g PGRPLIST] [-s SIDLIST]\n"
 		 "\t[-u EUIDLIST] [-U UIDLIST] [-G GIDLIST] [-t TERMLIST] "
 		 "[PATTERN]\n");
diff -N -u -r procps-2.0.7.orig/proc/readproc.c procps-2.0.7/proc/readproc.c
--- procps-2.0.7.orig/proc/readproc.c	Mon Jul 10 21:55:39 2000
+++ procps-2.0.7/proc/readproc.c	Wed Aug 29 21:10:19 2001
@@ -303,7 +303,7 @@
 proc_t* readproc(PROCTAB* PT, proc_t* rbuf) {
     static struct direct *ent;		/* dirent handle */
     static struct stat sb;		/* stat buffer */
-    static char path[32], sbuf[512];	/* bufs for stat,statm */
+    static char path[32], sbuf[1024];	/* bufs for stat,statm */
     int allocated = 0, matched = 0;	/* flags */
     proc_t *p = NULL;
 
@@ -403,7 +403,7 @@
 proc_t* ps_readproc(PROCTAB* PT, proc_t* rbuf) {
     static struct direct *ent;		/* dirent handle */
     static struct stat sb;		/* stat buffer */
-    static char path[32], sbuf[512];	/* bufs for stat,statm */
+    static char path[32], sbuf[1024];	/* bufs for stat,statm */
     int allocated = 0 /* , matched = 0 */ ;	/* flags */
     proc_t *p = NULL;
 
diff -N -u -r procps-2.0.7.orig/proc/sysinfo.c procps-2.0.7/proc/sysinfo.c
--- procps-2.0.7.orig/proc/sysinfo.c	Mon Jul 10 21:36:13 2000
+++ procps-2.0.7/proc/sysinfo.c	Wed Aug 29 21:10:19 2001
@@ -13,6 +13,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <locale.h>
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -62,12 +63,17 @@
 /***********************************************************************/
 int uptime(double *uptime_secs, double *idle_secs) {
     double up=0, idle=0;
+    char *savelocale;
 
     FILE_TO_BUF(UPTIME_FILE,uptime_fd);
+    savelocale = setlocale(LC_NUMERIC, NULL);
+    setlocale(LC_NUMERIC,"C");
     if (sscanf(buf, "%lf %lf", &up, &idle) < 2) {
+        setlocale(LC_NUMERIC,savelocale);
 	fprintf(stderr, "bad data in " UPTIME_FILE "\n");
 	return 0;
     }
+    setlocale(LC_NUMERIC,savelocale);
     SET_IF_DESIRED(uptime_secs, up);
     SET_IF_DESIRED(idle_secs, idle);
     return up;	/* assume never be zero seconds in practice */
@@ -121,6 +127,8 @@
     FILE_TO_BUF(UPTIME_FILE,uptime_fd);  sscanf(buf, "%lf", &up_2);
     /* uptime(&up_2, NULL); */
   } while((long)( (up_2-up_1)*1000.0/up_1 )); /* want under 0.1% error */
+  setlocale(LC_NUMERIC, savelocale);
+  
   jiffies = user_j + nice_j + sys_j + other_j;
   seconds = (up_1 + up_2) / 2;
   h = (unsigned long)( (double)jiffies/seconds );
@@ -171,12 +179,16 @@
 /***********************************************************************/
 int loadavg(double *av1, double *av5, double *av15) {
     double avg_1=0, avg_5=0, avg_15=0;
+    char *savelocale;
     
     FILE_TO_BUF(LOADAVG_FILE,loadavg_fd);
+    savelocale = setlocale(LC_NUMERIC, NULL);
+    setlocale(LC_NUMERIC, "C");
     if (sscanf(buf, "%lf %lf %lf", &avg_1, &avg_5, &avg_15) < 3) {
 	fprintf(stderr, "bad data in " LOADAVG_FILE "\n");
 	exit(1);
     }
+    setlocale(LC_NUMERIC, savelocale);
     SET_IF_DESIRED(av1,  avg_1);
     SET_IF_DESIRED(av5,  avg_5);
     SET_IF_DESIRED(av15, avg_15);
diff -N -u -r procps-2.0.7.orig/proc/whattime.c procps-2.0.7/proc/whattime.c
--- procps-2.0.7.orig/proc/whattime.c	Mon Apr 20 20:28:20 1998
+++ procps-2.0.7/proc/whattime.c	Wed Aug 29 21:10:19 2001
@@ -40,9 +40,10 @@
 
   time(&realseconds);
   realtime = localtime(&realseconds);
-  pos = sprintf(buf, " %2d:%02d%s  ",
-		realtime->tm_hour%12 ? realtime->tm_hour%12 : 12,
-		realtime->tm_min, realtime->tm_hour > 11 ? "pm" : "am");
+  pos = sprintf(buf, " %02d:%02d:%02d ",
+           realtime->tm_hour, realtime->tm_min, realtime->tm_sec);
+   
+
 
 /* read and calculate the amount of uptime */
 
diff -N -u -r procps-2.0.7.orig/ps/Makefile procps-2.0.7/ps/Makefile
--- procps-2.0.7.orig/ps/Makefile	Mon Jul 10 19:16:47 2000
+++ procps-2.0.7/ps/Makefile	Wed Aug 29 21:17:15 2001
@@ -30,7 +30,7 @@
 	install $(OWNERGROUP) --mode a=rx --strip ps $(BINDIR)/ps
 	install $(OWNERGROUP) --mode a=r ps.1 $(MAN1DIR)/ps.1
 	# The following does no harm and on older systems might help
-	rm -f /var/catman/cat1/ps.1.gz /var/man/cat1/ps.1.gz
+	#rm -f /var/catman/cat1/ps.1.gz /var/man/cat1/ps.1.gz
 
 clean:
 	rm -f *.o DEADJOE *~ core ps gmon.out
diff -N -u -r procps-2.0.7.orig/ps/Makefile~ procps-2.0.7/ps/Makefile~
--- procps-2.0.7.orig/ps/Makefile~	Thu Jan  1 01:00:00 1970
+++ procps-2.0.7/ps/Makefile~	Mon Jul 10 19:16:47 2000
@@ -0,0 +1,36 @@
+all: ps
+
+ps: escape.o global.o help.o select.o sortformat.o output.o parser.o display.o
+	$(CC) -o ps   escape.o global.o help.o select.o sortformat.o output.o parser.o display.o -L../proc -lproc
+
+# This just adds the stacktrace code
+debug: escape.o global.o help.o select.o sortformat.o output.o parser.o display.o stacktrace.o
+	$(CC) -o ps   escape.o global.o help.o select.o sortformat.o output.o parser.o display.o stacktrace.o -L../proc -lproc -lefence
+
+sortformat.o: sortformat.c common.h
+
+global.o: global.c common.h
+
+escape.o: escape.c
+
+help.o: help.c
+
+select.o: select.c common.h
+
+output.o: output.c common.h
+
+parser.o: parser.c common.h
+
+display.o: display.c common.h
+
+stacktrace.o: stacktrace.c
+
+
+install: ps
+	install $(OWNERGROUP) --mode a=rx --strip ps $(BINDIR)/ps
+	install $(OWNERGROUP) --mode a=r ps.1 $(MAN1DIR)/ps.1
+	# The following does no harm and on older systems might help
+	rm -f /var/catman/cat1/ps.1.gz /var/man/cat1/ps.1.gz
+
+clean:
+	rm -f *.o DEADJOE *~ core ps gmon.out
diff -N -u -r procps-2.0.7.orig/ps/output.c procps-2.0.7/ps/output.c
--- procps-2.0.7.orig/ps/output.c	Tue Jul 11 20:37:46 2000
+++ procps-2.0.7/ps/output.c	Wed Aug 29 21:22:57 2001
@@ -39,7 +39,7 @@
  * Table 5 could go in a file with the output functions.
  */
 
- 
+
 /* proc_t offset macro */
 #define PO(q) ((unsigned long)(&(((proc_t*)0)->q)))
 
@@ -437,9 +437,10 @@
  */
 
 static int pr_ruser(void){
-  if(user_is_number || (strlen(pp->ruser)>max_rightward))
-    return sprintf(outbuf, "%d", pp->ruid);
-  return sprintf(outbuf, "%s", pp->ruser);
+  int width = COLWID;
+  if(user_is_number) return snprintf(outbuf, COLWID, "%d", pp->ruid);
+  if (strlen(pp->ruser)>max_rightward) width = max_rightward;
+  return snprintf(outbuf, width, "%s", pp->ruser);
 }
 static int pr_egroup(void){
   if(strlen(pp->egroup)>max_rightward) return sprintf(outbuf, "%d", pp->egid);
@@ -450,8 +451,12 @@
   return sprintf(outbuf, "%s", pp->rgroup);
 }
 static int pr_euser(void){
-  if(user_is_number || (strlen(pp->euser)>max_rightward)) return sprintf(outbuf, "%d", pp->euid);
-  return sprintf(outbuf, "%s", pp->euser);
+  int width = COLWID;
+  if(user_is_number) return snprintf(outbuf, COLWID, "%d", pp->euid);
+  if (strlen(pp->euser)>max_rightward) width = max_rightward;
+  return snprintf(outbuf, width, "%s", pp->euser);
+  /*if(user_is_number || (strlen(pp->euser)>max_rightward)) return sprintf(outbuf, "%d", pp->euid);
+  return sprintf(outbuf, "%s", pp->euser);*/
 }
 
 /********* maybe standard (Unix98 only defines the header) **********/
@@ -810,12 +815,16 @@
   return sprintf(outbuf, "%s", pp->sgroup);
 }
 static int pr_fuser(void){
-  if(user_is_number || (strlen(pp->fuser)>max_rightward)) return sprintf(outbuf, "%d", pp->fuid);
-  return sprintf(outbuf, "%s", pp->fuser);
+  int width = COLWID;
+  if(user_is_number) return snprintf(outbuf, COLWID, "%d", pp->fuid);
+  if (strlen(pp->fuser)>max_rightward) width = max_rightward;
+  return snprintf(outbuf, width, "%s", pp->fuser);
 }
 static int pr_suser(void){
-  if(user_is_number || (strlen(pp->suser)>max_rightward)) return sprintf(outbuf, "%d", pp->suid);
-  return sprintf(outbuf, "%s", pp->suser);
+  int width = COLWID;
+  if(user_is_number) return snprintf(outbuf, COLWID, "%d", pp->suid);
+  if (strlen(pp->suser)>max_rightward) width = max_rightward;
+  return snprintf(outbuf, width, "%s", pp->suser);
 }
 
 
diff -N -u -r procps-2.0.7.orig/ps/output.c~ procps-2.0.7/ps/output.c~
--- procps-2.0.7.orig/ps/output.c~	Thu Jan  1 01:00:00 1970
+++ procps-2.0.7/ps/output.c~	Tue Jul 11 20:37:46 2000
@@ -0,0 +1,1492 @@
+/*
+ * Copyright 1999 by Albert Cahalan; all rights resered.
+ *
+ * This file may be used subject to the terms and conditions of the
+ * GNU Library General Public License Version 2, or any later version
+ * at your option, as published by the Free Software Foundation.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Library General Public License for more details.
+ */
+
+/*
+ * This file is really gross, and I know it. I looked into several
+ * alternate ways to deal with the mess, and they were all ugly.
+ *
+ * FreeBSD has a fancy hack using offsets into a struct -- that
+ * saves code but it is _really_ gross. See the PO macro below.
+ *
+ * We could have a second column width for wide output format.
+ * For example, Digital prints the real-time signals.
+ */
+
+
+/*
+ * Data table idea:
+ *
+ * table 1 maps aix to specifier
+ * table 2 maps shortsort to specifier
+ * table 3 maps macro to specifiers
+ * table 4 maps specifier to title,datatype,offset,vendor,helptext
+ * table 5 maps datatype to justification,width,widewidth,sorting,printing
+ *
+ * Here, "datatype" could be user,uid,u16,pages,deltaT,signals,tty,longtty...
+ * It must be enough to determine printing and sorting.
+ *
+ * After the tables, increase width as needed to fit the header.
+ *
+ * Table 5 could go in a file with the output functions.
+ */
+
+ 
+/* proc_t offset macro */
+#define PO(q) ((unsigned long)(&(((proc_t*)0)->q)))
+
+#include <ctype.h>
+#include <fcntl.h>
+#include <grp.h>
+#include <limits.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/resource.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <time.h>
+#include <unistd.h>
+
+#include "../proc/readproc.h"
+#include "../proc/sysinfo.h"
+#include "../proc/status.h"
+#include "../proc/procps.h"
+#include "../proc/devname.h"
+#include "common.h"
+
+
+/* TODO:
+ * Stop assuming system time is local time.
+ */
+
+static char  whitespace_and_outbuf[OUTBUF_SIZE + SPACE_AMOUNT + PAGE_SIZE*2];
+static char *outbuf = whitespace_and_outbuf+SPACE_AMOUNT;
+static char *whitespace = whitespace_and_outbuf;
+static unsigned max_rightward = 0x12345678; /* space for RIGHT stuff */
+static unsigned max_leftward = 0x12345678; /* space for LEFT stuff */
+
+static int wide_signals;  /* true if we have room */
+
+static proc_t *pp;     /* the process being printed */
+
+unsigned long seconds_since_boot;
+static unsigned long seconds_since_1970;
+static unsigned long time_of_boot;
+static unsigned long bytes_main_memory;
+static unsigned long page_shift;
+
+
+/*************************************************************************/
+/************ Lots of sort functions, starting with the NOP **************/
+
+static int sr_nop(const proc_t* a, const proc_t* b){
+  (void)a;(void)b; /* shut up gcc */
+  return 0;
+}
+
+#define CMP_STR(NAME) \
+static int sr_ ## NAME(const proc_t* P, const proc_t* Q) { \
+    return strcmp(P-> ## NAME, Q-> ## NAME); \
+}
+
+#define CMP_INT(NAME) \
+static int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \
+    if (P-> ## NAME < Q-> ## NAME) return -1; \
+    if (P-> ## NAME > Q-> ## NAME) return  1; \
+    return 0; \
+}
+
+CMP_INT(cutime)
+CMP_INT(cstime)
+CMP_INT(priority)                                             /* nice */
+CMP_INT(timeout)
+CMP_INT(nice)                                                 /* priority */
+CMP_INT(rss)      /* resident set size from stat file */ /* vm_rss, resident */
+CMP_INT(it_real_value)
+CMP_INT(size)      /* total pages */                     /* vm_size, vsize */
+CMP_INT(resident)  /* resident pages */                     /* vm_rss, rss */
+CMP_INT(share)     /* shared pages */
+CMP_INT(trs)       /* executable pages */
+CMP_INT(lrs)       /* obsolete "library" pages above 0x60000000 */
+CMP_INT(drs)       /* other pages (assumed data?) */
+CMP_INT(dt)        /* dirty pages */
+
+CMP_INT(vm_size)    /* kB VM */                             /* size, vsize */
+CMP_INT(vm_lock)    /* kB locked */
+CMP_INT(vm_rss)     /* kB rss */                          /* rss, resident */
+CMP_INT(vm_data)    /* kB "data" == data-stack */
+CMP_INT(vm_stack)   /* kB stack */
+CMP_INT(vm_exe)     /* kB "exec" == exec-lib */
+CMP_INT(vm_lib)     /* kB "libraries" */
+CMP_INT(vsize)      /* pages VM */                        /* size, vm_size */
+CMP_INT(rss_rlim)
+CMP_INT(flags)
+CMP_INT(min_flt)
+CMP_INT(maj_flt)
+CMP_INT(cmin_flt)
+CMP_INT(cmaj_flt)
+CMP_INT(nswap)
+CMP_INT(cnswap)
+CMP_INT(utime)
+CMP_INT(stime)    /* Old: sort by systime. New: show start time. Uh oh. */
+CMP_INT(start_code)
+CMP_INT(end_code)
+CMP_INT(start_stack)
+CMP_INT(kstk_esp)
+CMP_INT(kstk_eip)
+CMP_INT(start_time)
+CMP_INT(wchan)
+
+/* CMP_STR(*environ) */
+/* CMP_STR(*cmdline) */
+
+CMP_STR(ruser)
+CMP_STR(euser)
+CMP_STR(suser)
+CMP_STR(fuser)
+CMP_STR(rgroup)
+CMP_STR(egroup)
+CMP_STR(sgroup)
+CMP_STR(fgroup)
+CMP_STR(cmd)
+/* CMP_STR(ttyc) */    /* FIXME -- use strncmp with 8 max */
+
+CMP_INT(ruid)
+CMP_INT(rgid)
+CMP_INT(euid)
+CMP_INT(egid)
+CMP_INT(suid)
+CMP_INT(sgid)
+CMP_INT(fuid)
+CMP_INT(fgid)
+CMP_INT(pid)
+CMP_INT(ppid)
+CMP_INT(pgrp)
+CMP_INT(session)
+CMP_INT(tty)
+CMP_INT(tpgid)
+
+CMP_INT(pcpu)
+
+CMP_INT(state)
+
+/***************************************************************************/
+/************ Lots of format functions, starting with the NOP **************/
+
+static int pr_nop(void){
+  return sprintf(outbuf, "%c", '-');
+}
+
+
+/********* Unix 98 ************/
+
+/***
+
+Only comm and args are allowed to contain blank characters; all others are
+not. Any implementation-dependent variables will be specified in the system
+documentation along with the default header and indicating if the field
+may contain blank characters.
+
+Some headers do not have a standardized specifier!
+
+%CPU	pcpu	The % of cpu time used recently, with unspecified "recently".
+ADDR		The address of the process.
+C		Processor utilisation for scheduling.
+CMD		The command name, or everything with -f.
+COMMAND	args	Command + args. May chop as desired. May use either version.
+COMMAND	comm	argv[0]
+ELAPSED	etime	Elapsed time since the process was started. [[dd-]hh:]mm:ss
+F		Flags (octal and additive)
+GROUP	group	Effective group ID, prefer text over decimal.
+NI	nice	Decimal system scheduling priority, see nice(1).
+PGID	pgid	The decimal value of the process group ID.
+PID	pid	Decimal PID.
+PPID	ppid	Decimal PID.
+PRI		Priority. Higher numbers mean lower priority.
+RGROUP	rgroup	Real group ID, prefer text over decimal.
+RUSER	ruser	Real user ID, prefer text over decimal.
+S		The state of the process.
+STIME		Starting time of the process.
+SZ		The size in blocks of the core image of the process.
+TIME	time	Cumulative CPU time. [dd-]hh:mm:ss
+TT	tty	Name of tty in format used by who(1).
+TTY		The controlling terminal for the process.
+UID		UID, or name when -f
+USER	user	Effective user ID, prefer text over decimal.
+VSZ	vsz	Virtual memory size in decimal kB.
+WCHAN		Where waiting/sleeping or blank if running.
+
+The nice value is used to compute the priority.
+
+For some undefined ones, Digital does:
+
+F       flag    Process flags -- but in hex!
+PRI     pri     Process priority
+S       state   Symbolic process status
+TTY     tt,tty,tname,longtname  -- all do "ttyp1", "console", "??"
+UID     uid     Process user ID (effective UID)
+WCHAN   wchan   Address of event on which a
+
+For some undefined ones, Sun does:
+
+ADDR	addr	memory address of the process
+C	c	Processor utilization  for  scheduling  (obsolete).
+CMD
+F	f
+S	s	state: OSRZT
+STIME		start time, printed w/o blanks. If 24h old, months & days
+SZ		size (in pages) of the swappable process's image in main memory
+TTY
+UID	uid
+WCHAN	wchan
+
+For some undefined ones, SCO does:
+ADDR	addr	Virtual address of the process' entry in the process table.
+SZ		swappable size in kB of the virtual data and stack
+STIME	stime	hms or md time format
+***/
+
+/* Source & destination are known. Return bytes or screen characters? */
+static int forest_helper(void){
+  char *p = forest_prefix;
+  char *q = outbuf;
+  if(!*p) return 0;
+  /* Arrrgh! somebody defined unix as 1 */
+  if(forest_type == 'u') goto unixy;
+  p++;   /* don't show everything as init's child */
+  while(*p){
+    switch(*p){
+    case ' ': strcpy(q, "    ");  break;
+    case 'L': strcpy(q, " \\_ "); break;
+    case '+': strcpy(q, " \\_ "); break;
+    case '|': strcpy(q, " |  ");  break;
+    case '\0': return q-outbuf;    /* redundant & not used */
+    }
+    q += 4;
+    p++;
+  }
+  return q-outbuf;   /* gcc likes this here */
+unixy:
+  while(*p){
+    switch(*p){
+    case ' ': strcpy(q, "  "); break;
+    case 'L': strcpy(q, "  "); break;
+    case '+': strcpy(q, "  "); break;
+    case '|': strcpy(q, "  "); break;
+    case '\0': return q-outbuf;    /* redundant & not used */
+    }
+    q += 2;
+    p++;
+  }
+  return q-outbuf;   /* gcc likes this here */
+}
+
+
+/* XPG4-UNIX, according to Digital:
+The "args" and "command" specifiers show what was passed to the command.
+Modifications to the arguments are not shown.
+*/
+
+/*
+ * pp->cmd       short accounting name (comm & ucomm)
+ * pp->cmdline   long name with args (args & command)
+ * pp->environ   environment
+ */
+
+/* "command" is the same thing: long unless c */
+static int pr_args(void){
+  char *endp;
+  endp = outbuf + forest_helper();
+  if(bsd_c_option){
+    endp += escape_str(endp, pp->cmd, PAGE_SIZE); /* short version */
+  }else{
+    const char **lc = (const char**)pp->cmdline; /* long version */
+    if(lc && *lc) {
+      endp += escape_strlist(endp, lc, OUTBUF_SIZE);
+    } else {
+      char buf[ESC_STRETCH*PAGE_SIZE];
+      escape_str(buf, pp->cmd, ESC_STRETCH*PAGE_SIZE);
+      endp += sprintf(endp, "[%s]", buf);
+    }
+  }
+  if(bsd_e_option){
+    const char **env = (const char**)pp->environ;
+    if(env && *env){
+      *endp++ = ' ';
+      endp += escape_strlist(endp, env, OUTBUF_SIZE);
+    }
+  }
+  return endp - outbuf;
+}
+
+/* "ucomm" is the same thing: short unless -f */
+static int pr_comm(void){
+  char *endp;
+  endp = outbuf + forest_helper();
+  if(!unix_f_option){ /* does -f matter? */
+    endp += escape_str(endp, pp->cmd, PAGE_SIZE); /* short version */
+  }else{
+    const char **lc = (const char**)pp->cmdline; /* long version */
+    if(lc && *lc) {
+      endp += escape_strlist(endp, lc, OUTBUF_SIZE);
+    } else {
+      char buf[ESC_STRETCH*PAGE_SIZE];
+      escape_str(buf, pp->cmd, ESC_STRETCH*PAGE_SIZE);
+      endp += sprintf(endp, "[%s]", buf);
+    }
+  }
+  if(bsd_e_option){
+    const char **env = (const char**)pp->environ;
+    if(env && *env){
+      *endp++ = ' ';
+      endp += escape_strlist(endp, env, OUTBUF_SIZE);
+    }
+  }
+  return endp - outbuf;
+}
+/* Non-standard, from SunOS 5 */
+static int pr_fname(void){
+  char *endp;
+  endp = outbuf + forest_helper();
+  endp += escape_str(endp, pp->cmd, 8);
+  return endp - outbuf;
+}
+
+/* elapsed wall clock time, [[dd-]hh:]mm:ss format (not same as "time") */
+static int pr_etime(void){
+  unsigned t, dd,hh,mm,ss;
+  int c = 0;
+  t = (
+          ((unsigned long)seconds_since_boot)
+        - ((unsigned long)pp->start_time)
+        / Hertz
+      );
+  ss = t%60;
+  t /= 60;
+  mm = t%60;
+  t /= 60;
+  hh = t%24;
+  t /= 24;
+  dd = t;
+  c +=(      dd      ?  sprintf(outbuf, "%u-", dd)    :  sprintf(outbuf, "   ")   );
+  c +=(  (dd || hh)  ?  sprintf(outbuf+c, "%02u:", hh)  :  sprintf(outbuf+c, "   ")   );
+  c +=(                 sprintf(outbuf+c, "%02u:%02u", mm, ss)             );
+  return c;
+}
+static int pr_nice(void){
+  return sprintf(outbuf, "%ld", pp->nice);
+}
+
+/* "Processor utilisation for scheduling."  --- we use %cpu w/o fraction */
+static int pr_c(void){
+  return sprintf(outbuf, "%2u", (unsigned)(pp->pcpu / 10));
+}
+static int pr_pcpu(void){
+  return sprintf(outbuf, "%2u.%u",
+  		(unsigned)(pp->pcpu / 10), (unsigned)(pp->pcpu % 10));
+}
+static int pr_pgid(void){
+  return sprintf(outbuf, "%u", pp->pgrp);
+}
+static int pr_pid(void){
+  return sprintf(outbuf, "%u", pp->pid);
+}
+static int pr_ppid(void){
+  return sprintf(outbuf, "%u", pp->ppid);
+}
+
+
+/* cumulative CPU time, [dd-]hh:mm:ss format (not same as "etime") */
+static int pr_time(void){
+  int t, dd,hh,mm,ss;
+  int c = 0;
+  t = pp->utime + pp->stime;
+  t /= Hertz;
+  ss = t%60;
+  t /= 60;
+  mm = t%60;
+  t /= 60;
+  hh = t%24;
+  t /= 24;
+  dd = t;
+  c +=( dd ? sprintf(outbuf, "%d-", dd) : 0              );
+  c +=( sprintf(outbuf+c, "%02d:%02d:%02d", hh, mm, ss)    );
+  return c;
+}
+
+/* HP-UX puts this in kB and uses "sz" for pages */
+static int pr_vsz(void){
+  return sprintf(outbuf, "%lu", pp->vm_size);
+}
+
+/*
+ * internal terms:  ruid  euid  suid  fuid
+ * kernel vars:      uid  euid  suid fsuid
+ * command args:    ruid   uid svuid   n/a
+ */
+
+static int pr_ruser(void){
+  if(user_is_number || (strlen(pp->ruser)>max_rightward))
+    return sprintf(outbuf, "%d", pp->ruid);
+  return sprintf(outbuf, "%s", pp->ruser);
+}
+static int pr_egroup(void){
+  if(strlen(pp->egroup)>max_rightward) return sprintf(outbuf, "%d", pp->egid);
+  return sprintf(outbuf, "%s", pp->egroup);
+}
+static int pr_rgroup(void){
+  if(strlen(pp->rgroup)>max_rightward) return sprintf(outbuf, "%d", pp->rgid);
+  return sprintf(outbuf, "%s", pp->rgroup);
+}
+static int pr_euser(void){
+  if(user_is_number || (strlen(pp->euser)>max_rightward)) return sprintf(outbuf, "%d", pp->euid);
+  return sprintf(outbuf, "%s", pp->euser);
+}
+
+/********* maybe standard (Unix98 only defines the header) **********/
+
+
+/*
+ * "PRI" is created by "opri", or by "pri" when -c is used.
+ *
+ * Unix98 only specifies that a high "PRI" is low priority.
+ * Sun and SCO add the -c behavior. Sun defines "pri" and "opri".
+ * Linux may use "priority" for historical purposes.
+ */
+static int pr_priority(void){    /* -20..20 */
+    return sprintf(outbuf, "%ld", pp->priority);
+}
+static int pr_pri(void){         /* 20..60 */
+    return sprintf(outbuf, "%ld", 39 - pp->priority);
+}
+static int pr_opri(void){        /* 39..79 */
+    return sprintf(outbuf, "%ld", 60 + pp->priority);
+}
+
+static int pr_wchan(void){
+/*
+ * Unix98 says "blank if running" and also "no blanks"! :-(
+ * Unix98 also says to use '-' if something is meaningless.
+ * Digital uses both '*' and '-', with undocumented differences.
+ * (the '*' for -1 (rare) and the '-' for 0)
+ * Sun claims to use a blank AND use '-', in the same man page.
+ * Perhaps "blank" should mean '-'.
+ *
+ * AIX uses '-' for running processes, the location when there is
+ * only one thread waiting in the kernel, and '*' when there is
+ * more than one thread waiting in the kernel.
+ */
+    if(!(pp->wchan & 0xffffff)) return sprintf(outbuf, "%s", "-");
+    if(wchan_is_number) return sprintf(outbuf, "%lx", pp->wchan & 0xffffff);
+    return sprintf(outbuf, "%s", wchan(pp->wchan));
+}
+
+/* Terrible trunctuation, like BSD crap uses: I999 J999 K999 */
+/* FIXME: disambiguate /dev/tty69 and /dev/pts/69. */
+static int pr_tty4(void){
+/* sprintf(outbuf, "%02x:%02x", pp->tty>>8, pp->tty&0xff); */
+  return dev_to_tty(outbuf, 4, pp->tty, pp->pid, ABBREV_DEV|ABBREV_TTY|ABBREV_PTS);
+}
+
+/* Unix98: format is unspecified, but must match that used by who(1). */
+static int pr_tty8(void){
+/* sprintf(outbuf, "%02x:%02x", pp->tty>>8, pp->tty&0xff); */
+  return dev_to_tty(outbuf, PAGE_SIZE-1, pp->tty, pp->pid, ABBREV_DEV);
+}
+
+#if 0
+/* This BSD state display may contain spaces, which is illegal. */
+static int pr_oldstate(void){
+    return sprintf(outbuf, "%s", status(pp));
+}
+#endif
+
+/* This state display is Unix98 compliant and has lots of info like BSD. */
+static int pr_stat(void){
+    int end = 0;
+    outbuf[end++] = pp->state;
+    if(pp->rss == 0 && pp->state != 'Z')    outbuf[end++] = 'W';
+    if(pp->nice < 0)                        outbuf[end++] = '<';
+    if(pp->nice > 0)                        outbuf[end++] = 'N';
+    if(pp->vm_lock)                         outbuf[end++] = 'L';
+    outbuf[end] = '\0';
+    return end;
+}
+
+/* This minimal state display is Unix98 compliant, like SCO and SunOS 5 */
+static int pr_s(void){
+    outbuf[0] = pp->state;
+    outbuf[1] = '\0';
+    return 1;
+}
+
+static int pr_flag(void){
+    /* Unix98 requires octal -- good thing Linux hex looks octal! */
+    return sprintf(outbuf, "%03lx", (pp->flags)&0x777);
+}
+
+static int pr_euid(void){
+  return sprintf(outbuf, "%d", pp->euid);
+}
+
+/*********** non-standard ***********/
+
+/*** BSD
+sess	session pointer
+(SCO has:Process session leader ID as a decimal value. (SESSION))
+jobc	job control count
+cpu	short-term cpu usage factor (for scheduling)
+sl	sleep time (in seconds; 127 = infinity)
+re	core residency time (in seconds; 127 = infinity)
+pagein	pageins (same as majflt)
+lim	soft memory limit
+tsiz	text size (in Kbytes)
+***/
+
+static int pr_stackp(void){
+    return sprintf(outbuf, "%08lx", pp->start_stack);
+}
+
+static int pr_esp(void){
+    return sprintf(outbuf, "%08lx", pp->kstk_esp);
+}
+
+static int pr_eip(void){
+    return sprintf(outbuf, "%08lx", pp->kstk_eip);
+}
+
+/* This function helps print old-style time formats */
+static int old_time_helper(char *dst, unsigned long t, unsigned long rel) {
+    if(!t)      return sprintf(dst, "    -");
+    if((long)t == -1) return sprintf(dst, "   xx");
+    if((long)(t-=rel) < 0)  t=0;
+    if(t>9999)  return sprintf(dst, "%5lu", t/100);
+    else        return sprintf(dst, "%2lu.%02lu", t/100, t%100);
+}
+
+static int pr_bsdtime(void){
+    unsigned long t;
+    t = pp->utime + pp->stime;
+    if(include_dead_children) t += (pp->cutime + pp->cstime);
+    t /= Hertz;
+    return sprintf(outbuf, "%3ld:%02d", t/60, (int)(t%60));
+}
+
+static int pr_bsdstart(void){
+  time_t start;
+  time_t seconds_ago;
+  start = time_of_boot + pp->start_time/Hertz;
+  seconds_ago = seconds_since_1970 - start;
+  if(seconds_ago < 0) seconds_ago=0;
+  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
+  else                       strcpy(outbuf, ctime(&start)+10);
+  outbuf[6] = '\0';
+  return 6;
+}
+
+static int pr_timeout(void){
+    return old_time_helper(outbuf, pp->timeout, seconds_since_boot*Hertz);
+}
+
+static int pr_alarm(void){
+    return old_time_helper(outbuf, pp->it_real_value, 0);
+}
+
+/* HP-UX puts this in pages and uses "vsz" for kB */
+static int pr_sz(void){
+  return sprintf(outbuf, "%lu", (pp->vm_size)/(PAGE_SIZE/1024));
+}
+
+
+/*
+ * FIXME: trs,drs,tsiz,dsiz,m_trs,m_drs,vm_exe,vm_data,trss
+ * I suspect some/all of those are broken. They seem to have been
+ * inherited by Linux and AIX from early BSD systems. FreeBSD only
+ * retains tsiz. The prefixed versions come from Debian.
+ * Sun and Digital have none of this crap. The code here comes
+ * from an old Linux ps, and might not be correct for ELF executables.
+ *
+ * AIX            TRS    size of resident-set (real memory) of text
+ * AIX            TSIZ   size of text (shared-program) image
+ * FreeBSD        tsiz   text size (in Kbytes)
+ * 4.3BSD NET/2   trss   text resident set size (in Kbytes)
+ * 4.3BSD NET/2   tsiz   text size (in Kbytes)
+ */
+
+/* kB data size. See drs, tsiz & trs. */
+static int pr_dsiz(void){
+    long dsiz = 0;
+    if(pp->vsize) dsiz += (pp->vsize - pp->end_code + pp->start_code) >> 10;
+    return sprintf(outbuf, "%ld", dsiz);
+}
+
+/* kB text (code) size. See trs, dsiz & drs. */
+static int pr_tsiz(void){
+    long tsiz = 0;
+    if(pp->vsize) tsiz += (pp->end_code - pp->start_code) >> 10;
+    return sprintf(outbuf, "%ld", tsiz);
+}
+
+/* kB _resident_ data size. See dsiz, tsiz & trs. */
+static int pr_drs(void){
+    long drs = 0;
+    if(pp->vsize) drs += (pp->vsize - pp->end_code + pp->start_code) >> 10;
+    return sprintf(outbuf, "%ld", drs);
+}
+
+/* kB text _resident_ (code) size. See tsiz, dsiz & drs. */
+static int pr_trs(void){
+    long trs = 0;
+    if(pp->vsize) trs += (pp->end_code - pp->start_code) >> 10;
+    return sprintf(outbuf, "%ld", trs);
+}
+
+
+
+static int pr_minflt(void){
+    long flt = pp->min_flt;
+    if(include_dead_children) flt += pp->cmin_flt;
+    return sprintf(outbuf, "%ld", flt);
+}
+
+static int pr_majflt(void){
+    long flt = pp->maj_flt;
+    if(include_dead_children) flt += pp->cmaj_flt;
+    return sprintf(outbuf, "%ld", flt);
+}
+
+static int pr_lim(void){
+    if(pp->rss_rlim == RLIM_INFINITY) return sprintf(outbuf, "%s", "xx");
+    return sprintf(outbuf, "%5ld", pp->rss_rlim >> 10);
+}
+
+static int pr_nwchan(void){
+    if(!(pp->wchan & 0xffffff)) return sprintf(outbuf, "-");
+    return sprintf(outbuf, "%lx", pp->wchan & 0xffffff);
+}
+
+static int pr_rss(void){
+  return sprintf(outbuf, "%lu", pp->rss << (page_shift - 10));
+}
+
+static int pr_pmem(void){
+  unsigned long pmem = 0;
+  pmem = pp->rss * 1000 / (bytes_main_memory >> page_shift);
+  return sprintf(outbuf, "%2u.%u", (unsigned)(pmem/10), (unsigned)(pmem%10));
+}
+
+static int pr_lstart(void){
+  time_t t;
+  t = (
+           ((unsigned long)time_of_boot)
+         + ((unsigned long)pp->start_time)
+         / Hertz
+  );
+  return sprintf(outbuf, "%24.24s", ctime(&t));
+}
+
+/* Unix98 specifies a STIME header for a column that shows the start
+ * time of the process, but does not specify a format or format specifier.
+ * From the general Unix98 rules, we know there must not be any spaces.
+ * Most systems violate that rule, though the Solaris documentation
+ * claims to print the column without spaces. (NOT!)
+ *
+ * So this isn't broken, but could be renamed to u98_std_stime,
+ * as long as it still shows as STIME when using the -f option.
+ */
+static int pr_stime(void){
+  struct tm *proc_time;
+  struct tm *our_time;
+  time_t t;
+  char *fmt;
+  int tm_year;
+  int tm_yday;
+  our_time = localtime(&seconds_since_1970);   /* not reentrant */
+  tm_year = our_time->tm_year;
+  tm_yday = our_time->tm_yday;
+  t = (time_t)(
+            ((unsigned long)time_of_boot)
+          + ((unsigned long)pp->start_time)
+          / Hertz
+  );
+  proc_time = localtime(&t); /* not reentrant, this corrupts our_time */
+  fmt = "%H:%M";                                   /* 03:02 23:59 */
+  if(tm_yday != proc_time->tm_yday) fmt = "%b%d";  /* Jun06 Aug27 */
+  if(tm_year != proc_time->tm_year) fmt = "%Y";    /* 1991 2001 */
+  return strftime(outbuf, 42, fmt, proc_time);
+}
+
+static int pr_start(void){
+  time_t t;
+  char *str;
+  t = (
+           ((unsigned long)time_of_boot)
+         + ((unsigned long)pp->start_time)
+         / Hertz
+  );
+  str = ctime(&t);
+  if(str[8]==' ')  str[8]='0';
+  if(str[11]==' ') str[11]='0';
+  if((unsigned long)t+60*60*24 > seconds_since_1970)
+    return sprintf(outbuf, "%8.8s", str+11);
+  return sprintf(outbuf, "  %6.6s", str+4);
+}
+
+
+#ifdef SIGNAL_STRING
+static int help_pr_sig(const char *sig){
+  long len = 0;
+  len = strlen(sig);
+  if(wide_signals){
+    if(len>8) return sprintf(outbuf, "%s", sig);
+    return sprintf(outbuf, "00000000%s", sig);
+  }
+  if(len-strspn(sig,"0") > 8)
+    return sprintf(outbuf, "<%s", sig+len-8);
+  return sprintf(outbuf,  "%s", sig+len-8);
+}
+#else
+static int help_pr_sig(unsigned long long sig){
+  if(wide_signals) return sprintf(outbuf, "%016Lx", sig);
+  if(sig>>32)      return sprintf(outbuf, "<%08Lx", sig&0xffffffffLL);
+  return                  sprintf(outbuf,  "%08Lx", sig&0xffffffffLL);
+}
+#endif
+
+static int pr_sig(void){
+  return help_pr_sig(pp->signal);
+}
+static int pr_sigmask(void){
+  return help_pr_sig(pp->blocked);
+}
+static int pr_sigignore(void){
+  return help_pr_sig(pp->sigignore);
+}
+static int pr_sigcatch(void){
+  return help_pr_sig(pp->sigcatch);
+}
+
+
+static int pr_egid(void){
+  return sprintf(outbuf, "%d", pp->egid);
+}
+static int pr_rgid(void){
+  return sprintf(outbuf, "%d", pp->rgid);
+}
+static int pr_sgid(void){
+  return sprintf(outbuf, "%d", pp->sgid);
+}
+static int pr_fgid(void){
+  return sprintf(outbuf, "%d", pp->fgid);
+}
+static int pr_ruid(void){
+  return sprintf(outbuf, "%d", pp->ruid);
+}
+static int pr_suid(void){
+  return sprintf(outbuf, "%d", pp->suid);
+}
+static int pr_fuid(void){
+  return sprintf(outbuf, "%d", pp->fuid);
+}
+
+
+static int pr_fgroup(void){
+  if(strlen(pp->fgroup)>max_rightward) return sprintf(outbuf, "%d", pp->fgid);
+  return sprintf(outbuf, "%s", pp->fgroup);
+}
+static int pr_sgroup(void){
+  if(strlen(pp->sgroup)>max_rightward) return sprintf(outbuf, "%d", pp->sgid);
+  return sprintf(outbuf, "%s", pp->sgroup);
+}
+static int pr_fuser(void){
+  if(user_is_number || (strlen(pp->fuser)>max_rightward)) return sprintf(outbuf, "%d", pp->fuid);
+  return sprintf(outbuf, "%s", pp->fuser);
+}
+static int pr_suser(void){
+  if(user_is_number || (strlen(pp->suser)>max_rightward)) return sprintf(outbuf, "%d", pp->suid);
+  return sprintf(outbuf, "%s", pp->suser);
+}
+
+
+static int pr_sess(void){
+  return sprintf(outbuf, "%u", pp->session);
+}
+static int pr_tpgid(void){
+  return sprintf(outbuf, "%d", pp->tpgid);
+}
+
+
+/* SGI uses "cpu" to print the processor ID with header "P" */
+static int pr_sgi_p(void){          /* FIXME */
+  if(pp->state == 'R') return sprintf(outbuf, "%d", 0);
+  return sprintf(outbuf, "*");
+}
+
+
+
+/***************************************************************************/
+/*************************** other stuff ***********************************/
+
+/*
+ * Old header specifications.
+ *
+ * short   Up  "  PID TTY STAT  TIME COMMAND"
+ * long  l Pp  " FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN       STA TTY TIME COMMAND
+ * user  u up  "USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND
+ * jobs  j gPp " PPID   PID  PGID   SID TTY TPGID  STAT   UID   TIME COMMAND
+ * sig   s p   "  UID   PID SIGNAL   BLOCKED  IGNORED  CATCHED  STAT TTY   TIME COMMAND
+ * vm    v r   "  PID TTY STAT  TIME  PAGEIN TSIZ DSIZ  RSS   LIM %MEM COMMAND
+ * m     m r   "  PID TTY MAJFLT MINFLT   TRS   DRS  SIZE  SWAP   RSS  SHRD   LIB  DT COMMAND
+ * regs  X p   "NR   PID    STACK      ESP      EIP TMOUT ALARM STAT TTY   TIME COMMAND
+ */
+
+/*
+ * Unix98 requires that the heading for tty is TT, though XPG4, Digital,
+ * and BSD use TTY. The Unix98 headers are:
+ *              args,comm,etime,group,nice,pcpu,pgid
+ *              pid,ppid,rgroup,ruser,time,tty,user,vsz
+ *
+ * BSD c:   "command" becomes accounting name ("comm" or "ucomm")
+ * BSD n:   "user" becomes "uid" and "wchan" becomes "nwchan" (number)
+ */
+
+/* short names to save space */
+#define MEM PROC_FILLMEM     /* read statm  */
+#define CMD PROC_FILLCMD     /* read cmdline */
+#define ENV PROC_FILLENV     /* read environ */
+#define USR PROC_FILLUSR     /* uid_t and gid_t -> user and group names */
+#define BUG PROC_FILLBUG     /* what does this need? */
+
+/* TODO
+ *      pull out annoying BSD aliases into another table (to macro table?)
+ *      add sorting functions here (to unify names)
+ */
+
+/* temporary hack -- mark new stuff grabbed from Debian ps */
+#define LNx LNX
+
+/* there are about 194 listed */
+
+/* Many of these are placeholders for unsupported options. */
+static const format_struct format_array[] = {
+/* code       header     print()      sort()    width  ?   vendor flags  */
+{"%cpu",      "%CPU",    pr_pcpu,     sr_pcpu,    4,   0,    BSD, RIGHT}, /*pcpu*/
+{"%mem",      "%MEM",    pr_pmem,     sr_nop,     4,   0,    BSD, RIGHT}, /*pmem*/
+{"acflag",    "ACFLG",   pr_nop,      sr_nop,     5,   0,    XXX, RIGHT}, /*acflg*/
+{"acflg",     "ACFLG",   pr_nop,      sr_nop,     5,   0,    BSD, RIGHT}, /*acflag*/
+{"addr",      "ADDR",    pr_nop,      sr_nop,     4,   0,    XXX, RIGHT},
+{"alarm",     "ALARM",   pr_alarm,    sr_it_real_value, 5, 0, LNX, RIGHT},
+{"argc",      "ARGC",    pr_nop,      sr_nop,     4,   0,    LNX, RIGHT},
+{"args",      "COMMAND", pr_args,     sr_nop,    16,   0,    U98, UNLIMITED}, /*command*/
+{"blocked",   "BLOCKED", pr_sigmask,  sr_nop,     9,   0,    BSD, SIGNAL}, /*sigmask*/
+{"bnd",       "BND",     pr_nop,      sr_nop,     1,   0,    AIX, RIGHT},
+{"bsdstart",  "START",   pr_bsdstart, sr_nop,     6,   0,    LNX, RIGHT},
+{"bsdtime",   "TIME",    pr_bsdtime,  sr_nop,     6,   0,    LNX, RIGHT},
+{"c",         "C",       pr_c,        sr_pcpu,    2,   0,    SUN, RIGHT},
+{"caught",    "CAUGHT",  pr_sigcatch, sr_nop,     9,   0,    BSD, SIGNAL}, /*sigcatch*/
+{"class",     "CLS",     pr_nop,      sr_nop,     5,   0,    XXX, RIGHT},
+{"cls",       "-",       pr_nop,      sr_nop,     1,   0,    HPU, RIGHT},
+{"cmaj_flt",  "-",       pr_nop,      sr_cmaj_flt, 1,  0,    LNX, RIGHT},
+{"cmd",       "CMD",     pr_args,     sr_cmd,    16,   0,    DEC, UNLIMITED}, /*ucomm*/
+{"cmin_flt",  "-",       pr_nop,      sr_cmin_flt, 1,  0,    LNX, RIGHT},
+{"cnswap",    "-",       pr_nop,      sr_cnswap,  1,   0,    LNX, RIGHT},
+{"comm",      "COMMAND", pr_comm,     sr_nop,    16,   0,    U98, UNLIMITED}, /*ucomm*/
+{"command",   "COMMAND", pr_args,     sr_nop,    16,   0,    XXX, UNLIMITED}, /*args*/
+{"cp",        "CP",      pr_nop,      sr_nop,     2,   0,    DEC, RIGHT}, /*cpu*/
+{"cpu",       "CPU",     pr_nop,      sr_nop,     3,   0,    BSD, RIGHT}, /* FIXME ... HP-UX wants this as the CPU number for SMP? */
+{"cputime",   "TIME",    pr_time,     sr_nop,     8,   0,    DEC, RIGHT}, /*time*/
+{"cstime",    "-",       pr_nop,      sr_cstime,  1,   0,    LNX, RIGHT},
+{"cursig",    "CURSIG",  pr_nop,      sr_nop,     6,   0,    DEC, RIGHT},
+{"cutime",    "-",       pr_nop,      sr_cutime,  1,   0,    LNX, RIGHT},
+{"cwd",       "CWD",     pr_nop,      sr_nop,     3,   0,    LNX, LEFT},
+{"drs",       "DRS",     pr_drs,      sr_drs,     4,   0,    LNX, RIGHT},
+{"dsiz",      "DSIZ",    pr_dsiz,     sr_nop,     4,   0,    LNX, RIGHT},
+{"egid",      "EGID",    pr_egid,     sr_egid,    5,   0,    LNX, RIGHT},
+{"egroup",    "EGROUP",  pr_egroup,   sr_egroup,  8,   0,    LNX, USER},
+{"eip",       "EIP",     pr_eip,      sr_kstk_eip, 8,  0,    LNX, RIGHT},
+{"end_code",  "E_CODE",  pr_nop,      sr_end_code, 8,  0,    LNx, RIGHT},
+{"environ","ENVIRONMENT",pr_nop,      sr_nop,    11,   0,    LNx, UNLIMITED},
+{"esp",       "ESP",     pr_esp,      sr_kstk_esp, 8,  0,    LNX, RIGHT},
+{"etime",     "ELAPSED", pr_etime,    sr_nop,    11,   0,    U98, RIGHT}, /* was 7 wide */
+{"euid",      "EUID",    pr_euid,     sr_euid,    5,   0,    LNX, RIGHT},
+{"euser",     "EUSER",   pr_euser,    sr_euser,   8,   0,    LNX, USER},
+{"f",         "F",       pr_flag,     sr_nop,     3,   0,    XXX, RIGHT}, /*flags*/
+{"fgid",      "FGID",    pr_fgid,     sr_fgid,    5,   0,    LNX, RIGHT},
+{"fgroup",    "FGROUP",  pr_fgroup,   sr_fgroup,  8,   0,    LNX, USER},
+{"flag",      "F",       pr_flag,     sr_flags,   3,   0,    DEC, RIGHT},
+{"flags",     "F",       pr_flag,     sr_flags,   3,   0,    BSD, RIGHT}, /*f*/ /* was FLAGS, 8 wide */
+{"fname",     "COMMAND", pr_fname,    sr_nop,     8,   0,    SUN, LEFT},
+{"fsgid",     "FSGID",   pr_fgid,     sr_fgid,    5,   0,    LNX, RIGHT},
+{"fsgroup",   "FSGROUP", pr_fgroup,   sr_fgroup,  8,   0,    LNX, USER},
+{"fsuid",     "FSUID",   pr_fuid,     sr_fuid,    5,   0,    LNX, RIGHT},
+{"fsuser",    "FSUSER",  pr_fuser,    sr_fuser,   8,   0,    LNX, USER},
+{"fuid",      "FUID",    pr_fuid,     sr_fuid,    5,   0,    LNX, RIGHT},
+{"fuser",     "FUSER",   pr_fuser,    sr_fuser,   8,   0,    LNX, USER},
+{"gid",       "GID",     pr_egid,     sr_egid,    5,   0,    SUN, RIGHT},
+{"group",     "GROUP",   pr_egroup,   sr_egroup,  5,   0,    U98, USER}, /* was 8 wide */
+{"ignored",   "IGNORED", pr_sigignore,sr_nop,     9,   0,    BSD, SIGNAL}, /*sigignore*/
+{"inblk",     "INBLK",   pr_nop,      sr_nop,     5,   0,    BSD, RIGHT}, /*inblock*/
+{"inblock",   "INBLK",   pr_nop,      sr_nop,     5,   0,    DEC, RIGHT}, /*inblk*/
+{"intpri",    "PRI",     pr_opri,     sr_priority, 3,  0,    HPU, RIGHT},
+{"jobc",      "JOBC",    pr_nop,      sr_nop,     4,   0,    XXX, RIGHT},
+{"ktrace",    "KTRACE",  pr_nop,      sr_nop,     8,   0,    BSD, RIGHT},
+{"ktracep",   "KTRACEP", pr_nop,      sr_nop,     8,   0,    BSD, RIGHT},
+{"label",     "LABEL",   pr_nop,      sr_nop,    25,  0,     SGI, LEFT},
+{"lim",       "LIM",     pr_lim,      sr_rss_rlim, 5,  0,    BSD, RIGHT},
+{"login",     "LOGNAME", pr_nop,      sr_nop,     8,   0,    BSD, LEFT}, /*logname*/   /* double check */
+{"logname",   "LOGNAME", pr_nop,      sr_nop,     8,   0,    XXX, LEFT}, /*login*/
+{"longtname", "TTY",     pr_tty8,     sr_tty,     8,   0,    DEC, LEFT},
+{"lstart",    "STARTED", pr_lstart,   sr_nop,    24,   0,    XXX, RIGHT},
+{"luid",      "LUID",    pr_nop,      sr_nop,     5,   0,    LNX, RIGHT}, /* login ID */
+{"luser",     "LUSER",   pr_nop,      sr_nop,     8,   0,    LNX, USER}, /* login USER */
+{"m_drs",     "DRS",     pr_drs,      sr_drs,     5,   0,    LNx, RIGHT},
+{"m_dt",      "DT",      pr_nop,      sr_dt,      4,   0,    LNx, RIGHT},
+{"m_lrs",     "LRS",     pr_nop,      sr_lrs,     5,   0,    LNx, RIGHT},
+{"m_resident", "RES",    pr_nop,      sr_resident, 5,  0,    LNx, RIGHT},
+{"m_share",   "SHRD",    pr_nop,      sr_share,   5,   0,    LNx, RIGHT},
+{"m_size",    "SIZE",    pr_nop,      sr_size,    5,   0,    LNx, RIGHT},
+{"m_swap",    "SWAP",    pr_nop,      sr_nop,     5,   0,    LNx, RIGHT},
+{"m_trs",     "TRS",     pr_trs,      sr_trs,     5,   0,    LNx, RIGHT},
+{"maj_flt",   "MAJFL",   pr_majflt,   sr_maj_flt, 6,   0,    LNX, CUMUL|RIGHT},
+{"majflt",    "MAJFLT",  pr_majflt,   sr_maj_flt, 6,   0,    XXX, RIGHT},
+{"min_flt",   "MINFL",   pr_minflt,   sr_min_flt, 6,   0,    LNX, CUMUL|RIGHT},
+{"minflt",    "MINFLT",  pr_minflt,   sr_min_flt, 6,   0,    XXX, RIGHT},
+{"msgrcv",    "MSGRCV",  pr_nop,      sr_nop,     6,   0,    XXX, RIGHT},
+{"msgsnd",    "MSGSND",  pr_nop,      sr_nop,     6,   0,    XXX, RIGHT},
+{"ni",        "NI",      pr_nice,     sr_nice,    3,   0,    BSD, RIGHT}, /*nice*/
+{"nice",      "NI",      pr_nice,     sr_nice,    3,   0,    U98, RIGHT}, /*ni*/
+{"nivcsw",    "IVCSW",   pr_nop,      sr_nop,     5,   0,    XXX, RIGHT},
+{"nsignals",  "NSIGS",   pr_nop,      sr_nop,     5,   0,    DEC, RIGHT}, /*nsigs*/
+{"nsigs",     "NSIGS",   pr_nop,      sr_nop,     5,   0,    BSD, RIGHT}, /*nsignals*/
+{"nswap",     "NSWAP",   pr_nop,      sr_nswap,   5,   0,    XXX, RIGHT},
+{"nvcsw",     "VCSW",    pr_nop,      sr_nop,     5,   0,    XXX, RIGHT},
+{"nwchan",    "WCHAN",   pr_nwchan,   sr_nop,     6,   0,    XXX, RIGHT},
+{"opri",      "PRI",     pr_opri,     sr_priority, 3,  0,    SUN, RIGHT},
+{"osz",       "SZ",      pr_nop,      sr_nop,     2,   0,    SUN, RIGHT},
+{"oublk",     "OUBLK",   pr_nop,      sr_nop,     5,   0,    BSD, RIGHT}, /*oublock*/
+{"oublock",   "OUBLK",   pr_nop,      sr_nop,     5,   0,    DEC, RIGHT}, /*oublk*/
+{"p_ru",      "P_RU",    pr_nop,      sr_nop,     6,   0,    BSD, RIGHT},
+{"paddr",     "PADDR",   pr_nop,      sr_nop,     6,   0,    BSD, RIGHT},
+{"pagein",    "PAGEIN",  pr_majflt,   sr_nop,     6,   0,    XXX, RIGHT},
+{"pcpu",      "%CPU",    pr_pcpu,     sr_pcpu,    4,   0,    U98, RIGHT}, /*%cpu*/
+{"pending",   "PENDING", pr_sig,      sr_nop,     9,   0,    BSD, SIGNAL}, /*sig*/
+{"pgid",      "PGID",    pr_pgid,     sr_pgrp,    5,   0,    U98, RIGHT},
+{"pgrp",      "PGRP",    pr_pgid,     sr_pgrp,    5,   0,    LNX, RIGHT},
+{"pid",       "PID",     pr_pid,      sr_pid,     5,   0,    U98, RIGHT},
+{"pmem",      "%MEM",    pr_pmem,     sr_nop,     4,   0,    XXX, RIGHT}, /*%mem*/
+{"poip",      "-",       pr_nop,      sr_nop,     1,   0,    BSD, RIGHT},
+{"policy",    "POL",     pr_nop,      sr_nop,     3,   0,    DEC, RIGHT},
+{"ppid",      "PPID",    pr_ppid,     sr_ppid,    5,   0,    U98, RIGHT},
+{"pri",       "PRI",     pr_pri,      sr_nop,     3,   0,    XXX, RIGHT},
+{"priority",  "PRI",     pr_priority, sr_priority, 3,  0,    LNX, RIGHT}, /*ni,nice*/ /* from Linux sorting names */
+{"prmgrp",    "-",       pr_nop,      sr_nop,     1,   0,    HPU, RIGHT},
+{"prmid",     "-",       pr_nop,      sr_nop,     1,   0,    HPU, RIGHT},
+{"pset",      "PSET",    pr_nop,      sr_nop,     4,   0,    DEC, RIGHT},
+{"psr",       "PSR",     pr_nop,      sr_nop,     3,   0,    DEC, RIGHT},
+{"psxpri",    "PPR",     pr_nop,      sr_nop,     3,   0,    DEC, RIGHT},
+{"re",        "RE",      pr_nop,      sr_nop,     3,   0,    BSD, RIGHT},
+{"resident",  "-",       pr_nop,      sr_resident, 5,  0,    LNX, RIGHT},
+{"rgid",      "RGID",    pr_rgid,     sr_rgid,    5,   0,    XXX, RIGHT},
+{"rgroup",    "RGROUP",  pr_rgroup,   sr_rgroup,  6,   0,    U98, USER}, /* was 8 wide */
+{"rlink",     "RLINK",   pr_nop,      sr_nop,     8,   0,    BSD, RIGHT},
+{"rss",       "RSS",     pr_rss,      sr_rss,     4,   0,    XXX, RIGHT}, /* was 5 wide */
+{"rssize",    "RSS",     pr_rss,      sr_vm_rss,  4,   0,    DEC, RIGHT}, /*rsz*/
+{"rsz",       "RSZ",     pr_rss,      sr_vm_rss,  4,   0,    BSD, RIGHT}, /*rssize*/
+{"rtprio",    "RTPRIO",  pr_nop,      sr_nop,     7,   0,    BSD, RIGHT},
+{"ruid",      "RUID",    pr_ruid,     sr_ruid,    5,   0,    XXX, RIGHT},
+{"ruser",     "RUSER",   pr_ruser,    sr_ruser,   8,   0,    U98, USER},
+{"s",         "S",       pr_s,        sr_state,   1,   0,    SUN, LEFT}, /*stat,state*/
+{"sched",     "SCH",     pr_nop,      sr_nop,     1,   0,    AIX, RIGHT},
+{"scnt",      "SCNT",    pr_nop,      sr_nop,     4,   0,    DEC, RIGHT},  /* man page misspelling of scount? */
+{"scount",    "SC",      pr_nop,      sr_nop,     4,   0,    AIX, RIGHT},  /* scnt==scount, DEC claims both */
+{"sess",      "SESS",    pr_sess,     sr_session, 5,   0,    XXX, RIGHT},
+{"session",   "SESS",    pr_sess,     sr_session, 5,   0,    LNX, RIGHT},
+{"sgi_p",     "P",       pr_sgi_p,    sr_nop,     1,   0,    LNX, RIGHT}, /* "cpu" number */
+{"sgi_rss",   "RSS",     pr_rss,      sr_nop,     4,   0,    LNX, LEFT}, /* SZ:RSS */
+{"sgid",      "SGID",    pr_sgid,     sr_sgid,    5,   0,    LNX, RIGHT},
+{"sgroup",    "SGROUP",  pr_sgroup,   sr_sgroup,  8,   0,    LNX, USER},
+{"share",     "-",       pr_nop,      sr_share,   1,   0,    LNX, RIGHT},
+{"sid",       "SID",     pr_sess,     sr_session, 5,   0,    XXX, RIGHT}, /* Sun & HP */
+{"sig",       "PENDING", pr_sig,      sr_nop,     9,   0,    XXX, SIGNAL}, /*pending*/
+{"sig_block", "BLOCKED",  pr_sigmask, sr_nop,     9,   0,    LNX, SIGNAL},
+{"sig_catch", "CATCHED", pr_sigcatch, sr_nop,     9,   0,    LNX, SIGNAL},
+{"sig_ignore", "IGNORED",pr_sigignore, sr_nop,    9,   0,    LNX, SIGNAL},
+{"sig_pend",  "SIGNAL",   pr_sig,     sr_nop,     9,   0,    LNX, SIGNAL},
+{"sigcatch",  "CAUGHT",  pr_sigcatch, sr_nop,     9,   0,    XXX, SIGNAL}, /*caught*/
+{"sigignore", "IGNORED", pr_sigignore,sr_nop,     9,   0,    XXX, SIGNAL}, /*ignored*/
+{"sigmask",   "BLOCKED", pr_sigmask,  sr_nop,     9,   0,    XXX, SIGNAL}, /*blocked*/
+{"size",      "-",       pr_nop,      sr_size,    1,   0,    SCO, RIGHT},
+{"sl",        "SL",      pr_nop,      sr_nop,     3,   0,    XXX, RIGHT},
+{"stackp",    "STACKP",  pr_stackp,   sr_nop,     8,   0,    LNX, RIGHT}, /*start_stack*/
+{"start",     "STARTED", pr_start,    sr_nop,     8,   0,    XXX, RIGHT},
+{"start_code", "S_CODE",  pr_nop,     sr_start_code, 8, 0,   LNx, RIGHT},
+{"start_stack", "STACKP", pr_stackp,  sr_start_stack, 8, 0,  LNX, RIGHT}, /*stackp*/
+{"start_time", "START",  pr_stime,    sr_start_time, 5, 0,   LNx, RIGHT},
+{"stat",      "STAT",    pr_stat,     sr_state,   4,   0,    BSD, LEFT}, /*state,s*/
+{"state",     "S",       pr_s,        sr_state,   1,   0,    XXX, LEFT}, /*stat,s*/ /* was STAT */
+{"status",    "STATUS",  pr_nop,      sr_nop,     6,   0,    DEC, RIGHT},
+{"stime",     "STIME",   pr_stime,    sr_stime,   5,   0,    XXX, /* CUMUL| */RIGHT}, /* was 6 wide */
+{"suid",      "SUID",    pr_suid,     sr_suid,    5,   0,    LNx, RIGHT},
+{"suser",     "SUSER",   pr_suser,    sr_suser,   8,   0,    LNx, USER},
+{"svgid",     "SVGID",   pr_sgid,     sr_sgid,    5,   0,    XXX, RIGHT},
+{"svgroup",   "SVGROUP", pr_sgroup,   sr_sgroup,  8,   0,    LNX, USER},
+{"svuid",     "SVUID",   pr_suid,     sr_suid,    5,   0,    XXX, RIGHT},
+{"svuser",    "SVUSER",  pr_suser,    sr_suser,   8,   0,    LNX, USER},
+{"systime",   "SYSTEM",  pr_nop,      sr_nop,     6,   0,    DEC, RIGHT},
+{"sz",        "SZ",      pr_sz,       sr_nop,     5,   0,    HPU, RIGHT},
+{"tdev",      "TDEV",    pr_nop,      sr_nop,     4,   0,    XXX, RIGHT},
+{"thcount",   "THCNT",   pr_nop,      sr_nop,     1,   0,    AIX, RIGHT},
+{"tid",       "TID",     pr_nop,      sr_nop,     1,   0,    AIX, RIGHT},
+{"time",      "TIME",    pr_time,     sr_nop,     8,   0,    U98, CUMUL|RIGHT}, /*cputime*/ /* was 6 wide */
+{"timeout",   "TMOUT",   pr_timeout,  sr_timeout, 5,   0,    LNX, RIGHT},
+{"tmout",     "TMOUT",   pr_timeout,  sr_timeout, 5,   0,    LNX, RIGHT},
+{"tname",     "TTY",     pr_tty8,     sr_tty,     8,   0,    DEC, LEFT},
+{"tpgid",     "TPGID",   pr_tpgid,    sr_tpgid,   5,   0,    XXX, RIGHT},
+{"trs",       "TRS",     pr_trs,      sr_trs,     4,   0,    AIX, RIGHT},
+{"trss",      "TRSS",    pr_trs,      sr_trs,     4,   0,    BSD, RIGHT}, /* 4.3BSD NET/2 */
+{"tsess",     "TSESS",   pr_nop,      sr_nop,     5,   0,    BSD, RIGHT},
+{"tsession",  "TSESS",   pr_nop,      sr_nop,     5,   0,    DEC, RIGHT},
+{"tsiz",      "TSIZ",    pr_tsiz,     sr_nop,     4,   0,    BSD, RIGHT},
+{"tt",        "TT",      pr_tty8,     sr_tty,     8,   0,    BSD, LEFT},
+{"tty",       "TT",      pr_tty8,     sr_tty,     8,   0,    U98, LEFT}, /* Unix98 requires "TT" but has "TTY" too. :-( */  /* was 3 wide */
+{"tty4",      "TTY",     pr_tty4,     sr_tty,     4,   0,    LNX, LEFT},
+{"tty8",      "TTY",     pr_tty8,     sr_tty,     8,   0,    LNX, LEFT},
+{"u_procp",   "UPROCP",  pr_nop,      sr_nop,     6,   0,    DEC, RIGHT},
+{"ucmd",      "CMD",     pr_comm,     sr_cmd,    16,   0,    DEC, UNLIMITED}, /*ucomm*/
+{"ucomm",     "COMMAND", pr_comm,     sr_nop,    16,   0,    XXX, UNLIMITED}, /*comm*/
+{"uid",       "UID",     pr_euid,     sr_euid,    5,   0,    XXX, RIGHT},
+{"uid_hack",  "UID",     pr_euser,    sr_nop,     8,   0,    XXX, USER},
+{"umask",     "UMASK",   pr_nop,      sr_nop,     5,   0,    DEC, RIGHT},
+{"uname",     "USER",    pr_euser,    sr_euser,   8,   0,    DEC, USER}, /* man page misspelling of user? */
+{"upr",       "UPR",     pr_nop,      sr_nop,     3,   0,    BSD, RIGHT}, /*usrpri*/
+{"uprocp",    "-",       pr_nop,      sr_nop,     1,   0,    BSD, RIGHT},
+{"user",      "USER",    pr_euser,    sr_euser,   8,   0,    U98, USER}, /* BSD n forces this to UID */
+{"usertime",  "USER",    pr_nop,      sr_nop,     4,   0,    DEC, RIGHT},
+{"usrpri",    "UPR",     pr_nop,      sr_nop,     3,   0,    DEC, RIGHT}, /*upr*/
+{"utime",     "UTIME",   pr_nop,      sr_utime,   6,   0,    LNx, CUMUL|RIGHT},
+{"vm_data",   "DATA",    pr_nop,      sr_vm_data, 5,   0,    LNx, RIGHT},
+{"vm_exe",    "EXE",     pr_nop,      sr_vm_exe,  5,   0,    LNx, RIGHT},
+{"vm_lib",    "LIB",     pr_nop,      sr_vm_lib,  5,   0,    LNx, RIGHT},
+{"vm_lock",   "LCK",     pr_nop,      sr_vm_lock, 3,   0,    LNx, RIGHT},
+{"vm_stack",  "STACK",   pr_nop,      sr_vm_stack, 5,  0,    LNx, RIGHT},
+{"vsize",     "VSZ",     pr_vsz,      sr_vsize,   5,   0,    DEC, RIGHT}, /*vsz*/
+{"vsz",       "VSZ",     pr_vsz,      sr_vm_size, 5,   0,    U98, RIGHT}, /*vsize*/
+{"wchan",     "WCHAN",   pr_wchan,    sr_wchan,   6,   0,    XXX, WCHAN}, /* BSD n forces this to nwchan */ /* was 10 wide */
+{"xstat",     "XSTAT",   pr_nop,      sr_nop,     5,   0,    BSD, RIGHT},
+{"~",         "-",       pr_nop,      sr_nop,     1,   0,    LNX, RIGHT}  /* NULL would ruin alphabetical order */
+};
+
+static const int format_array_count = sizeof(format_array)/sizeof(format_struct);
+
+
+/****************************** Macro formats *******************************/
+/* First X field may be NR, which is p->start_code>>26 printed with %2ld */
+/* That seems useless though, and Debian already killed it. */
+/* The ones marked "Digital" have the name defined, not just the data. */
+const macro_struct macro_array[] = {
+{"DFMT",     "pid,tname,state,cputime,cmd"},         /* Digital's default */
+{"DefBSD",   "pid,tname,stat,bsdtime,args"},               /* Our BSD default */
+{"DefSysV",  "pid,tname,time,cmd"},                     /* Our SysV default */
+{"END_BSD",  "state,tname,cputime,comm"},                 /* trailer for O */
+{"END_SYS5", "state,tname,time,command"},                 /* trailer for -O */
+{"F5FMT",    "uname,pid,ppid,c,start,tname,time,cmd"},       /* Digital -f */
+
+{"FB_",      "pid,tt,stat,time,command"},                          /* FreeBSD default */
+{"FB_j",     "user,pid,ppid,pgid,sess,jobc,stat,tt,time,command"},     /* FreeBSD j */
+{"FB_l",     "uid,pid,ppid,cpu,pri,nice,vsz,rss,wchan,stat,tt,time,command"},   /* FreeBSD l */
+{"FB_u",     "user,pid,pcpu,pmem,vsz,rss,tt,stat,start,time,command"},     /* FreeBSD u */
+{"FB_v",     "pid,stat,time,sl,re,pagein,vsz,rss,lim,tsiz,pcpu,pmem,command"},   /* FreeBSD v */
+
+{"FD_",      "pid,tty,time,comm"},                                 /* Fictional Debian SysV default */
+{"FD_f",     "user,pid,ppid,start_time,tty,time,comm"},                /* Fictional Debian -f */
+{"FD_fj",    "user,pid,ppid,start_time,tty,time,pgid,sid,comm"},        /* Fictional Debian -jf */
+{"FD_j",     "pid,tty,time,pgid,sid,comm"},                                  /* Fictional Debian -j */
+{"FD_l",     "flags,state,uid,pid,ppid,priority,nice,vsz,wchan,tty,time,comm"},    /* Fictional Debian -l */
+{"FD_lj",    "flags,state,uid,pid,ppid,priority,nice,vsz,wchan,tty,time,pgid,sid,comm"}, /* Fictional Debian -jl */
+
+{"FL5FMT",   "f,state,uid,pid,ppid,pcpu,pri,nice,rss,wchan,start,time,command"},  /* Digital -fl */
+
+{"HP_",      "pid,tty,time,comm"},  /* HP default */
+{"HP_f",     "user,pid,ppid,cpu,stime,tty,time,args"},  /* HP -f */
+{"HP_fl",    "flags,state,user,pid,ppid,cpu,intpri,nice,addr,sz,wchan,stime,tty,time,args"},  /* HP -fl */
+{"HP_l",     "flags,state,uid,pid,ppid,cpu,intpri,nice,addr,sz,wchan,tty,time,comm"},  /* HP -l */
+
+{"JFMT",     "user,pid,ppid,pgid,sess,jobc,state,tname,cputime,command"},   /* Digital j and -j */
+{"L5FMT",    "f,state,uid,pid,ppid,c,pri,nice,addr,sz,wchan,tt,time,ucmd"},   /* Digital -l */
+{"LFMT",     "uid,pid,ppid,cp,pri,nice,vsz,rss,wchan,state,tname,cputime,command"},   /* Digital l */
+
+{"OL_X",     "pid,start_stack,esp,eip,timeout,alarm,stat,tname,bsdtime,args"},      /* Old i386 Linux X */
+{"OL_j",     "ppid,pid,pgid,sid,tname,tpgid,stat,uid,bsdtime,args"},                   /* Old Linux j */
+{"OL_l",     "flags,uid,pid,ppid,priority,nice,vsz,rss,wchan,stat,tname,bsdtime,args"},     /* Old Linux l */
+{"OL_m",     "pid,tname,majflt,minflt,m_trs,m_drs,m_size,m_swap,rss,m_share,vm_lib,m_dt,args"}, /* Old Linux m */
+{"OL_s",     "uid,pid,pending,sig_block,sig_ignore,caught,stat,tname,bsdtime,args"},  /* Old Linux s */
+{"OL_u",     "user,pid,pcpu,pmem,vsz,rss,tname,stat,start_time,bsdtime,args"},       /* Old Linux u */
+{"OL_v",     "pid,tname,stat,bsdtime,maj_flt,m_trs,m_drs,rss,pmem,args"},            /* Old Linux v */
+
+{"RD_",      "pid,tname,state,bsdtime,comm"},                                       /* Real Debian default */
+{"RD_f",     "uid,pid,ppid,start_time,tname,bsdtime,args"},                         /* Real Debian -f */
+{"RD_fj",    "uid,pid,ppid,start_time,tname,bsdtime,pgid,sid,args"},                /* Real Debian -jf */
+{"RD_j",     "pid,tname,state,bsdtime,pgid,sid,comm"},                               /* Real Debian -j */
+{"RD_l",     "flags,state,uid,pid,ppid,priority,nice,wchan,tname,bsdtime,comm"},           /* Real Debian -l */
+{"RD_lj",    "flags,state,uid,pid,ppid,priority,nice,wchan,tname,bsdtime,pgid,sid,comm"},  /* Real Debian -jl */
+
+{"RUSAGE",   "minflt,majflt,nswap,inblock,oublock,msgsnd,msgrcv,nsigs,nvcsw,nivcsw"}, /* Digital -o "RUSAGE" */
+{"SCHED",    "user,pcpu,pri,usrpri,nice,psxpri,psr,policy,pset"},                /* Digital -o "SCHED" */
+{"SFMT",     "uid,pid,cursig,sig,sigmask,sigignore,sigcatch,stat,tname,command"},  /* Digital s */
+
+{"Std_f",    "uid_hack,pid,ppid,c,stime,tname,time,cmd"},                     /* new -f */
+{"Std_fl",   "f,s,uid_hack,pid,ppid,c,opri,ni,addr,sz,wchan,stime,tname,time,cmd"}, /* -fl */
+{"Std_l",    "f,s,uid,pid,ppid,c,opri,ni,addr,sz,wchan,tname,time,ucmd"},  /* new -l */
+
+{"THREAD",   "user,pcpu,pri,scnt,wchan,usertime,systime"},                /* Digital -o "THREAD" */
+{"UFMT",     "uname,pid,pcpu,pmem,vsz,rss,tt,state,start,time,command"},   /* Digital u */
+{"VFMT",     "pid,tt,state,time,sl,pagein,vsz,rss,pcpu,pmem,command"},   /* Digital v */
+{"~", "~"} /* NULL would ruin alphabetical order */
+};
+
+const int macro_array_count = sizeof(macro_array)/sizeof(macro_struct);
+
+
+/*************************** AIX formats ********************/
+/* Convert AIX format codes to normal format specifiers. */
+const aix_struct aix_array[] = {
+{'C', "pcpu",   "%CPU"},
+{'G', "group",  "GROUP"},
+{'P', "ppid",   "PPID"},
+{'U', "user",   "USER"},
+{'a', "args",   "COMMAND"},
+{'c', "comm",   "COMMAND"},
+{'g', "rgroup", "RGROUP"},
+{'n', "nice",   "NI"},
+{'p', "pid",    "PID"},
+{'r', "pgid",   "PGID"},
+{'t', "etime",  "ELAPSED"},
+{'u', "ruser",  "RUSER"},
+{'x', "time",   "TIME"},
+{'y', "tty",    "TTY"},
+{'z', "vsz",    "VSZ"},
+{'~', "~",      "~"} /* NULL would ruin alphabetical order */
+};
+const int aix_array_count = sizeof(aix_array)/sizeof(aix_struct);
+
+
+/********************* sorting ***************************/
+/* Convert short sorting codes to normal format specifiers. */
+const shortsort_struct shortsort_array[] = {
+{'C', "pcpu"       },
+{'G', "tpgid"      },
+{'J', "cstime"     },
+/* {'K', "stime"      }, */  /* conflict, system vs. start time */
+{'M', "maj_flt"    },
+{'N', "cmaj_flt"   },
+{'P', "ppid"       },
+{'R', "resident"   },
+{'S', "share"      },
+{'T', "start_time" },
+{'U', "uid"        }, /* euid */
+{'c', "cmd"        },
+{'f', "flags"      },
+{'g', "pgrp"       },
+{'j', "cutime"     },
+{'k', "utime"      },
+{'m', "min_flt"    },
+{'n', "cmin_flt"   },
+{'o', "session"    },
+{'p', "pid"        },
+{'r', "rss"        },
+{'s', "size"       },
+{'t', "tty"        },
+{'u', "user"       },
+{'v', "vsize"      },
+{'y', "priority"   }, /* nice */
+{'~', "~"          } /* NULL would ruin alphabetical order */
+};
+const int shortsort_array_count = sizeof(shortsort_array)/sizeof(shortsort_struct);
+
+
+/*********** print format_array **********/
+/* called by the parser in another file */
+void print_format_specifiers(void){
+  const format_struct *walk = format_array;
+  while(*(walk->spec) != '~'){
+    if(walk->pr != pr_nop) printf("%-12.12s %-8.8s\n", walk->spec, walk->head);
+    walk++;
+  }
+}
+
+/************ comparison functions for bsearch *************/
+
+static int compare_format_structs(const void *a, const void *b){
+  return strcmp(((format_struct*)a)->spec,((format_struct*)b)->spec);
+}
+
+static int compare_macro_structs(const void *a, const void *b){
+  return strcmp(((macro_struct*)a)->spec,((macro_struct*)b)->spec);
+}
+
+/******** look up structs as needed by the sort & format parsers ******/
+
+const shortsort_struct *search_shortsort_array(const int findme){
+  const shortsort_struct *walk = shortsort_array;
+  while(walk->desc != '~'){
+    if(walk->desc == findme) return walk;
+    walk++;
+  }
+  return NULL;
+}
+
+const aix_struct *search_aix_array(const int findme){
+  const aix_struct *walk = aix_array;
+  while(walk->desc != '~'){
+    if(walk->desc == findme) return walk;
+    walk++;
+  }
+  return NULL;
+}
+
+const format_struct *search_format_array(const char *findme){
+  format_struct key;
+  key.spec = findme;
+  return bsearch(&key, format_array, format_array_count,
+    sizeof(format_struct), compare_format_structs
+  );
+}
+
+const macro_struct *search_macro_array(const char *findme){
+  macro_struct key;
+  key.spec = findme;
+  return bsearch(&key, macro_array, macro_array_count,
+    sizeof(macro_struct), compare_macro_structs
+  );
+}
+
+static unsigned int active_cols;  /* some multiple of screen_cols */
+
+/***** Last chance, avoid needless trunctuation. */
+static void check_header_width(void){
+  format_node *walk = format_list;
+  unsigned int total = 0;
+  int was_normal = 0;
+  unsigned int i = 0;
+  unsigned int sigs = 0;
+  while(walk){
+    switch((walk->flags) & JUST_MASK){
+    default:
+      total += walk->width;
+      total += was_normal;
+      was_normal = 1;
+      break;
+    case SIGNAL:
+      sigs++;
+      total += walk->width;
+      total += was_normal;
+      was_normal = 1;
+      break;
+    case UNLIMITED:  /* could chop this a bit */
+      if(walk->next) total += walk->width;
+      else total += 3; /* not strlen(walk->name) */
+      total += was_normal;
+      was_normal = 1;
+      break;
+    case 0:  /* AIX */
+      total += walk->width;
+      was_normal = 0;
+      break;
+    }
+    walk = walk->next;
+  }
+  for(;;){
+    i++;
+    active_cols = screen_cols * i;
+    if(active_cols>=total) break;
+    if(screen_cols*i >= OUTBUF_SIZE/2) break; /* can't go over */
+  }
+  wide_signals = (total+sigs*7 <= active_cols);
+  
+#if 0
+  printf("123456789-123456789-123456789-123456789-"
+         "123456789-123456789-123456789-123456789\n");
+  printf("need %d, using %d\n", total, active_cols);
+#endif
+}
+
+
+/********** show one process (NULL proc prints header) **********/
+void show_one_proc(proc_t* p){
+  /* unknown: maybe set correct & actual to 1, remove +/- 1 below */
+  int correct  = 0;  /* screen position we should be at */
+  int actual   = 0;  /* screen position we are at */
+  int camax    = 0;  /* MAX(correct,actual) */
+  int amount   = 0;  /* amount of text that this data is */
+  int leftpad  = 0;  /* amount of space this column _could_ need */
+  int space    = 0;  /* amount of space we actually need to print */
+  int dospace  = 0;  /* previous column determined that we need a space */
+  int legit    = 0;  /* legitimately stolen extra space */
+  format_node *fmt = format_list;
+  static int did_stuff = 0;  /* have we ever printed anything? */
+
+  if(-1==(long)p){    /* true only once, at the end */
+    check_header_width();  /* temporary test code */
+    if(did_stuff) return;
+    /* have _never_ printed anything, but might need a header */
+    if(!--lines_to_next_header){
+      lines_to_next_header = header_gap;
+      show_one_proc(NULL);
+    }
+    /* fprintf(stderr, "No processes available.\n"); */  /* legal? */
+    exit(1);
+  }
+  if(p){   /* not header, maybe we should call ourselves for it */
+    if(!--lines_to_next_header){
+      lines_to_next_header = header_gap;
+      show_one_proc(NULL);
+    }
+  }
+  did_stuff = 1;
+  pp = p;                 /* global, the proc_t struct */
+  if(active_cols>(int)OUTBUF_SIZE) fprintf(stderr,"Fix bigness error.\n");
+
+  /* print row start sequence */
+  do{
+    legit = 0;
+    camax = (correct>actual) ? correct : actual;
+    /* set width suggestion which might be ignored */
+    if(fmt->next) max_rightward = fmt->width;
+    else max_rightward = active_cols-camax;
+    max_leftward  = fmt->width + actual - correct; /* TODO check this */
+    /* prepare data and calculate leftpad */
+    if(p && fmt->pr) amount = (*fmt->pr)();
+    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
+    switch((fmt->flags) & JUST_MASK){
+    case 0:  /* for AIX, assigned outside this file */
+      leftpad = 0;
+      break;
+    case LEFT:          /* bad */
+      leftpad = 0;
+      break;
+    case RIGHT:     /* OK */
+      leftpad = fmt->width - amount;
+      if(leftpad < 0) leftpad = 0;
+      break;
+    case SIGNAL:
+      /* if the screen is wide enough, use full 16-character output */
+      if(wide_signals){
+        leftpad = 16 - amount;
+        legit = 7;
+      }else{
+        leftpad =  9 - amount;
+      }
+      if(leftpad < 0) leftpad = 0;
+      break;
+    case USER:       /* bad */
+      leftpad = fmt->width - amount;
+      if(leftpad < 0) leftpad = 0;
+      if(!user_is_number) leftpad = 0;
+      break;
+    case WCHAN:       /* bad */
+      if(wchan_is_number){
+        leftpad = fmt->width - amount;
+        if(leftpad < 0) leftpad = 0;
+        break;
+      }else{
+        if(fmt->next){
+          outbuf[fmt->width] = '\0';  /* Must chop, more columns! */
+        }else{
+          int chopspot;  /* place to chop */
+          int tmpspace;  /* need "space" before it is calculated below */
+          tmpspace = correct - actual;
+          if(tmpspace<1) tmpspace = dospace;
+          chopspot = active_cols-actual-tmpspace;
+          if(chopspot<1) chopspot=1;  /* oops, we (mostly) lose this column... */
+          outbuf[chopspot] = '\0';    /* chop at screen/buffer limit */
+        }
+        leftpad = 0;
+        break;
+      }
+    case UNLIMITED:
+      if(fmt->next){
+        outbuf[fmt->width] = '\0';  /* Must chop, more columns! */
+      }else{
+        int chopspot;  /* place to chop */
+        int tmpspace;  /* need "space" before it is calculated below */
+        tmpspace = correct - actual;
+        if(tmpspace<1) tmpspace = dospace;
+        chopspot = active_cols-actual-tmpspace;
+        if(chopspot<1) chopspot=1;  /* oops, we (mostly) lose this column... */
+        outbuf[chopspot] = '\0';    /* chop at screen/buffer limit */
+      }
+      leftpad = 0;
+      break;
+    default:
+      fputs("bad alignment code\n", stderr);
+      break;
+    }
+    /* At this point:
+     *
+     * amount     garbage
+     * actual     from previous column
+     * correct    from previous column
+     * space      gets toasted by the next line of code
+     */
+    space = correct - actual + leftpad;
+    if(space<1) space=dospace;
+    if(space>SPACE_AMOUNT) space=SPACE_AMOUNT;
+/* printf("[%d %d %d %d %d %d]", correct,actual,amount,leftpad,space,dospace); */
+    /* print data, set x position stuff */
+    actual += fprintf(stdout, "%s", outbuf-space);
+    correct += fmt->width;
+    correct += legit;        /* adjust for SIGNAL expansion */
+    if(fmt->pr && fmt->next && fmt->next->pr){ /* neither is AIX filler */
+       correct++;
+       dospace=1;
+     } else dospace = 0;              /* TODO need this? */
+  } while(( fmt = fmt->next ));
+  fputs("\n", stdout); /* print row end sequence */
+}
+
+#ifdef TESTING
+static void sanity_check(void){
+  format_struct *fs = format_array;
+  while((fs->spec)[0] != '~'){
+    if(strlen(fs->head) > fs->width) printf("%d %s\n",strlen(fs->head),fs->spec);
+    fs++;
+  }
+}
+#endif
+
+void init_output(void){
+  memset(whitespace, ' ', PAGE_SIZE);
+#if 0
+  mprotect(whitespace, PAGE_SIZE, PROT_READ); /* FIXME may fail if unaligned */
+  mprotect(
+    (void *)((unsigned long)(whitespace_and_outbuf-PAGE_SIZE) &~ (PAGE_SIZE-1)),
+    PAGE_SIZE, PROT_NONE
+  );
+#endif
+  seconds_since_boot = uptime(0,0);
+  seconds_since_1970 = time(NULL);
+  time_of_boot = seconds_since_1970 - seconds_since_boot;
+  bytes_main_memory = read_total_main();
+  switch(getpagesize()){
+  case 65536: page_shift = 16; break;
+  case 32768: page_shift = 15; break;
+  case 16384: page_shift = 14; break;
+  case  8192: page_shift = 13; break;
+  default: fprintf(stderr, "Unknown page size! (assume 4096)\n");
+  case  4096: page_shift = 12; break;
+  case  2048: page_shift = 11; break;
+  case  1024: page_shift = 10; break;
+  }
+  check_header_width();
+}
diff -N -u -r procps-2.0.7.orig/ps/ps.1.rej procps-2.0.7/ps/ps.1.rej
--- procps-2.0.7.orig/ps/ps.1.rej	Thu Jan  1 01:00:00 1970
+++ procps-2.0.7/ps/ps.1.rej	Wed Aug 29 21:10:19 2001
@@ -0,0 +1,1067 @@
+***************
+*** 1,213 ****
+  .\" Man page for ps.
+- .\" Quick hack conversion by Albert Cahalan, 1998.
+- .\" Licensed under version 2 of the Gnu General Public License.
+  .\"
+- .\" This man page is a horrid hack because *roff sucks.
+- .\" The whole system is way obsolete. The internal header
+- .\" stuff must die, and will when I figure out how to kill it.
+- .\" I've already killed the wasteful left margin and screwy
+- .\" old perfect justification. Gross! You'd think someone
+- .\" invented this crap in 1973. Oh yeah, they did. Sorry.
+  .\"
+  .TH PS 1 "July 5, 1998" "Linux" "Linux User's Manual"
+- .SH \fRNAME\fR
+- ps \- report process status
+- .ad r
+- .na
+- .ss 12 0
+- .in 0
+- .nh
+- .nf
+  
+- SYNOPSIS
+- ps [options]
+  
+  
+- DESCRIPTION
+- ps gives a snapshot of the current processes. If you want
+- a repetitive update of this status, use top. This man
+- page documents the /proc-based version of ps, or tries to.
+  
+  
+- COMMAND-LINE OPTIONS
+  
+- This version of ps accepts several kinds of options.
+  
+  Unix options may be grouped and must be preceeded by a dash.
+  BSD options may be grouped and must not be used with a dash.
+- Gnu long options are preceeded by two dashes.
+  
+  Options of different types may be freely mixed.
+  
+- Set the I_WANT_A_BROKEN_PS environment variable to force BSD syntax even
+- when options are preceeded by a dash. The PS_PERSONALITY environment
+  variable (described below) provides more detailed control of ps behavior.
+  
+  SIMPLE PROCESS SELECTION
+- -A           select all processes
+- -N           negate selection
+- -a           select all with a tty except session leaders
+- -d           select all, but omit session leaders
+- -e           select all processes
+- T            select all processes on this terminal
+- a            select all processes on a terminal, including those of other users
+- g            really all, even group leaders (does nothing w/o SunOS settings)
+- r            restrict output to running processes
+- x            select processes without controlling ttys
+- --deselect   negate selection
+  
+  PROCESS SELECTION BY LIST
+- -C           select by command name
+- -G           select by RGID (supports names)
+- -U           select by RUID (supports names)
+- -g           select by session leader OR by group name
+- -p           select by PID
+- -s           select processes belonging to the sessions given
+- -t           select by tty
+- -u           select by effective user ID (supports names)
+- U            select processes for specified users
+- p            select by process ID
+- t            select by tty
+- --Group      select by real group name or ID
+- --User       select by real user name or ID
+- --group      select by effective group name or ID
+- --pid        select by process ID
+- --sid        select by session ID
+- --tty        select by terminal
+- --user       select by effective user name or ID
+- -123         implied --sid
+- 123          implied --pid
+  
+  OUTPUT FORMAT CONTROL
+- -O           is preloaded "-o"
+- -c           different scheduler info for -l option
+- -f           does full listing
+- -j           jobs format
+- -l           long format
+- -o           user-defined format
+- -y           do not show flags; show rss in place of addr
+- O            is preloaded "o" (overloaded)
+- X            old Linux i386 register format
+- j            job control format
+- l            display long format
+- o            specify user-defined format
+- s            display signal format
+- u            display user-oriented format
+- v            display virtual memory format
+- --format     user-defined format
+  
+  OUTPUT MODIFIERS
+- -H           show process hierarchy (forest)
+- -m           show threads
+- -n           set namelist file
+- -w           wide output
+- C            use raw CPU time for %CPU instead of decaying average
+- N            specify namelist file
+- O            sorting order (overloaded)
+- S            include some dead child process data (as a sum with the parent)
+- c            true command name
+- e            show environment after the command
+- f            ASCII-art process hierarchy (forest)
+- h            no header (or, one header per screen in the BSD personality)
+- m            all threads
+- n            numeric output for WCHAN and USER
+- w            wide output
+- --cols       set screen width
+- --columns    set screen width
+- --cumulative include some dead child process data (as a sum with the parent)
+- --forest     ASCII art process tree
+- --headers    repeat header lines, one per page of output
+- --no-headers print no header line at all
+- --lines      set screen height
+- --rows       set screen height
+- --sort       specify sorting order
+- --width      set screen width
+  
+  INFORMATION
+- -V          print version
+- L           list all format specifiers
+- V           show version info
+- --help      print help message
+- --info      print debugging info
+- --version   print version
+  
+  OBSOLETE
+- A           increases the argument space (DecUnix)
+- M           use alternate core (try -n or N instead)
+- W           get swap info from ... not /dev/drum (try -n or N instead)
+- k           use /vmcore as c-dumpfile (try -n or N instead)
+  
+  
+  
+- NOTES
+- 
+- The "-g" option can select by session leader OR by group name.
+  Selection by session leader is specified by many standards,
+  but selection by group is the logical behavior that several other
+  operating systems use. This ps will select by session leader when
+  the list is completely numeric (as sessions are). Group ID numbers
+  will work only when some group names are also specified.
+  
+- The "m" option should not be used. Use "-m" or "-o" with a list.
+- ("m" displays memory info, shows threads, or sorts by memory use)
+  
+- The "h" option is problematic.  Standard BSD ps uses the option to
+- print a header on each page of output, but older Linux ps uses the option
+  to totally disable the header.  This version of ps follows the Linux
+  usage of not printing the header unless the BSD personality has been
+  selected, in which case it prints a header on each page of output.
+  Regardless of the current personality, you can use the long options
+- --headers and --no-headers to enable printing headers each page and
+  disable headers entirely, respectively.
+  
+  Terminals (ttys, or screens for text output) can be specified in several
+- forms: /dev/ttyS1, ttyS1, S1. Obsolete "ps t" (your own terminal) and
+- "ps t?" (processes without a terminal) syntax is supported, but modern
+- options ("T", "-t" with list, "x", "t" with list) should be used instead.
+  
+- The BSD "O" option can act like "-O" (user-defined output format with
+  some common fields predefined) or can be used to specify sort order.
+  Heuristics are used to determine the behavior of this option. To ensure
+  that the desired behavior is obtained, specify the other option (sorting
+  or formatting) in some other way.
+  
+- For sorting, BSD "O" option syntax is O[+|-]k1[,[+|-]k2[,...]]
+  Order the process listing according to the multilevel sort specified by
+- the sequence of short keys from SORT KEYS, k1, k2, ... The `+' is quite
+  optional, merely re-iterating the default direction on a key. `-' reverses
+- direction only on the key it precedes. The O option must be the last option
+  in a single command argument, but specifications in successive arguments are
+  catenated.
+  
+- Gnu sorting syntax is --sortX[+|-]key[,[+|-]key[,...]]
+  Choose a multi-letter key from the SORT KEYS section. X may be any
+  convenient separator character. To be GNU-ish use `='. The `+' is really
+  optional since default direction is increasing numerical or lexicographic
+- order. For example, ps jax --sort=uid,-ppid,+pid
+  
+- This ps works by reading the virtual files in /proc. This ps does not
+- need to be suid kmem or have any privileges to run. Do not give this ps
+  any special permissions.
+  
+- This ps needs access to a namelist file for proper WCHAN display.
+  The namelist file must match the current Linux kernel exactly for
+  correct output.
+  
+  To produce the WCHAN field, ps needs to read the System.map file created
+  when the kernel is compiled. The search path is:
+  
+- $PS_SYSTEM_MAP
+- /boot/System.map-`uname -r`
+- /boot/System.map
+- /lib/modules/`uname -r`/System.map
+- /usr/src/linux/System.map
+  
+  The member used_math of task_struct is not shown, since crt0.s checks
+  to see if math is present. This causes the math flag to be set for all
+  processes, and so it is worthless. (Somebody fix libc or the kernel please)
+  
+  Programs swapped out to disk will be shown without command line arguments,
+- and unless the c option is given, in brackets.
+  
+  %CPU shows the cputime/realtime percentage. It will not add up to 100%
+  unless you are lucky. It is time used divided by the time the process has
+--- 1,219 ----
++ '\" t
+  .\" Man page for ps.
++ .\" Licensed under version 2 of the GNU General Public License.
+  .\"
+  .\"
+  .TH PS 1 "July 5, 1998" "Linux" "Linux User's Manual"
++ .SH NAME
++ \fBps\fR \- report process status
+  
++ .SH SYNOPSIS
++ \fBps\fR [\fIoptions\fR]
+  
+  
++ .SH DESCRIPTION
++ \fBps\fR gives a snapshot of the current processes. If you want
++ a repetitive update of this status, use \fBtop\fR. This man
++ page documents the /proc-based version of \fBps\fR, or tries to.
+  
+  
++ .SH OPTIONS
+  
++ This version of \fBps\fR accepts several kinds of options.
+  
+  Unix options may be grouped and must be preceeded by a dash.
+  BSD options may be grouped and must not be used with a dash.
++ GNU long options are preceeded by two dashes.
+  
+  Options of different types may be freely mixed.
+  
++ Set the \fBI_WANT_A_BROKEN_PS\fR environment variable to force BSD syntax even
++ when options are preceeded by a dash. The \fBPS_PERSONALITY\fR environment
+  variable (described below) provides more detailed control of ps behavior.
+  
+  SIMPLE PROCESS SELECTION
++ .TS
++ lfB l.
++ -A	select all processes
++ -N	negate selection
++ -a	select all with a tty except session leaders
++ -d	select all, but omit session leaders
++ -e	select all processes
++ T	select all processes on this terminal
++ a	select all processes on a terminal, including those of other users
++ g	really all, even group leaders (does nothing w/o SunOS settings)
++ r	restrict output to running processes
++ x	select processes without controlling ttys
++ --deselect	negate selection
++ .TE
+  
+  PROCESS SELECTION BY LIST
++ .TS
++ lfB l.
++ -C	select by command name
++ -G	select by RGID (supports names)
++ -U	select by RUID (supports names)
++ -g	select by session leader OR by group name
++ -p	select by PID
++ -s	select processes belonging to the sessions given
++ -t	select by tty
++ -u	select by effective user ID (supports names)
++ U	select processes for specified users
++ p	select by process ID
++ t	select by tty
++ --Group	select by real group name or ID
++ --User	select by real user name or ID
++ --group	select by effective group name or ID
++ --pid	select by process ID
++ --sid	select by session ID
++ --tty	select by terminal
++ --user	select by effective user name or ID
++ -123	implied --sid
++ 123	implied --pid
++ .TE
+  
+  OUTPUT FORMAT CONTROL
++ .TS
++ lfB l.
++ -O	is preloaded "-o"
++ -c	different scheduler info for -l option
++ -f	does full listing
++ -j	jobs format
++ -l	long format
++ -o	user-defined format
++ -y	do not show flags; show rss in place of addr
++ O	is preloaded "o" (overloaded)
++ X	old Linux i386 register format
++ j	job control format
++ l	Display long format
++ o	specify user-defined format
++ s	display signal format
++ u	display user-oriented format
++ v	display virtual memory format
++ --format	user-defined format
++ .TE
+  
+  OUTPUT MODIFIERS
++ .TS
++ lfB l.
++ -H	show process hierarchy (forest)
++ -m	shows threads
++ -n	sets namelist file
++ -w	wide output
++ C	use raw CPU time for %CPU instead of decaying average
++ N	specify namelist file
++ O	sorting order (overloaded)
++ S,
++ --cumulative	include some dead child process data (as a sum with the parent)
++ c	true command name
++ e	show environment after the command
++ f, --forest	ASCII-art process hierarchy (forest)
++ h	no header (or, one header per screen in the BSD personality)
++ m	all threads
++ n	numeric output for WCHAN and USER
++ --cols,
++ --columns,
++ --width	set screen width
++ --headers	repeat header lines, one per page of output
++ --no-headers	print no header line at all
++ --lines,
++ --rows	set screen height
++ --sort	specify sorting order
++ .TE
+  
+  INFORMATION
++ .TS
++ lfB l.
++ -V, V,
++ --version	print version
++ L	list all format specifiers
++ --help	print help message
++ --info	print debugging info
++ .TE
+  
+  OBSOLETE
++ .TS
++ lfB l.
++ A	increases the argument space (DecUnix)
++ M	use alternate core (try -n or N instead)
++ W	get swap info from ... not /dev/drum (try -n or N instead)
++ k	use /vmcore as c-dumpfile (try -n or N instead)
++ .TE
+  
+  
++ .SH NOTES
+  
++ The \fB-g\fR option can select by session leader OR by group name.
+  Selection by session leader is specified by many standards,
+  but selection by group is the logical behavior that several other
+  operating systems use. This ps will select by session leader when
+  the list is completely numeric (as sessions are). Group ID numbers
+  will work only when some group names are also specified.
+  
++ The \fBm\fR option should not be used. Use \fB-m\fR or \fB-o\fR with a list.
++ (\fBm\fR displays memory info, shows threads, or sorts by memory use)
+  
++ The \fBh\fR option is problematic.  Standard BSD \fBps\fR uses the option to
++ print a header on each page of output, but older Linux \fBps\fR uses the option
+  to totally disable the header.  This version of ps follows the Linux
+  usage of not printing the header unless the BSD personality has been
+  selected, in which case it prints a header on each page of output.
+  Regardless of the current personality, you can use the long options
++ \fB--headers\fR and \fB--no-headers\fR to enable printing headers each page and
+  disable headers entirely, respectively.
+  
+  Terminals (ttys, or screens for text output) can be specified in several
++ forms: \fI/dev/ttyS1\fR, \fIttyS1\fR, \fIS1\fR. Obsolete \fBps t\fR (your own terminal) and
++ \fBps t?\fR (processes without a terminal) syntax is supported, but modern
++ options (\fBT\fR, \fB-t\fR with list, \fBx\fR, \fBt\fR with list) should be used instead.
+  
++ The BSD \fBO\fR option can act like \fB-O\fR (user-defined output format with
+  some common fields predefined) or can be used to specify sort order.
+  Heuristics are used to determine the behavior of this option. To ensure
+  that the desired behavior is obtained, specify the other option (sorting
+  or formatting) in some other way.
+  
++ For sorting, BSD \fBO\fR option syntax is \fBO\fR[+|-]\fIk1\fR[,[+|-]\fIk2\fR[,...]]
+  Order the process listing according to the multilevel sort specified by
++ the sequence of short keys from SORT KEYS, \fIk1\fR, \fIk2\fR, ... The `+' is quite
+  optional, merely re-iterating the default direction on a key. `-' reverses
++ direction only on the key it precedes. The \fBO\fR option must be the last option
+  in a single command argument, but specifications in successive arguments are
+  catenated.
+  
++ GNU sorting syntax is \fB--sort\fIX\fR[+|-]\fIkey\fR[,[+|-]\fIkey\fR[,...]]
+  Choose a multi-letter key from the SORT KEYS section. X may be any
+  convenient separator character. To be GNU-ish use `='. The `+' is really
+  optional since default direction is increasing numerical or lexicographic
++ order. For example, \fBps\fR \fIjax\fR \fB--sort\fR=\fIuid\fR,-\fIppid\fR,+\fIpid\fR
+  
++ This \fBps\fR works by reading the virtual files in /proc. This \fBps\fR does not
++ need to be suid kmem or have any privileges to run. Do not give this \fBps\fR
+  any special permissions.
+  
++ This \fBps\fR needs access to a namelist file for proper WCHAN display.
+  The namelist file must match the current Linux kernel exactly for
+  correct output.
+  
+  To produce the WCHAN field, ps needs to read the System.map file created
+  when the kernel is compiled. The search path is:
+  
++ .B $PS_SYSTEM_MAP
++ .br
++ .I /boot/System.map-`uname -r`
++ .br
++ .I /boot/System.map
++ .br
++ .I /lib/modules/`uname -r`/System.map
++ .br
++ .I /usr/src/linux/System.map
+  
+  The member used_math of task_struct is not shown, since crt0.s checks
+  to see if math is present. This causes the math flag to be set for all
+  processes, and so it is worthless. (Somebody fix libc or the kernel please)
+  
+  Programs swapped out to disk will be shown without command line arguments,
++ and unless the \fBc\fR option is given, in brackets.
+  
+  %CPU shows the cputime/realtime percentage. It will not add up to 100%
+  unless you are lucky. It is time used divided by the time the process has
+***************
+*** 219,512 ****
+  
+  Processes marked <defunct> are dead processes (so-called "zombies") that
+  remain because their parent has not destroyed them properly. These processes
+- will be destroyed by init(8) if the parent process exits.
+  
+  
+  PROCESS FLAGS
+- 
+- ALIGNWARN    001    print alignment warning msgs
+- STARTING     002    being created
+- EXITING      004    getting shut down
+- PTRACED      010    set if ptrace (0) has been called
+- TRACESYS     020    tracing system calls
+- FORKNOEXEC   040    forked but didn't exec
+- SUPERPRIV    100    used super-user privileges
+- DUMPCORE     200    dumped core
+- SIGNALED     400    killed by a signal
+  
+  
+  PROCESS STATE CODES
+- 
+- D uninterruptible sleep (usually IO)
+- R runnable (on run queue)
+- S sleeping
+- T traced or stopped
+- Z a defunct ("zombie") process
+  
+  For BSD formats and when the "stat" keyword is used, additional
+  letters may be displayed:
+  
+- W has no resident pages
+- < high-priority process
+- N low-priority task
+- L has pages locked into memory (for real-time and custom IO)
+- 
+- 
+- SORT KEYS
+  
+  Note that the values used in sorting are the internal values ps uses and not
+  the `cooked' values used in some of the output format fields. Pipe ps
+- output into the sort(1) command if you want to sort the cooked values.
+  
+- KEY LONG       DESCRIPTION
+- c   cmd        simple name of executable
+- C   cmdline    full command line
+- f   flags      flags as in long format F field
+- g   pgrp       process group ID
+- G   tpgid      controlling tty process group ID
+- j   cutime     cumulative user time
+- J   cstime     cumulative system time
+- k   utime      user time
+- K   stime      system time
+- m   min_flt    number of minor page faults
+- M   maj_flt    number of major page faults
+- n   cmin_flt   cumulative minor page faults
+- N   cmaj_flt   cumulative major page faults
+- o   session    session ID
+- p   pid        process ID
+- P   ppid       parent process ID
+- r   rss        resident set size
+- R   resident   resident pages
+- s   size       memory size in kilobytes
+- S   share      amount of shared pages
+- t   tty        the minor device number of tty
+- T   start_time time process was started
+- U   uid        user ID number
+- u   user       user name
+- v   vsize      total VM size in kB
+- y   priority   kernel scheduling priority
+  
+- 
+- AIX FORMAT DESCRIPTORS
+  
+  This ps supports AIX format descriptors, which work somewhat like the
+- formatting codes of printf(1) and printf(3). For example, the normal
+- default output can be produced with this:   ps -eo "%p %y %x %c"
+- 
+- CODE  NORMAL    HEADER
+- %C    pcpu      %CPU
+- %G    group     GROUP
+- %P    ppid      PPID
+- %U    user      USER
+- %a    args      COMMAND
+- %c    comm      COMMAND
+- %g    rgroup    RGROUP
+- %n    nice      NI
+- %p    pid       PID
+- %r    pgid      PGID
+- %t    etime     ELAPSED
+- %u    ruser     RUSER
+- %x    time      TIME
+- %y    tty       TTY
+- %z    vsz       VSZ
+  
+  
+- STANDARD FORMAT SPECIFIERS
+  
+  These may be used to control both output format and sorting.
+  For example:  ps -eo pid,user,args --sort user
+  
+- CODE         HEADER
+- %cpu         %CPU    
+- %mem         %MEM    
+- alarm        ALARM   
+- args         COMMAND 
+- blocked      BLOCKED 
+- bsdstart     START   
+- bsdtime      TIME    
+- c            C       
+- caught       CAUGHT  
+- cmd          CMD     
+- comm         COMMAND 
+- command      COMMAND 
+- cputime      TIME    
+- drs          DRS     
+- dsiz         DSIZ    
+- egid         EGID    
+- egroup       EGROUP  
+- eip          EIP     
+- esp          ESP     
+- etime        ELAPSED 
+- euid         EUID    
+- euser        EUSER   
+- f            F       
+- fgid         FGID    
+- fgroup       FGROUP  
+- flag         F       
+- flags        F       
+- fname        COMMAND 
+- fsgid        FSGID   
+- fsgroup      FSGROUP 
+- fsuid        FSUID   
+- fsuser       FSUSER  
+- fuid         FUID    
+- fuser        FUSER   
+- gid          GID     
+- group        GROUP   
+- ignored      IGNORED 
+- intpri       PRI     
+- lim          LIM     
+- longtname    TTY     
+- lstart       STARTED 
+- m_drs        DRS     
+- m_trs        TRS     
+- maj_flt      MAJFL   
+- majflt       MAJFLT  
+- min_flt      MINFL   
+- minflt       MINFLT  
+- ni           NI      
+- nice         NI      
+- nwchan       WCHAN   
+- opri         PRI     
+- pagein       PAGEIN  
+- pcpu         %CPU    
+- pending      PENDING 
+- pgid         PGID    
+- pgrp         PGRP    
+- pid          PID     
+- pmem         %MEM    
+- ppid         PPID    
+- pri          PRI     
+- priority     PRI     
+- rgid         RGID    
+- rgroup       RGROUP  
+- rss          RSS     
+- rssize       RSS     
+- rsz          RSZ     
+- ruid         RUID    
+- ruser        RUSER   
+- s            S       
+- sess         SESS    
+- session      SESS    
+- sgi_p        P       
+- sgi_rss      RSS     
+- sgid         SGID    
+- sgroup       SGROUP  
+- sid          SID     
+- sig          PENDING 
+- sig_block    BLOCKED 
+- sig_catch    CATCHED 
+- sig_ignore   IGNORED 
+- sig_pend     SIGNAL  
+- sigcatch     CAUGHT  
+- sigignore    IGNORED 
+- sigmask      BLOCKED 
+- stackp       STACKP  
+- start        STARTED 
+- start_stack  STACKP  
+- start_time   START   
+- stat         STAT    
+- state        S       
+- stime        STIME   
+- suid         SUID    
+- suser        SUSER   
+- svgid        SVGID   
+- svgroup      SVGROUP 
+- svuid        SVUID   
+- svuser       SVUSER  
+- sz           SZ      
+- time         TIME    
+- timeout      TMOUT   
+- tmout        TMOUT   
+- tname        TTY     
+- tpgid        TPGID   
+- trs          TRS     
+- trss         TRSS    
+- tsiz         TSIZ    
+- tt           TT      
+- tty          TT      
+- tty4         TTY     
+- tty8         TTY     
+- ucmd         CMD     
+- ucomm        COMMAND 
+- uid          UID     
+- uid_hack     UID     
+- uname        USER    
+- user         USER    
+- vsize        VSZ     
+- vsz          VSZ     
+- wchan        WCHAN   
+  
+  
+  
+  
+- ENVIRONMENT VARIABLES
+  The following environment variables could affect ps:
+-     COLUMNS             Override default display width.
+-     LINES               Override default display height.
+-     PS_PERSONALITY      Set to one of posix,old,linux,bsd,sun,digital...
+-     CMD_ENV             Set to one of posix,old,linux,bsd,sun,digital...
+-     I_WANT_A_BROKEN_PS  Force obsolete command line interpretation.
+-     LC_TIME             Date format.
+-     PS_COLORS           Not currently supported.
+-     PS_FORMAT           Default output format override.
+-     PS_SYSMAP           Default namelist (System.map) location.
+-     PS_SYSTEM_MAP       Default namelist (System.map) location.
+-     POSIXLY_CORRECT     Don't find excuses to ignore bad "features".
+-     UNIX95              Don't find excuses to ignore bad "features".
+-     _XPG                Cancel CMD_ENV=irix non-standard behavior.
+  
+  In general, it is a bad idea to set these variables. The one exception
+- is CMD_ENV or PS_PERSONALITY, which could be set to Linux for normal
+- systems. Without that setting, ps follows the useless and bad parts
+  of the Unix98 standard.
+  
+  
+  PERSONALITY
+-     390      like the S/390 OpenEdition ps
+-     aix      like AIX ps
+-     bsd      like FreeBSD ps (totally non-standard)
+-     compaq   like Digital Unix ps
+-     debian   like the old Debian ps
+-     digital  like Digital Unix ps
+-     gnu      like the old Debian ps
+-     hp       like HP-UX ps
+-     hpux     like HP-UX ps
+-     irix     like Irix ps
+-     linux    ***** RECOMMENDED *****
+-     old      like the original Linux ps (totally non-standard)
+-     posix    standard
+-     sco      like SCO ps
+-     sgi      like Irix ps
+-     sun      like SunOS 4 ps (totally non-standard)
+-     sunos    like SunOS 4 ps (totally non-standard)
+-     sysv     standard
+-     unix     standard
+-     unix95   standard
+-     unix98   standard
+  
+  
+- EXAMPLES
+  To see every process on the system using standard syntax:
+-     ps -e
+  To see every process on the system using BSD syntax:
+-     ps ax
+  To see every process except those running as root (real & effective ID)
+-     ps -U root -u root -N
+  To see every process with a user-defined format:
+-     ps -eo pid,tt,user,fname,tmout,f,wchan
+  Odd display with AIX field descriptors:
+-     ps -o "%u : %U : %p : %a"
+  Print only the process IDs of syslogd:
+-     ps -C syslogd -o pid=
+- 
+- SEE ALSO
+- top(1) pstree(1) proc(5)
+  
+- STANDARDS
+- This ps conforms to version 2 of the Single Unix Specification.
+  
+- AUTHOR
+  ps was originally written by Branko Lankester <lankeste@fwi.uva.nl>. Michael
+  K. Johnson <johnsonm@redhat.com> re-wrote it significantly to use the proc
+  filesystem, changing a few things in the process. Michael Shields
+--- 225,538 ----
+  
+  Processes marked <defunct> are dead processes (so-called "zombies") that
+  remain because their parent has not destroyed them properly. These processes
++ will be destroyed by \fBinit\fR(8) if the parent process exits.
+  
+  
+  PROCESS FLAGS
++ .TS
++ l l l.
++ ALIGNWARN	001	print alignment warning msgs
++ STARTING	002	being created
++ EXITING	004	getting shut down
++ PTRACED	010	set if ptrace (0) has been called
++ TRACESYS	020	tracing system calls
++ FORKNOEXEC	040	forked but didn't exec
++ SUPERPRIV	100	used super-user privileges
++ DUMPCORE	200	dumped core
++ SIGNALED	400	killed by a signal
++ .TE
+  
+  
+  PROCESS STATE CODES
++ .TS
++ l l.
++ D	uninterruptible sleep (usually IO)
++ R	runnable (on run queue)
++ S	sleeping
++ T	traced or stopped
++ Z	a defunct ("zombie") process
++ .TE
+  
+  For BSD formats and when the "stat" keyword is used, additional
+  letters may be displayed:
++ .TS
++ l l.
++ W	has no resident pages
++ <	high-priority process
++ N	low-priority task
++ L	has pages locked into memory (for real-time and custom IO)
++ .TE
+  
++ .SH SORT KEYS
+  
+  Note that the values used in sorting are the internal values ps uses and not
+  the `cooked' values used in some of the output format fields. Pipe ps
++ output into the \fBsort\fR(1) command if you want to sort the cooked values.
+  
++ .TS
++ l l l.
++ KEY	LONG	DESCRIPTION
++ c	cmd	simple name of executable
++ C	cmdline	full command line
++ f	flags	flags as in long format F field
++ g	pgrp	process group ID
++ G	tpgid	controlling tty process group ID
++ j	cutime	cumulative user time
++ J	cstime	cumulative system time
++ k	utime	user time
++ K	stime	system time
++ m	min_flt	number of minor page faults
++ M	maj_flt	number of major page faults
++ n	cmin_flt	cumulative minor page faults
++ N	cmaj_flt	cumulative major page faults
++ o	session	session ID
++ p	pid	process ID
++ P	ppid	parent process ID
++ r	rss	resident set size
++ R	resident	resident pages
++ s	size	memory size in kilobytes
++ S	share	amount of shared pages
++ t	tty	the minor device number of tty
++ T	start_time	time process was started
++ U	uid	user ID number
++ u	user	user name
++ v	vsize	total VM size in kB
++ y	priority	kernel scheduling priority
++ .TE
+  
++ .SH AIX FORMAT DESCRIPTORS
+  
+  This ps supports AIX format descriptors, which work somewhat like the
++ formatting codes of \fBprintf\fR(1) and \fBprintf\fR(3). For example, the normal
++ default output can be produced with this:   \fBps\fR \fB-eo\fR "%p %y %x %c"
+  
++ .TS
++ l l l.
++ CODE	NORMAL	HEADER
++ %C	pcpu	%CPU
++ %G	group	GROUP
++ %P	ppid	PPID
++ %U	user	USER
++ %a	args	COMMAND
++ %c	comm	COMMAND
++ %g	rgroup	RGROUP
++ %n	nice	NI
++ %p	pid	PID
++ %r	pgid	PGID
++ %t	etime	ELAPSED
++ %u	ruser	RUSER
++ %x	time	TIME
++ %y	tty	TTY
++ %z	vsz	VSZ
++ .TE
+  
++ .SH STANDARD FORMAT SPECIFIERS
+  
+  These may be used to control both output format and sorting.
+  For example:  ps -eo pid,user,args --sort user
+  
++ .TS
++ l l.
++ CODE	HEADER
++ %cpu	%CPU
++ %mem	%MEM
++ alarm	ALARM
++ args	COMMAND
++ blocked	BLOCKED
++ bsdstart	START
++ bsdtime	TIME
++ c	C
++ caught	CAUGHT
++ cmd	CMD
++ comm	COMMAND
++ command	COMMAND
++ cputime	TIME
++ drs	DRS
++ dsiz	DSIZ
++ egid	EGID
++ egroup	EGROUP
++ eip	EIP
++ esp	ESP
++ etime	ELAPSED
++ euid	EUID
++ euser	EUSER
++ f	F
++ fgid	FGID
++ fgroup	FGROUP
++ flag	F
++ flags	F
++ fname	COMMAND
++ fsgid	FSGID
++ fsgroup	FSGROUP
++ fsuid	FSUID
++ fsuser	FSUSER
++ fuid	FUID
++ fuser	FUSER
++ gid	GID
++ group	GROUP
++ ignored	IGNORED
++ intpri	PRI
++ lim	LIM
++ longtname	TTY
++ lstart	STARTED
++ m_drs	DRS
++ m_trs	TRS
++ maj_flt	MAJFL
++ majflt	MAJFLT
++ min_flt	MINFL
++ minflt	MINFLT
++ ni	NI
++ nice	NI
++ nwchan	WCHAN
++ opri	PRI
++ pagein	PAGEIN
++ pcpu	%CPU
++ pending	PENDING
++ pgid	PGID
++ pgrp	PGRP
++ pid	PID
++ pmem	%MEM
++ ppid	PPID
++ pri	PRI
++ priority	PRI
++ rgid	RGID
++ rgroup	RGROUP
++ rss	RSS
++ rssize	RSS
++ rsz	RSZ
++ ruid	RUID
++ ruser	RUSER
++ s	S
++ sess	SESS
++ session	SESS
++ sgi_p	P
++ sgi_rss	RSS
++ sgid	SGID
++ sgroup	SGROUP
++ sid	SID
++ sig	PENDING
++ sig_block	BLOCKED
++ sig_catch	CATCHED
++ sig_ignore	IGNORED
++ sig_pend	SIGNAL
++ sigcatch	CAUGHT
++ sigignore	IGNORED
++ sigmask	BLOCKED
++ stackp	STACKP
++ start	STARTED
++ start_stack	STACKP
++ start_time	START
++ stat	STAT
++ state	S
++ stime	STIME
++ suid	SUID
++ suser	SUSER
++ svgid	SVGID
++ svgroup	SVGROUP
++ svuid	SVUID
++ svuser	SVUSER
++ sz	SZ
++ time	TIME
++ timeout	TMOUT
++ tmout	TMOUT
++ tname	TTY
++ tpgid	TPGID
++ trs	TRS
++ trss	TRSS
++ tsiz	TSIZ
++ tt	TT
++ tty	TT
++ tty4	TTY
++ tty8	TTY
++ ucmd	CMD
++ ucomm	COMMAND
++ uid	UID
++ uid_hack	UID
++ uname	USER
++ user	USER
++ vsize	VSZ
++ vsz	VSZ
++ wchan	WCHAN
++ .TE
+  
+  
+  
++ .SH ENVIRONMENT VARIABLES
+  
+  The following environment variables could affect ps:
++ .TS
++ lfB l.
++ COLUMNS	Override default display width.
++ LINES	Override default display height.
++ PS_PERSONALITY	Set to one of posix,old,linux,bsd,sun,digital...
++ CMD_ENV	Set to one of posix,old,linux,bsd,sun,digital...
++ I_WANT_A_BROKEN_PS	Force obsolete command line interpretation.
++ LC_TIME	Date format.
++ PS_COLORS	Not currently supported.
++ PS_FORMAT	Default output format override.
++ PS_SYSMAP	Default namelist (System.map) location.
++ PS_SYSTEM_MAP	Default namelist (System.map) location.
++ POSIXLY_CORRECT	Don't find excuses to ignore bad "features".
++ UNIX95	Don't find excuses to ignore bad "features".
++ _XPG	Cancel CMD_ENV=irix non-standard behavior.
++ .TE
+  
+  In general, it is a bad idea to set these variables. The one exception
++ is \fBCMD_ENV\fR or \fBPS_PERSONALITY\fR, which could be set to Linux for normal
++ systems. Without that setting, \fBps\fR follows the useless and bad parts
+  of the Unix98 standard.
+  
+  
+  PERSONALITY
++ .TS
++ l l.
++ 390	like the S/390 OpenEdition ps
++ aix	like AIX ps
++ bsd	like FreeBSD ps (totally non-standard)
++ compaq	like Digital Unix ps
++ debian	like the old Debian ps
++ digital	like Digital Unix ps
++ gnu	like the old Debian ps
++ hp	like HP-UX ps
++ hpux	like HP-UX ps
++ irix	like Irix ps
++ linux	***** RECOMMENDED *****
++ old	like the original Linux ps (totally non-standard)
++ posix	standard
++ sco	like SCO ps
++ sgi	like Irix ps
++ sun	like SunOS 4 ps (totally non-standard)
++ sunos	like SunOS 4 ps (totally non-standard)
++ sysv	standard
++ unix	standard
++ unix95	standard
++ unix98	standard
++ .TE
+  
+  
++ .SH EXAMPLES
+  To see every process on the system using standard syntax:
++     \fBps\fR \fB-e\fR
++ .br
+  To see every process on the system using BSD syntax:
++     \fBps\fR \fBax\fR
++ .br
+  To see every process except those running as root (real & effective ID)
++     \fBps\fR \fB-U\fR \fIroot\fR \fB-u\fR \fIroot\fR \fB-N\fR
++ .br
+  To see every process with a user-defined format:
++     \fBps\fR \fB-eo\fR pid,tt,user,fname,tmout,f,wchan
++ .br
+  Odd display with AIX field descriptors:
++     \fBps\fR \fB-o\fR "%u : %U : %p : %a"
++ .br
+  Print only the process IDs of syslogd:
++     \fBps\fR \fB-C\fR \fIsyslogd\fR \fB-o\fR pid=
+  
++ .SH CONFORMING TO
++ This \fBps\fR conforms to version 2 of the Single Unix Specification.
+  
++ .SH AUTHOR
+  ps was originally written by Branko Lankester <lankeste@fwi.uva.nl>. Michael
+  K. Johnson <johnsonm@redhat.com> re-wrote it significantly to use the proc
+  filesystem, changing a few things in the process. Michael Shields
+***************
+*** 515,521 ****
+  device name-to-number mmaped database, the approximate binary search
+  directly on System.map, and many code and documentation cleanups. David
+  Mossberger-Tang wrote the generic BFD support for psupdate. Albert Cahalan
+- <acahalan@cs.uml.edu> rewrote ps for full Unix98 and BSD support, along with
+  some ugly hacks for obsolete and foreign syntax.
+  
+- Please send bug reports to <acahalan@cs.uml.edu>
+--- 541,551 ----
+  device name-to-number mmaped database, the approximate binary search
+  directly on System.map, and many code and documentation cleanups. David
+  Mossberger-Tang wrote the generic BFD support for psupdate. Albert Cahalan
++ <acahalan@cs.uml.edu> rewrote \fBps\fR for full Unix98 and BSD support, along with
+  some ugly hacks for obsolete and foreign syntax.
+  
++ Please send bug reports to <acahalan@cs.uml.edu> or use the Debian Bug Tracking System.
++ 
++ .SH SEE ALSO
++ \fBtop\fR(1), \fBpstree\fR(1), \fBproc\fR(5)
++ 
diff -N -u -r procps-2.0.7.orig/ps/ps.1~ procps-2.0.7/ps/ps.1~
--- procps-2.0.7.orig/ps/ps.1~	Thu Jan  1 01:00:00 1970
+++ procps-2.0.7/ps/ps.1~	Tue Jul 11 19:22:44 2000
@@ -0,0 +1,606 @@
+,\" t
+.\" (The preceding line is a note to broken versions of man to tell
+.\" them to pre-process this man page with tbl)
+.\" Man page for ps.
+.\" Licensed under version 2 of the GNU General Public License.
+.\" Modified by Michael K. Johnson from a gross plain-text hack
+.\" by Albert Cahalan of Michael's original version.
+.\"
+.TH PS 1 "March 11, 1999" "Linux" "Linux User's Manual"
+.SH NAME
+ps \- report process status
+.SH SYNOPSIS
+ps [\fIoptions\fP]
+
+.SH DESCRIPTION
+ps gives a snapshot of the current processes. If you want
+a repetitive update of this status, use top. This man
+page documents the /proc-based version of ps, or tries to.
+
+.SH "COMMAND-LINE OPTIONS"
+
+This version of ps accepts several kinds of options.
+.br
+.RS
+Unix98 options may be grouped and must be preceeded by a dash.
+.br
+BSD options may be grouped and must not be used with a dash.
+.br
+GNU long options are preceeded by two dashes.
+.RE
+.br
+Options of different types may be freely mixed.
+
+Set the \f(CWI_WANT_A_BROKEN_PS\fR environment variable to force BSD
+syntax even when options are preceeded by a dash. The \f(CWPS_PERSONALITY\fR
+environment variable (described below) provides more detailed control of
+ps behavior.
+
+.SS "SIMPLE PROCESS SELECTION"
+.TS
+lB lB
+lfCW l.
+Switch	Description
+.TH
+-A	select all processes
+-N	negate selection
+-a	select all with a tty except session leaders
+-d	select all, but omit session leaders
+-e	select all processes
+T	select all processes on this terminal
+a	T{
+select all processes on a terminal, including those of other users
+T}
+g	T{
+really all, even group leaders (does nothing w/o SunOS settings)
+T}
+r	restrict output to running processes
+x	select processes without controlling ttys
+--deselect	negate selection
+.TE
+
+.SS "PROCESS SELECTION BY LIST"
+.TS
+lB lB
+lfCW l.
+Switch	Description
+.TH
+-C	select by command name
+-G	select by RGID (supports names)
+-U	select by RUID (supports names)
+-g	select by session leader OR by group name
+-p	select by PID
+-s	select processes belonging to the sessions given
+-t	select by tty
+-u	select by effective user ID (supports names)
+U	select processes for specified users
+p	select by process ID
+t	select by tty
+--Group	select by real group name or ID
+--User	select by real user name or ID
+--group	select by effective group name or ID
+--pid	select by process ID
+--sid	select by session ID
+--tty	select by terminal
+--user	select by effective user name or ID
+-123	implied --sid
+123	implied --pid
+.TE
+
+.SS "OUTPUT FORMAT CONTROL"
+.TS
+lB lB
+lfCW l.
+Switch	Description
+.TH
+-O	is preloaded "-o"
+-c	different scheduler info for -l option
+-f	does full listing
+-j	jobs format
+-l	long format
+-o	user-defined format
+-y	do not show flags; show rss in place of addr
+O	is preloaded "o" (overloaded)
+X	old Linux i386 register format
+j	job control format
+l	display long format
+o	specify user-defined format
+s	display signal format
+u	display user-oriented format
+v	display virtual memory format
+--format	user-defined format
+.TE
+
+.SS "OUTPUT MODIFIERS"
+.TS
+lB lB
+lfCW l.
+Switch	Description
+.TH
+-H	show process hierarchy (forest)
+-m	show threads
+-n	set namelist file
+-w	wide output
+C	use raw CPU time for %CPU instead of decaying average
+N	specify namelist file
+O	sorting order (overloaded)
+S	T{
+include some dead child process data (as a sum with the parent)
+T}
+c	true command name
+e	show environment after the command
+f	ASCII-art process hierarchy (forest)
+h	T{
+do not print header lines (repeat header lines in BSD personality)
+T}
+m	all threads
+n	numeric output for WCHAN and USER
+w	wide output
+--cols	set screen width
+--columns	set screen width
+--cumulative	T{
+include some dead child process data (as a sum with the parent)
+T}
+--forest	ASCII art process tree
+--html	HTML escaped output
+--headers	repeat header lines
+--no-headers	print no header line at all
+--lines	set screen height
+--nul	unjustified output with NULs
+--null	unjustified output with NULs
+--rows	set screen height
+--sort	specify sorting order
+--width	set screen width
+--zero	unjustified output with NULs
+.TE
+
+.SS INFORMATION
+.TS
+lB lB
+lfCW l.
+Switch	Description
+.TH
+-V	print version
+L	list all format specifiers
+V	show version info
+--help	print help message
+--info	print debugging info
+--version	print version
+.TE
+
+.SS OBSOLETE
+.TS
+lB lB
+lfCW l.
+Switch	Description
+.TH
+A	increase the argument space (DecUnix)
+M	use alternate core (try -n or N instead)
+W	get swap info from ... not /dev/drum (try -n or N instead)
+k	use /vmcore as c-dumpfile (try -n or N instead)
+.TE
+
+.SH NOTES
+
+The "-g" option can select by session leader OR by group name.
+Selection by session leader is specified by many standards,
+but selection by group is the logical behavior that several other
+operating systems use. This ps will select by session leader when
+the list is completely numeric (as sessions are). Group ID numbers
+will work only when some group names are also specified.
+
+The "m" option should not be used. Use "-m" or "-o" with a list.
+("m" displays memory info, shows threads, or sorts by memory use)
+
+The "h" option is problematic.  Standard BSD ps uses the option to
+print a header on each page of output, but older Linux ps uses the option
+to totally disable the header.  This version of ps follows the Linux
+usage of not printing the header unless the BSD personality has been
+selected, in which case it prints a header on each page of output.
+Regardless of the current personality, you can use the long options
+--headers and --no-headers to enable printing headers each page and
+disable headers entirely, respectively.
+
+Terminals (ttys, or screens of text output) can be specified in several
+forms: /dev/ttyS1, ttyS1, S1. Obsolete "ps t" (your own terminal) and
+"ps t?" (processes without a terminal) syntax is supported, but modern
+options ("T", "-t" with list, "x", "t" with list) should be used instead.
+
+The BSD "O" option can act like "-O" (user-defined output format with
+some common fields predefined) or can be used to specify sort order.
+Heuristics are used to determine the behavior of this option. To ensure
+that the desired behavior is obtained, specify the other option (sorting
+or formatting) in some other way.
+
+For sorting, BSD "O" option syntax is O[+|-]k1[,[+|-]k2[,...]]
+Order the process listing according to the multilevel sort specified by
+the sequence of short keys from SORT KEYS, k1, k2, ... The `+' is quite
+optional, merely re-iterating the default direction on a key. `-' reverses
+direction only on the key it precedes. The O option must be the last option
+in a single command argument, but specifications in successive arguments are
+catenated.
+
+GNU sorting syntax is --sortX[+|-]key[,[+|-]key[,...]]
+Choose a multi-letter key from the SORT KEYS section. X may be any
+convenient separator character. To be GNU-ish use `='. The `+' is really
+optional since default direction is increasing numerical or lexicographic
+order. For example, ps jax --sort=uid,-ppid,+pid
+
+This ps works by reading the virtual files in /proc. This ps does not
+need to be suid kmem or have any privileges to run. Do not give this ps
+any special permissions.
+
+This ps needs access to a namelist file for proper WCHAN display.
+The namelist file must match the current Linux kernel exactly for
+correct output.
+
+To produce the WCHAN field, ps needs to read the System.map file created
+when the kernel is compiled. The search path is:
+.RS
+$PS_SYSTEM_MAP
+.br
+/boot/System.map-`uname -r`
+.br
+/boot/System.map
+.br
+/lib/modules/`uname -r`/System.map
+.br
+/usr/src/linux/System.map
+.br
+/System.map
+.RE
+The member used_math of task_struct is not shown, since crt0.s checks
+to see if math is present. This causes the math flag to be set for all
+processes, and so it is worthless. (Somebody fix libc or the kernel please.)
+
+Programs swapped out to disk will be shown without command line arguments,
+and unless the c option is given, in brackets.
+
+%CPU shows the cputime/realtime percentage. It will not add up to 100%
+unless you are lucky. It is time used divided by the time the process has
+been running.
+
+The SIZE and RSS fields don't count the page tables and the task_struct of a
+proc; this is at least 12k of memory that is always resident. SIZE is the
+virtual size of the proc (code+data+stack).
+
+Processes marked <defunct> are dead processes (so-called "zombies")
+that remain because their parent has not destroyed them properly. These
+processes will be destroyed by init(8) if the parent process exits.
+
+.SS "PROCESS FLAGS"
+.TS
+lfCW lfCW l.
+ALIGNWARN	001	print alignment warning msgs
+STARTING	002	being created
+EXITING	004	getting shut down
+PTRACED	010	set if ptrace (0) has been called
+TRACESYS	020	tracing system calls
+FORKNOEXEC	040	forked but didn't exec
+SUPERPRIV	100	used super-user privileges
+DUMPCORE	200	dumped core
+SIGNALED	400	killed by a signal
+.TE
+
+.SS "PROCESS STATE CODES"
+.TS
+lfCW l.
+D	uninterruptible sleep (usually IO)
+R	runnable (on run queue)
+S	sleeping
+T	traced or stopped
+Z	a defunct ("zombie") process
+.TE
+
+For BSD formats and when the "stat" keyword is used, additional
+letters may be displayed:
+.TS
+lfCW l.
+W	has no resident pages
+<	high-priority process
+N	low-priority task
+L	has pages locked into memory (for real-time and custom IO)
+.TE
+
+.SS "SORT KEYS"
+
+Note that the values used in sorting are the internal values ps uses and not
+the `cooked' values used in some of the output format fields. Pipe ps
+output into the sort(1) command if you want to sort the cooked values.
+
+.TS
+lB lB lB
+lfCW lfCW l.
+KEY	LONG	DESCRIPTION
+.TH
+c	cmd	simple name of executable
+C	cmdline	full command line
+f	flags	flags as in long format F field
+g	pgrp	process group ID
+G	tpgid	controlling tty process group ID
+j	cutime	cumulative user time
+J	cstime	cumulative system time
+k	utime	user time
+K	stime	system time
+m	min_flt	number of minor page faults
+M	maj_flt	number of major page faults
+n	cmin_flt	cumulative minor page faults
+N	cmaj_flt	cumulative major page faults
+o	session	session ID
+p	pid	process ID
+P	ppid	parent process ID
+r	rss	resident set size
+R	resident	resident pages
+s	size	memory size in kilobytes
+S	share	amount of shared pages
+t	tty	the minor device number of tty
+T	start_time	time process was started
+U	uid	user ID number
+u	user	user name
+v	vsize	total VM size in bytes
+y	priority	kernel scheduling priority
+.TE
+
+.SS "AIX FORMAT DESCRIPTORS"
+
+This ps supports AIX format descriptors, which work somewhat like the
+formatting codes of printf(1) and printf(3). For example, the normal
+default output can be produced with this:   ps -eo "%p %y %x %c"
+
+.TS
+lB lB lB
+lfCW lfCW l.
+CODE	NORMAL	HEADER
+.TH
+%C	pcpu	%CPU
+%G	group	GROUP
+%P	ppid	PPID
+%U	user	USER
+%a	args	COMMAND
+%c	comm	COMMAND
+%g	rgroup	RGROUP
+%n	nice	NI
+%p	pid	PID
+%r	pgid	PGID
+%t	etime	ELAPSED
+%u	ruser	RUSER
+%x	time	TIME
+%y	tty	TTY
+%z	vsz	VSZ
+.TE
+
+.SS "STANDARD FORMAT SPECIFIERS"
+
+These may be used to control both output format and sorting.
+.br
+For example:  ps -eo pid,user,args --sort user
+
+.TS
+lB lB
+lfCW lfCW.
+CODE	HEADER
+.TH
+%cpu	%CPU
+%mem	%MEM
+alarm	ALARM
+args	COMMAND
+blocked	BLOCKED
+bsdstart	START
+bsdtime	TIME
+c	C
+caught	CAUGHT
+cmd	CMD
+comm	COMMAND
+command	COMMAND
+cputime	TIME
+drs	DRS
+dsiz	DSIZ
+egid	EGID
+egroup	EGROUP
+eip	EIP
+esp	ESP
+etime	ELAPSED
+euid	EUID
+euser	EUSER
+f	F
+fgid	FGID
+fgroup	FGROUP
+flag	F
+flags	F
+fname	COMMAND
+fsgid	FSGID
+fsgroup	FSGROUP
+fsuid	FSUID
+fsuser	FSUSER
+fuid	FUID
+fuser	FUSER
+gid	GID
+group	GROUP
+ignored	IGNORED
+intpri	PRI
+lim	LIM
+longtname	TTY
+lstart	STARTED
+m_drs	DRS
+m_trs	TRS
+maj_flt	MAJFL
+majflt	MAJFLT
+min_flt	MINFL
+minflt	MINFLT
+ni	NI
+nice	NI
+nwchan	WCHAN
+opri	PRI
+pagein	PAGEIN
+pcpu	%CPU
+pending	PENDING
+pgid	PGID
+pgrp	PGRP
+pid	PID
+pmem	%MEM
+ppid	PPID
+pri	PRI
+rgid	RGID
+rgroup	RGROUP
+rss	RSS
+rssize	RSS
+rsz	RSZ
+ruid	RUID
+ruser	RUSER
+s	S
+sess	SESS
+session	SESS
+sgi_p	P
+sgi_rss	RSS
+sgid	SGID
+sgroup	SGROUP
+sid	SID
+sig	PENDING
+sig_block	BLOCKED
+sig_catch	CATCHED
+sig_ignore	IGNORED
+sig_pend	SIGNAL
+sigcatch	CAUGHT
+sigignore	IGNORED
+sigmask	BLOCKED
+stackp	STACKP
+start	STARTED
+start_stack	STACKP
+start_time	START
+stat	STAT
+state	S
+stime	STIME
+suid	SUID
+suser	SUSER
+svgid	SVGID
+svgroup	SVGROUP
+svuid	SVUID
+svuser	SVUSER
+sz	SZ
+time	TIME
+timeout	TMOUT
+tmout	TMOUT
+tname	TTY
+tpgid	TPGID
+trs	TRS
+trss	TRSS
+tsiz	TSIZ
+tt	TT
+tty	TT
+tty4	TTY
+tty8	TTY
+ucomm	COMMAND
+uid	UID	
+uid_hack	UID
+uname	USER	
+user	USER	
+vsize	VSZ	
+vsz	VSZ	
+wchan	WCHAN	
+.TE
+
+.SS "ENVIRONMENT VARIABLES"
+
+The following environment variables could affect ps:
+.TS
+lfCW l.
+COLUMNS	Override default display width
+LINES	Override default display height
+PS_PERSONALITY	Set to one of posix,old,linux,bsd,sun,digital
+CMD_ENV	Set to one of posix,old,linux,bsd,sun,digital
+I_WANT_A_BROKEN_PS	Force obsolete command line interpretation
+LC_TIME	Date format
+PS_FORMAT	Default output format override
+PS_SYSMAP	Default namelist (System.map) location
+PS_SYSTEM_MAP	Default namelist (System.map) location
+POSIXLY_CORRECT	Don't find excuses to ignore bad "features"
+UNIX95	Don't find excuses to ignore bad "features"
+_XPG	Cancel CMD_ENV=irix non-standard behavior
+.TE
+
+In general, it is a bad idea to set these variables. The two exceptions
+are CMD_ENV (or PS_PERSONALITY), to set the desired default personality,
+and POSIXLY_CORRECT (or UNIX95), which should be set for Unix98 standard
+compliance.
+
+.TS
+lfCW lb
+lfCW l.
+PS_PERSONALITY	Description
+.TH
+\fInone\fP	"Do the right thing"
+aix	like AIX ps
+bsd	like FreeBSD ps
+compaq	like Digital Unix ps
+debian	like the old Debian ps
+digital	like Digital Unix ps
+gnu	like the old Debian ps
+hp	like HP-UX ps
+hpux	like HP-UX ps
+irix	like Irix ps
+linux	deviate from Unix98 for convenience only
+old	like the original Linux ps
+posix	standard
+sco	like SCO ps
+sgi	like Irix ps
+sun	like SunOS 4 ps
+sunos	like SunOS 4 ps
+sysv	standard
+unix	standard
+unix95	standard
+unix98	standard
+.TE
+
+.SH EXAMPLES
+
+To see every process on the system using standard syntax:
+.RS
+ps -e
+.RE
+To see every process on the system using BSD syntax:
+.RS
+ps ax
+.RE
+To see every process except those running as root (real & effective ID)
+.RS
+ps -U root -u root -N
+.RE
+To see every process with a user-defined format:
+.RS
+ps -eo pid,tt,user,fname,tmout,f,wchan
+.RE
+Odd display with AIX field descriptors:
+.RS
+ps -o "%u : %U : %p : %a"
+.RE
+Print only the process IDs of syslogd:
+.RS
+ps -C syslogd -o pid=
+.RE
+
+.SH "SEE ALSO"
+top(1) pstree(1) proc(5)
+
+.SH STANDARDS
+This ps can be set to conform to version 2 of the Single Unix Specification.
+
+.SH AUTHOR
+ps was originally written by Branko Lankester <lankeste@fwi.uva.nl>.
+.br
+Michael K. Johnson <johnsonm@redhat.com> re-wrote it significantly to
+use the proc filesystem, changing a few things in the process.
+.br
+Michael Shields <shields@msrl.com> added the pid-list feature.
+.br
+Charles Blake <cblake@bbn.com> added multi-level sorting, the dirent-style
+library, the device name-to-number mmaped database, the approximate
+binary search directly on System.map, and many code and documentation cleanups.
+.br
+David Mosberger-Tang wrote the generic BFD support for psupdate.
+.br
+Albert Cahalan <acahalan@cs.uml.edu> rewrote ps for full Unix98 and
+BSD support, along with some ugly hacks for obsolete and foreign syntax.
+
+Michael K. Johnson <johnsonm@redhat.com> is the current maintainer.
+
+Please send bug reports to <procps-bugs@redhat.com>
diff -N -u -r procps-2.0.7.orig/skill.1 procps-2.0.7/skill.1
--- procps-2.0.7.orig/skill.1	Tue Jul 11 19:22:44 2000
+++ procps-2.0.7/skill.1	Wed Aug 29 21:10:20 2001
@@ -1,4 +1,4 @@
-,\" t
+'\" t
 .\" (The preceding line is a note to broken versions of man to tell
 .\" them to pre-process this man page with tbl)
 .\" Man page for skill and snice.
diff -N -u -r procps-2.0.7.orig/top.c procps-2.0.7/top.c
--- procps-2.0.7.orig/top.c	Thu Jul 13 22:19:21 2000
+++ procps-2.0.7/top.c	Wed Aug 29 21:10:20 2001
@@ -101,6 +101,7 @@
 #include <setjmp.h>
 #include <stdarg.h>
 #include <sys/param.h>
+#include <locale.h>
 
 #include "proc/sysinfo.h"
 #include "proc/procps.h"
@@ -239,7 +240,9 @@
 {
     FILE *fp;
     char *pt;
-    char rcfile[MAXNAMELEN];
+    char *rcfile = NULL;        /* path to rc file... */
+    char *home = NULL;          /* path of user's home directory... */
+    size_t home_length = 0;     /* length of path... */
     char Options[256] = "";
     int i;
 
@@ -248,30 +251,38 @@
     /* read cpuname */
     for (i=0; i< nr_cpu; i++) cpu_mapping[i]=i;
     header_lines = 6 + nr_cpu;
-    strcpy(rcfile, SYS_TOPRC);
-    fp = fopen(rcfile, "r");
+    fp = fopen(SYS_TOPRC, "r");
     if (fp != NULL) {
 	fgets(Options, 254, fp);
 	fclose(fp);
     }
     parse_options(Options, 0);
     strcpy(Options, "");
-    if (getenv("HOME")) {
-	strcpy(rcfile, getenv("HOME"));
-	strcat(rcfile, "/");
-    }
-    strcat(rcfile, RCFILE);
-    fp = fopen(rcfile, "r");
-    if (fp == NULL) {
-	strcpy(Fields, DEFAULT_SHOW);
-    } else {
-	if (fgets(Fields, 254, fp) != NULL) {
-	    pt = strchr(Fields, '\n');
-	    if (pt) *pt = 0;
-	}
-	fgets(Options, 254, fp);
-	fclose(fp);
+
+    if ( (home = getenv("HOME")) != NULL) {
+          home_length = strlen(home);
     }
+
+    if ( (rcfile = malloc(home_length + strlen(RCFILE) + 2))) {
+        if (home != NULL) {
+            strcpy(rcfile, home);
+            strcat(rcfile, "/");
+        }
+        strcat(rcfile, RCFILE);
+        fp = fopen(rcfile, "r");
+        if (fp == NULL) {
+            strcpy(Fields, DEFAULT_SHOW);
+        } else {
+            if (fgets(Fields, 254, fp) != NULL) {
+                pt = strchr(Fields, '\n');
+                if (pt) *pt = 0;
+            }
+            fgets(Options, 254, fp);
+            fclose(fp);
+        }
+
+        free(rcfile);
+    }    
     parse_options(Options, getuid()? Secure : 0);
 }
 
@@ -699,6 +710,7 @@
     char *line;
     int i;
     float r;
+    char *savelocale;
 
     line = getstr();
 
@@ -713,7 +725,10 @@
     if (!line[0])
 	return (BAD_INPUT);
 
-    sscanf(line, "%f", &r);
+    savelocale = setlocale(LC_NUMERIC, NULL);
+    setlocale(LC_NUMERIC, "C");
+    sscanf(line, "%f", &r); 
+    setlocale(LC_NUMERIC, savelocale);
     return (r);
 }
 
@@ -1732,45 +1747,49 @@
 	change_order();
 	break;
       case 'W':
-	if (getenv("HOME")) {
-	    strcpy(rcfile, getenv("HOME"));
-	    strcat(rcfile, "/");
-	    strcat(rcfile, RCFILE);
-	    fp = fopen(rcfile, "w");
-	    if (fp != NULL) {
-		fprintf(fp, "%s\n", Fields);
-		i = (int) Sleeptime;
-		if (i < 2)
-		    i = 2;
-		if (i > 9)
-		    i = 9;
-		fprintf(fp, "%d", i);
-		if (Secure)
-		    fprintf(fp, "%c", 's');
-		if (Cumulative)
-		    fprintf(fp, "%c", 'S');
-		if (!show_cmd)
+	if (Secure)
+	    SHOWMESSAGE(("\aCan't write configuration in secure mode"));
+        else {
+	    if (getenv("HOME")) {
+	        strcpy(rcfile, getenv("HOME"));
+              strcat(rcfile, "/");
+              strcat(rcfile, RCFILE);
+              fp = fopen(rcfile, "w");
+              if (fp != NULL) {
+                  fprintf(fp, "%s\n", Fields);
+	 	  i = (int) Sleeptime;
+                  if (i < 2)
+                      i = 2;
+                  if (i > 9)
+                      i = 9;
+                  fprintf(fp, "%d", i);
+                  if (Secure)
+                      fprintf(fp, "%c", 's');
+                  if (Cumulative)
+                      fprintf(fp, "%c", 'S');
+                  if (!show_cmd)
 		    fprintf(fp, "%c", 'c');
-		if (Noidle)
-		    fprintf(fp, "%c", 'i');
-		if (!show_memory)
-		    fprintf(fp, "%c", 'm');
-		if (!show_loadav)
+                  if (Noidle)
+                      fprintf(fp, "%c", 'i');
+                  if (!show_memory)
+                      fprintf(fp, "%c", 'm');
+                  if (!show_loadav)
 		    fprintf(fp, "%c", 'l');
-		if (!show_stats)
-		    fprintf(fp, "%c", 't');
-		if (!Irixmode)
-		    fprintf(fp, "%c", 'I');
-		fprintf(fp, "\n");
-		fclose(fp);
-		SHOWMESSAGE(("Wrote configuration to %s", rcfile));
-	    } else {
-		SHOWMESSAGE(("Couldn't open %s", rcfile));
-	    }
-	} else {
-	    SHOWMESSAGE(("Couldn't get $HOME -- not saving"));
-	}
-	break;
+                  if (!show_stats)
+                      fprintf(fp, "%c", 't');
+                  if (!Irixmode)
+                      fprintf(fp, "%c", 'I');
+                  fprintf(fp, "\n");
+		  fclose(fp);
+		  SHOWMESSAGE(("Wrote configuration to %s", rcfile));
+              } else {
+                  SHOWMESSAGE(("Couldn't open %s", rcfile));
+              }
+            } else {
+                SHOWMESSAGE(("Couldn't get $HOME -- not saving"));
+            }
+          }
+        break;
       default:
 	SHOWMESSAGE(("\aUnknown command `%c' -- hit `h' for help", c));
     }
diff -N -u -r procps-2.0.7.orig/w.c procps-2.0.7/w.c
--- procps-2.0.7.orig/w.c	Mon Jul 10 23:41:32 2000
+++ procps-2.0.7/w.c	Wed Aug 29 21:29:17 2001
@@ -107,8 +107,6 @@
 			"Aug", "Sep", "Oct", "Nov", "Dec" };
     time_t curt;
     struct tm *logtm, *curtm;
-    int hour;
-    char *merid; /* meridian indicator */
     int today;
 
     curt = time(NULL);
@@ -116,18 +114,14 @@
     /* localtime returns a pointer to static memory */
     today = curtm->tm_yday;
     logtm = localtime(&logt);
-    hour = logtm->tm_hour;
-    merid = (hour < 12) ? "am" : "pm";
-    if (hour >= 12) hour -= 12;
-    if (hour == 0)  hour = 12;
     if (curt - logt > 12*60*60 && logtm->tm_yday != today) {
 	if (curt - logt > 6*24*60*60)
 	    fprintf(fout, " %2d%3s%02d", logtm->tm_mday, month[logtm->tm_mon],
 		    logtm->tm_year % 100);
 	else
-	    fprintf(fout, " %3s%2d%s", weekday[logtm->tm_wday], hour, merid);
+	    fprintf(fout, " %3s%2d ", weekday[logtm->tm_wday], logtm->tm_hour);
     } else {
-	fprintf(fout, " %2d:%02d%s", hour, logtm->tm_min, merid);
+	fprintf(fout, " %2d:%02d ", logtm->hour, logtm->tm_min);
     }
 }
 
diff -N -u -r procps-2.0.7.orig/watch.c procps-2.0.7/watch.c
--- procps-2.0.7.orig/watch.c	Mon Jul 10 22:50:02 2000
+++ procps-2.0.7/watch.c	Wed Aug 29 21:10:20 2001
@@ -23,7 +23,7 @@
 #include <sys/ioctl.h>
 #include <time.h>
 #include <unistd.h>
-
+#include <locale.h>
 
 struct option longopts[] =
   {
@@ -105,7 +105,10 @@
   int interval=2;
   char *command;
   int command_length=0;		/* not including final \0 */
+  int s;
+  char *endp;
 
+  setlocale(LC_ALL,"");
   progname = argv[0];
 
   while ((optc = getopt_long(argc, argv, "+d::hn:v", longopts, (int *) 0))
@@ -123,9 +126,9 @@
 	  break;
 	case 'n':
 	  {
-	    char *s;
-	    interval = strtol(optarg, &s, 10);
-	    if (!*optarg || *s)
+	    char *str;
+	    interval = strtol(optarg, &str, 10);
+	    if (!*optarg || *str)
 	      do_usage();
 	  }
 	  break;
@@ -137,6 +140,7 @@
 	  break;
 	}
     }
+    
 
   if (option_version)
     {
@@ -159,16 +163,19 @@
   if (optind >= argc)
     do_usage();
 
-  command = strdup(argv[optind++]);
-  command_length = strlen(command);
+  command_length = strlen(argv[optind]);
+  command = (char*)malloc(command_length + 1); /* space or \0 */
+  memcpy(command, argv[optind++], command_length);
+  command[command_length] = '\0';
   for (;optind<argc;optind++)
     {
-      int s = strlen(argv[optind]);
-      char *endp = &command[command_length];
+      s = strlen(argv[optind]);
+      command = realloc(command, command_length+s+2); /* space and \0 */
+      endp = command + command_length;
       *endp = ' ';
-      command_length += s + 1;
-      command = realloc(command, command_length+1);
-      strcpy(endp+1, argv[optind]);
+      memcpy(endp+1, argv[optind],s);
+      command_length += 1+s; /* space then string length */
+      command[command_length] = '\0';
     }
 
   get_terminal_size();
@@ -208,9 +215,9 @@
       /* left justify interval and command, right justify time, clipping all
 	 to fit window width */
       asprintf(&header, "Every %ds: %.*s",
-	       interval, max(width-1, command_length), command);
+	       interval, min(width-1, command_length), command);
       mvaddstr(0, 0, header);
-      if (strlen(header) > width - tsl - 1)
+      if (strlen(header) > (size_t)(width - tsl - 1))
 	mvaddstr(0, width - tsl - 4, "...  ");
       mvaddstr(0, width - tsl + 1, ts);
       free(header);
