--- procps-2.0.7/top.c.org	Mon Jan 22 16:25:40 2001
+++ procps-2.0.7/top.c	Mon Jan 22 16:59:34 2001
@@ -1276,6 +1276,19 @@
     return mem[meminfo_main][meminfo_total] >> 10;
 }
 
+
+
+/* Trim to zero if we get negative time ticks, which
+   may happen on some kernels. (see Bugzilla Bug #18380).
+   This hack gives at least a nicer output (hdeller@redhat.com)
+*/
+static unsigned int trimzero( int x )
+{
+    if (x<=0)
+	return 0;
+    return x;
+}
+
 /*
  * Calculates the number of tasks in each state (running, sleeping, etc.).
  * Calculates the CPU time in each state (system, user, nice, etc).
@@ -1465,14 +1478,14 @@
 		  printf ("CPU%d states: %2d%s%-d%% user, %2d%s%-d%% system,"
 			  " %2d%s%-d%% nice, %2d%s%-d%% idle",
 			  cpumap,
-			  (u_ticks - u_ticks_o[i] + n_ticks - n_ticks_o[i]) * 100 / t_ticks, decimal_point,
-			  (u_ticks - u_ticks_o[i]) * 100 % t_ticks / 100,
-			  (s_ticks - s_ticks_o[i]) * 100 / t_ticks, decimal_point,
-			  (s_ticks - s_ticks_o[i]) * 100 % t_ticks / 100,
-			  (n_ticks - n_ticks_o[i]) * 100 / t_ticks, decimal_point,
-			  (n_ticks - n_ticks_o[i]) * 100 % t_ticks / 100,
-			  (i_ticks - i_ticks_o[i]) * 100 / t_ticks, decimal_point,
-			  (i_ticks - i_ticks_o[i]) * 100 % t_ticks / 100);
+			  trimzero(u_ticks - u_ticks_o[i] + n_ticks - n_ticks_o[i]) * 100 / t_ticks, decimal_point,
+			  trimzero(u_ticks - u_ticks_o[i]) * 100 % t_ticks / 100,
+			  trimzero(s_ticks - s_ticks_o[i]) * 100 / t_ticks, decimal_point,
+			  trimzero(s_ticks - s_ticks_o[i]) * 100 % t_ticks / 100,
+			  trimzero(n_ticks - n_ticks_o[i]) * 100 / t_ticks, decimal_point,
+			  trimzero(n_ticks - n_ticks_o[i]) * 100 % t_ticks / 100,
+			  trimzero(i_ticks - i_ticks_o[i]) * 100 / t_ticks, decimal_point,
+			  trimzero(i_ticks - i_ticks_o[i]) * 100 % t_ticks / 100);
 		  s_ticks_o[i] = s_ticks;
 		  u_ticks_o[i] = u_ticks;
 		  n_ticks_o[i] = n_ticks;
