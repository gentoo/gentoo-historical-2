--- grub-0.91/stage2/shared.h	Fri Jan 25 21:33:39 2002
+++ grub/stage2/shared.h	Fri Jan 25 20:08:10 2002
@@ -979,6 +979,9 @@
 int grub_strlen (const char *str);
 char *grub_strcpy (char *dest, const char *src);
 
+/* simple version of string to unsigned long; doesn't handle bases */
+unsigned long simple_strtoul(char *str_ptr, char **endp);
+
 #ifndef GRUB_UTIL
 typedef unsigned long grub_jmp_buf[6];
 #else
--- grub-0.91/stage2/char_io.c	Fri Jan 25 21:33:39 2002
+++ grub/stage2/char_io.c	Fri Jan 25 21:33:24 2002
@@ -964,6 +964,34 @@
   return 1;
 }
 
+/* convert a string to an unsigned long.  basically taken straight from
+ * the Linux kernel (lib/vsprintf.c) but made even simpler due to lack of
+ * base handling
+ * str_ptr is the start of the string, 
+ * endp will point to the end of the parsed string when we're done
+ */
+unsigned long 
+simple_strtoul(char *str_ptr, char **endp)
+{
+  unsigned long result = 0;
+
+  while (1)
+	{
+	  unsigned int digit;
+
+	  digit = *str_ptr - '0';
+	  /* since digit is unsigned, it will wrap */
+	  if (digit > 9)
+		break;
+	  result = result * 10 + digit;
+	  str_ptr++;
+	}
+  
+  if (endp)
+	*endp = (char *)str_ptr;
+  return result;
+}
+
 int
 grub_tolower (int c)
 {
--- grub-0.91/stage2/boot.c	Mon Nov 12 01:57:29 2001
+++ grub/stage2/boot.c	Fri Jan 25 21:27:44 2002
@@ -28,6 +28,7 @@
 static int cur_addr;
 entry_func entry_addr;
 static struct mod_list mll[99];
+static unsigned long kernel_mem_end = 0;
 
 
 /*
@@ -308,6 +309,36 @@
 			 0,
 			 (64 - setup_sects - 1) << 9);
 
+	  /* we need to parse mem= from the command-line so that we can load
+		 the initrd in the right place. bleah */
+	  {
+		char *mem;
+
+	    mem = grub_strstr (arg, "mem=");
+		if (mem) 
+		  {
+            /* we handle this identically to the kernel; see memparse 
+			   in lib/cmdline.c of the kernel source for the 
+			   original location of this code */
+            kernel_mem_end = simple_strtoul(mem+4, &mem);
+            
+            switch(*mem) 
+              {
+              case 'G':
+              case 'g':
+                kernel_mem_end <<= 10;
+              case 'M':
+              case 'm':
+                kernel_mem_end <<= 10;
+              case 'K':
+              case 'k':
+                kernel_mem_end <<= 10;
+              default:
+                break;
+              }
+		  }
+	  }
+
 	  /* Copy command-line plus memory hack to staging area.
 	     NOTE: Linux has a bug that it doesn't handle multiple spaces
 	     between two options and a space after a "mem=" option isn't
@@ -720,7 +751,9 @@
       goto fail;
     }
 
-  moveto = ((mbi.mem_upper + 0x400) * 0x400 - len) & 0xfffff000;
+  if (!kernel_mem_end)
+    kernel_mem_end = (mbi.mem_upper + 0x400) * 0x400;
+  moveto = (kernel_mem_end - len) & 0xfffff000;
   if (moveto + len >= LINUX_INITRD_MAX_ADDRESS)
     moveto = (LINUX_INITRD_MAX_ADDRESS - len) & 0xfffff000;
   
