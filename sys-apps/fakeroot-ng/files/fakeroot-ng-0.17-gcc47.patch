--- file.cpp
+++ file.cpp
@@ -29,6 +29,7 @@
 #include <limits.h>
 
 #include <string.h>
+#include <unistd.h>
 
 #include "syscalls.h"
 #include "file_lie.h"
@@ -53,7 +54,7 @@
         // Entering the syscall
         state->state=pid_state::RETURN;
         state->context_state[0]=ptlib_get_argument( pid, 2 ); // Store the pointer to the stat struct
-        dlog("stat64: "PID_F" stored pointer at %p\n", pid, (void*)state->context_state[0] );
+        dlog("stat64: " PID_F " stored pointer at %p\n", pid, (void*)state->context_state[0] );
 
         // If the process is chrooted, we need to translate the file name
         int real_sc=ptlib_get_syscall( pid );
@@ -63,7 +64,7 @@
     } else if( state->state==pid_state::RETURN ) {
         // Returning from the syscall
         int returncode=ptlib_get_retval( pid );
-        dlog("stat64: "PID_F" returned %x\n", pid, returncode);
+        dlog("stat64: " PID_F " returned %x\n", pid, returncode);
         if( ptlib_success( pid, sc_num ) ) {
             struct ptlib_stat ret;
             struct stat_override override;
@@ -92,11 +93,11 @@
                 }
 
                 if( ok ) {
-                    dlog("stat64: "PID_F" override dev="DEV_F" inode="INODE_F" mode=%o uid="UID_F" gid="GID_F"\n",
+                    dlog("stat64: " PID_F " override dev=" DEV_F " inode=" INODE_F " mode=%o uid=" UID_F " gid=" GID_F "\n",
                         pid, ret.dev, ret.ino, ret.mode, ret.uid, ret.gid );
                     ptlib_set_mem( pid, &ret, (void *)state->context_state[0], sizeof(struct stat) );
                 } else {
-                    dlog("stat64: "PID_F" dev="DEV_F" inode="INODE_F" override entry corrupt - removed\n", pid, ret.dev, ret.ino );
+                    dlog("stat64: " PID_F " dev=" DEV_F " inode=" INODE_F " override entry corrupt - removed\n", pid, ret.dev, ret.ino );
                     remove_map( ret.dev, ret.ino );
                 }
             }
@@ -117,7 +118,7 @@
         chroot_translate_paramat( pid, state, ptlib_get_argument( pid, 1 ), 2, (ptlib_get_argument(pid, 4)&AT_SYMLINK_NOFOLLOW)!=0 );
 
         state->context_state[0]=ptlib_get_argument( pid, 3 ); // Store the pointer to the stat struct
-        dlog("statat64: "PID_F" stored pointer at %p\n", pid, (void*)state->context_state[0] );
+        dlog("statat64: " PID_F " stored pointer at %p\n", pid, (void*)state->context_state[0] );
 
         return true;
     } else {
@@ -213,11 +214,11 @@
                 override.dev_id=0;
                 override.transient=true;
 
-                dlog("chmod: "PID_F" error (race?) getting override info for dev "DEV_F" inode "INODE_F"\n",
+                dlog("chmod: " PID_F " error (race?) getting override info for dev " DEV_F " inode " INODE_F "\n",
                         pid, state->context_state[2], state->context_state[3] );
             }
             override.mode=(override.mode&~07777)|(((mode_t)state->context_state[1])&07777);
-            dlog("chmod: "PID_F" Setting override mode %o dev "DEV_F" inode "INODE_F"\n", pid, override.mode, override.dev,
+            dlog("chmod: " PID_F " Setting override mode %o dev " DEV_F " inode " INODE_F "\n", pid, override.mode, override.dev,
                     override.inode );
             set_map( &override );
 
@@ -233,7 +234,7 @@
 
         state->state=pid_state::NONE;
     } else {
-        dlog("chmod: "PID_F" unknown state %d\n", pid, state->state );
+        dlog("chmod: " PID_F " unknown state %d\n", pid, state->state );
     }
 
     return true;
@@ -295,7 +296,7 @@
         }
 
         ptlib_set_syscall( pid, stat_function );
-        dlog("chown: "PID_F" redirected chown call to stat\n", pid );
+        dlog("chown: " PID_F " redirected chown call to stat\n", pid );
 
         state->state=pid_state::REDIRECT2;
     } else if( state->state==pid_state::REDIRECT2 ) {
@@ -306,7 +307,7 @@
             ptlib_get_mem( pid, state->memory, &stat, sizeof( stat ) );
 
             if( !get_map( stat.dev, stat.ino, &override ) ) {
-                dlog("chown: "PID_F" no override for file - create a new one\n", pid );
+                dlog("chown: " PID_F " no override for file - create a new one\n", pid );
                 stat_override_copy( &stat, &override );
             }
 
@@ -315,10 +316,10 @@
             if( ((int)state->context_state[1])!=-1 )
                 override.gid=state->context_state[1];
 
-            dlog("chown: "PID_F" changing owner of dev "DEV_F" inode "INODE_F"\n", pid, override.dev, override.inode );
+            dlog("chown: " PID_F " changing owner of dev " DEV_F " inode " INODE_F "\n", pid, override.dev, override.inode );
             set_map( &override );
         } else {
-            dlog("chown: "PID_F" stat call failed with error %s\n", pid, strerror(ptlib_get_error(pid, sc_num)) );
+            dlog("chown: " PID_F " stat call failed with error %s\n", pid, strerror(ptlib_get_error(pid, sc_num)) );
         }
 
         state->state=pid_state::NONE;
@@ -391,7 +392,7 @@
         mode|= 00600;
 
         if( S_ISCHR(mode) || S_ISBLK(mode) ) {
-            dlog("mknod: "PID_F" tried to create %s device, turn to regular file\n", pid, S_ISCHR(mode) ? "character" : "block" );
+            dlog("mknod: " PID_F " tried to create %s device, turn to regular file\n", pid, S_ISCHR(mode) ? "character" : "block" );
             mode=(mode&~S_IFMT) | S_IFREG;
         }
         ptlib_set_argument( pid, mode_offset+1, mode );
@@ -414,11 +415,11 @@
 
             state->state=pid_state::REDIRECT1;
 
-            dlog("mknod: "PID_F" Actual node creation successful. Calling stat\n", pid );
+            dlog("mknod: " PID_F " Actual node creation successful. Calling stat\n", pid );
             return ptlib_generate_syscall( pid, stat_function, state->shared_memory );
         } else {
             // Nothing to do if the call failed
-            dlog("mknod: "PID_F" call failed with error %s\n", pid, strerror(ptlib_get_error(pid, sc_num) ) );
+            dlog("mknod: " PID_F " call failed with error %s\n", pid, strerror(ptlib_get_error(pid, sc_num) ) );
         }
     } else if( state->state==pid_state::REDIRECT2 ) {
         if( ptlib_success( pid, sc_num ) ) {
@@ -434,12 +435,12 @@
             override.uid=state->fsuid;
             override.gid=state->fsgid;
 
-            dlog("mknod: "PID_F" registering the new device in the override DB dev "DEV_F" inode "INODE_F"\n", pid,
+            dlog("mknod: " PID_F " registering the new device in the override DB dev " DEV_F " inode " INODE_F "\n", pid,
                 stat.dev, stat.ino );
 
             mode_t mode=(mode_t)state->context_state[0];
             if( S_ISCHR(mode) || S_ISBLK(mode) || (mode&07000)!=0) {
-                dlog("mknod: "PID_F" overriding the file type and/or mode\n", pid );
+                dlog("mknod: " PID_F " overriding the file type and/or mode\n", pid );
                 override.mode=(override.mode&~(S_IFMT|07000)) | (mode&(S_IFMT|07000));
                 override.dev_id=(dev_t)state->context_state[1];
             }
@@ -451,7 +452,7 @@
             set_map( &override );
         } else {
             // mknod succeeded, but stat failed?
-            dlog("mknod: "PID_F" stat failed. Leave override DB non-updated\n", pid );
+            dlog("mknod: " PID_F " stat failed. Leave override DB non-updated\n", pid );
         }
 
         ptlib_restore_state( pid, state->saved_state );
@@ -512,7 +513,7 @@
         // Did we request to create a new file?
         if( (state->context_state[0]&O_CREAT)!=0 && ptlib_success(pid, sc_num) ) {
             int fd=(long)ptlib_get_retval(pid);
-            dlog("open: "PID_F" opened fd %d, assume we actually created it\n", pid, fd );
+            dlog("open: " PID_F " opened fd %d, assume we actually created it\n", pid, fd );
 
             ptlib_save_state( pid, state->saved_state );
             state->state=pid_state::REDIRECT1;
@@ -545,12 +546,12 @@
                 // XXX We are ignoring the umask here!
 
                 set_map( &override );
-                dlog("open: "PID_F" creating override for dev "DEV_F" inode "INODE_F"\n", pid, override.dev, override.inode);
+                dlog("open: " PID_F " creating override for dev " DEV_F " inode " INODE_F "\n", pid, override.dev, override.inode);
             } else {
-                dlog("open: "PID_F" map for dev "DEV_F" inode "INODE_F" already exists - doing nothing\n", pid, stat.dev, stat.ino );
+                dlog("open: " PID_F " map for dev " DEV_F " inode " INODE_F " already exists - doing nothing\n", pid, stat.dev, stat.ino );
             }
         } else {
-            dlog("open: "PID_F" fstat failed %s\n", pid, strerror( ptlib_get_error( pid, sc_num ) ) );
+            dlog("open: " PID_F " fstat failed %s\n", pid, strerror( ptlib_get_error( pid, sc_num ) ) );
         }
 
         state->state=pid_state::NONE;
@@ -607,7 +608,7 @@
         state->state=pid_state::NONE;
 
         if( ptlib_success( pid, sc_num ) ) {
-            dlog("mkdir: "PID_F" succeeded. Call stat\n", pid );
+            dlog("mkdir: " PID_F " succeeded. Call stat\n", pid );
             ptlib_save_state( pid, state->saved_state );
 
             // Perform a stat operation so we can know the directory's dev and inode
@@ -625,7 +626,7 @@
             return ptlib_generate_syscall( pid, stat_function, state->shared_memory );
         } else {
             // If mkdir failed, we don't have anything else to do.
-            dlog("mkdir: "PID_F" failed with error %s\n", pid, strerror(ptlib_get_error( pid, sc_num ) ) );
+            dlog("mkdir: " PID_F " failed with error %s\n", pid, strerror(ptlib_get_error( pid, sc_num ) ) );
         }
     } else if( state->state==pid_state::REDIRECT2 ) {
         if( ptlib_success( pid, sc_num ) ) {
@@ -643,10 +644,10 @@
             override.mode|= state->context_state[0]&00700;
             // XXX This code does not take the umask into account
 
-            dlog("mkdir: "PID_F" storing override for dev "DEV_F" inode "INODE_F"\n", pid, override.dev, override.inode);
+            dlog("mkdir: " PID_F " storing override for dev " DEV_F " inode " INODE_F "\n", pid, override.dev, override.inode);
             set_map( &override );
         } else {
-            dlog("mkdir: "PID_F" stat failed with error %s\n", pid, strerror(ptlib_get_error(pid, sc_num)));
+            dlog("mkdir: " PID_F " stat failed with error %s\n", pid, strerror(ptlib_get_error(pid, sc_num)));
         }
 
         ptlib_restore_state( pid, state->saved_state );
@@ -704,7 +705,7 @@
         state->state=pid_state::RETURN;
     } else if( state->state==pid_state::RETURN ) {
         if( ptlib_success( pid, sc_num ) ) {
-            dlog("symlink: "PID_F" success. Call stat to mark uid/gid override\n", pid );
+            dlog("symlink: " PID_F " success. Call stat to mark uid/gid override\n", pid );
             ptlib_save_state( pid, state->saved_state );
 
             for( int i=0; i<mode_offset; ++i ) {
@@ -720,7 +721,7 @@
 
             return ptlib_generate_syscall( pid, stat_function, state->shared_memory );
         } else {
-            dlog("symlink: "PID_F" failed with error %s\n", pid, strerror( ptlib_get_error(pid, sc_num) ) );
+            dlog("symlink: " PID_F " failed with error %s\n", pid, strerror( ptlib_get_error(pid, sc_num) ) );
             state->state=pid_state::NONE;
         }
     } else if( state->state==pid_state::REDIRECT2 ) {
@@ -738,14 +739,14 @@
                 override.uid=state->fsuid;
                 override.gid=state->fsgid;
 
-                dlog("symlink: "PID_F" set uid/gid override for dev "DEV_F" inode "INODE_F"\n", pid, override.dev, override.inode );
+                dlog("symlink: " PID_F " set uid/gid override for dev " DEV_F " inode " INODE_F "\n", pid, override.dev, override.inode );
                 set_map( &override );
             } else {
-                dlog("symlink: "PID_F" acutal file on disk is not a symlink. Type %o dev "DEV_F" inode "INODE_F"\n", pid, stat.mode, stat.dev,
+                dlog("symlink: " PID_F " acutal file on disk is not a symlink. Type %o dev " DEV_F " inode " INODE_F "\n", pid, stat.mode, stat.dev,
                     stat.ino );
             }
         } else {
-            dlog("symlink: "PID_F" symlink succeeded, but stat failed with %s\n", pid, strerror(ptlib_get_error(pid, sc_num)));
+            dlog("symlink: " PID_F " symlink succeeded, but stat failed with %s\n", pid, strerror(ptlib_get_error(pid, sc_num)));
         }
 
         ptlib_restore_state( pid, state->saved_state );
@@ -885,7 +886,7 @@
         state->state=pid_state::REDIRECT2;
         if( start<addr1 && end>addr1 ) {
             // The unmap range covers the lower range
-            dlog("sys_munmap: "PID_F" tried to unmap range %p-%p, which conflicts with our %s range %p-%p\n",
+            dlog("sys_munmap: " PID_F " tried to unmap range %p-%p, which conflicts with our %s range %p-%p\n",
                 pid, (void*)start, (void*)end, name1, (void*)addr1, (void*)(addr1+len1) );
 
             if( end>addr1+len1 ) {
@@ -897,13 +898,13 @@
             end=addr1;
         } else if( start>=addr1 && start<addr1+len1 ) {
             // The start pointer is inside the lower memory range
-            dlog("sys_munmap: "PID_F" tried to unmap range %p-%p, which conflicts with our %s range %p-%p\n",
+            dlog("sys_munmap: " PID_F " tried to unmap range %p-%p, which conflicts with our %s range %p-%p\n",
                 pid, (void*)start, (void*)end, name1, (void*)addr1, (void*)(addr1+len1) );
 
             start=addr1+len1;
         } else if( start<addr2 && end>addr2 ) {
             // The unmap area covers the upper memory range
-            dlog("sys_munmap: "PID_F" tried to unmap range %p-%p, which conflicts with our %s range %p-%p\n",
+            dlog("sys_munmap: " PID_F " tried to unmap range %p-%p, which conflicts with our %s range %p-%p\n",
                 pid, (void*)start, (void*)end, name2, (void*)addr2, (void*)(addr2+len2) );
 
             if( end>addr2+len2 ) {
@@ -915,7 +916,7 @@
             end=addr2;
         } else if( start>=addr2 && start<addr2+len2 ) {
             // The start pointer is inside the upper memory range
-            dlog("sys_munmap: "PID_F" tried to unmap range %p-%p, which conflicts with our %s range %p-%p\n",
+            dlog("sys_munmap: " PID_F " tried to unmap range %p-%p, which conflicts with our %s range %p-%p\n",
                 pid, (void*)start, (void*)end, name2, (void*)addr2, (void*)(addr2+len2) );
 
             start=addr2+len2;
@@ -951,7 +952,7 @@
             }
         } else {
             // The syscall failed - we will end it here even if we thought we had something more to do
-            dlog("sys_munmap: "PID_F" failed: %s\n", pid, strerror(ptlib_get_error(pid, sc_num)));
+            dlog("sys_munmap: " PID_F " failed: %s\n", pid, strerror(ptlib_get_error(pid, sc_num)));
         }
 
         if( state->context_state[2]==1 ) {
@@ -1090,7 +1091,7 @@
                 } else {
                     // lstat syscall failed - pass the error along
                     state->state=pid_state::NONE;
-                    dlog("%s: "PID_F" lstat failed with error: %s\n", __FUNCTION__, pid, strerror(ptlib_get_error(pid, sc_num)));
+                    dlog("%s: " PID_F " lstat failed with error: %s\n", __FUNCTION__, pid, strerror(ptlib_get_error(pid, sc_num)));
                 }
             }
             break;
@@ -1111,13 +1112,13 @@
                         if( get_map( key->dev, key->inode, &map ) ) {
                             map.transient=true;
                             set_map( &map );
-                            dlog("sys_unlink: "PID_F" inode "INODE_F" in override mapping marked transient\n", pid, key->inode );
+                            dlog("sys_unlink: " PID_F " inode " INODE_F " in override mapping marked transient\n", pid, key->inode );
                         }
                     }
                 } else {
                     // The "restore state" command overwrote the error
                     ptlib_set_error( pid, sc_num, error );
-                    dlog("%s: "PID_F" unlink failed with error: %s\n", __FUNCTION__, pid, strerror(error));
+                    dlog("%s: " PID_F " unlink failed with error: %s\n", __FUNCTION__, pid, strerror(error));
                 }
             }
             break;
@@ -1229,7 +1230,7 @@
                 } else {
                     // lstat syscall failed - pass the error along
                     state->state=pid_state::NONE;
-                    dlog("%s: "PID_F" fstatat failed with error: %s\n", __FUNCTION__, pid, strerror(ptlib_get_error(pid, sc_num)));
+                    dlog("%s: " PID_F " fstatat failed with error: %s\n", __FUNCTION__, pid, strerror(ptlib_get_error(pid, sc_num)));
                 }
             }
             break;
@@ -1250,14 +1251,14 @@
                         if( get_map( key->dev, key->inode, &map ) ) {
                             map.transient=true;
                             set_map( &map );
-                            dlog("%s: "PID_F" inode "INODE_F" in override mapping marked transient\n", __FUNCTION__,
+                            dlog("%s: " PID_F " inode " INODE_F " in override mapping marked transient\n", __FUNCTION__,
                                     pid, key->inode );
                         }
                     }
                 } else {
                     // The "restore state" command overwrote the error
                     ptlib_set_error( pid, sc_num, error );
-                    dlog("%s: "PID_F" unlinkat failed with error: %s\n", __FUNCTION__, pid, strerror(error));
+                    dlog("%s: " PID_F " unlinkat failed with error: %s\n", __FUNCTION__, pid, strerror(error));
                 }
             }
             break;
@@ -1350,7 +1351,7 @@
                 if( get_map( key->dev, key->inode, &map ) ) {
                     map.transient=true;
                     set_map( &map );
-                    dlog("sys_rmdir: "PID_F" inode "INODE_F" in override mapping marked transient\n", pid, key->inode );
+                    dlog("sys_rmdir: " PID_F " inode " INODE_F " in override mapping marked transient\n", pid, key->inode );
                 }
             } else {
                 // Need to copy the error number (overwritten by the state restore)
--- file_lie.cpp
+++ file_lie.cpp
@@ -64,7 +64,7 @@
     stat_override override;
     int params;
 
-    while( (params=fscanf(file, "dev="DEV_F", ino="INODE_F", mode=%o, uid=%d, gid=%d, rdev="DEV_F" \n", &override.dev, &override.inode,
+    while( (params=fscanf(file, "dev=" DEV_F ", ino=" INODE_F ", mode=%o, uid=%d, gid=%d, rdev=" DEV_F " \n", &override.dev, &override.inode,
             &override.mode, &override.uid, &override.gid, &override.dev_id ))==6 )
     {
         set_map( &override );
@@ -78,7 +78,7 @@
 
         override=&(i->second);
         if( !override->transient ) {
-            fprintf( file, "dev="DEV_F",ino="INODE_F",mode=%o,uid=%d,gid=%d,rdev="DEV_F"\n", override->dev, override->inode,
+            fprintf( file, "dev=" DEV_F ",ino=" INODE_F ",mode=%o,uid=%d,gid=%d,rdev=" DEV_F "\n", override->dev, override->inode,
                     override->mode, override->uid, override->gid, override->dev_id );
         }
     }
--- parent.cpp
+++ parent.cpp
@@ -40,6 +40,7 @@
 #include <limits.h>
 #include <string.h>
 #include <stdlib.h>
+#include <unistd.h>
 
 #include "arch/platform.h"
 
@@ -397,7 +398,7 @@
         // This process has no parent, or had a parent that already quit
         return;
     }
-    dlog("notify_parent: "PID_F" sent a notify about "PID_F"(%x)\n", parent, waiting.pid(), waiting.status());
+    dlog("notify_parent: " PID_F " sent a notify about " PID_F "(%x)\n", parent, waiting.pid(), waiting.status());
     pid_state *proc_state=lookup_state(parent);
     assert(proc_state!=NULL);
 
@@ -407,7 +408,7 @@
     if( proc_state->state==pid_state::WAITING ) {
         // Call the original function handler, now that it has something to do
         if( syscalls[proc_state->orig_sc].func( -1, parent, proc_state ) ) {
-            dlog("notify_parent: "PID_F" released from wait\n", parent);
+            dlog("notify_parent: " PID_F " released from wait\n", parent);
             ptlib_continue(PTRACE_SYSCALL, parent, 0);
         }
     }
@@ -423,7 +424,7 @@
     // Set the process state to ZOMBIE with usage count of 1
     proc_state->state=pid_state::ZOMBIE;
     proc_state->context_state[0]=1;
-    dlog("%s: "PID_F" is now a zombie\n", __func__, pid );
+    dlog("%s: " PID_F " is now a zombie\n", __func__, pid );
 
     pid_state *parent_state=lookup_state(proc_state->parent);
 
@@ -497,12 +498,12 @@
         // Due to platform incompatibilities and other issues, we may be called several times over the same
         // child. Don't make a fuss - just return.
 
-        dlog("%s: Process "PID_F" already registered - not performing any operation\n", __FUNCTION__, child_id );
+        dlog("%s: Process " PID_F " already registered - not performing any operation\n", __FUNCTION__, child_id );
 
         return;
     }
 
-    dlog("%s: Registering "PID_F" with parent "PID_F"\n", __FUNCTION__, child_id, parent_id );
+    dlog("%s: Registering " PID_F " with parent " PID_F "\n", __FUNCTION__, child_id, parent_id );
 
     // The platform may want to init the process in some way
     ptlib_prepare(child_id);
@@ -561,7 +562,7 @@
         // The process does not exist!
         // Register it
         pid_t parent_pid=ptlib_get_parent(pid);
-        dlog("Caught unknown new process "PID_F", detected parent "PID_F"\n", pid, parent_pid );
+        dlog("Caught unknown new process " PID_F ", detected parent " PID_F "\n", pid, parent_pid );
         dlog(NULL);
         assert( parent_pid==0 || parent_pid==1 || state.find(parent_pid)!=state.end() ); // Make sure the parent is, indeed, ours
 
@@ -583,20 +584,20 @@
             if( proc_state->state==pid_state::REDIRECT1 ) {
                 // REDIRECT1 is just a filler state between the previous call, where the arguments were set up and
                 // the call initiated, and the call's return (REDIRECT2). No need to actually call the handler
-                dlog(PID_F": Calling syscall %ld redirected from %s\n", pid, ret, syscalls[proc_state->orig_sc].name );
+                dlog(PID_F ": Calling syscall %ld redirected from %s\n", pid, ret, syscalls[proc_state->orig_sc].name );
                 proc_state->state=pid_state::REDIRECT2;
             } else if( proc_state->state==pid_state::REDIRECT2 || proc_state->state==pid_state::REDIRECT3 ) {
                 // REDIRECT2 means a return from a syscall generated by us.
                 // REDIRECT3 means entering a syscall generated by us, but for which the handler function would like
                 // to be notified (unlike REDIRECT1 above, which is short circuited)
                 if( proc_state->orig_sc!=SYS_execve ) {
-                    dlog(PID_F": Called syscall %ld, redirected from %s\n", pid, ret, syscalls[proc_state->orig_sc].name );
+                    dlog(PID_F ": Called syscall %ld, redirected from %s\n", pid, ret, syscalls[proc_state->orig_sc].name );
 
                     if( !syscalls[proc_state->orig_sc].func( ret, pid, proc_state ) )
                         sig=-1; // Mark for ptrace not to continue the process
                 } else {
                     // Special handling of the execve case
-                    dlog(PID_F": Called syscall %ld, redirected from execve\n", pid, ret );
+                    dlog(PID_F ": Called syscall %ld, redirected from execve\n", pid, ret );
 
                     if( !sys_execve( ret, pid, proc_state, posttrap_always ) )
                         sig=-1;
@@ -610,14 +611,14 @@
                 if( proc_state->state!=pid_state::ALLOCATE ) {
                     // Sanity check - returning from same syscall that got us in
                     if( proc_state->state==pid_state::RETURN && ret!=proc_state->orig_sc ) {
-                        dlog("process "PID_F" orig_sc=%d actual sc=%ld state=%s\n", pid, proc_state->orig_sc, ret,
+                        dlog("process " PID_F " orig_sc=%d actual sc=%ld state=%s\n", pid, proc_state->orig_sc, ret,
                                 state2str(proc_state->state));
                         dlog(NULL);
                         assert( proc_state->state!=pid_state::RETURN || ret==proc_state->orig_sc );
                     }
 
                     if( proc_state->state==pid_state::NONE && proc_state->debugger!=0 && proc_state->trace_mode==TRACE_SYSCALL ) {
-                        dlog(PID_F": pre-syscall hook called for debugger "PID_F"\n", pid, proc_state->debugger );
+                        dlog(PID_F ": pre-syscall hook called for debugger " PID_F "\n", pid, proc_state->debugger );
 
                         // Notify the debugger before the syscall
                         proc_state->context_state[0]=wait_state;
@@ -651,18 +652,18 @@
                             proc_state->orig_sc=ret;
 
                         if( syscalls.find(ret)!=syscalls.end() ) {
-                            dlog(PID_F": Called %s(%s)\n", pid, syscalls[ret].name, state2str(proc_state->state));
+                            dlog(PID_F ": Called %s(%s)\n", pid, syscalls[ret].name, state2str(proc_state->state));
 
                             if( !syscalls[ret].func( ret, pid, proc_state ) ) {
                                 sig=-1; // Mark for ptrace not to continue the process
                             }
                         } else if( ret==SYS_execve ) {
-                            dlog(PID_F": Called execve(%s)\n", pid, state2str(proc_state->state));
+                            dlog(PID_F ": Called execve(%s)\n", pid, state2str(proc_state->state));
 
                             if( !sys_execve(ret, pid, proc_state, posttrap_always ) )
                                 sig=-1;
                         } else {
-                            dlog(PID_F": Unknown syscall %ld(%s)\n", pid, ret, state2str(proc_state->state));
+                            dlog(PID_F ": Unknown syscall %ld(%s)\n", pid, ret, state2str(proc_state->state));
                             if( proc_state->state==pid_state::NONE ) {
                                 proc_state->state=pid_state::RETURN;
                             } else if( proc_state->state==pid_state::RETURN ) {
@@ -680,7 +681,7 @@
                     posttrap_always )
               )
             {
-                dlog(PID_F": notify debugger "PID_F" about post-syscall hook\n", pid, proc_state->debugger );
+                dlog(PID_F ": notify debugger " PID_F " about post-syscall hook\n", pid, proc_state->debugger );
                 proc_state->trace_mode=TRACE_STOPPED2;
 
                 pid_state::wait_state waiting;
@@ -694,7 +695,7 @@
         }
         break;
     case SIGNAL:
-        dlog(PID_F": Signal %s\n", pid, sig2str(ret));
+        dlog(PID_F ": Signal %s\n", pid, sig2str(ret));
         if( proc_state->debugger==0 )
             sig=ret;
         else {
@@ -713,9 +714,9 @@
     case SIGEXIT:
         {
             if( wait_state==EXIT ) {
-                dlog(PID_F": Exit with return code %ld\n", pid, ret);
+                dlog(PID_F ": Exit with return code %ld\n", pid, ret);
             } else {
-                dlog(PID_F": Exit with %s\n", pid, sig2str(ret));
+                dlog(PID_F ": Exit with %s\n", pid, sig2str(ret));
             }
 
             struct rusage rusage;
@@ -738,7 +739,7 @@
         break;
     case NEWPROCESS:
         {
-            dlog(PID_F": Created new child process %ld\n", pid, ret);
+            dlog(PID_F ": Created new child process %ld\n", pid, ret);
             handle_new_process( pid, ret );
         }
     }
@@ -752,11 +753,11 @@
 
     // Attach a debugger to the child
     if( ptrace(PTRACE_ATTACH, child, 0, 0)!=0 ) {
-        dlog("Could not start trace of process "PID_F": %s\n", child, strerror(errno) );
+        dlog("Could not start trace of process " PID_F ": %s\n", child, strerror(errno) );
 
         return false;
     }
-    dlog("Debugger successfully attached to process "PID_F"\n", child );
+    dlog("Debugger successfully attached to process " PID_F "\n", child );
 
     // Let's free the process to do the exec
     errno=0;
@@ -892,7 +893,7 @@
                         pid_t child=-1;
 
                         if( read( session_socket, &child, sizeof(child))>0 && child>0 ) {
-                            dlog("Got asynchronous request to attach to process "PID_F"\n", child);
+                            dlog("Got asynchronous request to attach to process " PID_F "\n", child);
 
                             attach_debugger(child, session_socket);
                         }
@@ -932,7 +933,7 @@
 
 bool allocate_process_mem( pid_t pid, pid_state *state, int sc_num )
 {
-    dlog("allocate_process_mem: "PID_F" running syscall %d needs process memory\n", pid, sc_num );
+    dlog("allocate_process_mem: " PID_F " running syscall %d needs process memory\n", pid, sc_num );
 
     state->orig_sc=sc_num;
 
@@ -964,7 +965,7 @@
     int fd=mkstemp(filename);
 
     if( fd==-1 ) {
-        dlog("allocate_shared_mem: "PID_F" Failed to create file %s: %s\n", pid, filename, strerror(errno) );
+        dlog("allocate_shared_mem: " PID_F " Failed to create file %s: %s\n", pid, filename, strerror(errno) );
 
         // We'll kill the process
         ptlib_continue( PTRACE_KILL, pid, 0 );
@@ -978,7 +979,7 @@
     char *memory=(char *)mmap( NULL, shared_mem_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0 );
 
     if( memory==MAP_FAILED ) {
-        dlog("allocate_shared_mem: "PID_F" filed to map file %s into memory: %s\n", pid, filename, strerror(errno) );
+        dlog("allocate_shared_mem: " PID_F " filed to map file %s into memory: %s\n", pid, filename, strerror(errno) );
 
         // Cleanup
         close(fd);
@@ -1035,7 +1036,7 @@
         // First step - mmap just returned
         if( ptlib_success( pid, sc_num ) ) {
             state->memory=(void *)ptlib_get_retval( pid );
-            dlog("handle_memory_allocation: "PID_F" allocated for our use %lu bytes at %p\n", pid,
+            dlog("handle_memory_allocation: " PID_F " allocated for our use %lu bytes at %p\n", pid,
                     (unsigned long)static_mem_size, state->memory);
 
             // "All" we need now is the shared memory. First, let's generate the local version for it.
@@ -1045,7 +1046,7 @@
                 return false;
         } else {
             // The allocation failed. What can you do except kill the process?
-            dlog("handle_memory_allocation: "PID_F" our memory allocation failed with error. Kill process. %s\n", pid,
+            dlog("handle_memory_allocation: " PID_F " our memory allocation failed with error. Kill process. %s\n", pid,
                     strerror(ptlib_get_error(pid, sc_num)) );
             ptlib_continue( PTRACE_KILL, pid, 0 );
             return false;
@@ -1088,7 +1089,7 @@
             ptlib_generate_syscall( pid, PREF_MMAP, (char *)state->memory+ptlib_prepare_memory_len() );
         } else {
             // open failed
-            dlog( "handle_memory_allocation: "PID_F" process failed to open %s: %s\n", pid, state->shared_mem_local.getc(),
+            dlog( "handle_memory_allocation: " PID_F " process failed to open %s: %s\n", pid, state->shared_mem_local.getc(),
                 strerror(ptlib_get_error(pid, sc_num)) );
             ptlib_continue( PTRACE_KILL, pid, 0 );
             return false;
@@ -1105,7 +1106,7 @@
         if( ptlib_success( pid, sc_num ) ) {
             // mmap succeeded
             state->shared_memory=(void *)(ptlib_get_retval( pid )+ptlib_prepare_memory_len());
-            dlog("handle_memory_allocation: "PID_F" allocated for our use %lu shared bytes at %p\n", pid,
+            dlog("handle_memory_allocation: " PID_F " allocated for our use %lu shared bytes at %p\n", pid,
                     (unsigned long)shared_mem_size, (char *)state->shared_memory-ptlib_prepare_memory_len());
 
             // We now need to close the file descriptor
@@ -1113,7 +1114,7 @@
 
             return ptlib_generate_syscall( pid, SYS_close, state->shared_memory );
         } else {
-            dlog( "handle_memory_allocation: "PID_F" process failed to mmap memory: %s\n", pid, strerror(ptlib_get_error(pid, sc_num) ) );
+            dlog( "handle_memory_allocation: " PID_F " process failed to mmap memory: %s\n", pid, strerror(ptlib_get_error(pid, sc_num) ) );
 
             ptlib_continue( PTRACE_KILL, pid, 0 );
             return false;
@@ -1128,7 +1129,7 @@
         // Close done - we can revert to whatever we were previously doing
         if( !ptlib_success( pid, sc_num ) ) {
             // If close failed, we'll log the error and leak the file descriptor, but otherwise do nothing about it
-            dlog( "handle_memory_allocation: "PID_F" procss close failed: %s\n", pid, strerror(ptlib_get_error(pid, sc_num) ) );
+            dlog( "handle_memory_allocation: " PID_F " procss close failed: %s\n", pid, strerror(ptlib_get_error(pid, sc_num) ) );
         }
         return ptlib_generate_syscall( pid, state->orig_sc , state->shared_memory );
     case 8:
@@ -1137,14 +1138,14 @@
             ptlib_restore_state( pid, state->saved_state );
             state->state=pid_state::NONE;
 
-            dlog("handle_memory_allocation: "PID_F" restore state and call handler for syscall %d\n", pid, sc_num );
+            dlog("handle_memory_allocation: " PID_F " restore state and call handler for syscall %d\n", pid, sc_num );
         }
         break;
     case 25:
         // Close done - we now need to deallocate the previous shared mem
         if( !ptlib_success( pid, sc_num ) ) {
             // If close failed, we'll log the error and leak the file descriptor, but otherwise do nothing about it
-            dlog( "handle_memory_allocation: "PID_F" procss close failed: %s\n", pid, strerror(ptlib_get_error(pid, sc_num) ) );
+            dlog( "handle_memory_allocation: " PID_F " procss close failed: %s\n", pid, strerror(ptlib_get_error(pid, sc_num) ) );
         }
 
         ptlib_set_argument( pid, 1, state->context_state[2]-ptlib_prepare_memory_len() );
@@ -1159,7 +1160,7 @@
         // Munmap done
         if( !ptlib_success( pid, sc_num ) ) {
             // Again, if the unmap failed, we'll log it but otherwise continue
-            dlog( "handle_memory_allocation: "PID_F" process munmap failed: %s\n", pid, strerror( ptlib_get_error(pid, sc_num) ) );
+            dlog( "handle_memory_allocation: " PID_F " process munmap failed: %s\n", pid, strerror( ptlib_get_error(pid, sc_num) ) );
         }
 
         // Restart the original system call
@@ -1173,10 +1174,10 @@
 bool sys_mmap( int sc_num, pid_t pid, pid_state *state )
 {
     if( state->state==pid_state::NONE ) {
-        dlog("mmap: "PID_F" direct call\n", pid);
+        dlog("mmap: " PID_F " direct call\n", pid);
         state->state=pid_state::RETURN;
     } else if( state->state==pid_state::RETURN ) {
-        dlog("mmap: "PID_F" direct return\n", pid);
+        dlog("mmap: " PID_F " direct return\n", pid);
         state->state=pid_state::NONE;
     }
 
@@ -1209,7 +1210,7 @@
     dlog("PID\tParent\tState\n");
 
     for( map_class<pid_t, pid_state>::const_iterator i=state.begin(); i!=state.end(); ++i ) {
-        dlog(PID_F"\t"PID_F"\t%s", i->first, i->second.parent, state2str(i->second.state) );
+        dlog(PID_F "\t" PID_F "\t%s", i->first, i->second.parent, state2str(i->second.state) );
 
         if( i->second.state==pid_state::ZOMBIE ) {
             dlog("(%d)", (int)i->second.context_state[0]);
--- process.cpp
+++ process.cpp
@@ -95,7 +95,7 @@
         if( (flags&CLONE_PTRACE)!=0 )
             state->context_state[0]|=NEW_PROCESS_SAME_DEBUGGER;
 
-        dlog(PID_F": clone called with flags %lx\n", pid, (unsigned long)flags );
+        dlog(PID_F ": clone called with flags %lx\n", pid, (unsigned long)flags );
 
         // Whatever it originally was, add a CLONE_PTRACE to the flags so that we remain in control
         flags|=CLONE_PTRACE;
@@ -107,10 +107,10 @@
 
         if( ptlib_success( pid, state->orig_sc ) ) {
             pid_t newpid=(pid_t)ptlib_get_retval( pid );
-            dlog(PID_F": clone succeeded, new process "PID_F"\n", pid, newpid );
+            dlog(PID_F ": clone succeeded, new process " PID_F "\n", pid, newpid );
             handle_new_process( pid, newpid );
         } else {
-            dlog(PID_F": clone failed: %s\n", pid, strerror( ptlib_get_error( pid, state->orig_sc ) ) );
+            dlog(PID_F ": clone failed: %s\n", pid, strerror( ptlib_get_error( pid, state->orig_sc ) ) );
         }
     }
 
@@ -133,7 +133,7 @@
         if( log_level>0 ) {
             char cmd[PATH_MAX];
             ptlib_get_string( pid, (void *)ptlib_get_argument( pid, 1 ), cmd, sizeof(cmd) );
-            dlog("execve: "PID_F" calling execve for executing %s\n", pid, cmd );
+            dlog("execve: " PID_F " calling execve for executing %s\n", pid, cmd );
             dlog(NULL);
         }
 
@@ -156,7 +156,7 @@
             state->state=pid_state::NONE;
 
             if( ptlib_success( pid, sc_num ) && state->context_state[1]==0 ) {
-                dlog("execve: "PID_F" successfully execed a new command\n", pid );
+                dlog("execve: " PID_F " successfully execed a new command\n", pid );
 
                 // All memory allocations performed before the exec are now null and void
                 state->memory=NULL;
@@ -175,15 +175,15 @@
                 }
 #endif
             } else if( state->context_state[1]!=0 ) {
-                dlog("execve: "PID_F" chroot translation forced error on us: %s\n", pid, strerror(state->context_state[1]) );
+                dlog("execve: " PID_F " chroot translation forced error on us: %s\n", pid, strerror(state->context_state[1]) );
 
                 ptlib_set_error( pid, state->orig_sc, state->context_state[1] );
             } else {
-                dlog("execve: "PID_F" failed with error %s\n", pid, strerror(ptlib_get_error(pid, sc_num)) );
+                dlog("execve: " PID_F " failed with error %s\n", pid, strerror(ptlib_get_error(pid, sc_num)) );
             }
         } else {
             state->state=pid_state::NONE;
-            dlog("execve: "PID_F" absorbed dummy SIGTRAP after successful execve\n", pid );
+            dlog("execve: " PID_F " absorbed dummy SIGTRAP after successful execve\n", pid );
             
             // If the trace mode is not SYSCALL, the post handling will not generate a TRACE. If PTLIB_TRAP_AFTER_EXEC is set,
             // a trace is required, however, even if not in TRACE_SYSCALL
@@ -328,7 +328,7 @@
                 if( child_state->state==pid_state::ZOMBIE ) {
                     // We can dispense with the pid entry
                     delete_state(child->pid());
-                    dlog("%s: Child "PID_F" removed from process table\n", __func__, child->pid() );
+                    dlog("%s: Child " PID_F " removed from process table\n", __func__, child->pid() );
                     child_state=NULL;
                 }
 
@@ -367,7 +367,7 @@
 
                 state->state=pid_state::REDIRECT2;
             } else {
-                dlog("wait4: "PID_F" hanged in wait for %d\n", pid, wait_pid );
+                dlog("wait4: " PID_F " hanged in wait for %d\n", pid, wait_pid );
             }
         }
         
--- ptrace.cpp
+++ ptrace.cpp
@@ -37,13 +37,13 @@
     pid_state *child_state=lookup_state( traced );
     if( child_state==NULL || child_state->debugger!=pid )
     {
-        dlog("ptrace verify_permission: %d failed permission - not the debugger for "PID_F"\n", pid, traced);
+        dlog("ptrace verify_permission: %d failed permission - not the debugger for " PID_F "\n", pid, traced);
         errno=ESRCH;
         return false;
     }
     if( child_state->trace_mode!=TRACE_STOPPED1 && child_state->trace_mode!=TRACE_STOPPED2 )
     {
-        dlog("ptrace verify_permission: %d failed permission - "PID_F" is not stopped\n", pid, traced);
+        dlog("ptrace verify_permission: %d failed permission - " PID_F " is not stopped\n", pid, traced);
         errno=ESRCH;
         return false;
     }
@@ -57,10 +57,10 @@
     pid_state *parent_state=lookup_state( debugger );
 
     if( child_state==NULL || parent_state==NULL || child_state->debugger!=0 ) {
-        dlog("begin_trace: %d Failed to start trace for "PID_F": child_state=%p, parent_state=%p", debugger, child, child_state,
+        dlog("begin_trace: %d Failed to start trace for " PID_F ": child_state=%p, parent_state=%p", debugger, child, child_state,
             parent_state );
         if( child_state!=NULL ) {
-            dlog("child_state debugger="PID_F, child_state->debugger);
+            dlog("child_state debugger=" PID_F, child_state->debugger);
         }
         dlog("\n");
 
@@ -82,10 +82,10 @@
     __ptrace_request req=(__ptrace_request)state->context_state[0];
     if( req==PTRACE_CONT ) {
         child_state->trace_mode|=TRACE_CONT;
-        dlog("ptrace: %d PTRACE_CONT("PID_F")\n", pid, child );
+        dlog("ptrace: %d PTRACE_CONT(" PID_F ")\n", pid, child );
     } else if( req==PTRACE_SYSCALL ) {
         child_state->trace_mode|=TRACE_SYSCALL;
-        dlog("ptrace: %d PTRACE_SYSCALL("PID_F")\n", pid, child );
+        dlog("ptrace: %d PTRACE_SYSCALL(" PID_F ")\n", pid, child );
     } else if( req==PTRACE_DETACH ) {
         child_state->trace_mode&=TRACE_MASK2;
     } else {
@@ -95,7 +95,7 @@
     long rc=0;
 
     if( (child_state->trace_mode&TRACE_MASK2)==TRACE_STOPPED1 ) {
-        dlog("handle_cont_syscall: "PID_F" process "PID_F" was in pre-syscall hook\n", pid, child );
+        dlog("handle_cont_syscall: " PID_F " process " PID_F " was in pre-syscall hook\n", pid, child );
         // Need to restart the syscall
         int status=child_state->context_state[1];
         PTLIB_WAIT_RET wait_state=(PTLIB_WAIT_RET)child_state->context_state[0];
@@ -109,14 +109,14 @@
             rc=ptlib_continue(PTRACE_SYSCALL, child, sig);
         }
     } else if( (child_state->trace_mode&TRACE_MASK2)==TRACE_STOPPED2 ) {
-        dlog("handle_cont_syscall: "PID_F" process "PID_F" was in post-syscall hook\n", pid, child );
+        dlog("handle_cont_syscall: " PID_F " process " PID_F " was in post-syscall hook\n", pid, child );
         child_state->trace_mode&=TRACE_MASK1;
         rc=ptlib_continue( PTRACE_SYSCALL, child, (int)state->context_state[3] );
     } else {
         // Our child was not stopped (at least, by us)
         // This is an internal inconsistency
 
-        dlog("handle_cont_syscall: "PID_F" process "PID_F" was started with no specific state (%x)\n", pid, child,
+        dlog("handle_cont_syscall: " PID_F " process " PID_F " was started with no specific state (%x)\n", pid, child,
                 child_state->trace_mode );
         dlog(NULL);
         rc=-1;
@@ -143,7 +143,7 @@
 static bool handle_detach( pid_t pid, pid_state *state )
 {
     if( verify_permission( pid, state ) ) {
-        dlog("ptrace: %d PTRACE_DETACH("PID_F")\n", pid, (pid_t)state->context_state[1]);
+        dlog("ptrace: %d PTRACE_DETACH(" PID_F ")\n", pid, (pid_t)state->context_state[1]);
 
         pid_state *child_state=lookup_state((pid_t)state->context_state[1]);
 
@@ -167,13 +167,13 @@
     pid_t child=(pid_t)state->context_state[1];
 
     if( verify_permission( pid, state ) ) {
-        dlog("handle_kill: %d is sending a kill to "PID_F"\n", pid, child );
+        dlog("handle_kill: %d is sending a kill to " PID_F "\n", pid, child );
 
         ptlib_continue(PTRACE_KILL, child, 0);
         ptlib_set_retval( pid, 0 );
     } else {
         ptlib_set_error( pid, state->orig_sc, errno );
-        dlog("handle_kill: %d tried to kill "PID_F": %s\n", pid, child, strerror(errno));
+        dlog("handle_kill: %d tried to kill " PID_F ": %s\n", pid, child, strerror(errno));
     }
 }
 
@@ -185,7 +185,7 @@
         errno=0;
         long data=ptrace( (__ptrace_request)state->context_state[0], child, state->context_state[2], 0 );
         if( data!=-1 || errno==0 ) {
-            dlog("handle_peek_data: %d is peeking data from "PID_F" at address %p\n", pid, child, (void*)state->context_state[2] );
+            dlog("handle_peek_data: %d is peeking data from " PID_F " at address %p\n", pid, child, (void*)state->context_state[2] );
 
             // Write the result where applicable
             // XXX This may be a Linux only semantics - pass addres to write result to as "data" argument
@@ -199,7 +199,7 @@
         }
     } else {
         ptlib_set_error( pid, state->orig_sc, errno );
-        dlog("handle_peek_data: %d tried get data from "PID_F": %s\n", pid, child, strerror(errno));
+        dlog("handle_peek_data: %d tried get data from " PID_F ": %s\n", pid, child, strerror(errno));
     }
 }
 
@@ -210,11 +210,11 @@
     if( verify_permission( pid, state ) &&
         ptrace( (__ptrace_request)state->context_state[0], child, state->context_state[2], state->context_state[3] )==0 )
     {
-        dlog("handle_poke_data: %d is pokeing data in "PID_F" at address %p\n", pid, child, (void*)state->context_state[2] );
+        dlog("handle_poke_data: %d is pokeing data in " PID_F " at address %p\n", pid, child, (void*)state->context_state[2] );
         ptlib_set_retval( pid, 0 );
     } else {
         ptlib_set_error( pid, state->orig_sc, errno );
-        dlog("handle_poke_data: %d tried push data to "PID_F": %s\n", pid, child, strerror(errno));
+        dlog("handle_poke_data: %d tried push data to " PID_F ": %s\n", pid, child, strerror(errno));
     }
 }
 
@@ -228,7 +228,7 @@
         state->context_state[2]=ptlib_get_argument( pid, 3 ); // addr
         state->context_state[3]=ptlib_get_argument( pid, 4 ); // data
 
-        dlog("ptrace: "PID_F" ptrace( %d, "PID_F", %p, %p )\n", pid, (int)state->context_state[0], (pid_t)state->context_state[1],
+        dlog("ptrace: " PID_F " ptrace( %d, " PID_F ", %p, %p )\n", pid, (int)state->context_state[0], (pid_t)state->context_state[1],
             (void*)state->context_state[2], (void*)state->context_state[3] );
 
         ptlib_set_syscall( pid, PREF_NOP );
@@ -240,7 +240,7 @@
         switch( state->context_state[0] ) {
         case PTRACE_TRACEME:
             if( begin_trace( state->parent, pid ) ) {
-                dlog("ptrace: %d PTRACE_TRACEME parent "PID_F"\n", pid, state->parent );
+                dlog("ptrace: %d PTRACE_TRACEME parent " PID_F "\n", pid, state->parent );
                 ptlib_set_retval( pid, 0 );
             } else {
                 dlog("ptrace: %d PTRACE_TRACEME failed %s\n", pid, strerror(errno) );
@@ -249,10 +249,10 @@
             break;
         case PTRACE_ATTACH:
             if( begin_trace( pid, (pid_t)state->context_state[1] ) ) {
-                dlog("ptrace: "PID_F" PTRACE_ATTACH("PID_F") succeeded\n", pid, (pid_t)state->context_state[1] );
+                dlog("ptrace: " PID_F " PTRACE_ATTACH(" PID_F ") succeeded\n", pid, (pid_t)state->context_state[1] );
                 ptlib_set_retval( pid, 0 );
             } else {
-                dlog("ptrace: "PID_F" PTRACE_ATTACH("PID_F") failed %s\n", pid, (pid_t)state->context_state[1], strerror(errno) );
+                dlog("ptrace: " PID_F " PTRACE_ATTACH(" PID_F ") failed %s\n", pid, (pid_t)state->context_state[1], strerror(errno) );
                 ptlib_set_error( pid, state->orig_sc, errno );
             }
             break;
@@ -293,7 +293,7 @@
         case PTRACE_SINGLESTEP:
             // We do not support single step right now
             ptlib_set_error( pid, state->orig_sc, EINVAL );
-            dlog("ptrace: "PID_F" tried to call SINGLESTEP on "PID_F"\n", pid, (pid_t)state->context_state[1]);
+            dlog("ptrace: " PID_F " tried to call SINGLESTEP on " PID_F "\n", pid, (pid_t)state->context_state[1]);
             break;
         case PTRACE_CONT:
         case PTRACE_SYSCALL:
@@ -306,7 +306,7 @@
             handle_detach( pid, state );
             break;
         default:
-            dlog("ptrace: "PID_F" Unsupported option %lx\n", pid, state->context_state[0] );
+            dlog("ptrace: " PID_F " Unsupported option %lx\n", pid, state->context_state[0] );
             ptlib_set_error(pid, state->orig_sc, EINVAL);
             break;
         }
