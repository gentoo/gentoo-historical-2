From arnold@skeeve.com Thu Mar 27 02:58:00 2003
Return-Path: <arnold@skeeve.com>
Delivered-To: azarah@chiba.3jane.net
Received: from gentoo.org (mail.gentoo.org [204.126.2.42]) by
	chiba.3jane.net (Postfix) with SMTP id 5FD3FABAE8 for
	<azarah@chiba.3jane.net>; Thu, 27 Mar 2003 02:58:00 -0600 (CST)
Received: (qmail 9186 invoked by alias); 27 Mar 2003 08:58:00 -0000
Delivered-To: azarah@gentoo.org
Received: (qmail 23216 invoked from network); 27 Mar 2003 08:57:57 -0000
Received: from unknown (HELO skeeve.com) (192.117.127.213) by
	mail.gentoo.org with SMTP; 27 Mar 2003 08:57:57 -0000
Received: from localhost.localdomain (skeeve [127.0.0.1]) by skeeve.com
	(8.12.5/8.12.5) with ESMTP id h2R8xBKj024532 for <azarah@gentoo.org>; Thu,
	27 Mar 2003 10:59:11 +0200
Received: (from arnold@localhost) by localhost.localdomain
	(8.12.5/8.12.5/Submit) id h2R8x9Wd024530 for azarah@gentoo.org; Thu, 27 Mar
	2003 10:59:09 +0200
Date: Thu, 27 Mar 2003 10:59:09 +0200
From: Aharon Robbins <arnold@skeeve.com>
Message-Id: <200303270859.h2R8x9Wd024530@localhost.localdomain>
To: azarah@gentoo.org
Subject:  Re: gawk-3.1.2 do not take input file on command line
Status:   
X-Evolution-Source: pop://azarah@chiba.3jane.net
Mime-Version: 1.0
Content-Transfer-Encoding: 8bit

Greetings.  Re this:

> Subject: gawk-3.1.2 do not take input file on command line
> From: Martin Schlemmer <azarah@gentoo.org>
> To: bug-gawk@gnu.org
> Date: 26 Mar 2003 16:04:17 +0200
>
> Hi
>
> For gawk-3.1.1 this was still fine, but with gawk-3.1.2 I get:
>
> -------------------------------------------------
> # gawk '/devfs/ { print }' /proc/filesystems 
> #
> -------------------------------------------------
>
> Which should have given the same as:
>
> -------------------------------------------------
> # cat /proc/filesystems | gawk '/devfs/ { print }'
> nodev	devfs
> nodev	usbdevfs
> # 
> --------------------------------------------------
>
> Breaks our boot up pretty bad 8)
>
>
> Regards,
>
> -- 
> Martin Schlemmer
> Gentoo Linux Developer, Desktop Team
> Cape Town, South Africa

As mentioned in private email, the problem is that such special files
report themselves as regular files of length 0, when in fact they have
data in them if you try to read them.  The new record-reading code wasn't
quite smart enough to deal with such a bizarre case.  The following
patch fixes the problem, at least for me.

Thanks for the bug report!

Arnold
--------------------
Thu Mar 27 10:44:11 2003  Arnold D. Robbins  <arnold@skeeve.com>

	* io.c (rs1_get_a_record, rsnull_get_a_record, rsre_get_a_record):
	Enhance check for no data left in file to be only if file has
	non-zero size.  Linux files such as /proc/filesystems stat as a
	regular file of size 0, but actually have contents. Ugh.
	Thanks to Martin Schlemmer <azarah@gentoo.org> for the bug report.

*** ../gawk-3.1.2/io.c	Tue Feb 25 12:32:30 2003
--- io.c	Thu Mar 27 10:43:36 2003
***************
*** 2506,2516 ****
                          /* Use read to put more data into the buffer. If we've read                 */
                          /* as many characters as in the file, don't try to read more.               */
                          /*                                                                          */
                          /*                                                                          */
                          /* <put more data into the buffer>=                                         */
                          if ((iop->flag & IOP_IS_INTERNAL) != 0) {
                                  iop->flag |= IOP_AT_EOF;
!                         } else if (S_ISREG(iop->sbuf.st_mode) && iop->total >= iop->sbuf.st_size)
                                  iop->flag |= IOP_AT_EOF;
                          else {
  #define min(x, y) (x < y ? x : y)
--- 2506,2521 ----
                          /* Use read to put more data into the buffer. If we've read                 */
                          /* as many characters as in the file, don't try to read more.               */
                          /*                                                                          */
+                         /* Well, not quite.  Linux files such as /proc/filesystems show             */
+                         /* up to stat() as though they're of size zero, but in fact they            */
+                         /* have data in them.  IMHO this is a Linux bug.                            */
+                         /*                                                                          */
                          /*                                                                          */
                          /* <put more data into the buffer>=                                         */
                          if ((iop->flag & IOP_IS_INTERNAL) != 0) {
                                  iop->flag |= IOP_AT_EOF;
!                         } else if (S_ISREG(iop->sbuf.st_mode) && iop->sbuf.st_size > 0
!                                    && iop->total >= iop->sbuf.st_size)
                                  iop->flag |= IOP_AT_EOF;
                          else {
  #define min(x, y) (x < y ? x : y)
***************
*** 2549,2555 ****
                                  else {
                                          iop->dataend += iop->count;
                                          iop->total += iop->count;
!                                         if (S_ISREG(iop->sbuf.st_mode) && iop->total >= iop->sbuf.st_size)
                                                  iop->flag |= IOP_AT_EOF;
                                          /* reset the sentinel */
                                          /* <set sentinel>=                                                          */
--- 2554,2561 ----
                                  else {
                                          iop->dataend += iop->count;
                                          iop->total += iop->count;
!                                         if (S_ISREG(iop->sbuf.st_mode) && iop->sbuf.st_size > 0
!                                             && iop->total >= iop->sbuf.st_size)
                                                  iop->flag |= IOP_AT_EOF;
                                          /* reset the sentinel */
                                          /* <set sentinel>=                                                          */
***************
*** 2748,2758 ****
                          /* Use read to put more data into the buffer. If we've read                 */
                          /* as many characters as in the file, don't try to read more.               */
                          /*                                                                          */
                          /*                                                                          */
                          /* <put more data into the buffer>=                                         */
                          if ((iop->flag & IOP_IS_INTERNAL) != 0) {
                                  iop->flag |= IOP_AT_EOF;
!                         } else if (S_ISREG(iop->sbuf.st_mode) && iop->total >= iop->sbuf.st_size)
                                  iop->flag |= IOP_AT_EOF;
                          else {
  #define min(x, y) (x < y ? x : y)
--- 2754,2769 ----
                          /* Use read to put more data into the buffer. If we've read                 */
                          /* as many characters as in the file, don't try to read more.               */
                          /*                                                                          */
+                         /* Well, not quite.  Linux files such as /proc/filesystems show             */
+                         /* up to stat() as though they're of size zero, but in fact they            */
+                         /* have data in them.  IMHO this is a Linux bug.                            */
+                         /*                                                                          */
                          /*                                                                          */
                          /* <put more data into the buffer>=                                         */
                          if ((iop->flag & IOP_IS_INTERNAL) != 0) {
                                  iop->flag |= IOP_AT_EOF;
!                         } else if (S_ISREG(iop->sbuf.st_mode) && iop->sbuf.st_size > 0
!                                    && iop->total >= iop->sbuf.st_size)
                                  iop->flag |= IOP_AT_EOF;
                          else {
  #define min(x, y) (x < y ? x : y)
***************
*** 2791,2797 ****
                                  else {
                                          iop->dataend += iop->count;
                                          iop->total += iop->count;
!                                         if (S_ISREG(iop->sbuf.st_mode) && iop->total >= iop->sbuf.st_size)
                                                  iop->flag |= IOP_AT_EOF;
                                          /* reset the sentinel */
                                          /* <set sentinel>=                                                          */
--- 2802,2809 ----
                                  else {
                                          iop->dataend += iop->count;
                                          iop->total += iop->count;
!                                         if (S_ISREG(iop->sbuf.st_mode) && iop->sbuf.st_size > 0
!                                             && iop->total >= iop->sbuf.st_size)
                                                  iop->flag |= IOP_AT_EOF;
                                          /* reset the sentinel */
                                          /* <set sentinel>=                                                          */
***************
*** 3012,3022 ****
                          /* Use read to put more data into the buffer. If we've read                 */
                          /* as many characters as in the file, don't try to read more.               */
                          /*                                                                          */
                          /*                                                                          */
                          /* <put more data into the buffer>=                                         */
                          if ((iop->flag & IOP_IS_INTERNAL) != 0) {
                                  iop->flag |= IOP_AT_EOF;
!                         } else if (S_ISREG(iop->sbuf.st_mode) && iop->total >= iop->sbuf.st_size)
                                  iop->flag |= IOP_AT_EOF;
                          else {
  #define min(x, y) (x < y ? x : y)
--- 3024,3039 ----
                          /* Use read to put more data into the buffer. If we've read                 */
                          /* as many characters as in the file, don't try to read more.               */
                          /*                                                                          */
+                         /* Well, not quite.  Linux files such as /proc/filesystems show             */
+                         /* up to stat() as though they're of size zero, but in fact they            */
+                         /* have data in them.  IMHO this is a Linux bug.                            */
+                         /*                                                                          */
                          /*                                                                          */
                          /* <put more data into the buffer>=                                         */
                          if ((iop->flag & IOP_IS_INTERNAL) != 0) {
                                  iop->flag |= IOP_AT_EOF;
!                         } else if (S_ISREG(iop->sbuf.st_mode) && iop->sbuf.st_size > 0
!                                    && iop->total >= iop->sbuf.st_size)
                                  iop->flag |= IOP_AT_EOF;
                          else {
  #define min(x, y) (x < y ? x : y)
***************
*** 3055,3061 ****
                                  else {
                                          iop->dataend += iop->count;
                                          iop->total += iop->count;
!                                         if (S_ISREG(iop->sbuf.st_mode) && iop->total >= iop->sbuf.st_size)
                                                  iop->flag |= IOP_AT_EOF;
                                          /* reset the sentinel */
                                          /* <set sentinel>=                                                          */
--- 3072,3079 ----
                                  else {
                                          iop->dataend += iop->count;
                                          iop->total += iop->count;
!                                         if (S_ISREG(iop->sbuf.st_mode) && iop->sbuf.st_size > 0
!                                             && iop->total >= iop->sbuf.st_size)
                                                  iop->flag |= IOP_AT_EOF;
                                          /* reset the sentinel */
                                          /* <set sentinel>=                                                          */
