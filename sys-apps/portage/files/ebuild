#!/bin/bash
# Copyright 1999-2000 Daniel Robbins, Gentoo Technologies, Inc.
# Distributed under the GPL

if [ ! -f "/usr/lib/portage/bin/python" ]
then
   cp /usr/bin/python /usr/lib/portage/bin/python
fi

if [ "`whoami`" != "root" ]
then
	echo "Since ebuild can modify critical system files, only root is"
	echo "allowed to use the ebuild system."
	exit 1
fi

#allow any envvars to be set like QTDIR, even if Qt was just installed
source /etc/profile
export PATH=/usr/lib/portage/bin:${PATH}
eval `import-settings PROXY HTTP_PROXY FTP_PROXY FETCHCOMMAND PACKAGE DEBUG MAKEOPTS USE MAINTAINER CHOST CFLAGS CXXFLAGS PORTDIR DISTDIR BUILD_PREFIX PKGDIR RPMDIR PLATFORM ROOT`
export DEPEND

initvars() {
	export DESTTREE=/usr
	export INSDESTTREE=""
	export EXEDESTTREE=""
	export DOCDESTTREE=""
	export INSOPTIONS="-m0644"
	export EXEOPTIONS="-m0755"	
	export LIBOPTIONS="-m0644"
	export MOPREFIX=${PN}
	export KVERS=`uname -r`
}

initvars

src_unpack() { 
	unpack ${A} 
}

src_compile() { 
	return 
}

src_install() 
    { 
	return 
    }

pkg_preinst()
    {
	return
    }

pkg_postinst()
    {
	return
    }

pkg_prerm()
    {
	return
    }

pkg_postrm()
    {
	return
    }

try() {
	eval $*
	if [ $? -ne 0 ]
	then
		echo 
		echo '!!! '"ERROR: the $1 command did not complete successfully."
		echo '!!! '"(\"$*\")"
		echo '!!! '"Since this is a critical task, ebuild will be stopped."
		echo
		exit 1
	fi
}

dyn_touch() {
	local x
	for x in ${A} 
	do
		if [ -e ${DISTDIR}/${x} ]
		then	
			touch ${DISTDIR}/${x}
		fi
	done
}

dyn_digest() {
	local x
	if [ ! -d ${FILESDIR} ]
	then
		install -d ${FILESDIR}
		if [ -n ${MAINTAINER} ]
		then
			echo ">>> adding ${FILESDIR} to CVS (just in case it isn't there)"
			( echo; cd `/usr/bin/dirname ${FILESDIR}`; cvs add `/usr/bin/basename ${FILESDIR}`; echo)
		fi
	fi
	for x in ${A}
	do
		if [ ! -e ${DISTDIR}/${x} ]
		then
			echo '!!! Cannot compute message digests: '${x} not found
			echo "error, aborting."
			exit 1
		else
	    	mymd5=`md5sum ${DISTDIR}/${x} | cut -f1 -d" "`
	    	echo "MD5 $mymd5 $x" >> ${FILESDIR}/.digest-${PF}
		fi
    done
    mv ${FILESDIR}/.digest-${PF} ${FILESDIR}/digest-${PF}
    if [ -n "${MAINTAINER}" ]
    then
		echo ">>> adding digest-${PF} to CVS (just in case it isn't there)"
		( echo; cd ${FILESDIR}; cvs add digest-${PF}; echo )
    fi
    echo ">>> Computed message digests."
}

merge_check() {
	if [ -d ${ROOT}var/db/pkg/${CATEGORY}/${PF} ]
    then
		echo 
		echo '!!!' "${PF} already merged -- unmerge first" 
		echo
		exit 1
    fi
}

digest_check() {
	if [ ! -e ${FILESDIR}/digest-${PF} ]
	then
		echo '!!!'" No message digest file found."
		if [ -n "$MAINTAINER" ]
		then
			echo '>>> Maintainer mode: auto-computing digests.'
			dyn_digest
			return 0
		else
			echo '!!!'" Maintainer: ebuild digest to update message digests."
			return 1
		fi
    fi
	if [ ! -e ${DISTDIR}/${1} ]
	then
		echo '!!!'" ${1} not found."
		echo '!!!'" Ebuild fetch to retrieve files."
		return 1
	fi	
	local mycdigest=`grep " ${1}" ${FILESDIR}/digest-${PF} | cut -f2 -d" "`
	if [ -z "$mycdigest" ]
	then
		echo
		echo '!!!'" No message digest found for ${1}."
		if [ -n "$MAINTAINER" ]
		then
			echo '>>> Maintainer mode: auto-computing digests.'
			dyn_digest
			echo 
			return 0
		else
			echo '!!!'" Maintainer: ebuild digest to update message digests."
			echo
			return 1
		fi
	fi
	local mydigest=`md5sum ${DISTDIR}/${1} | cut -f1 -d" "`
	if [ "$mycdigest" != "$mydigest" ]
	then
		echo
		echo '!!!'" ${1}: message digests do not match!"
		echo '!!!'" ${1} is corrupt or incomplete"
		echo ">>> md5 con ${mycdigest}"
		echo ">>> md5 now ${mydigest}"
		echo ">>> Please delete/redownload ${DISTDIR}/${1}"
		echo
		return 1
	else
		echo ">>> md5 ;-) ${1}"
	fi
	return 0
}

dyn_batchdigest() {
    local x
    if [ ! -e ${FILESDIR}/digest-${PF} ]
    then
	if [ "${A}" != "" ]
	then
		echo "${CATEGORY}/${PF} has no digest file."
	fi
	exit 1
    fi
    	for x in ${A}
    	do
		if [ ! -e ${DISTDIR}/${x} ]
    		then
			echo "${CATEGORY}/${PF}:${x} does not exist in ${DISTDIR}."
			continue
		else
			local mycdigest=`grep " ${x}" ${FILESDIR}/digest-${PF} | cut -f2 -d" "`
			if [ -z "$mycdigest" ]
			then
				echo "${CATEGORY}/${PF}:${x} digest not yet recorded."
				continue
			fi
    			local mydigest=`md5sum ${DISTDIR}/${x} | cut -f1 -d" "`
    			if [ "$mycdigest" != "$mydigest" ]
   			then
				echo "${CATEGORY}/${PF}:${x} is corrupt or has an invalid digest."
			fi
		fi
	done
}


dyn_fetch() {
	local y
	for y in ${A}
	do
		if [ ! -e ${DISTDIR}/${y} ]
		then
			echo ">>> Fetching ${y}..."
			echo
			local x
			local _SRC_URI
			_SRC_URI=`/usr/bin/queryhost.sh "${SRC_URI}"`
			for x in ${_SRC_URI}
			do
				if [ ! -e ${DISTDIR}/${y} ] 
				then
			    		if [ $y == ${x##*/} ]
			    		then
						echo ">>> Trying site ${x}..."
						eval ${FETCHCOMMAND}
						if [ $? -ne 0 ]
		        			then
			    				echo '!!!'" Couldn't download ${y}."
						fi
		    			fi
				fi
			done
			if [ ! -e ${DISTDIR}/${y} ]
			then
  				echo '!!!'" Couldn't download ${y}.  Aborting."
				exit 1
			fi
			echo
    	fi	
	done
	for y in ${A}
	do
		digest_check ${y}
		if [ $? -ne 0 ]
		then
				exit 1
		fi
	done
}

dyn_unpack() {
	trap "abort_unpack" SIGINT SIGQUIT
	local unpackwork="yes"
	if [ -e ${WORKDIR} ]
	then
		local x
		for x in $A $EBUILD
		do
			echo ">>> Checking ${x}'s mtime..."
			if [ ${DISTDIR}/${x} -nt ${WORKDIR} ]
			then
				echo ">>> ${x} has been updated; recreating WORKDIR..."
				rm -rf ${WORKDIR}
				break
			fi
		done
		echo ">>> WORKDIR is up-to-date, not unpacking. (clean to force unpack)"
		unpackwork="no"
	fi
	if [ "$unpackwork" = "yes" ]
	then
		install -m0700 -d ${WORKDIR}
		cd ${WORKDIR}
		echo ">>> Unpacking source..."
		src_unpack
		echo ">>> Source unpacked."
		cd ..
    fi
    trap SIGINT SIGQUIT
}

dyn_clean() {
	if [ -d ${WORKDIR} ]
	then
		rm -rf ${WORKDIR} 
	fi
	if [ -d ${BUILDDIR}/image ]
	then
		rm -rf ${BUILDDIR}/image
	fi
	rm -rf ${BUILDDIR}/.compiled
}

into() {
	if [ $1 = "/" ]
	then
		export DESTTREE=""
	else
		export DESTTREE=$1
		if [ ! -d ${D}${DESTTREE} ]
		then
			install -d ${D}${DESTTREE}
		fi
	fi
}

insinto() {
    if [ $1 = "/" ]
    then
	export INSDESTTREE=""
    else
	export INSDESTTREE=$1
	if [ ! -d ${D}${INSDESTTREE} ]
	then
	    install -d ${D}${INSDESTTREE}
	fi
    fi
}

exeinto() {
    if [ $1 = "/" ]
    then
	export EXEDESTTREE=""
    else
	export EXEDESTTREE=$1
	if [ ! -d ${D}${EXEDESTTREE} ]
	then
	    install -d ${D}${EXEDESTTREE}
	fi
    fi
}
docinto() {
    if [ $1 = "/" ]
    then
	export DOCDESTTREE=""
    else
	export DOCDESTTREE=$1
	if [ ! -d ${D}usr/doc/${PF}/${DOCDESTTREE} ]
	then
	    install -d ${D}usr/doc/${PF}/${DOCDESTTREE} 
	fi
    fi
}

insopts() {
    INSOPTIONS=""
    for x in $*
    do
	#if we have a debug build, let's not strip anything
	if [ -n "$DEBUG" ] &&  [ "$x" = "-s" ]
	then
	    continue
        else
             INSOPTIONS="$INSOPTIONS $x"
        fi
    done
    export INSOPTIONS
}

doins() {
    local mynum=${#}
    if [ ${mynum} -lt 1 ]
    then
	echo "${0}: at least one argument needed"
	return
    fi
    if [ ! -d ${D}${INSDESTTREE} ]
    then
	install -d ${D}${INSDESTTREE}
    fi
    local x
    local mysrc
    for x in "$@"
    do
	if [ -L $x ]
	then
	    cp $x ${T}
	    mysrc=${T}/`/usr/bin/basename ${x}`
	elif [ -d $x ]
	then
	    echo "doins: warning, skipping directory ${x}"
            continue
        else
	    mysrc=${x}
	fi
        install ${INSOPTIONS} ${mysrc} ${D}${INSDESTTREE}
    done
}

donewins() {
    local mynum=${#}
    if [ ${mynum} -lt 1 ]
    then
	echo "${0}: at least one argument needed"
	return
    fi
    if [ ! -d ${D}${INSDESTTREE} ]
    then
	install -d ${D}${INSDESTTREE}
    fi
    install -D ${INSOPTIONS} ${1} ${D}${INSDESTTREE}/${2}

}

exeopts() {
    EXEOPTIONS=""
    for x in $*
    do
	#if we have a debug build, let's not strip anything
	if [ -n "$DEBUG" ] &&  [ "$x" = "-s" ]
	then
	    continue
        else
             EXEOPTIONS="$EXEOPTIONS $x"
        fi
    done
    export EXEOPTIONS
}

libopts() {
    LIBOPTIONS=""
    for x in $*
    do
	#if we have a debug build, let's not strip anything
	if [ -n "$DEBUG" ] &&  [ "$x" = "-s" ]
	then
	    continue
        else
             LIBOPTIONS="$LIBOPTIONS $x"
        fi
    done
    export LIBOPTIONS
}

abort_compile() {
    echo 
    echo '*** Compilation Aborted ***'
    echo
    cd ${BUILDDIR} #original dir
    rm -f .compiled
    trap SIGINT SIGQUIT
    exit 1
}

abort_unpack() {
    echo 
    echo '*** Unpack Aborted ***'
    echo
    cd ${BUILDDIR} #original dir
    rm -f .unpacked
    rm -rf work
    trap SIGINT SIGQUIT
    exit 1
}

abort_package() {
    echo 
    echo '*** Packaging Aborted ***'
    echo
    cd ${BUILDDIR} #original dir
    rm -f .packaged
    rm -f ${PKGDIR}/All/${PF}.t*
    trap SIGINT SIGQUIT
    exit 1
}

abort_image() {
    echo 
    echo '*** Imaging Aborted ***'
    echo
    cd ${BUILDDIR} #original dir
    rm -rf image
    trap SIGINT SIGQUIT
    exit 1
}

dyn_compile() {
    trap "abort_compile" SIGINT SIGQUIT
    export CFLAGS CXXFLAGS LIBCFLAGS LIBCXXFLAGS
    if [ ${BUILDDIR}/.compiled -nt ${WORKDIR} ]
    then
	echo ">>> It appears that ${PN} is already compiled.  skipping."
	echo ">>> (clean to force compilation)"
	trap SIGINT SIGQUIT
	return
    fi
    if [ -d ${S} ]
    then
    cd ${S}
    fi
    src_compile 
    cd ${BUILDDIR}
    touch .compiled
    trap SIGINT SIGQUIT
}

dyn_package() {
    trap "abort_package" SIGINT SIGQUIT
    local PNAME=${PF}.${PACKAGE}
    cd ${BUILDDIR}/image
    echo ">>> Creating ${PNAME} in ${PKGDIR}/All..."
    if [ "$PACKAGE" = "tbz2" ]
    then
	tar cvf ${PKGDIR}/All/${PF}.tar *
	bzip2 ${PKGDIR}/All/${PF}.tar
	mv ${PKGDIR}/All/${PF}.tar.bz2 ${PKGDIR}/All/${PNAME}	
    elif [ "$PACKAGE" = "tgz" ]
    then
 	tar czvf ${PKGDIR}/All/${PNAME} *
    else
	echo '!!! Package format '${PACKAGE}' not recognized.  Please correct /etc/make.conf'
	exit 1
    fi
    ln -sf ${PKGDIR}/All/${PNAME} ${PKGDIR}/${CATEGORY}/${PNAME}
    echo ">>> Done."
    cd ${BUILDDIR}
    touch .packaged
    trap SIGINT SIGQUIT
}

dyn_install() {
    local ROOT
    trap "abort_image" SIGINT SIGQUIT
    rm -rf ${BUILDDIR}/image
    mkdir ${BUILDDIR}/image
    if [ -d ${S} ]
    then
    cd ${S}
    fi
    echo
    echo ">>> Install ${PF} into ${D} category ${CATEGORY}"
    src_install
    prepall
    install -d -m0700 ${D}var/db/pkg/${CATEGORY}/${PF}
    cp ${STARTDIR}/${EBUILD} ${D}var/db/pkg/${CATEGORY}/${PF}
    echo ">>> Completed installing into ${D}"
    echo
    cd ${BUILDDIR}
    trap SIGINT SIGQUIT
}

dyn_merge() {
    trap "" SIGINT SIGQUIT
    #not interruptible, so that the db doesn't get garbled
    if [ -d ${ROOT}var/db/pkg/${CATEGORY}/${PF} ]
    then
	echo 
	echo '!!!' "${PF} already merged -- unmerge first" 
	echo
	exit 1
    fi
    echo
    pkg_preinst
    #/usr/sbin/portage-merge
	dopython portage.merge "$CATEGORY" "$PF" "$D"
	cd ${BUILDDIR}
    #zap it so that people don't look at a bad image and get confused
    rm -rf image
    pkg_postinst
    trap SIGINT SIGQUIT
}

dyn_unmerge() {
    trap "" SIGINT SIGQUIT
    #/usr/sbin/portage-unmerge ${PF}
    dopython portage.unmerge "$CATEGORY" "$PF"
    trap SIGINT_SIGQUIT
}


dyn_spec() {
    tar czf /usr/src/redhat/SOURCES/${PF}.tar.gz ${O}/${PF}.ebuild ${O}/files

    cat <<__END1__ > ${PF}.spec
Summary: ${DESCRIPTION}
Name: ${PN}
Version: ${PV}
Release: ${PR}
Copyright: GPL
Group: portage/${CATEGORY}
Source: ${PF}.tar.gz
Buildroot: ${D}
%description
${DESCRIPTION}

${HOMEPAGE}

%prep
%setup -c

%build

%install

%clean

%files
/
__END1__

}
dyn_rpm () {
    dyn_spec
    rpm -bb ${PF}.spec

    install -D /usr/src/redhat/RPMS/i386/${PN}-${PV}-${PR}.i386.rpm ${RPMDIR}/${CATEGORY}/${PN}-${PV}-${PR}.rpm
}

dyn_help() {
	echo
	echo "Portage v1.0-r1"
	echo "Copyright 2000 Gentoo Technologies, Inc."
	echo 
	echo "How to use the ebuild command:"
	echo 
	echo "The first argument to ebuild should be an existing .ebuild file."
	echo
	echo "One or more of the following options can then be specified.  If more"
	echo "than one option is specified, each will be executed in order."
	echo
	echo "  fetch       : download source archive(s) and patches"
	echo "  unpack      : unpack/patch sources (auto-fetch if needed)"
	echo "  compile     : compile sources (auto-fetch/unpack if needed)"
	echo "  merge       : merge image into live filesystem, recording files in db"
	echo "                (auto-fetch/unpack/compile if needed)"
	echo "  unmerge     : remove package from live filesystem"
	echo "  package     : create tarball package of type ${PACKAGE}"
        echo "                (will be stored in ${PKGDIR}/All)"
	echo "  clean       : clean up all source and temporary files"
	echo
	echo "The following settings will be used for the ebuild process:"
	echo
	echo "  package     : ${PF}" 
	echo "  category    : ${CATEGORY}" 
	echo "  description : ${DESCRIPTION}"
	echo "  system      : ${CHOST}" 
	echo "  c flags     : ${CFLAGS}" 
	echo "  c++ flags   : ${CXXFLAGS}" 
	echo "  make flags  : ${MAKEOPTS}" 
	echo -n "  build mode  : "
	if [ -n "${DEBUG}" ]
	then
	    echo "debug (large)"
	else
	    echo "production (stripped)"
	fi
	echo "  merge to    : ${ROOT}" 
	echo "  db location : ${ROOT}var/db/pkg/${CATEGORY}/${P}/CONTENTS"
	echo 
	if [ -n "$USE" ]
	then
	    echo "Additionally, support for the following toolkits will be enabled if necessary:"
	    echo 
	    echo "  ${USE}"
	fi    
	echo
}

src_menu() {
    MYDIR=${BUILDDIR}
    if [ "$1" = "p" ]
    then
	echo ${PF}
	exit 0
    fi

    local MYfoo
    for MYfoo in "$@" 
    do
	case "${MYfoo}" in
	noop)
	    ;;
	unpack)
	    dyn_fetch
	    dyn_unpack
	    ;;
	compile)
        dopython portage.dep_frontend
		if [ $? -ne 0 ]
		then
			exit $?
		fi
	            dyn_fetch
	    dyn_unpack
	    dyn_compile
            ;;
	prerm|postrm|preinst|postinst|config)
	    pkg_${MYfoo}
	    ;;
	help|batchdigest|touch|clean|fetch|digest|pkginfo|pkgloc|unmerge|install)
	    dyn_${MYfoo}
	    ;;
	package)
        dopython portage.dep_frontend
		if [ $? -ne 0 ]
		then
			exit $?
		fi
		dyn_fetch
	local PNAME=${PF}.${PACKAGE}
	if [ ! -d ${PKGDIR} ]
	then
		install -d ${PKGDIR}
	fi
	if [ ! -d ${PKGDIR}/All ]
	then
		install -d ${PKGDIR}/All
	fi	
	if [ ! -d ${PKGDIR}/${CATEGORY} ]
	then
		install -d ${PKGDIR}/${CATEGORY}
	fi
    	if [ -e ${PKGDIR}/All/${PNAME} ]
    	then
		if [ ! -d ${PKGDIR}/${CATEGORY}/${PNAME} ]
		then
			ln -sf ${PKGDIR}/All/${PNAME} ${PKGDIR}/${CATEGORY}/${PNAME}
		fi
    		local x
    		local dopackage
    		dopackage="no"
    		for x in ${A} ${EBUILD}
    		do
			if [ ${x} -nt ${PKGDIR}/All/${PNAME} ]
			then
				dopackage="yes"
				break
			fi
    		done
		if [ "$dopackage" = "no" ]
		then
			echo
			echo ">>> Package ${PNAME} appears to be up-to-date."
			echo ">>> To force rebuild, touch ${EBUILD}."
			echo
			continue
		fi
    	fi
        dyn_unpack
	dyn_compile
	dyn_install
	dyn_package
	;;
	qmerge)
	    dyn_merge
	    ;;
 	merge)
        merge_check
		dopython portage.dep_frontend
		if [ $? -ne 0 ]
		then
			exit $?
		fi
		dyn_fetch
	    dyn_unpack
	    dyn_compile
            dyn_install
            dyn_merge
	    ;;
	rpm)
        dopython portage.dep_frontend
		if [ $? -ne 0 ]
		then
			exit $?
		fi
	            dyn_fetch
	    dyn_unpack
	    dyn_compile
            dyn_install	
	    dyn_rpm
	    ;;
	*)
	    echo "Please specify a valid command."
	    echo
            dyn_help
	esac
    done
    cd $MYDIR
}

#dummy value for help printouts
P=packagename

if [ $# -lt 1 ]
then
	echo
	echo '!!!' "At least two arguments expected."
	dyn_help
	exit 1
fi

if [ ! -e ${1} ]
then
	echo
	echo '!!!' "${1} not found."
	dyn_help
	exit 1
fi

# this function sets various environment variables that are used by 
# portage.  For a package called "foo-1.2-r1", they would be set as
# follows:
# P=foo-1.2
# PF=foo-1.2-r1 (r1 is the rev, or release of the ebuild script)
# PN=foo
# PV=1.2
# PR=1 (rev is zero if unspecified)

setp() {
	if [ $# -ne 3 ]
	then
		echo '!!!' ${P} is not a valid package name.  Exiting.
		exit 1
	fi
	if [ "${3}" = "0" ]
	then
		export PF="${1}-${2}"
	else
		export PF="${1}-${2}-r${3}"
	fi
	export P="${1}-${2}"
	export PN="${1}"
	export PV="${2}"
	export PR="${3}"
}

export STARTDIR=`pwd`

if [ "${1:0:1}" = "/" ]
then
	export O=`dirname ${1}`
else
	tmpfoo=`dirname ${1}`
	export O=`( cd ${tmpfoo}; pwd )`
fi
tmpfoo=`(cd ${O}/..;pwd)`
export CATEGORY=`/usr/bin/basename $tmpfoo`
export EBUILD=${1}
export PEBUILD=${O}/files/${PLATFORM}.ebuild
export FILESDIR=${O}/files

tmpfoo=`/usr/bin/basename ${1%.*}`
setp `/usr/sbin/pkgname ${tmpfoo}`

source ${1}
if [ -e ${PEBUILD} ]
then
	source ${PEBUILD}
fi

if [ ! -z ${BUILD_PREFIX} ]
then
    export BUILDDIR=${BUILD_PREFIX}/${PF}
else
    export BUILDDIR=${O}
fi
if [ ! -d ${BUILDDIR} ]
then
   install -d ${BUILDDIR}
fi

export T=${BUILDDIR}/temp
if [ ! -d ${T} ]
then
   install -d ${T}
fi
export WORKDIR=${BUILDDIR}/work
export D=${BUILDDIR}/image
dlen=$(( ${#D} -1 ))
if [ "${D:${dlen}:1}" != "/" ]
then
    export D=${D}/
fi

source ${1}
if [ -e ${PEBUILD} ]
then
	source ${PEBUILD}
fi


if [ $# -eq 1 ]
then
	dyn_help
fi

foo=2
while [ $foo -le $# ]
do
eval "src_menu \${${foo}}"
if [ $? -ne 0 ]
then
        echo "***error***"
        exit 1
fi
foo=$(( $foo + 1))
done


