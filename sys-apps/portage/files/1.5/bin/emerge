#!/usr/bin/env spython

import portage
import sys
import os
import xpak
import string
import commands
import shutil

#build our package digraph

class depgraph:

	def __init__(self,mymode,myopts):
		self.mymode=mymode
		self.myopts=myopts
		virts=portage.getvirtuals("/")
		self.db={}
		self.db["/"]={"virtuals":virts,"vartree":portage.vartree("/",virts),"porttree":portage.portagetree("/",virts),"bintree":portage.binarytree("/",virts)}
		if portage.root!="/":
			pr=portage.root
			virts=portage.getvirtuals(pr)
			self.db[pr]={"virtuals":virts,"vartree":portage.vartree(pr,virts),"porttree":portage.portagetree(pr,virts),"bintree":portage.binarytree(pr,virts)}
		self.digraph=portage.digraph()

	def create(self,mybigkey=None,myparent=None):
		sys.stdout.write(".")	
		sys.stdout.flush()
		if self.digraph.hasnode(mybigkey):
			#if we've already hit this node before, we're already recursing on the dependencies.
			#no need to recurse again.
			if myparent:
				self.digraph.addnode(mybigkey,myparent)
			return 1
		mytype,myroot,mykey=string.split(mybigkey)
		if mytype=="binary":
			if not self.db[portage.root]["bintree"].exists_specific(mykey):
				print "\n\n!!!",mytype,mykey,"not found (possibly blocked by package.mask)\n"
				sys.exit(1)
			mytbz2=xpak.tbz2(self.db[portage.root]["bintree"].getname(mykey))
			edepend=["",string.join(mytbz2.getelements("RDEPEND")," ")]
		else:
			#ebuild specified
			if not self.db[myroot]["porttree"].exists_specific(mykey):
				print "\n\n!!!",mytype,mykey,"not found (possibly blocked by package.mask)\n"
				sys.exit(1)
				mydep={}
			myebuild=self.db[myroot]["porttree"].getname(mykey)
			edepend=portage.doebuild(myebuild,"depend")
		mydep={}	
		if portage.root=="/":
			mydep["/"]=edepend[0]+" "+edepend[1]
		else:
			mydep["/"],mydep[portage.root]=edepend
		self.digraph.addnode(mybigkey,myparent)
		for dep in mydep.keys():
			mycheck=self.db[dep]["vartree"].depcheck(mydep[dep])
			if mycheck[0]==0:
				print "!!! depgraph.create() error: string format:",mydep
				return 0
			for x in mycheck[1]:
				mynew=self.match(x)
				if not self.digraph.hasnode(mynew):
					if not self.create(mynew,mybigkey):
						return 0
				else:
					self.digraph.addnode(mynew,mybigkey)
		return 1
	
	def altlist(self):
		mygraph=self.digraph.copy()
		dolist=["/"]
		retlist=[]
		for x in self.db.keys():
			self.db[x]["merge"]=[]
			if x not in dolist:
				dolist.append(x)
		while (not mygraph.empty()):
			mycurkey=mygraph.firstzero()
			if not mycurkey:
				print "!!! Error: circular dependencies"
				sys.exit(1)
			splitski=string.split(mycurkey)
			self.db[splitski[1]]["merge"].append(splitski)	
			mygraph.delnode(mycurkey)
		for x in dolist:
			for y in self.db[x]["merge"]:
				retlist.append(y)
		return retlist

	def syscreate(self,mylines):
		for x in mylines:
			myline=string.join(string.split(x))
			if not len(myline):
				continue
			if myline[0]=="#":
				continue
			if "update" not in self.mymode:
				mycheck=self.db[portage.root]["vartree"].depcheck(myline)
				if mycheck[0]==0:
					print "\n!!! Warning:",myline,"has an invalid depstring\n"
					continue
				if mycheck[1]==None:
					continue
				for x in mycheck[1]:
					self.create(self.match(myline))
			else:
				self.create(self.match(myline))
	
	def match(self,mydep):
		myeb=self.db[portage.root]["porttree"].dep_bestmatch(mydep)
		if not myeb:
			print "\n!!! Error: couldn't find match for",myline,"\n"
			sys.exit(1)
		if "--usepkg" in self.myopts:
			mypk=self.db[portage.root]["bintree"].dep_bestmatch(mydep)
			if myeb==mypk:
				myk="binary "+portage.root+" "+mypk
			else:
				myk="ebuild "+portage.root+" "+myeb
		else:
			myk="ebuild "+portage.root+" "+myeb
		return myk	
	
	def display(self,mylist):
		for x in mylist:
			if self.db[x[1]]["vartree"].exists_specific(x[2]):
				addl=" R "
			elif self.db[x[1]]["vartree"].exists_specific_cat(x[2]):
				addl="  U"
			else:
				addl="N  "
			print "["+x[0]+" "+addl+"]",x[2],"to",x[1]
				
	def merge(self,mylist):
		for x in mylist:
			os.environ["ROOT"]=x[1]
			print ">>> emerge",x[2],"to",x[1]
			#the last argument in the portage.doebuild() tells doebuild to *not* do dep checking
			#(emerge is already handling that)
			y=self.db[x[1]]["porttree"].getname(x[2])
			if x[0]=="ebuild":
				if "--buildpkg" in self.myopts:
					#create pkg, then merge pkg
					retval=portage.doebuild(y,"clean",0)
					if retval:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
					retval=portage.doebuild(y,"package",0)
					if retval:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
					#dynamically update our database	
					self.db[portage.root]["bintree"].inject(x[2])
					mytbz2=self.db[portage.root]["bintree"].getname(x[2])
					retval=portage.pkgmerge(mytbz2)
					if retval==None:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
				else:
					retval=portage.doebuild(y,"clean",0)
					if retval:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
					retval=portage.doebuild(y,"merge",0)
					if retval:
						print "!!! emerge aborting on ",y,"."
						sys.exit(1)
					#dynamically update our database	
			else:
				#merge the tbz2
				mytbz2=self.db[portage.root]["bintree"].getname(x[2])
				retval=portage.pkgmerge(mytbz2)
				if retval==None:
					print "!!! emerge aborting on ",y,"."
					sys.exit(1)
				#need to check for errors
			self.db[x[1]]["vartree"].inject(x[2])
			if "--autoclean" in self.myopts:
				retval=portage.doebuild(y,"clean",0)
				if retval:
					print "!!! emerge aborting on ",y,"."
					sys.exit(1)
opts=["--help","--pretend","--buildpkg","--usepkg","--autoclean"]
modes=["rsync","system","update"]
myopts=[]
mymode=[]
myfiles=[]

for x in sys.argv[1:]:
	if len(x)>=2:
		if x[0:2]=="--":
			if x in opts:
				myopts.append(x)
			else:
				print "!!! Error:",x,"is an invalid option."
				sys.exit(1)
		elif x in modes:
			if len(mymode)>=1:
				print "!!! Error: more than one mode specified on command-line."
				print "!!! Available modes:",modes
				sys.exit(1)
			else:
				mymode.append(x)
		elif os.path.exists(x):
			if not x in myfiles:
				myfiles.append(x)
		else:
			print "!!! Error:",x,"does not exist or is an invalid command-line option."
			sys.exit(1)

if "--help" in myopts:
	print "Usage: emerge [--pretend] pkg1.tbz2 [pkg2.tbz2]..."
	sys.exit(1)

if "--pretend" in myopts:
		print
		print "These are the packages that I would merge, in order."
		print

if "rsync" in mymode:
	if not os.path.exists("/usr/bin/rsync"):
		print "!!! /usr/bin/rsync does not exist, so rsync support is disabled."
		sys.exit(1)
	rclean=0
	myportdir=portage.settings["PORTDIR"]
	if myportdir[-1]=="/":
		myportdir=myportdir[:-1]
	if not os.path.exists(myportdir):
		print ">>>",myportdir,"not found, creating it."
		os.makedirs(myportdir,0755)	
	if len(sys.argv)>2:
		if sys.argv[2]=="clean":
			#we'll --delete files when we rsync
			rclean=1
	mycommand="/usr/bin/rsync -av --stats --progress "
	if rclean:
		mycommand=mycommand+"--delete --exclude='distfiles/*' --exclude='packages/*' "
	mycommand=mycommand+"rsync://cvs.gentoo.org/gentoo-x86-portage/* "+myportdir
	print ">>> starting rsync with cvs.gentoo.org..."
	sys.exit(os.system(mycommand))	

if ("system" in mymode) or ("update" in mymode):
	#system profile mode
	if not os.path.exists(portage.root+"etc/make.profile/packages"):
		print "!!!",portage.root+"etc/make.profile/packages does not exist.  \"system\" mode unavailable."
		sys.exit(1)
	myfile=open(portage.root+"etc/make.profile/packages","r")
	mylines=myfile.readlines()
	myfile.close()
	mydepgraph=depgraph(mymode,myopts)
	print "Calculating system dependencies",
	mydepgraph.syscreate(mylines)
	print " done!"
	if "--pretend" in myopts:
		mydepgraph.display(mydepgraph.altlist())
	else:
		mydepgraph.merge(mydepgraph.altlist())
	sys.exit(0)

mydepgraph=depgraph(mymode,myopts)
for mypkg in myfiles:
	if mypkg[-5:]==".tbz2":
		mytype="binary"
		mytbz2=xpak.tbz2(mypkg)
		mykey=mytbz2.getelements("CATEGORY")[0]+"/"+os.path.basename(mypkg)[:-5]
	elif mypkg[-7:]==".ebuild":
		mytype="ebuild"
		mykey=os.path.basename(os.path.abspath(mypkg+"/../.."))+"/"+os.path.basename(mypkg)[:-7]
	else:
		print "!!! Error:",x,"is neither an ebuild nor a .tbz2 package."
		sys.exit(1)
	print "Calculating dependencies",
	mydepgraph.create(mytype+" "+portage.root+" "+mykey)
	print " done!"
	if "--pretend" in myopts:
		mydepgraph.display(mydepgraph.altlist())
	else:
		mydepgraph.merge(mydepgraph.altlist())
