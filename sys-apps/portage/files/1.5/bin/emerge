#!/usr/bin/env python

import portage
import sys
import os
import xpak
import string
import commands

#build our package digraph

class depgraph:

	def __init__(self):
		virts=portage.getvirtuals("/")
		self.db={}
		self.db["/"]={"virtuals":virts,"vartree":portage.vartree("/",virts),"porttree":portage.portagetree("/",virts)}
		if portage.root!="/":
			pr=portage.root
			virts=portage.getvirtuals(pr)
			self.db[pr]={"virtuals":virts,"vartree":portage.vartree(pr,virts),"porttree":portage.portagetree(pr,virts)}
	
		self.digraph=portage.digraph()

	def create(self,mybigkey=None,myparent=None):
		sys.stdout.write(".")	
		sys.stdout.flush()
		if self.digraph.hasnode(mybigkey):
			#if we've already hit this node before, we're already recursing on the dependencies.
			#no need to recurse again.
			if myparent:
				self.digraph.addnode(mybigkey,myparent)
			return 1
		myroot,mykey=string.split(mybigkey)
		myebuild=self.db[myroot]["porttree"].getname(mykey)
		mydep={}
		edepend=portage.doebuild(myebuild,"depend")
		if portage.root=="/":
			mydep["/"]=edepend[0]+" "+edepend[1]
		else:
			mydep["/"],mydep[portage.root]=edepend
		self.digraph.addnode(mybigkey,myparent)
		for dep in mydep.keys():
			mycheck=self.db[dep]["vartree"].depcheck(mydep[dep])
			if mycheck[0]==0:
				print "!!! depgraph.create() error: string format:",mydep
				return 0
			for x in mycheck[1]:
				mymatch=self.db[dep]["porttree"].dep_bestmatch(x)
				if mymatch=="":
					print "!!! depgraph.create() error: can't resolve dependency:",x
					return 0
				mynew=dep+" "+mymatch
				if not self.digraph.hasnode(mynew):
					if not self.create(mynew,mybigkey):
						return 0
				else:
					self.digraph.addnode(mynew,mybigkey)
		return 1
	
	def altlist(self):
		mygraph=self.digraph.copy()
		dolist=["/"]
		retlist=[]
		for x in self.db.keys():
			self.db[x]["merge"]=[]
			if x not in dolist:
				dolist.append(x)
		while (not mygraph.empty()):
			mycurkey=mygraph.firstzero()
			if not mycurkey:
				print "!!! Error: circular dependencies"
				sys.exit(1)
			splitski=string.split(mycurkey)
			self.db[splitski[0]]["merge"].append(splitski[1])	
			mygraph.delnode(mycurkey)
		for x in dolist:
			for y in self.db[x]["merge"]:
				retlist.append([x,y])
		return retlist

	def list(self):
		mygraph=self.digraph.copy()
		retlist=[]
		while not mygraph.empty():
			mycurkey=mygraph.firstzero()
			if not mycurkey:
				print "!!! Error: circular dependencies"
				sys.exit(1)
			retlist.append(string.split(mycurkey))	
			mygraph.delnode(mycurkey)
		return retlist
	
	def syscreate(self,mylines):
		for x in mylines:
			myline=string.join(string.split(x))
			if not len(myline):
				continue
			if myline[0]=="#":
				continue
			mykey=self.db[portage.root]["porttree"].dep_bestmatch(myline)
			if not mykey:
				print "\n!!! Warning: couldn't find match for",myline,"\n"
				continue
			self.create(portage.root+" "+mykey)
			
	def display(self,mylist):
		for x in mylist:
			print x[1],"to",x[0]

	def merge(self,mylist):
		for x in mylist:
			os.environ["ROOT"]=x[0]
			print ">>> emerge",x[1],"to",x[0]
			#the last argument in the portage.doebuild() tells doebuild to *not* do dep checking
			#(emerge is already handling that)
			retval=portage.doebuild(self.db[x[0]]["porttree"].getname(x[1]),"merge",0)
			if retval:
				print "!!! emerge aborting."
				sys.exit(1)
			#dynamically update our database	
			self.db[x[0]]["vartree"].inject(x[1])

pretend=0
if len(sys.argv)>=2:
	if sys.argv[1]=="--pretend":
		print
		print "These are the packages that I would merge, in order."
		print
		pretend=1
		del sys.argv[1]
	elif sys.argv[1]=="--help":
		print "Usage: pkgmerge [--pretend] pkg1.tbz2 [pkg2.tbz2]..."
		sys.exit(1)
	if sys.argv[1]=="system":
		myfile=open(portage.root+"etc/make.profile/packages","r")
		mylines=myfile.readlines()
		myfile.close()
		mydepgraph=depgraph()
		print "Calculating system dependencies",
		mydepgraph.syscreate(mylines)
		if pretend:
			mydepgraph.display(mydepgraph.altlist())
		else:
			mydepgraph.merge(mydepgraph.altlist())
		sys.exit(0)

for mypkg in sys.argv[1:]:
	if len(mypkg)<=7:
		print ">>> Error: short ebuild name, skipping..."
		continue
	if mypkg[-7:]!=".ebuild":
		print ">>> Error: there is no ebuild extension on",mypkg+", skipping..."
		continue
		
	mykey=os.path.basename(os.path.abspath(mypkg+"/../.."))+"/"+os.path.basename(mypkg)[:-7]
	mydepgraph=depgraph()
	print "Calculating dependencies",
	mydepgraph.create(portage.root+" "+mykey)
	print " done!"
	if pretend:
		mydepgraph.display(mydepgraph.altlist())
	else:
		mydepgraph.merge(mydepgraph.altlist())
