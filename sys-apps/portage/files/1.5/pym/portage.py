# Gentoo Linux Dependency Checking Code
# Copyright 1998-2000 Daniel Robbins, Gentoo Technologies, Inc.
# Distributed under the GNU Public License
# Version 1.0 7/31/2000


import string,os
from commands import *
from stat import *
import fchksum,types
import sys
import shlex
import shutil
import xpak

# parsever:
# This function accepts an 'inter-period chunk' such as
# "3","4","3_beta5", or "2b" and returns an array of three
# integers. "3_beta5" returns [ 3, -2, 5 ]
# These values are used to determine which package is
# newer.

# master category list.  Any new categories should be added to this list to ensure that they all categories are read
# when we check the portage directory for available ebuilds.

categories=("app-admin", "app-arch", "app-cdr", "app-doc", "app-editors", "app-emulation", "app-games", "app-misc", 
			"app-office", "app-shells", "app-text", "dev-db", "dev-java", "dev-lang", "dev-libs", "dev-perl", 
			"dev-python", "dev-ruby", "dev-util", "gnome-apps", "gnome-base", "gnome-libs", 
			"gnome-office","kde-apps", "kde-base", "kde-libs", "media-gfx", "media-libs", "media-sound", "media-video", 
			"net-analyzer", "net-dialup", "net-fs", "net-ftp", "net-irc", "net-libs", "net-mail", "net-misc", "net-nds", 
			"net-print", "net-www", "packages", "sys-apps", "sys-devel", "sys-kernel", "sys-libs", "x11-base", "x11-libs", 
			"x11-terms", "x11-wm","virtual")

#parse /etc/env.d and generate /etc/profile.env

def env_update():
	global root
	fns=os.listdir(root+"etc/env.d")
	fns.sort()
	pos=0
	while (pos<len(fns)):
		if fns[pos]<=2:
			del fns[pos]
			continue
		if (fns[pos][0] not in string.digits) or (fns[pos][1] not in string.digits):
			del fns[pos]
			continue
		pos=pos+1

	specials={"PATH":[],"CLASSPATH":[],"LDPATH":[],"MANPATH":[],"INFODIR":[],"ROOTPATH":[]}
	env={}

	for x in fns:
		myconfig=configfile(root+"etc/env.d/"+x)
		# process PATH, CLASSPATH, LDPATH
		for myspec in specials.keys():
			if myconfig.has_key(myspec):
				if myspec=="LDPATH":
					specials[myspec].extend(string.split(myconfig.get_key(myspec),":"))
				else:
					specials[myspec].append(myconfig.get_key(myspec))
			myconfig.del_key(myspec)
		# process all other variables
		for myenv in myconfig.all_keys():
			env[myenv]=myconfig.get_key(myenv)
			
	if os.path.exists(root+"etc/ld.so.conf"):
		myld=open(root+"etc/ld.so.conf")
		myldlines=myld.readlines()
		myld.close()
		oldld=[]
		for x in myldlines:
			#each line has at least one char (a newline)
			if x[0]=="#":
				continue
			oldld.append(x[:-1])
		oldld.sort()
	#	os.rename(root+"etc/ld.so.conf",root+"etc/ld.so.conf.bak")
	# Where is the new ld.so.conf generated? (achim)
	else:
		oldld=None
	specials["LDPATH"].sort()
	if (oldld!=specials["LDPATH"]):
		#ld.so.conf needs updating and ldconfig needs to be run
		newld=open(root+"etc/ld.so.conf","w")
		newld.write("# ld.so.conf autogenerated by env-update; make all changes to\n")
		newld.write("# contents of /etc/env.d directory\n")
		for x in specials["LDPATH"]:
			newld.write(x+"\n")
		newld.close()
		#run ldconfig here
	print ">>> Regenerating "+root+"etc/ld.so.cache..."
	getstatusoutput("/sbin/ldconfig -r "+root)
	del specials["LDPATH"]

	outfile=open(root+"/etc/profile.env","w")

	for path in specials.keys():
		if len(specials[path])==0:
			continue
		outstring="export "+path+"='"
		for x in specials[path][:-1]:
			outstring=outstring+x+":"
		outstring=outstring+specials[path][-1]+"'"
		outfile.write(outstring+"\n")
		#get it out of the way
		del specials[path]
	
	#create /etc/profile.env
	for x in env.keys():
		if type(env[x])!=types.StringType:
			continue
		outfile.write("export "+x+"='"+env[x]+"'\n")
	outfile.close()
	
	#need to add cshrc support

#new configfile reading code using shlex
class configfile:
	def __init__(self,cfgfile):
		self.keys={}
		self.filename=cfgfile
		f=open(cfgfile,'r')
		lex=shlex.shlex(f)
		lex.wordchars=string.digits+string.letters+"~!@#$%*_\:;?,./-+{}"     
		lex.quotes="\"'"
		while 1:
			key=lex.get_token()
			if (key==''):
				#normal end of file
				break;
			equ=lex.get_token()
			if (equ==''):
				#unexpected end of file
				#lex.error_leader(self.filename,lex.lineno)
				print "!!! Unexpected end of config file: variable",key
				return None
			elif (equ!='='):
				#invalid token
				#lex.error_leader(self.filename,lex.lineno)
				print "!!! Invalid token (not \"=\")",equ
				return None
			val=lex.get_token()
			if (val==''):
				#unexpected end of file
				#lex.error_leader(self.filename,lex.lineno)
				print "!!! Unexpected end of config file: variable",key
				return None
			self.keys[key]=val
	def get_key(self,mykey):
		if self.keys.has_key(mykey):
			return self.keys[mykey]
		else:
			return ""
	def has_key(self,mykey):
		return self.keys.has_key(mykey)
	def set_key(self,mykey,myval):
		self.keys[mykey]=myval
	def del_key(self,mykey):
		if self.keys.has_key(mykey):
			del self.keys[mykey]
	def all_keys(self):
		return self.keys.keys()
		
def var_expand(mystring,dictlist=[]):
	"""
	new variable expansion code.  Removes quotes, handles \n, etc, and
	will soon use the dictlist to expand ${variable} references.
	This code will be used by the configfile code, as well as others (parser)
	This would be a good bunch of code to port to C.
	"""
	mystring=" "+mystring
	#in single, double quotes
	insing=0
	indoub=0
	pos=1
	newstring=""
	while (pos<len(mystring)):
		if (mystring[pos]=="'") and (mystring[pos-1]!="\\"):
			if (indoub):
				newstring=newstring+"'"
			else:
				insing=not insing
			pos=pos+1
			continue
		elif (mystring[pos]=='"') and (mystring[pos-1]!="\\"):
			if (insing):
				newstring=newstring+'"'
			else:
				indoub=not indoub
			pos=pos+1
			continue
		if (not insing): 
			#expansion time
			if (mystring[pos]=="\\"):
				#backslash expansion time
				if (pos+1>=len(mystring)):
					newstring=newstring+mystring[pos]
					break
				else:
					a=mystring[pos+1]
					pos=pos+2
					if a=='a':
						newstring=newstring+chr(007)
					elif a=='b':
						newstring=newstring+chr(010)
					elif a=='e':
						newstring=newstring+chr(033)
					elif (a=='f') or (a=='n'):
						newstring=newstring+chr(012)
					elif a=='r':
						newstring=newstring+chr(015)
					elif a=='t':
						newstring=newstring+chr(011)
					elif a=='v':
						newstring=newstring+chr(013)
					else:
						#remove backslash only, as bash does: this takes care of \\ and \' and \" as well
						newstring=newstring+mystring[pos-1:pos]
						continue
			else:
				newstring=newstring+mystring[pos]
				pos=pos+1
		else:
			newstring=newstring+mystring[pos]
			pos=pos+1
	return newstring	
	
def gen_archnames():
	"generate archive names from URL list"
	myurls=getenv("SRC_URI")
	a=string.split(myurls)
	returnme=""
	for x in a:
		returnme=returnme+" "+string.split(x,"/")[-1]
	print "A='"+returnme[1:]+"'"

def doebuild(myebuild,mydo):
	return os.system("/usr/sbin/ebuild "+myebuild+" "+mydo)

def isdev(x):
	mymode=os.stat(x)[ST_MODE]
	return ( S_ISCHR(mymode) or S_ISBLK(mymode))

def isfifo(x):
	mymode=os.stat(x)[ST_MODE]
	return S_ISFIFO(mymode)

def movefile(src,dest):
	"""moves a file from src to dest, preserving all permissions and attributes."""
	if dest=="/bin/cp":
		getstatusoutput("/bin/mv /bin/cp /bin/cp.old")
		a=getstatusoutput("/bin/cp.old -a "+"'"+src+"' /bin/cp")
		os.unlink("/bin/cp.old")
	elif dest=="/bin/bash":
		a=getstatusoutput("rm /bin/bash; /bin/cp -a "+"'"+src+"' '"+dest+"'")
	else:
		a=getstatusoutput("/bin/cp -af "+"'"+src+"' '"+dest+"'")	
#	cp -a takes care of this
#	mymode=os.lstat(src)[ST_MODE]
#	os.chmod(dest,mymode)
	os.unlink(src)
	if a[0]==0:
		return 1
	else:
		return 0

def getmtime(x):
	 return `os.lstat(x)[-2]`

def md5(x):
	return string.upper(fchksum.fmd5t(x)[0])

def pathstrip(x,mystart):
    cpref=os.path.commonprefix([x,mystart])
    return [root+x[len(cpref)+1:],x[len(cpref):]]

def merge(cat,pkg,mystart,myinfostart):
	mylink=dblink(cat,pkg)
	if not mylink.exists():
		mylink.create()
		#shell error code
	mylink.merge(mystart,myinfostart)

def unmerge(cat,pkg):
	mylink=dblink(cat,pkg)
	if mylink.exists():
		mylink.unmerge()
	dblink.delete()

def getenv(mykey):
	if os.environ.has_key(mykey):
		return os.environ[mykey]
	return ""

def getsetting(mykey,env=1,recdepth=0):
	"""perform bash-like basic variable expansion, recognizing ${foo} and $bar"""
	
	if recdepth>10:
		return ""
		#avoid infinite recursion
	
	configdefaults=getconfig("/etc/make.defaults")
	configsettings=getconfig("/etc/make.conf")
	
	if env:
		if os.environ.has_key(mykey):
			mystring=os.environ[mykey]
		elif configsettings.has_key(mykey):
			mystring=configsettings[mykey]
		elif configdefaults.has_key(mykey):
			mystring=configdefaults[mykey]
		else:
			return ""
	else:
		if configsettings.has_key(mykey):
			mystring=configsettings[mykey]
		elif configdefaults.has_key(mykey):
			mystring=configdefaults[mykey]
		else:
			return ""
		
	if (len(mystring)==0):
		return ""
	if mystring[0]=="'":
		#single-quoted, no expansion
		return mystring[1:-1]
	newstring=""
	pos=0
	while (pos<len(mystring)):
		if mystring[pos]=='\\':
			if (pos+1)>=len(mystring):
				#we're at the end of the string
				return "" #error
			a=mystring[pos+1]
			pos=pos+2
			if a=='a':
				newstring=newstring+chr(007)
			elif a=='b':
				newstring=newstring+chr(010)
			elif a=='e':
				newstring=newstring+chr(033)
			elif a=='f':
				newstring=newstring+chr(012)
			elif a=='r':
				newstring=newstring+chr(015)
			elif a=='t':
				newstring=newstring+chr(011)
			elif a=='v':
				newstring=newstring+chr(013)
			elif a=="'":
				newstring=newstring+"'"
			else:
				newstring=newstring+mystring[pos-1:pos]
		elif mystring[pos]=="$":
			#variable expansion
			if (pos+1)>=len(mystring):
				#we're at the end of the string, error
				return ""
			if mystring[pos+1]=="{":
				newpos=pos+1
				while newpos<len(mystring) and mystring[newpos]!="}":
					newpos=newpos+1
				if newpos>=len(mystring):
					return "" # ending } not found
				varname=mystring[pos+2:newpos]
				if len(varname)==0:
					return "" #zero-length variable, error
				newstring=newstring+getsetting(varname,env,recdepth+1)
				pos=newpos+1
			else:
				newpos=pos+1
				while newpos<len(mystring) and (mystring[newpos] not in string.whitespace):
					newpos=newpos+1
				if newpos>=len(mystring):
					varname=mystring[pos+1:]
				else:
					varname=mystring[pos+1:newpos]
				pos=newpos
				if len(varname)==0:
					return "" #zero-length variable, error
				newstring=newstring+getsetting(varname,env,recdepth+1)
				#recurse
		else:
			newstring=newstring+mystring[pos]
			pos=pos+1
	return newstring
				
def getconfig(mycfg):
	myconfigfile=open(mycfg,"r")
	myconfiglines=myconfigfile.readlines()
	myconfigfile.close()
	myconfigdict={}
	for x in myconfiglines:
		#strip whitespace
		x=string.strip(x)
		#skip comment or blank line
		if (len(x)==0):
			continue
		if (x[0]=="#"):
			continue
		myparts=string.split(x,"=")
		if myparts<2:
			continue
			#invalid line, no equals sign
		mykey=string.strip(myparts[0])
		myvalue=string.strip(string.join(myparts[1:],"="))
		if myvalue[0]=='"':
			if myvalue[-1]=='"':
				myvalue=myvalue[1:-1]
			else:
				continue
				#no closing double-quote!
		elif myvalue[0]=="'":
			if myvalue[-1]=="'":
				pass
			else:
				continue
				#no closing single-quote!
		if len(myvalue)>0:
			myconfigdict[mykey]=myvalue
	return myconfigdict

def relparse(myver):
	number=0
	p1=0
	p2=0
	mynewver=string.split(myver,"_")
	if len(mynewver)==2:
		#alpha,beta or pre
		number=string.atof(mynewver[0])
		if "beta" == mynewver[1][:4]:
			p1=-3
			try:
				p2=string.atof(mynewver[1][4:])
			except:
				p2=0
		elif "alpha" == mynewver[1][:5]:
			p1=-4
			try:
				p2=string.atof(mynewver[1][5:])
			except:
				p2=0
		elif "pre" ==mynewver[1][:3]:
			p1=-2
			try:
				p2=string.atof(mynewver[1][3:])
			except:
				p2=0
		elif "rc" ==mynewver[1][:2]:
			p1=-1
			try:
				p2=string.atof(mynewver[1][2:])
			except:
				p2=0

		elif "p" ==mynewver[1][:1]:
			try:
				p1=string.atoi(mynewver[1][1:])
			except:
				p1=0
	else:
		#normal number or number with letter at end
		divider=len(myver)-1
		if myver[divider:] not in "1234567890":
			#letter at end
			p1=ord(myver[divider:])
			number=string.atof(myver[0:divider])
		else:
			number=string.atof(myver)		
	return [number,p1,p2]


def revverify(myrev):
	if len(myrev)==0:
		return 0
	if myrev[0]=="r":
		try:
			string.atoi(myrev[1:])
			return 1
		except: 
			pass
	return 0

#returns 1 if valid version string, else 0
# valid string in format: <v1>.<v2>...<vx>[a-z,_{alpha,beta,pre}[vy]]
# ververify doesn't do package rev.

def ververify(myval):
	global ERRVER
	ERRVER=""
	myval=string.split(myval,'.')
	for x in myval[1:]:
		x="."+x
	for x in myval[:-1]:
		try:
			foo=string.atof(x)
		except:
			ERRVER=x+" is not a valid version component."
			return 0
	try:
		string.atof(myval[-1])
		return 1
	except:
		pass
	if myval[-1][-1] in "abcdefghijklmnopqrstuvwxyz":
		try:
			string.atof(myval[-1][:-1])
			# if we got here, it's something like .02a
			return 1
		except:
			pass
	splits=string.split(myval[-1],"_")
	if len(splits)!=2:
		#not a valid _alpha, _beta, _pre or _p, so fail
		ERRVER="Too many or too few \"_\" characters."
		return 0
	try:
		string.atof(splits[0])
	except:
		#something like .asldfkj_alpha1 which is invalid :)
		ERRVER=splits[0]+" is not a valid number."
		return 0
	valid=["alpha","beta","p","rc","pre"]
	for x in valid:
		if splits[1][0:len(x)]==x:
			firpart=x
			secpart=splits[1][len(x):]
			ok=1
	if not ok:
		ERRVER='Did not find an "alpha", "beta", "pre" or "p" after trailing "_"'
		return 0
	if len(secpart)==0:
		if firpart=="p":
			#patchlevel requires an int
			ERRVER='"p" (patchlevel) requires a trailing integer (i.e. "p3")'
			return 0	
		else:
			#alpha, beta and pre don't require an int
			return 1
	try:
		string.atoi(secpart)
		return 1
		#the int after the "alpha", "beta" or "pre" was ok
	except:
		ERRVER=secpart+" is not a valid integer."
		return 0
		#invalid number!

def isjustname(mypkg):
	myparts=string.split(mypkg,'-')
	for x in myparts:
		if ververify(x):
			return 0
	return 1

def isspecific(mypkg):
	mysplit=string.split(mypkg,"/")
	if len(mysplit)==2:
		if not isjustname(mysplit[1]):
			return 1
	return 0
	
# This function can be used as a package verification function, i.e.
# "pkgsplit("foo-1.2-1") will return None if foo-1.2-1 isn't a valid
# package (with version) name.  If it is a valid name, pkgsplit will
# return a list containing: [ pkgname, pkgversion(norev), pkgrev ].
# For foo-1.2-1, this list would be [ "foo", "1.2", "1" ].  For 
# Mesa-3.0, this list would be [ "Mesa", "3.0", "0" ].

def pkgsplit(mypkg):
	myparts=string.split(mypkg,'-')
	if len(myparts)<2:
		return None
	if revverify(myparts[-1]):
		if ververify(myparts[-2]):
			if len(myparts)==2:
				return None
			else:
				for x in myparts[:-2]:
					if ververify(x):
						return None
						#names can't have versiony looking parts
				return [string.join(myparts[:-2],"-"),myparts[-2],myparts[-1]]
		else:
			return None

	elif ververify(myparts[-1]):
		if len(myparts)==1:
			return None
		else:
			for x in myparts[:-1]:
				if ververify(x):
					return None
			return [string.join(myparts[:-1],"-"),myparts[-1],"r0"]
	else:
		return None

def catpkgsplit(mycatpkg):
	"""returns [cat, pkgname, version, rev ]"""
	mysplit=string.split(mycatpkg,"/")
	if len(mysplit)!=2:
		return None
	mysplit2=pkgsplit(mysplit[1])
	if mysplit2==None:
		return None
	return [mysplit[0],mysplit2[0],mysplit2[1],mysplit2[2]]

# vercmp:
# This takes two version strings and returns an integer to tell you whether
# the versions are the same, val1>val2 or val2>val1.

def vercmp(val1,val2):
	val1=string.split(val1,'-')
	if len(val1)==2:
		val1[0]=val1[0]+"."+val1[1]
	val1=string.split(val1[0],'.')
	#add back decimal point so that .03 does not become "3" !
	for x in val1[1:]:
		x="."+x
	val2=string.split(val2,'-')
	if len(val2)==2:
		val2[0]=val2[0]+"."+val2[1]
	val2=string.split(val2[0],'.')
	for x in val2[1:]:
		x="."+x
	if len(val2)<len(val1):
		for x in range(0,len(val1)-len(val2)):
			val2.append("0")
	elif len(val1)<len(val2):
		for x in range(0,len(val2)-len(val1)):
			val1.append("0")
	#The above code will extend version numbers out so they
	#have the same number of digits.
	myval1=[]
	for x in range(0,len(val1)):
		cmp1=relparse(val1[x])
		cmp2=relparse(val2[x])
		for y in range(0,3):
			myret=cmp1[y]-cmp2[y]
			if myret != 0:
				return myret
	return 0


def pkgcmp(pkg1,pkg2):
	"""if returnval is less than zero, then pkg2 is newer than pkg2, zero if equal and positive if older."""
	mycmp=vercmp(pkg1[1],pkg2[1])
	if mycmp>0:
		return 1
	if mycmp<0:
		return -1
	r1=string.atoi(pkg1[2][1:])
	r2=string.atoi(pkg2[2][1:])
	if r1>r2:
		return 1
	if r2>r1:
		return -1
	return 0

def getgeneral(mycatpkg):
	"""Takes a specific catpkg and returns the general version.  getgeneral("foo/bar-1.0") returns "foo/bar"""
	mysplit=catpkgsplit(mycatpkg)
	if not mysplit:
		return None
	else:
		return string.join([mysplit[0],mysplit[1]],"/")

def dep_parenreduce(mysplit,mypos=0):
	"Accepts a list of strings, and converts '(' and ')' surrounded items to sub-lists"
	while (mypos<len(mysplit)): 
		if (mysplit[mypos]=="("):
			firstpos=mypos
			mypos=mypos+1
			while (mypos<len(mysplit)):
				if mysplit[mypos]==")":
					mysplit[firstpos:mypos+1]=[mysplit[firstpos+1:mypos]]
					mypos=firstpos
					break
				elif mysplit[mypos]=="(":
					#recurse
					mysplit=dep_parenreduce(mysplit,mypos)
				mypos=mypos+1
		mypos=mypos+1
	return mysplit

def dep_opconvert(mysplit,myuse):
	"Does dependency operator conversion, such as moving '||' inside a sub-list, etc."
	mypos=0
	while mypos<len(mysplit):
		if type(mysplit[mypos])==types.ListType:
			mysplit[mypos]=dep_opconvert(mysplit[mypos],myuse)
		elif mysplit[mypos]==")":
			#mismatched paren, error
			return None
		elif mysplit[mypos]=="||":
			if (mypos+1)<len(mysplit):
				if type(mysplit[mypos+1])!=types.ListType:
					# || must be followed by paren'd list
					return None
				else:
					mynew=dep_opconvert(mysplit[mypos+1],myuse)
					mysplit[mypos+1]=mynew
					mysplit[mypos+1][0:0]=["||"]
					del mysplit[mypos]
			else:
				#don't end a depstring with || :)
				return None
		elif mysplit[mypos][-1]=="?":
			#uses clause, i.e "gnome? ( foo bar )"
			if (mysplit[mypos][:-1]) in myuse:
				#if the package is installed, just delete the conditional
				del mysplit[mypos]
			else:
				#the package isn't installed, delete conditional and next item
				del mysplit[mypos]
				del mysplit[mypos]
				#we don't want to move to the next item, so we perform a quick hack
				mypos=mypos-1
		mypos=mypos+1
	return mysplit

def dep_wordreduce(mydeplist):
	"""Calls dep_depreduce() on all the items in the deplist"""
	mypos=0
	deplist=mydeplist[:]
	while mypos<len(deplist):
		if type(deplist[mypos])==types.ListType:
			#recurse
			deplist[mypos]=dep_wordreduce(deplist[mypos])
		else:
			if deplist[mypos]=="||":
				pass
			else:
				mydep=dep_depreduce(deplist[mypos])
				if mydep!=None:
					deplist[mypos]=mydep
				else:
					#encountered invalid string
					return None
		mypos=mypos+1
	return deplist

def dep_eval(deplist):
	if len(deplist)==0:
		return 1
	if deplist[0]=="||":
		#or list; we just need one "1"
		for x in deplist[1:]:
			if type(x)==types.ListType:
				if dep_eval(x)==1:
					return 1
			elif x==1:
				return 1
		return 0
	else:
		for x in deplist:
			if type(x)==types.ListType:
				if dep_eval(x)==0:
					return 0
			elif x==0:
				return 0
		return 1

def dep_catpkgstring(mypkgdep):
	if mypkgdep[0]=="!":
		if not pkgsplit(mypkgdep[1:]):
			return "(invalid dependency)"
		else:
			return "unmerge "+mypkgdep[1:]
	elif mypkgdep[0]=="=":
		if not pkgsplit(mypkgdep[1:]):
			return "(invalid dependency)"
		else:
			return "merge "+mypkgdep[1:]
	elif mypkgdep[0:2]==">=":
		if not pkgsplit(mypkgdep[2:]):
			return "(invalid dependency)"
		else:
			return "merge "+mypkgdep[2:]+" or newer"
	elif mypkgdep[0:2]=="<=":
		if not pkgsplit(mypkgdep[2:]):
			return "(invalid dependency)"
		else:
			return "merge "+mypkgdep[2:]+" or older"
	elif mypkgdep[0]=="<":
		mysplit=catpkgsplit(mypkgdep[1:])
		if mysplit==None:
			return "(invalid dependency)"
		else:
			myret="merge "+string.join([mysplit[0],mysplit[1]],"/")+" older than version"
			if mysplit[3]=="r0":
				return myret+" "+mysplit[2]
			else:
				return myret+" "+mysplit[2]+"-"+mysplit[3]
	elif mypkgdep[0]==">":
		mysplit=catpkgsplit(mypkgdep[1:])
		if mysplit==None:
			return "(invalid dependency)"
		else:
			myret="merge "+string.join([mysplit[0],mysplit[1]],"/")+" newer than version"
			if mysplit[3]=="r0":
				return myret+" "+mysplit[2]
			else:
				return myret+" "+mysplit[2]+"-"+mysplit[3]
	elif not isspecific(mypkgdep):
		mysplit=string.split(mypkgdep,"/")
		if len(mysplit)!=2:
			return "(invalid dependency)"
		else:
			return "merge any version of "+mypkgdep
	else:
		return "(invalid dependency)"

def dep_print(deplist,mylevel=0):
	"Prints out a deplist in a human-understandable format"
	if (deplist==None) or (len(deplist)==0):
		return
	if deplist[0]=="||":
		for x in deplist[1:]:
			if type(x)==types.ListType:
				dep_print(x,mylevel+1)
			else:
				print "  "*(mylevel)+"|| "+dep_catpkgstring(x)
	else:
		for x in deplist:
			if type(x)==types.ListType:
				dep_print(x,mylevel+1)
			else:
				print "  "*(mylevel)+"&& "+dep_catpkgstring(x)



"""
This is an early (semi-working) attempt at recursive ebuilding.  Commented out as
we're getting ready for production use.

def dep_print_resolve(deplist):
	"Prints out list of things to do"
	if (deplist==None) or (len(deplist)==0):
		return
	if deplist[0]=="||":
		for x in deplist[1:]:
			if type(x)==types.ListType:
				dep_print(x)
			else:
				print "|| "+dep_catpkgstring(x)+' ('+porttree.dep_bestmatch(x)+')'
		return
	else:
		for x in deplist:
			if type(x)==types.ListType:
				dep_print_resolve(x)
			else:
				mymatch=porttree.dep_bestmatch(x)
				if mymatch=="":
					print "!! "+dep_catpkgstring(x)
					return
				else:
					print "Best match is",mymatch
					mysplit=catpkgsplit(mymatch)
					myebuild=getsetting("PORTDIR")+"/"+mysplit[0]+"/"+mysplit[1]+"/"+string.split(mymatch,"/")[1]+".ebuild"
					print "ebuild file is",myebuild
					result=doebuild(myebuild,"merge")
					if result:
						#error
						print "STOPPING deep merge!"
						sys.exit(1)
		myebuild=getsetting("PORTDIR")+"/"+getsetting("CATEGORY")+"/"+getsetting("PN")+"/"+getsetting("PF")+".ebuild"
		result=doebuild(myebuild,"merge")
		return result
"""

def dep_zapdeps(unreduced,reduced):
	"""Takes an unreduced and reduced deplist and removes satisfied dependencies.
	Returned deplist contains steps that must be taken to satisfy dependencies."""
	if unreduced[0]=="||":
		if dep_eval(reduced):
			#deps satisfied, return None
			return None
		else:
			return unreduced
	else:
		if dep_eval(reduced):
			#deps satisfied, return None
			return None
		else:
			returnme=[]
			x=0
			while x<len(reduced):
				if type(reduced[x])==types.ListType:
					myresult=dep_zapdeps(unreduced[x],reduced[x])
					if myresult:
						returnme.append(myresult)
				else:
					if reduced[x]==0:
						returnme.append(unreduced[x])
				x=x+1
			return returnme

def dep_listcleanup(deplist):
	"remove unnecessary clutter from deplists.  Remove multiple list levels, empty lists"
	newlist=[]
	if (len(deplist)==1):
		#remove multiple-depth lists
		if (type(deplist[0])==types.ListType):
			for x in deplist[0]:
				if type(x)==types.ListType:
					if len(x)!=0:
						newlist.append(dep_listcleanup(x))
				else:
					newlist.append(x)
		else:
			#unembed single nodes
			newlist.append(deplist[0])
	else:
		for x in deplist:
			if type(x)==types.ListType:
				if len(x)==1:
					newlist.append(x[0])
				elif len(x)!=0:
					newlist.append(dep_listcleanup(x))
			else:
				newlist.append(x)
	return newlist
	
def dep_frontend(mytype,depstring):
	"""ebuild frontend for dependency system"""
	global ebuild_intialized
	if ebuild_initialized==0:
		ebuild_init()
	if depstring=="":
		print ">>> No",mytype,"dependencies."
		return 0
	if mytype=="build":
		myparse=localtree.depcheck(depstring)
	elif mytype=="runtime":
		myparse=roottree.depcheck(depstring)
	else:
		print "!!! Error: dependency type",mytype,"not recognized.  Exiting."
		sys.exit(1)
	if myparse[0]==0:
		#error
		print '!!! '+mytype+' dependency error:',myparse[1]
		return 1
	elif myparse[1]==[]:
		print '>>> '+mytype+' dependencies OK ;)'
		return 0
	else:
		print '!!! Some '+mytype+' dependencies must be satisfied:'
		print
		print myparse[1]
		dep_print(myparse[1])
		print
#		This is the semi-working auto-ebuild stuff, disabled for now
#		dep_print_resolve(myparse[1])		
	return 1

def port_porttree():
	"""
	This function builds a dictionary of available ebuilds in the portage tree.
	Dictionary format is:
	mydict["cat/pkg"]=[
					["cat/fullpkgname",["cat","pkg","ver","rev"]
					["cat/fullpkgname",["cat","pkg","ver2","rev2"]
					]
	"""
	portagedict={}
	mydir=getsetting("PORTDIR")
	if not os.path.isdir(mydir):
		return
	origdir=os.getcwd()
	os.chdir(mydir)
	for x in categories:
		if not os.path.isdir(os.getcwd()+"/"+x):
			continue
		for y in os.listdir(os.getcwd()+"/"+x):
			if not os.path.isdir(os.getcwd()+"/"+x+"/"+y):
				continue
			if y=="CVS":
				continue
			for mypkg in os.listdir(os.getcwd()+"/"+x+"/"+y):
				if mypkg[-7:] != ".ebuild":
					continue
				mypkg=mypkg[:-7]
				mykey=x+"/"+y
				fullpkg=x+"/"+mypkg
				if not portagedict.has_key(mykey):
					portagedict[mykey]=[]
				portagedict[mykey].append([fullpkg,catpkgsplit(fullpkg)])
	os.chdir(origdir)
	return portagedict

class packagetree:
	def __init__(self):
		self.tree={}
		self.populated=0
	def populate(self):
		"populates the tree with values"
		populated=1
		pass
	def exists_specific(self,catpkg):
		if not self.populated:
			self.populate()
		"this function tells you whether or not a specific package is installed"
		cpsplit=catpkgsplit(catpkg)
		if cpsplit==None:
			return None 
		if not self.tree.has_key(cpsplit[0]+"/"+cpsplit[1]):
			return 0
		for x in self.tree[cpsplit[0]+"/"+cpsplit[1]]:
			if x[0]==catpkg:
				return 1
		return 0
	def exists_node(self,nodename):
		if not self.populated:
			self.populate()
		if self.tree.has_key(nodename):
			return 1
		return 0
	def getnodes(self,nodename):
		if not self.populated:
			self.populate()
		if self.tree.has_key(nodename):
			return self.tree[nodename]
		return []
	def depcheck(self,depstring):
		"""evaluates a dependency string and returns a 2-node result list
		[1, None] = ok, no dependencies
		[1, ["x11-base/foobar","sys-apps/oni"] = dependencies must be satisfied
		[0, * ] = parse error
		"""
		if not self.populated:
			self.populate()
		myusesplit=string.split(getsetting("USE"))
		mysplit=string.split(depstring)
		#convert parenthesis to sublists
		mysplit=dep_parenreduce(mysplit)
		#mysplit can't be None here, so we don't need to check
		mysplit=dep_opconvert(mysplit,myusesplit)
		#if mysplit==None, then we have a parse error (paren mismatch or misplaced ||)
		#up until here, we haven't needed to look at the database tree
		
		if mysplit==None:
			return [0,"Parse Error (parenthesis mismatch or || abuse?)"]
		elif mysplit==[]:
			#dependencies were reduced to nothing
			return [1,[]]
		mysplit2=mysplit[:]
		mysplit2=self.dep_wordreduce(mysplit2)
		if mysplit2==None:
			return [0,"Invalid token"]
		myeval=dep_eval(mysplit2)
		if myeval:
			return [1,[]]
		else:
			return [1,dep_listcleanup(dep_zapdeps(mysplit,mysplit2))]
	def dep_wordreduce(self,mydeplist):
		"""Calls dep_depreduce() on all the items in the deplist"""
		mypos=0
		deplist=mydeplist[:]
		while mypos<len(deplist):
			if type(deplist[mypos])==types.ListType:
				#recurse
				deplist[mypos]=self.dep_wordreduce(deplist[mypos])
			else:
				if deplist[mypos]=="||":
					pass
				else:
					mydep=self.dep_depreduce(deplist[mypos])
					if mydep!=None:
						deplist[mypos]=mydep
					else:
						#encountered invalid string
						return None
			mypos=mypos+1
		return deplist
	def dep_depreduce(self,mypkgdep):
		if mypkgdep[0]=="!":
			# !cat/pkg-v
			if self.exists_specific(mypkgdep[1:]):
				return 0
			else:
				return 1
		elif mypkgdep[0]=="=":
			# =cat/pkg-v
			return self.exists_specific(mypkgdep[1:])
		elif (mypkgdep[0]=="<") or (mypkgdep[0]==">"):
			# >=cat/pkg-v or <=,>,<
			if mypkgdep[1]=="=":
					cmpstr=mypkgdep[0:2]
					cpv=mypkgdep[2:]
			else:
					cmpstr=mypkgdep[0]
					cpv=mypkgdep[1:]
			if not isspecific(cpv):
				return None
			if self.exists_node(getgeneral(cpv)):
				mycatpkg=catpkgsplit(cpv)
				mykey=mycatpkg[0]+"/"+mycatpkg[1]
				if not self.exists_node(mykey):
					return 0
				for x in self.getnodes(mykey):
					if eval("pkgcmp(x[1][1:],mycatpkg[1:])"+cmpstr+"0"):
						return 1
			return 0
		if not isspecific(mypkgdep):
			# cat/pkg 
			if self.exists_node(mypkgdep):
				return 1
			else:
				return 0
		else:
			return None
	def dep_bestmatch(self,mypkgdep):
		"""
		returns best match for mypkgdep in the tree.  Accepts
		a single depstring, such as ">foo/bar-1.0" and finds
		the most recent version of foo/bar that satisfies the
		dependency and returns it, i.e: "foo/bar-1.3".  Works
		for >,<,>=,<=,=,and general deps.  Don't call with a !
		dep, since there is no good match for a ! dep.
		"""
		if (mypkgdep[0]=="="):
			if self.exists_specific(mypkgdep[1:]):
				return mypkgdep[1:]
			else:
				return ""
		elif (mypkgdep[0]==">") or (mypkgdep[0]=="<"):
			if mypkgdep[1]=="=":
				cmpstr=mypkgdep[0:2]
				cpv=mypkgdep[2:]
			else:
				cmpstr=mypkgdep[0]
				cpv=mypkgdep[1:]
			if not isspecific(cpv):
				return ""
			mycatpkg=catpkgsplit(cpv)
			mykey=mycatpkg[0]+"/"+mycatpkg[1]
			if not self.exists_node(mykey):
				return ""
			mynodes=[]
			for x in self.getnodes(mykey):
				if eval("pkgcmp(x[1][1:],mycatpkg[1:])"+cmpstr+"0"):
					mynodes.append(x)
			#now we have a list of all nodes that qualify
			if len(mynodes)==0:
				return ""
			bestmatch=mynodes[0]
			for x in mynodes[1:]:
				if pkgcmp(x[1][1:],bestmatch[1][1:])>0:
					bestmatch=x
			return bestmatch[0]		
		elif not isspecific(mypkgdep):
			if not self.exists_node(mypkgdep):
				return ""
			mynodes=self.getnodes(mypkgdep)[:]
			if len(mynodes)==0:
				return ""
			bestmatch=mynodes[0]
			for x in mynodes[1:]:
				if pkgcmp(x[1][1:],bestmatch[1][1:])>0:
					bestmatch=x
			return bestmatch[0]
	def dep_match(self,mypkgdep):
		"""
		returns a list of all matches for mypkgdep in the tree.  Accepts
		a single depstring, such as ">foo/bar-1.0" and finds
		all the versions of foo/bar that satisfy the
		dependency and returns them, i.e: ["foo/bar-1.3"].  Works
		for >,<,>=,<=,=,and general deps.  Don't call with a !
		dep, since there is no good match for a ! dep.
		"""
		if (mypkgdep[0]=="="):
			if self.exists_specific(mypkgdep[1:]):
				return [mypkgdep[1:]]
			else:
				return []
		elif (mypkgdep[0]==">") or (mypkgdep[0]=="<"):
			if mypkgdep[1]=="=":
				cmpstr=mypkgdep[0:2]
				cpv=mypkgdep[2:]
			else:
				cmpstr=mypkgdep[0]
				cpv=mypkgdep[1:]
			if not isspecific(cpv):
				return []
			mycatpkg=catpkgsplit(cpv)
			mykey=mycatpkg[0]+"/"+mycatpkg[1]
			if not self.exists_node(mykey):
				return []
			mynodes=[]
			for x in self.getnodes(mykey):
				if eval("pkgcmp(x[1][1:],mycatpkg[1:])"+cmpstr+"0"):
					mynodes.append(x)
			#now we have a list of all nodes that qualify
			#since we want all nodes that match, return this list
			return mynodes
		elif not isspecific(mypkgdep):
			if not self.exists_node(mypkgdep):
				return [] 
			return self.getnodes(mypkgdep)[:]
			
class vartree(packagetree):
	"this tree will scan a var/db/pkg database located at root (passed to init)"
	def __init__(self,root):
		self.root=root
		packagetree.__init__(self)
	def populate(self):
		"populates the local tree (/var/db/pkg)"
		if not os.path.isdir(self.root+"var"):
			os.mkdir(self.root+"var",0755)
		if not os.path.isdir(self.root+"var/db"):
			os.mkdir(self.root+"var/db",0755)
		if not os.path.isdir(self.root+"var/db/pkg"):
			os.mkdir(self.root+"var/db/pkg",0755)
		dbdir=self.root+"var/db/pkg"
		origdir=os.getcwd()
		os.chdir(dbdir)
		for x in os.listdir(os.getcwd()):
			if not os.path.isdir(os.getcwd()+"/"+x):
				continue
			for y in os.listdir(os.getcwd()+"/"+x):
				if x=="virtual":
					#virtual packages don't require versions, if none is found, add a "1.0" to the end
					if isjustname(y):
						fullpkg=x+"/"+y+"-1.0"
					else:
						fullpkg=x+"/"+y
				else:
					fullpkg=x+"/"+y
				mysplit=catpkgsplit(fullpkg)
				mykey=x+"/"+mysplit[1]
				if not self.tree.has_key(mykey):
					self.tree[mykey]=[]
				self.tree[mykey].append([fullpkg,mysplit])
		os.chdir(origdir)
		self.populated=1

class portagetree(packagetree):
	"this tree will scan a portage directory located at root (passed to init)"
	def __init__(self,root):
		self.root=root
		packagetree.__init__(self)
	def populate(self):
		"populates the port tree"
		origdir=os.getcwd()
		os.chdir(self.root)
		for x in categories:
			if not os.path.isdir(os.getcwd()+"/"+x):
				continue
			for y in os.listdir(os.getcwd()+"/"+x):
				if not os.path.isdir(os.getcwd()+"/"+x+"/"+y):
					continue
				if y=="CVS":
					continue
				for mypkg in os.listdir(os.getcwd()+"/"+x+"/"+y):
					if mypkg[-7:] != ".ebuild":
						continue
					mypkg=mypkg[:-7]
					mykey=x+"/"+y
					fullpkg=x+"/"+mypkg
					if not self.tree.has_key(mykey):
						self.tree[mykey]=[]
					self.tree[mykey].append([fullpkg,catpkgsplit(fullpkg)])
		os.chdir(origdir)
		self.populated=1
	def getdeps(self,pf):
		"returns list of dependencies, if any"
		if not self.populated:
			self.populate()
		if self.exists_specific(pf):
			mysplit=catpkgsplit(pf)
			mydepfile=self.root+"/"+mysplit[0]+"/"+mysplit[1]+"/files/depend-"+string.split(pf,"/")[1]
			if os.path.exists(mydepfile):
				myd=open(mydepfile,"r")
				mydeps=myd.readlines()
				myd.close()
				returnme=""
				for x in mydeps:
					returnme=returnme+" "+x[:-1]
				return returnme
		return ""

class currenttree(packagetree):
	"this tree will scan a current package file located at root (passed to init)"
	def __init__(self,root):
		self.root=root
		packagetree.__init__(self)
	def populate(self):
		"populates the current tree"
		mycurrent=open(self.root,"r")
		mylines=mycurrent.readlines()
		for x in mylines:
			if x[:2]!="./":
				continue
			myline=string.split(string.strip(x)[2:-7],"/")
			if len(myline)!=3:
				continue
			fullpkg=string.join([myline[0],myline[2]],"/")
			mysplit=catpkgsplit(fullpkg)
			mykey=mysplit[0]+"/"+mysplit[1]
			if not self.tree.has_key(mykey):
				self.tree[mykey]=[]
			self.tree[mykey].append([fullpkg,mysplit])
		mycurrent.close()
		self.populated=1

class binarytree(packagetree):
	"this tree scans for a list of all packages available in PKGDIR"
	def __init__(self):
		self.root=getsetting("PKGDIR")
		packagetree.__init__(self)
	def populate(self):
		"popules the binarytree"
		if (not os.path.isdir(self.root)):
			return 0
		for mypkg in os.listdir(self.root+"/All"):
			if mypkg[-5:]!=".tbz2":
				continue
			mytbz2=xpak.tbz2(self.root+"/All/"+mypkg)
			mycat=mytbz2.getfile("CATEGORY")
			if not mycat:
				#old-style or corrupt package
				continue
			mycat=string.strip(mycat)
			fullpkg=mycat+"/"+mypkg[:-5]
			cps=catpkgsplit(fullpkg)
			mykey=mycat+"/"+cps[1]
			if not self.tree.has_key(mykey):
				self.tree[mykey]=[]
			self.tree[mykey].append([fullpkg,cps])
		self.populated=1
	def getname(self,pkgname):
		"returns file location for this particular package"
		mysplit=string.split(pkgname,"/")
		if len(mysplit)==1:
			return self.root+"/All/"+pkgname+".tbz2"
		else:
			return self.root+"/All/"+mysplit[1]+".tbz2"

class dblink:
	"this class provides an interface to the standard text package database"
	def __init__(self,cat,pkg):
		"create a dblink object for cat/pkg.  This dblink entry may or may not exist"
		self.cat=cat
		self.pkg=pkg
		self.dbdir=root+"/var/db/pkg/"+cat+"/"+pkg
	def getpath(self):
		"return path to location of db information (for >>> informational display)"
		return self.dbdir
	def exists(self):
		"does the db entry exist?  boolean."
		return os.path.exists(self.dbdir)
	def create(self):
		"create the skeleton db directory structure.  No contents, virtuals, provides or anything.  Also will create /var/db/pkg if necessary."
		if not os.path.exists(self.dbdir):
			os.makedirs(self.dbdir)
	def delete(self):
		"erase this db entry completely"
		if not os.path.exists(self.dbdir):
			return
		for x in os.listdir(self.dbdir):
			os.unlink(self.dbdir+"/"+x)
		os.rmdir(self.dbdir)
	def clearcontents(self):
		if os.path.exists(self.dbdir+"/CONTENTS"):
			os.unlink(self.dbdir+"/CONTENTS")
	def getcontents(self):
		if not os.path.exists(self.dbdir+"/CONTENTS"):
			return None
		pkgfiles={}
		myc=open(self.dbdir+"/CONTENTS","r")
		mylines=myc.readlines()
		myc.close()
		for line in mylines:
			mydat=string.split(line)
			# we do this so we can remove from non-root filesystems
			# (use the ROOT var to allow maintenance on other partitions)
			mydat[1]=os.path.normpath(root+mydat[1][1:])
			if mydat[0]=="obj":
				#format: type, mtime, md5sum
				pkgfiles[string.join(mydat[1:-2]," ")]=[mydat[0], mydat[-1], mydat[-2]]
			elif mydat[0]=="dir":
				#format: type
				pkgfiles[string.join(mydat[1:])]=[mydat[0] ]
			elif mydat[0]=="sym":
				#format: type, mtime, dest
				x=len(mydat)-1
				splitter=-1
				while(x>=0):
					if mydat[x]=="->":
						splitter=x
						break
					x=x-1
				if splitter==-1:
					return None
				pkgfiles[string.join(mydat[1:splitter]," ")]=[mydat[0], mydat[-1], string.join(mydat[(splitter+1):-1]," ")]
			elif mydat[0]=="dev":
				#format: type
				pkgfiles[string.join(mydat[1:]," ")]=[mydat[0] ]
			elif mydat[0]=="fif":
				#format: type
				pkgfiles[string.join(mydat[1:]," ")]=[mydat[0]]
			else:
				return None
		return pkgfiles
	
	def unmerge(self,pkgfiles=None):
		if not pkgfiles:
			pkgfiles=self.getcontents()
			if not pkgfiles:
				return
		
		myebuildfile=os.path.normpath(self.dbdir+"/"+self.pkg+".ebuild")
		if os.path.exists(myebuildfile):
			if pkgfiles.has_key(myebuildfile):
				del pkgfiles[myebuildfile]
				
		mykeys=pkgfiles.keys()
		mykeys.sort()
		mykeys.reverse()
		
		#do prerm script
		doebuild(self.dbdir+"/"+self.pkg+".ebuild","prerm")
		
		for obj in mykeys:
			obj=os.path.normpath(obj)
			if not os.path.islink(obj):
				#we skip this if we're dealing with a symlink
				#because os.path.exists() will operate on the
				#link target rather than the link itself.
				if not os.path.exists(obj):
					print "--- !found", pkgfiles[obj][0], obj
					continue
			if (pkgfiles[obj][0] not in ("dir","fif","dev")) and (getmtime(obj) != pkgfiles[obj][1]):
				print "--- !mtime", pkgfiles[obj][0], obj
				continue
			if pkgfiles[obj][0]=="dir":
				if not os.path.isdir(obj):
					print "--- !dir  ","dir", obj
					continue
				if os.listdir(obj):
					print "--- !empty","dir", obj
					continue
				os.rmdir(obj)
				print "<<<       ","dir",obj
			elif pkgfiles[obj][0]=="sym":
				if not os.path.islink(obj):
					print "--- !sym  ","sym", obj
					continue
				mydest=os.readlink(obj)
				if os.path.exists(os.path.normpath(root+mydest)):
					if mydest != pkgfiles[obj][2]:
						print "--- !destn","sym", obj
						continue
				os.unlink(obj)
				print "<<<       ","sym",obj
			elif pkgfiles[obj][0]=="obj":
				if not os.path.isfile(obj):
					print "--- !obj  ","obj", obj
					continue
				mymd5=md5(obj)
				if mymd5 != string.upper(pkgfiles[obj][2]):
					print "--- !md5  ","obj", obj
					continue
				os.unlink(obj)
				print "<<<       ","obj",obj
			elif pkgfiles[obj][0]=="fif":
				if not isfifo(obj):
					print "--- !fif  ","fif", obj
					continue
				os.unlink(obj)
				print "<<<       ","fif",obj
			elif pkgfiles[obj][0]=="dev":
				if not isdev(obj):
					print "--- !dev  ","dev", obj
					continue
				os.unlink(obj)
				print "<<<       ","dev",obj

		#do original postrm
		doebuild(self.dbdir+"/"+self.pkg+".ebuild","postrm")
	
	def merge(self,mergeroot,inforoot,mergestart=None,outfile=None):
		
		if mergestart==None:
			origdir=os.getcwd()
			if not os.path.exists(self.dbdir):
				self.create()
				#open contents file if it isn't already open
			mergestart=mergeroot
			print 
			print ">>> Merging",self.cat+"/"+self.pkg,"to",root
			if not os.path.exists(root):
				print "!!! Error: ROOT setting points to a non-existent directory.  Exiting."
				return
			elif not os.path.isdir(root):
				print "!!! Error: ROOT setting points to a non-directory.  Exiting."
				return
		
			#get old contents info for later unmerging
			oldcontents=self.getcontents()
			doebuild(inforoot+"/"+self.pkg+".ebuild","preinst")
			outfile=open(self.dbdir+"/CONTENTS","w")
			
		mergestart=mergestart
		os.chdir(mergestart)
		cpref=os.path.commonprefix([mergeroot,mergestart])
		relstart=mergestart[len(cpref):]
		myfiles=os.listdir(mergestart)
		
		for x in myfiles:
			relfile=relstart+"/"+x
			rootfile=os.path.normpath(root+relfile)
			#symbolic link
			if os.path.islink(x):
				myto=os.readlink(x)
				if os.path.exists(rootfile):
					if (not os.path.islink(rootfile)) and (os.path.isdir(rootfile)):
						print "!!!",rootfile,"->",myto
					else:
						os.unlink(rootfile)
				try:
					os.symlink(myto,rootfile)
					print "<<<",rootfile,"->",myto
					outfile.write("sym "+relfile+" -> "+myto+" "+getmtime(rootfile)+"\n")
				except:
					print "!!!",rootfile,"->",myto
			#directory
			elif os.path.isdir(x):
				mystat=os.stat(x)
				if not os.path.exists(rootfile):
					os.mkdir(rootfile)
					os.chmod(rootfile,mystat[0])
					os.chown(rootfile,mystat[4],mystat[5])
					print "<<<",rootfile+"/"
				else:
					print "---",rootfile+"/"
				#mtime doesn't mean much for directories -- we don't store it
				outfile.write("dir "+relfile+"\n")
				#enter directory, recurse
				os.chdir(x)
				self.merge(mergeroot,inforoot,mergestart+"/"+x,outfile)
				#return to original path
				os.chdir(mergestart)
			elif os.path.isfile(x):
				mymd5=md5(x)
				if movefile(x,rootfile):
					zing="<<<"
				else:
					zing="!!!"
		
				print zing+" "+rootfile
				print "md5",mymd5
				outfile.write("obj "+relfile+" "+mymd5+" "+getmtime(rootfile)+"\n")
			elif isfifo(x):
				zing="!!!"
				if not os.path.exists(rootfile):	
					if movefile(x,rootfile):
						zing="<<<"
				elif isfifo(rootfile):
					os.unlink(rootfile)
					if movefile(x,rootfile):
						zing="<<<"
				print zing+" "+rootfile
				outfile.write("fif "+relfile+"\n")
			else:
				if movefile(x,rootfile):
					zing="<<<"
				else:
					zing="!!!"
				print zing+" "+rootfile
				outfile.write("dev "+relfile+"\n")

		if mergestart==mergeroot:
			#if we opened it, close it	
			outfile.close()
			if (oldcontents):
				print ">>> Safely unmerging already-installed instance..."
				self.unmerge(oldcontents)
				print ">>> original instance of package unmerged safely."	

			os.chdir(inforoot)
			#get original provides settings for later updating, all other variables are overwritten
			oldprovides=self.getprovides()
			for x in os.listdir("."):
				self.copyfile(x)
			#this will update the virtual links that are different between the current and old provides settings
			self.setprovides(None,oldprovides)
			#update environment settings, library paths
			env_update()	
			print ">>>",self.cat+"/"+self.pkg,"merged."
			os.chdir(origdir)
	
	def doebuild(self,funcname):
		if not os.path.exists(self.dbdir+"/"+self.pkg+".ebuild"):
			return 0
		return doebuild(self.dbdir+"/"+self.pkg+".ebuild",funcname)

	def getstring(self,name):
		"returns contents of a file with whitespace converted to spaces"
		if not os.path.exists(self.dbdir+"/"+name):
			return ""
		myfile=open(self.dbdir+"/"+name,"r")
		mydata=string.split(myfile.read())
		myfile.close()
		return string.join(mydata," ")
	
	def copyfile(self,fname):
		if not os.path.exists(self.dbdir):
			self.create()
		shutil.copyfile(fname,self.dbdir+"/"+os.path.basename(fname))
	
	def getfile(self,fname):
		if not os.path.exists(self.dbdir+"/"+fname):
			return ""
		myfile=open(self.dbdir+"/"+fname,"r")
		mydata=myfile.read()
		myfile.close()
		return mydata

	def setfile(self,fname,data):
		if not os.path.exists(self.dbdir):
			self.create()
		myfile=open(self.dbdir+"/"+fname,"w")
		myfile.write(data)
		myfile.close()
		
	def getelements(self,ename):
		if not os.path.exists(self.dbdir+"/"+ename):
			return [] 
		myelement=open(self.dbdir+"/"+ename,"r")
		mylines=myelement.readlines()
		myreturn=[]
		for x in mylines:
			myreturn.append(x[:-1])
		myelement.close()
		return myreturn
	
	def setelements(self,mylist,ename):
		if not os.path.exists(self.dbdir):
			self.create()
		myelement=open(self.dbdir+"/"+ename,"w")
		for x in mylist:
			myelement.write(x+"\n")
		myelement.close()
	
	def haselement(self,mycat,mypkg,ename):
		"boolean -- is the specified cat/pkg listed in this package's elements file?"
		mycmp=mycat+"/"+mypkg
		for x in self.getelements(ename):
			if x == mycmp:
				return 1
		return 0
	
	def hasprovide(self,mycat,mypkg):
		return self.haselement(mycat,mypkg,"PROVIDE")
	
	def getprovides(self):
		"get a list of virtual packages provided by this package."
		return self.getelements("PROVIDE")
	
	def setprovides(self,mylist=None,oldprovides=None):
		"set virtual packages provided by this package, and also update virtual links"
		if not mylist:
			mylist=self.getelements("PROVIDE")
		if not oldprovides:
			oldprovides=self.getelements("PROVIDE")
		for x in mylist:
			if x not in oldprovides:
				#remove old virtual link
				mypsplit=string.split(x,"/")
				mylink=dblink(mypsplit[0],mypsplit[1])
				myvirts=plink.getvirtuals()
				if self.cat+"/"+self.pkg in myvirts:
					myvirts.remove(self.cat+"/"+self.pkg)
					mylink.setvirtuals(myvirts)
		for x in oldprovides:
			if x not in mylist:
				#add new virtual link
				mypsplit=string.split(x,"/")
				mylink=dblink(mypsplit[0],mypsplit[1])
				myvirts=plink.getvirtuals()
				if not self.cat+"/"+self.pkg in myvirts:
					myvirts.append(self.cat+"/"+self.pkg)
					mylink.setvirtuals(myvirts)
		return self.setelements(mylist,"PROVIDE")
	
	def isprovide(self):
		return os.path.exists(self.dbdir+"/PROVIDE")

	def hasvirtual(self,mycat,mypkg):
		return self.haselement(mycat,mypkg,"VIRTUAL")
	
	def getvirtuals(self):
		"get a list of packages providing this virtual package."
		return self.getelements("VIRTUAL")
	
	def setvirtuals(self,mylist):
		"set a list of packages providing this virtual package."
		return self.setelements(mylist,"VIRTUAL")
	
	def isvirtual(self):
		"is this a virtual package?  boolean."
		return os.path.exists(self.dbdir+"/VIRTUAL")

def depgrab(myfilename,depmark):
	"""
	Will grab the dependency string from an ebuild file, using
	depmark as a marker (normally DEPEND or RDEPEND)
	"""
	depstring=""
	myfile=open(myfilename,"r")
	mylines=myfile.readlines()
	myfile.close()
	pos=0
	while (pos<len(mylines)):
		if mylines[pos][0:len(depmark)+1]==depmark+"=":
			depstart=string.split(mylines[pos][len(depmark):],'"')
			if len(depstart)==3:
				depstring=depstart[1]
				return string.join(string.split(depstring)," ")
			elif len(depstart)==2:
				depstring=depstart[1]+" "
				pos=pos+1
				while 1:
					mysplit=string.split(mylines[pos],'"')
					depstring=depstring+mysplit[0]+" "
					if len(mysplit)>1:
						return string.join(string.split(depstring)," ")
					pos=pos+1
			elif len(depstart)==1:
				depstring=depstring+mylines[pos][len(depmark)+1:]
				break
			else:
				break
		else:
			pos=pos+1
	return string.join(string.split(depstring)," ")

def cleanup_pkgmerge(mypkg,origdir):
	shutil.rmtree(getsetting("PKG_TMPDIR")+"/"+mypkg,1)
	os.chdir(origdir)

def pkgmerge(mytbz2):
	"""will merge a .tbz2 file, returning a list of runtime dependencies that must be
		satisfied, or None if there was a merge error.  This code assumes the package
		exists."""
	if mytbz2[-5:]!=".tbz2":
		print "!!! Not a .tbz2 file"
		return None
	mypkg=os.path.basename(mytbz2)[:-5]
	xptbz2=xpak.tbz2(mytbz2)
	pkginfo={}
	mycat=xptbz2.getfile("CATEGORY")
	if not mycat:
		print "!!! CATEGORY info missing from info chunk, aborting..."
		return None
	mycat=string.strip(mycat)
	mycatpkg=mycat+"/"+mypkg

	tmploc=getsetting("PKG_TMPDIR")
	pkgloc=tmploc+"/"+mypkg+"/bin"
	infloc=tmploc+"/"+mypkg+"/inf"
	if os.path.exists(tmploc+"/"+mypkg):
		shutil.rmtree(tmploc+"/"+mypkg,1)
	os.makedirs(pkgloc)
	os.makedirs(infloc)
	print ">>> extracting info"
	xptbz2.unpackinfo(infloc)
	origdir=os.getcwd()
	os.chdir(pkgloc)
	print ">>> extracting",mypkg
	notok=os.system("cat "+mytbz2+"| bzip2 -dq | tar xf -")
	if notok:
		print "!!! Error extracting",mytbz2
		cleanup_pkgmerge(mypkg,origdir)
		return None
	#the merge takes care of pre/postinst and old instance auto-unmerge, virtual/provides updates, etc.
	merge(mycat,mypkg,pkgloc,infloc)
	if not os.path.exists(infloc+"/RDEPEND"):
		returnme=""
	else:
		#get runtime dependencies
		a=open(infloc+"/RDEPEND","r")
		returnme=string.join(string.split(a.read())," ")
		a.close()
	cleanup_pkgmerge(mypkg,origdir)
	return returnme

def ebuild_init():
	"performs db/variable initialization for the ebuild system.  Not required for other scripts."
	global configdefaults, configsettings, currtree, roottree, localtree, porttree, ebuild_initialized, root
	configdefaults=getconfig("/etc/make.defaults")
	configsettings=getconfig("/etc/make.conf")
	localtree=vartree("/")	
	if root=="/":
		#root is local, and build dep database is the runtime dep database
		roottree=localtree
	else:
		#root is non-local, initialize non-local database as roottree
		roottree=vartree(root)
	porttree=portagetree(getsetting("PORTDIR"))
	currtree=currenttree(getsetting("CURRENTFILE"))
	ebuild_initialized=1

root=getsetting("ROOT")
if len(root)==0:
	root="/"
elif root[-1]!="/":
	root=root+"/"
if root != "/":
	if not os.path.exists(root[:-1]):
		print "!!! Error: ROOT",root,"does not exist.  Please correct this."
		print "!!! Exiting."
		print
		sys.exit(1)
	elif not os.path.isdir(root[:-1]):
		print "!!! Error: ROOT",root[:-1],"is not a directory.  Please correct this."
		print "!!! Exiting."
		print
		sys.exit(1)
ebuild_initialized=0
