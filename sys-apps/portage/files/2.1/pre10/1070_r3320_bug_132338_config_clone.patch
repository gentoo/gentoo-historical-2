=== modified file 'pym/portage.py'
--- pym/portage.py	
+++ pym/portage.py	
@@ -1292,13 +1292,15 @@
 			self.features = portage_util.unique_array(self["FEATURES"].split())
 		else:
 			# XXX
-			# The below self.regenerate() causes previous changes to FEATURES (and 
-			# other incrementals) to be reverted.  If this instance is a clone, we
-			# need to skip regenerate() so that the copied values are preserved.
-			self.features = portage_util.unique_array(self["FEATURES"].split())
+			# The below self.regenerate() causes previous changes to FEATURES
+			# (and other incrementals) to be reverted.  If this instance is a
+			# clone, we need to take the cloned FEATURES from backupenv and
+			# save them where the regenerate() call will not destroy them.
+			# Later, we use backup_changes() to restore the cloned FEATURES
+			# into the backupenv once again.
+			self.features = portage_util.unique_array(
+				self.backupenv["FEATURES"].split())
 			self.regenerate()
-			self["FEATURES"] = " ".join(self.features)
-			self.backup_changes("FEATURES")
 
 		#XXX: Should this be temporary? Is it possible at all to have a default?
 		if "gpg" in self.features:
@@ -1314,7 +1316,7 @@
 				self.features.remove("usersandbox")
 
 		self.features.sort()
-		self["FEATURES"] = " ".join(["-*"]+self.features)
+		self["FEATURES"] = " ".join(self.features)
 		self.backup_changes("FEATURES")
 
 		if not len(self["CBUILD"]) and len(self["CHOST"]):
@@ -1501,6 +1503,14 @@
 			myincrementals=["USE"]
 		else:
 			myincrementals=portage_const.INCREMENTALS
+
+		# If self.features exists, it has already been stacked and may have
+		# been mutated, so don't stack it again or else any mutations will be
+		# reverted.
+		if "FEATURES" in myincrementals and hasattr(self, "features"):
+			myincrementals = set(myincrementals)
+			myincrementals.remove("FEATURES")
+
 		for mykey in myincrementals:
 			if mykey=="USE":
 				mydbs=self.uvlist

