===================================================================
RCS file: /cvs/hal/hal/hald/linux/volume_id/Attic/volume_id.c,v
retrieving revision 1.45.2.4
retrieving revision 1.45.2.6
diff -u -r1.45.2.4 -r1.45.2.6
--- volume_id.c	2005/01/12 02:05:31	1.45.2.4
+++ volume_id.c	2005/01/17 15:25:00	1.45.2.6
@@ -774,6 +774,8 @@
 #define FAT16_MAX			0xfff5
 #define FAT_ATTR_VOLUME_ID		0x08
 #define FAT_ATTR_DIR			0x10
+#define FAT_ATTR_LONG_NAME		0x0f
+#define FAT_ATTR_MASK			0x3f
 #define FAT_ENTRY_FREE			0xe5
 static int probe_vfat(struct volume_id *id, __u64 off)
 {
@@ -859,6 +861,9 @@
 	/* believe only that's fat, don't trust the version
 	 * the cluster_count will tell us
 	 */
+	if (strncmp(vs->sysid, "NTFS", 4) == 0)
+		return -1;
+
 	if (strncmp(vs->type.fat32.magic, "MSWIN", 5) == 0)
 		goto valid;
 
@@ -956,7 +961,7 @@
 
 	dir = (struct vfat_dir_entry*) buf;
 
-	for (i = 0; i <= root_dir_entries; i++) {
+	for (i = 0; i < root_dir_entries; i++) {
 		/* end marker */
 		if (dir[i].name[0] == 0x00) {
 			dbg("end of dir");
@@ -967,7 +972,15 @@
 		if (dir[i].name[0] == FAT_ENTRY_FREE)
 			continue;
 
+		/* long name */
+		if ((dir[i].attr & FAT_ATTR_MASK) == FAT_ATTR_LONG_NAME)
+			continue;
+
 		if ((dir[i].attr & (FAT_ATTR_VOLUME_ID | FAT_ATTR_DIR)) == FAT_ATTR_VOLUME_ID) {
+			/* labels do not have file data */
+			if (dir[i].cluster_high != 0 || dir[i].cluster_low != 0)
+				continue;
+
 			dbg("found ATTR_VOLUME_ID id in root dir");
 			label = dir[i].name;
 			break;
@@ -976,6 +989,10 @@
 		dbg("skip dir entry");
 	}
 
+	vs = (struct vfat_super_block *) get_buffer(id, off, 0x200);
+	if (vs == NULL)
+		return -1;
+
 	if (label != NULL && strncmp(label, "NO NAME    ", 11) != 0) {
 		set_label_raw(id, label, 11);
 		set_label_string(id, label, 11);
@@ -1015,7 +1032,7 @@
 		count = buf_size / sizeof(struct vfat_dir_entry);
 		dbg("expected entries 0x%x", count);
 
-		for (i = 0; i <= count; i++) {
+		for (i = 0; i < count; i++) {
 			/* end marker */
 			if (dir[i].name[0] == 0x00) {
 				dbg("end of dir");
@@ -1026,7 +1043,15 @@
 			if (dir[i].name[0] == FAT_ENTRY_FREE)
 				continue;
 
+			/* long name */
+			if ((dir[i].attr & FAT_ATTR_MASK) == FAT_ATTR_LONG_NAME)
+				continue;
+
 			if ((dir[i].attr & (FAT_ATTR_VOLUME_ID | FAT_ATTR_DIR)) == FAT_ATTR_VOLUME_ID) {
+				/* labels do not have file data */
+				if (dir[i].cluster_high != 0 || dir[i].cluster_low != 0)
+					continue;
+
 				dbg("found ATTR_VOLUME_ID id in root dir");
 				label = dir[i].name;
 				goto fat32_label;
@@ -1050,6 +1075,10 @@
 		dbg("reached maximum follow count of root cluster chain, give up");
 
 fat32_label:
+	vs = (struct vfat_super_block *) get_buffer(id, off, 0x200);
+	if (vs == NULL)
+		return -1;
+
 	if (label != NULL && strncmp(label, "NO NAME    ", 11) != 0) {
 		set_label_raw(id, label, 11);
 		set_label_string(id, label, 11);
