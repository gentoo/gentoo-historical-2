--- ChangeLog	(revision 1964)
+++ ChangeLog	(working copy)
@@ -1,6 +1,23 @@
 # ChangeLog for Gentoo System Intialization ("rc") scripts
 # Copyright 1999-2006 Gentoo Foundation; Distributed under the GPLv2
 
+  12 Apr 2006; Roy Marples <uberlord@gentoo.org>:
+
+    vlans can now be configured with their own interface scripts, which
+    means that they can now be renamed, #128283.
+    Thanks to Jonathan deBoer.
+
+  11 Apr 2006; Roy Marples <uberlord@gentoo.org>:
+
+    udhcpc.sh now works with the -q|--quit option again, #129437.
+
+  09 Apr 2006; Roy Marples <uberlord@gentoo.org>:
+
+    RC_COLDPLUG now controls if we add coldplugged services to the boot
+    runlevel or not, #129331.
+
+    The ccwgroup module now really works!
+
 * baselayout-1.12.0_pre17 (08 Apr 2006)
 
   07 Apr 2006; Roy Marples <uberlord@gentoo.org>:
--- etc/conf.d/rc	(revision 1964)
+++ etc/conf.d/rc	(working copy)
@@ -16,6 +16,17 @@
 
 RC_INTERACTIVE="yes"
 
+# Dynamic /dev managers can trigger coldplug events which cause services to
+# start before we are ready for them. If this happens, we can defer these
+# services to start in the boot runlevel. If you don't want this then set
+# RC_COLDPLUG to no.
+# For more fine grained control you can list full service names to allow
+# them to coldplug and prefix them with ! so they don't coldplug.
+# Example - RC_COLDLUG="net.wlan !net.*"
+# This allows net.wlan and any service not matching net.* to coldplug.
+
+RC_COLDPLUG="yes"
+
 # RC_NET_STRICT_CHECKING allows some flexibility with the 'net' service.
 # The following values are allowed:
 #  none  - The 'net' service is always considered up.
--- lib/rcscripts/net.modules.d/udhcpc.sh	(revision 1964)
+++ lib/rcscripts/net.modules.d/udhcpc.sh	(working copy)
@@ -126,9 +126,15 @@
 		fi
 	fi
 
-	eval start-stop-daemon --start --exec /sbin/udhcpc \
-		--pidfile "${pidfile}" \
-		-- "${opts}" --interface="${iface}" --now \
+	# Don't use s-s-d if the user wants to quit on lease.
+	if [[ " ${opts} " == *" -q "* || " ${opts} " == *" --quit "*  ]]; then
+		x="/sbin/udhcpc"
+	else
+		x="start-stop-daemon --start --exec /sbin/udhcpc \
+			--pidfile \"${pidfile}\" --"
+	fi
+	
+	eval "${x}" "${opts}" --interface="${iface}" --now \
 		--script=/lib/rcscripts/sh/udhcpc.sh \
 		--pidfile="${pidfile}" >/dev/null
 	eend $? || return 1
--- lib/rcscripts/net.modules.d/ifconfig.sh	(revision 1964)
+++ lib/rcscripts/net.modules.d/ifconfig.sh	(working copy)
@@ -109,7 +109,7 @@
 ifconfig_is_up() {
 	local check="\<UP\>" addr="${2:-false}"
 	${addr} && check="\<inet addr:.*${check}"
-	ifconfig "$1" | grep -Eq "${check}" && return 0
+	ifconfig "$1" | tr '\n' ' ' | grep -Eq "${check}" && return 0
 	return 1
 }
 
--- lib/rcscripts/net.modules.d/ccwgroup.sh	(revision 1964)
+++ lib/rcscripts/net.modules.d/ccwgroup.sh	(working copy)
@@ -11,30 +11,44 @@
 
 ccwgroup_pre_start() {
 	local iface="$1" ifvar="$(bash_variable "$1")"
-	local ccwgroup="ccwgroup_${ifvar}[@]"
+	local ccw="ccwgroup_${ifvar}[@]"
+	local -a ccwgroup=( "${!ccw}" )
 
-	[[ -z ${!ccwgroup} ]] && return 0
+	[[ -z ${!ccw} ]] && return 0
 	if [[ ! -d /sys/bus/ccwgroup ]] ; then
 		eerror "ccwgroup support missing in kernel"
 		return 1
 	fi
 
 	einfo "Enabling ccwgroup on ${iface}"
-	echo "${!ccwgroup// /,}" > /sys/bus/ccwgroup/drivers/qeth/group
-	echo "1" > /sys/devices/qeth/"${!ccwgroup[0]}"/online
+	echo "${!ccw// /,}" > /sys/bus/ccwgroup/drivers/qeth/group
+	echo "1" > /sys/devices/qeth/"${ccwgroup[0]}"/online
 	eend $?
 }
 
-ccwgroup_post_stop() {
+ccwgroup_pre_stop() {
 	local iface="$1"
+
+	# Erase any existing ccwgroup to be safe
+	save_options ccwgroup_device ""
 	
 	[[ ! -L /sys/class/net/"${iface}"/driver ]] && return 0
 	local driver="$(readlink /sys/class/net/"${iface}"/driver)"
 	[[ ${driver} != *"/bus/ccwgroup/"* ]] && return 0
+
+	local device="$(readlink /sys/class/net/"${iface}"/device)"
+	device="${device##*/}"
+	save_options ccwgroup_device "${device}"
+}
+
+ccwgroup_post_stop() {
+	local iface="$1" device="$(get_options ccwgroup_device)"
 	
+	[[ -z ${device} ]] && return 0
+	
 	einfo "Disabling ccwgroup on ${iface}"
-	echo "0"  > /sys/class/net/"${iface}"/device/online
-	echo "1"  > /sys/class/net/"${iface}"/device/ungroup
+	echo "0"  > /sys/devices/qeth/"${device}"/online
+	echo "1"  > /sys/devices/qeth/"${device}"/ungroup
 	eend $?
 }
 
--- lib/rcscripts/net.modules.d/vlan.sh	(revision 1964)
+++ lib/rcscripts/net.modules.d/vlan.sh	(working copy)
@@ -98,9 +98,9 @@
 #
 # Always returns 0 (true) 
 vlan_post_start() {
-	local iface="$1" vlan vlans vlans_old e ifname ifvar="$(bash_variable "$1")"
-
+	local iface="$1" vlan vlans vlans_old ifname ifvar="$(bash_variable "$1")"
 	vlans="vlans_${ifvar}[@]"
+	local start="vlan_start_${ifvar}"
 
 	# BACKWARD COMPATIBILITY: check for old vlan variable name
 	vlans_old="iface_${ifvar}_vlans"
@@ -121,6 +121,11 @@
 		fi
 		eend 0
 
+		# We may not want to start the vlan ourselves, but
+		# as a seperate init script. This allows the vlan to be
+		# renamed if needed.
+		[[ -n ${!start} && ${!start} != "yes" ]] && continue
+		
 		# We need to work out the interface name of our new vlan id
 		ifname="$( \
 			sed -n -e 's/^\([^ \t]*\) *| '"${vlan}"' *| .*'"${iface}"'$/\1/p' \
--- init.d/net.lo	(revision 1964)
+++ init.d/net.lo	(working copy)
@@ -1086,19 +1086,6 @@
 # which localises variables and unsets functions
 start() {
 	declare -r IFACE="${SVCNAME#*.}"
-	if [[ ${IN_HOTPLUG} == "1" ]] ; then
-		# If we've been called by hotplug, check if we have
-		# a policy for the interface for not starting
-		local x ifvar="$(bash_variable "${IFACE}")"
-		x="hotplug_${ifvar}"
-		if [[ ${!x} == "no" || ${!x} == "false" ]] ; then
-			eerror "Not starting interface ${IFACE} due to hotplug policy"
-			unset -f exit
-			mark_service_stopped "net.${IFACE}"
-			exit 1
-		fi
-	fi
-
 	einfo "Starting ${IFACE}"
 	run "${IFACE}" start
 }
--- etc/conf.d/net.example	(revision 1964)
+++ etc/conf.d/net.example	(working copy)
@@ -21,15 +21,6 @@
 # read through the rest of this file.
 
 ##############################################################################
-# DEFAULTS
-#
-# hotplug_eth0="yes"
-# Do we allow hotplug to bring up interfaces or not? The default is we do,
-# otherwise put no in the above value.
-# NOTE: hotplug just has to be installed for hotplugging to work - it does
-# not matter if it's in any runlevel or not.
-
-##############################################################################
 # MODULES
 #
 # We now support modular networking scripts which means we can easily
@@ -325,7 +316,16 @@
 # NOTE: Vlans are controlled by their physical interface and not per vlan
 # This means you do not need to create init scripts in /etc/init.d for each
 # vlan, you must need to create one for the physical interface.
+# If you wish to control the configuration of each vlan through a seperate
+# script, or wish to rename the vlan interface to something that vconfig
+# cannot then you need to do this.
+#vlan_start_eth0="no
 
+# If you do the above then you may want to depend on eth0 like so
+# depend_vlan1() {
+#	need net.eth0
+# }
+
 #-----------------------------------------------------------------------------
 # Bonding
 # For link bonding/trunking emerge net-misc/ifenslave
@@ -361,7 +361,7 @@
 #link_ppp0="/dev/ttyS0" 		# Most PPP links will use a serial port
 #link_ppp0="eth0"       		# PPPoE requires an ethernet interface
 #link_ppp0="/dev/null"			# PPPoA and ISDN links should have this
-#link_ppp0="pty $(your_link_command)"	# PPP links over ssh, rsh, etc
+#link_ppp0="pty 'your_link_command'"	# PPP links over ssh, rsh, etc
 #
 # Here you should specify what pppd plugins you want to use
 # Available plugins are: pppoe, pppoa, capi, dhcpc, minconn, radius,
--- sbin/runscript.sh	(revision 1964)
+++ sbin/runscript.sh	(working copy)
@@ -27,6 +27,14 @@
 # until after rc sysinit has completed so we punt them to the boot runlevel
 if [[ -e /dev/.rcsysinit ]] ; then
 	eerror "ERROR:  cannot run ${SVCNAME} until sysinit completes"
+	[[ ${RC_COLDPLUG} == "no" ]] && exit 1
+	if [[ ${RC_COLDPLUG} != "yes" ]] ; then
+		for x in ${RC_COLDPLUG} ; do
+			# We don't quote ${x} so we can do globbing
+			[[ ${SVCNAME} == ${x} ]] && break
+			[[ "!${SVCNAME}" == ${x} ]] && exit 1
+		done
+	fi
 	eerror "${SVCNAME} will be started in the ${BOOTLEVEL} runlevel"
 	if [[ ! -L /dev/.rcboot/"${SVCNAME}" ]] ; then
 		[[ ! -d /dev/.rcboot ]] && mkdir /dev/.rcboot
--- sbin/rc	(revision 1964)
+++ sbin/rc	(working copy)
@@ -164,7 +164,7 @@
 			CRITICAL_SERVICES="${CRITICAL_SERVICES} ${x##*/}"
 		done
 	else
-		CRITICAL_SERVICES="checkroot modules checkfs localmount clock bootmisc"
+		CRITICAL_SERVICES="checkroot modules checkfs localmount clock"
 	fi
 
 	export CRITICAL_SERVICES
