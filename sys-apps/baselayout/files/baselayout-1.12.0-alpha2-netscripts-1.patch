diff -u net.modules.d/dhclient /lib/rcscripts/net.modules.d/dhclient
--- net.modules.d/dhclient	2005-04-18 17:51:25.000000000 +0100
+++ lib/rcscripts/net.modules.d/dhclient	2005-04-26 07:57:32.483284550 +0100
@@ -124,7 +124,7 @@
 	[[ ${x:${#x} - 5:5} == "bound" ]]
 	if [[ $? != 0 ]]; then
 		# We need to kill the process if we fail
-		kill -s TERM $( < ${pidfile} ) 2>/dev/null
+		[[ -e ${pidfile} ]] && kill -s TERM $( < ${pidfile} ) 2>/dev/null
 		eend 1
 		return 1
 	fi
diff -u net.modules.d/ifconfig /lib/rcscripts/net.modules.d/ifconfig
--- net.modules.d/ifconfig	2005-04-18 18:10:41.000000000 +0100
+++ lib/rcscripts/net.modules.d/ifconfig	2005-04-22 16:56:22.563108496 +0100
@@ -241,7 +241,8 @@
 # fail, the routine should still return success to indicate that
 # net.eth0 was successful
 ifconfig_post_start() {
-	local iface=$1 ifvar=$( bash_variable $1 ) routes x
+	local iface=$1 ifvar=$( bash_variable $1 ) routes x metric
+	eval metric=\"\$\{metric_${ifvar}\}\"
 
 	# Make sure interface is marked UP
 	ifconfig_up ${iface}
@@ -270,19 +271,18 @@
 
 		# Support iproute2 style routes
 		x="${x//via/gw} "
-		x=${x//scope * / }
+		x="${x//scope * / }"
 		
 		# Assume we're a net device unless told otherwise
 		[[ " ${x} " != *' -net '* && " ${x} " != *' -host '* ]] && x="-net ${x}"
 
 		# Support adding IPv6 addresses easily
-		if [[ ${x} == *:* && ${x} != *'-A inet6'* ]]; then
-			route add -A inet6 ${x} dev ${iface}
-		else
-			# We do this so we don't have to specify host or net
-			# in our config
-			route add ${x} dev ${iface} 
-		fi
+		[[ ${x} == *:* && ${x} != *'-A inet6'* ]] && x="-A inet6 ${x}"
+
+		# Add a metric if we don't have one
+		[[ ${x} != *' metric '* ]] && x="${x} metric ${metric}"
+		
+		route add ${x} dev ${iface} 
 		eend $?
 	done
 	eoutdent
@@ -294,7 +294,7 @@
 #
 # Adds the given address to the interface
 ifconfig_add_address() {
-	local iface=$1 i=0
+	local iface=$1 i=0 r e
 
 	ifconfig_exists ${iface} true || return 1
 
@@ -324,11 +324,45 @@
 	# Some kernels like to apply lo with an address when they are brought up
 	if [[ ${iface} == "lo" || ${config[@]} == "127.0.0.1/8 broadcast 127.255.255.255" ]]; then
 		ifconfig ${iface} ${config[@]} 2>/dev/null
-		return 0
+		r=0
 	else
-		ifconfig ${iface} ${config[@]}
-		return $?
+		e=$( ifconfig ${iface} ${config[@]} 2>&1 )
+		r=$?
+		[[ ${r} != 0 ]] && echo "${e}" > /dev/stderr
 	fi
+
+	[[ ${r} != 0 ]] && return ${r}
+
+	local metric ifvar=$( bash_variable ${iface} )
+	# Remove the newly added route and replace with our metric
+	eval metric=\"\$\{metric_${ifvar}\}\"
+	[[ ${metric} == 0 || ${auto_interface} != "yes" ]] && return ${r}
+
+	local ip=${config[0]} netmask
+	local cidr=${ip##*/}
+	ip=${ip%%/*}
+
+	if [[ -n ${cidr} && ${cidr} != ${ip} ]]; then
+		netmask=$( cidr2netmask ${cidr} )
+	else
+		for (( i=1; i<${#config[@]}-1; i++ )); do
+			if [[ ${config[i]} == "netmask" ]]; then
+				netmask=${config[i+1]}
+				cidr=$( netmask2cidr ${netmask} )
+				break
+			fi
+		done
+	fi
+
+	[[ -z ${netmask} ]] && return ${r}
+	echo ${netmask}
+	
+	local network=$( ip_network ${ip} ${netmask} )
+
+        route del -net ${network}/${cidr} dev ${iface}
+        route add -net ${network}/${cidr} metric ${metric} dev ${iface}
+
+        return ${r}
 }
 
 # void ifconfig_default_route(char* interface, char* gateway_ip, int metric)
diff -u net.modules.d/iproute2 /lib/rcscripts/net.modules.d/iproute2
--- net.modules.d/iproute2	2005-04-18 18:10:41.000000000 +0100
+++ lib/rcscripts/net.modules.d/iproute2	2005-04-25 08:05:15.723750125 +0100
@@ -220,8 +220,11 @@
 		case ${config[x]} in
 			netmask)
 				config[0]="${config[0]}/$( netmask2cidr ${config[x+1]} )"
-				unset config[x]
-				unset config[x+1]
+				unset config[x] config[x+1]
+				;;
+			mtu)
+				ip link set mtu ${config[x+1]} dev ${iface}
+				unset config[x] config[x+1]
 				;;
 		esac
 	done
@@ -236,13 +239,30 @@
 	iproute2_up ${iface}
 
 	# Some kernels like to apply lo with an address when they are brought up
+	local r
 	if [[ ${iface} == "lo" && ${config[@]} == "127.0.0.1/8 brd 127.255.255.255 scope host" ]]; then
 		ip addr add dev ${iface} ${config[@]} 2>/dev/null
-		return 0
+		r=0
 	else
 		ip addr add dev ${iface} ${config[@]}
-		return $?
+		r=$?
 	fi
+
+	local metric ifvar=$( bash_variable ${iface} )
+	# Remove the newly added route and replace with our metric
+	eval metric=\"\$\{metric_${ifvar}\}\"
+	[[ ${metric} == 0 || ${auto_interface} != "yes" ]] && return ${r}
+	
+	local network=$( ip_network ${config[0]} )
+	[[ -z ${network} ]] && return ${r}
+
+	local cidr=${config[0]}
+	cidr=${cidr##*/}
+	
+	ip route del ${network}/${cidr} dev ${iface}
+	ip route add ${network}/${cidr} metric ${metric} dev ${iface}
+	
+	return ${r}
 }
 
 # bool iproute2_post_start(char *interface)
@@ -278,11 +298,9 @@
 		[[ ${x} == *'-host'* ]] && x="${x//-host} scope host"
 
 		# Add a metric if we don't have one
-		if [[ ${x// metric } == ${x} ]]; then
-			ip route append ${x} metric ${metric} dev ${iface}
-		else
-			ip route append ${x} dev ${iface}
-		fi
+		[[ ${x} != *' metric '* ]] && x="${x} metric ${metric}"
+	
+		ip route append ${x} dev ${iface}
 		eend $?
 	done
 	eoutdent
@@ -296,7 +314,7 @@
 # the given interface
 iproute2_default_route() {
 	local metric=${3:-0}
-	
+
 	ip route change default via $2 metric ${metric} dev $1 2>/dev/null \
 	|| ip route append default via $2 metric ${metric} dev $1 2>/dev/null
 }
diff -u net.modules.d/iwconfig /lib/rcscripts/net.modules.d/iwconfig
--- net.modules.d/iwconfig	2005-04-18 18:10:41.000000000 +0100
+++ lib/rcscripts/net.modules.d/iwconfig	2005-04-26 08:18:37.729553836 +0100
@@ -492,6 +492,12 @@
 		fi
 	fi
 
+	# HUP the interface
+	# This may be have to be moved to the associate function
+	# if things like dhcp clients keep timing out but work manually
+	interface_down ${IFACE}
+	interface_up ${IFACE}
+
 	# Change back mode if needed
 	x=$( eval echo \$\{mode_${ifvar}\} | tr '[:upper:]' '[:lower:]' )
 	x=${x:-auto}
@@ -832,7 +838,7 @@
 # First we check if wireless extensions exist on the interface
 # If they are then we configue wireless
 iwconfig_pre_start() {
-	local iface=$1 r=0 local wasup=true
+	local iface=$1 r=0
 
 	# We don't configure wireless if we're being called from
 	# the background
@@ -841,23 +847,15 @@
 	save_options "ESSID" ""
 	interface_exists ${iface} || return 0
 
+	interface_up ${iface}
+
 	if ! iwconfig_check_extensions ${iface} ; then
-		if ! interface_is_up ${iface} ; then
-			interface_up ${iface}
-			wasup=false
-		fi
-		if ! iwconfig_check_extensions ${iface} ; then
-			veinfo "Wireless extensions not found for ${iface}"
-			! ${wasup} && interface_down ${iface}
-			return 0
-		fi
+		veinfo "Wireless extensions not found for ${iface}"
+		return 0
 	fi
 
 	einfo "Configuring wireless network for ${iface}"
 
-	# We need to bring the interface up to apply stuff
-	interface_up ${iface}
-
 	# Are we a proper IEEE device?
 	# Most devices reutrn IEEE 802.11b/g - but intel cards return IEEE in lower case
 	# and RA cards return RAPCI or similar which really sucks :(
diff -u net.modules.d/wpa_supplicant /lib/rcscripts/net.modules.d/wpa_supplicant
--- net.modules.d/wpa_supplicant	2005-04-19 09:16:28.000000000 +0100
+++ lib/rcscripts/net.modules.d/wpa_supplicant	2005-04-26 22:33:09.262334226 +0100
@@ -98,6 +98,7 @@
 # Returns 0 if we're associated correctly or 1 if not
 # Note that just because we are associated does not mean we are using the
 # correct encryption keys
+# We only need this for wpa_supplicant-0.3.x
 wpa_supplicant_associated() {
 	local -a status=( "$( wpa_cli -i$1 status | sed -n -e 's/^\(key_mgmt\|wpa_state\|EAP state\)=\([^=]\+\).*/\U\2/p' )" )
 
@@ -115,21 +116,35 @@
 # Kills any existing wpa_supplicant process on the interface
 wpa_supplicant_kill() {
 	local iface=$1 report=${2:-false}
-	local pid=$( pgrep -f "^/usr/sbin/wpa_supplicant .* -i${iface}[ ]*$" )
-
-	if [[ -n ${pid} ]]; then
+	local pidfile="/var/run/wpa_supplicant-${iface}.pid"
+	
+	if ! clean_pidfile ${pidfile} ; then
 		${report} && ebegin "Stopping wpa_supplicant on ${iface}"
-		kill -s TERM ${pid}
-		${report} && eend 0
+		start-stop-daemon --stop --exec /usr/sbin/wpa_supplicant \
+			--pidfile ${pidfile}
+		${report} && eend $?
+	else
+		# Support wpa_supplicant-0.3.x
+		local pid=$( pgrep -f "^/usr/sbin/wpa_supplicant .* -i${iface}[ ]*$" )
+		if [[ -n ${pid} ]]; then
+			${report} && ebegin "Stopping wpa_supplicant on ${iface}"
+			kill -s TERM ${pid}
+			${report} && eend 0
+		fi
 	fi
-
+	
 	# If wpa_supplicant exits uncleanly, we need to remove the stale dir
 	[[ -S /var/run/wpa_supplicant/${iface} ]] \
 		&& rm -f /var/run/wpa_supplicant/${iface}
 
-	[[ -x /usr/sbin/wpa_monitor ]] && \
-		start-stop-daemon --stop --exec /usr/sbin/wpa_monitor \
-			--pidfile /var/run/wpa_monitor-${iface}.pid
+	# wpa_cli should close itself down cleanly, but just incase ...
+	pidfile="/var/run/wpa_cli-${iface}.pid"
+	if ! clean_pidfile ${pidfile} ; then
+		${report} && ebegin "Stopping wpa_cli on ${iface}"
+		start-stop-daemon --stop --exec /usr/bin/wpa_cli \
+			--pidfile ${pidfile} 
+		${report} && eend $?
+	fi
 }
 
 # bool wpa_supplicant_associate(char *interface)
@@ -165,8 +180,9 @@
 # Start wpa_supplicant on an interface and wait for association
 # Returns 0 (true) when successful, non-zero otherwise
 wpa_supplicant_pre_start() {
-	local iface=$1 opts timeout
+	local iface=$1 opts timeout action
 	local cfgfile="/etc/wpa_supplicant.conf"
+	local actfile="/usr/sbin/wpa_cli.action"
 
 	# We don't configure wireless if we're being called from
 	# the background
@@ -217,21 +233,27 @@
 	# Some drivers require the interface to be up
 	interface_up ${iface}
 
-	if ! wpa_supplicant ${opts} -B -c/etc/wpa_supplicant.conf -i${iface} ; then
-		eend 1
-		return 1
-	fi
-
-	if ! wpa_cli -i${iface} status &>/dev/null ; then
-		eend 1 "wpa_supplicant has exited unexpectedly"
-		return 1
-	fi
-
-	# If wpa_monitor is available then we background regardless
-	if [[ -x /usr/sbin/wpa_monitor ]]; then
-		ebegin "Starting wpa_monitor on ${iface}"
-		/usr/sbin/wpa_monitor -a/usr/sbin/wpa_monitor.action -i${iface}
-		eend $?
+	version=$( wpa_cli -v | sed -n -e 's/wpa_cli v//p' )
+	version=( ${version//./ } )
+	(( version = version[0] * 1000 + version[1] * 100 + version[2] ))
+	# wpa_supplicant 0.4.0 and greater supports wpa_cli actions
+	if [[ ${version} -gt 399 && -x ${actfile} ]]; then
+		opts="${opts} -W -P/var/run/wpa_supplicant-${iface}.pid"
+		action=true
+	fi
+
+	start-stop-daemon --start --exec /usr/sbin/wpa_supplicant \
+		-- ${opts} -B -c/etc/wpa_supplicant.conf -i${iface}
+	eend $? || return 1
+
+# Starting wpa_supplication-0.4.0, we can get wpa_cli to
+	# start/stop our scripts from wpa_supplicant messages
+	if [[ ${action} ]]; then
+		ebegin "Starting wpa_cli on ${iface}"
+		start-stop-daemon --start --exec /usr/bin/wpa_cli \
+			-- -a${actfile} -i${iface} \
+			-P/var/run/wpa_cli-${iface}.pid -B
+		eend $? || return 1
 		go_background
 	fi
 
diff -u net.modules.d/helpers.d/dhcp /lib/rcscripts/net.modules.d/helpers.d/dhcp
--- net.modules.d/helpers.d/dhcp	2005-04-18 18:10:41.000000000 +0100
+++ lib/rcscripts/net.modules.d/helpers.d/dhcp	2005-04-22 16:58:55.906796712 +0100
@@ -90,6 +90,7 @@
 	else
 		metric=0
 	fi
+	eval metric_${ifvar}="${metric}"
 fi
 
 # Configure our IP address
diff -u net.modules.d/helpers.d/functions /lib/rcscripts/net.modules.d/helpers.d/functions
--- net.modules.d/helpers.d/functions	2005-04-18 18:10:41.000000000 +0100
+++ lib/rcscripts/net.modules.d/helpers.d/functions	2005-04-26 18:44:39.097840000 +0100
@@ -10,9 +10,9 @@
 # Can handle eth0:1 and eth0.1
 # Which returns eth0 in this case
 interface_device() {
-	local dev=${1%%.*}
-	[[ ${dev} == ${1} ]] && dev=${1%%:*}
-	echo ${dev}
+	local dev="${1%%.*}"
+	[[ ${dev} == $1 ]] && dev="${1%%:*}"
+	echo "${dev}"
 }
 
 # char* interface_type(char* iface)
@@ -20,7 +20,7 @@
 # Returns the base type of the interface
 # eth, ippp, etc
 interface_type() {
-	echo ${1%%[0-9]*}
+	echo "${1%%[0-9]*}"
 }
 
 # void save_state(char *interface)
@@ -79,7 +79,7 @@
 	# Have we already got a metric?
 	local m=$( awk '$1=="'${iface}'" && $2=="00000000" { print $7 }' /proc/net/route )
 	if [[ -n ${m} ]]; then
-		echo ${m}
+		echo "${m}"
 		return 0
 	fi
 	
@@ -106,7 +106,7 @@
 	done
 
 	local m=$( awk "${exclude} { print "'$7'" }" /proc/net/route | sort -rn | head -n 1 | cut -d' ' -f2 )
-	m=${m:--1}
+	m="${m:--1}"
 	(( m ++ ))
 
 	# If we're a wireless device then add 1000 so that wired interfaces take preference
@@ -135,15 +135,15 @@
 		done
 		binary="${binary}${bin}"
 	done
-	binary=${binary%%0*}
-	echo ${#binary}
+	binary="${binary%%0*}"
+	echo "${#binary}"
 }
 
 # char* netmask2cidr(int cidr)
 #
 # Returns the netmask of a given CIDR
 cidr2netmask() {
-	local cidr=${1} netmask="" done=0 i sum=0 cur=128
+	local cidr="$1" netmask="" done=0 i sum=0 cur=128
 	local octets frac
 
 	(( octets=cidr/8 ))
@@ -168,22 +168,52 @@
 		done
 	fi
 
-	echo ${netmask:1}
+	echo "${netmask:1}"
 }
 
+# char* ip_network(char *ip, char *netmask)
+#
+# Returns the network of the ip address
+# ip can be 192.168.0.51/24
+# or
+# ip can be 192.168.0.51 and netmask is 255.255.255.0
+ip_network() {
+	local ip="$1" mask="$2" i network x
+
+	# If we didn't get parameter 2 then assume we have a CIDR
+	if [[ -z ${mask} ]]; then
+		mask="${ip##*/}"
+		[[ -z ${mask} || ${mask} == ${ip} ]] && return 1
+		mask=$( cidr2netmask ${mask} )
+		ip="${ip%%/*}"
+	fi
+
+	ip=( ${ip//./ } )
+	mask=( ${mask//./ } )
+
+	for (( i=0; i<4; i++ )); do
+		(( x=ip[i] & mask[i] ))
+		network="${network}${x}"
+		[[ ${i} -lt 3 ]] && network="${network}."
+	done
+
+	echo "${network}"
+}
+
+
 # bool clean_pidfile(char *file)
 #
 # Removes the given pidfile if the process is not running
 # Returns 1 if the process is still running otherwise 0
 clean_pidfile() {
-	local pidfile=${1}
+	local pidfile="$1"
 
 	[[ ! -f ${pidfile} ]] && return 0
 	local pid=$( < ${pidfile} )
 
 	if [[ -n ${pid} ]]; then
-		local cmd=${pidfile##*/}
-		cmd=${cmd%%-*}
+		local cmd="${pidfile##*/}"
+		cmd="${cmd%%-*}"
 		ps -p ${pid} 2>/dev/null | grep -q ${cmd} && return 1
 	fi
 
@@ -196,7 +226,7 @@
 # We wait for 10 seconds until the command ${cmd}
 # stops running on the process ${pid}
 process_finished() {
-	local i pid=$1 cmd=$2 secs=${3:-9}
+	local i pid="$1" cmd="$2" secs="${3:-9}"
 
 	for (( i=0; i<secs; i++ )); do
 		ps -p ${pid} 2>/dev/null | grep -q ${cmd} || return 0
@@ -213,7 +243,7 @@
 function_wrap() {
 	local i
 
-	[[ $( type -t ${2}_provides ) == function ]] && return
+	[[ $( type -t ${2}_provides ) == "function" ]] && return
 
 	for i in $( typeset -f | grep -o ^${1}_'[^ ]*' ); do
 		eval "${2}${i#${1}}() { ${i} \"\$@\"; }"
--- net.lo	2005-04-18 18:10:41.000000000 +0100
+++ init.d/net.lo	2005-04-25 08:09:32.599442139 +0100
@@ -199,7 +199,7 @@
 				if [[ ${umods[i]:1} == ${MODULES[j]} || ${umods[i]:1} == ${PROVIDES[j]} ]]; then
 					# We may need to setup a class wrapper for it even though
 					# we don't use it directly
-					${MODULES[j]}_check_installed && module_class_wrap ${MODULES[j]} ${PROVIDES[j]}
+					${MODULES[j]}_check_installed && function_wrap ${MODULES[j]} ${PROVIDES[j]}
 					unset MODULES[j]
 					unset PROVIDES[j]
 					break
@@ -724,7 +724,7 @@
 	if [[ $( type -t postup ) == "function" ]]; then
 		einfo "Running postup function"
 		eindent
-		$( postup ${iface} )
+		x=$( postup ${iface} ; echo $? )
 		eoutdent
 	fi
 
@@ -760,7 +760,7 @@
 	if [[ $( type -t postdown ) == "function" ]]; then
 		einfo "Running postdown function"
 		eindent
-		$( postdown ${iface} )
+		x=$( postdown ${iface} ; echo $? )
 		eoutdent
 	fi
 
