Index: ChangeLog
===================================================================
--- ChangeLog	(revision 2021)
+++ ChangeLog	(working copy)
@@ -1,6 +1,12 @@
 # ChangeLog for Gentoo System Intialization ("rc") scripts
 # Copyright 1999-2006 Gentoo Foundation; Distributed under the GPLv2
 
+  04 May 2006; Roy Marples <uberlord@gentoo.org>:
+
+    RC_COLDPLUG is now just a yes|no setting and the service list allowed
+    is now in RC_PLUG_SERVICES.
+    Added RC_HOTPLUG setting similar to RC_COLDPLUG.
+
 * baselayout-1.12.0_pre19 (02 May 2006)
 
   01 May 2006; Roy Marples <uberlord@gentoo.org>:
Index: etc/conf.d/rc
===================================================================
--- etc/conf.d/rc	(revision 2021)
+++ etc/conf.d/rc	(working copy)
@@ -16,17 +16,30 @@
 
 RC_INTERACTIVE="yes"
 
+# Do we allow services to be hotplugged? If not, set to RC_HOTPLUG="no"
+# NOTE: This does not affect anything hotplug/udev related, just the
+# starting/stopping of the init.d service triggered by hotplug.
+
+RC_HOTPLUG="yes"
+
 # Dynamic /dev managers can trigger coldplug events which cause services to
 # start before we are ready for them. If this happens, we can defer these
-# services to start in the boot runlevel. If you don't want this then set
-# RC_COLDPLUG to no.
-# For more fine grained control you can list full service names to allow
-# them to coldplug and prefix them with ! so they don't coldplug.
-# Example - RC_COLDPLUG="net.wlan !net.*"
-# This allows net.wlan and any service not matching net.* to coldplug.
+# services to start in the boot runlevel. Set RC_COLDPLUG="no" if you don't
+# want this.
+# NOTE: This does not affect anything coldplug/udev related, just the
+# starting/stopping of the init.d service triggered by coldplug.
 
 RC_COLDPLUG="yes"
 
+# Some people want a finer grain over hotplug/coldplug. RC_PLUG_SERVICES is a
+# list of services that are matched in order, either allowing or not. By
+# default we allow services through as RC_COLDPLUG/RC_HOTPLUG has to be yes
+# anyway.
+# Example - RC_PLUG_SERVICES="net.wlan !net.*"
+# This allows net.wlan and any service not matching net.* to be plugged.
+
+RC_PLUG_SERVICES=""
+
 # RC_NET_STRICT_CHECKING allows some flexibility with the 'net' service.
 # The following values are allowed:
 #  none  - The 'net' service is always considered up.
Index: sbin/runscript.sh
===================================================================
--- sbin/runscript.sh	(revision 2021)
+++ sbin/runscript.sh	(working copy)
@@ -27,14 +27,12 @@
 # until after rc sysinit has completed so we punt them to the boot runlevel
 if [[ -e /dev/.rcsysinit ]] ; then
 	eerror "ERROR:  cannot run ${SVCNAME} until sysinit completes"
-	[[ ${RC_COLDPLUG} == "no" ]] && exit 1
-	if [[ ${RC_COLDPLUG} != "yes" ]] ; then
-		for x in ${RC_COLDPLUG} ; do
-			# We don't quote ${x} so we can do globbing
-			[[ ${SVCNAME} == ${x} ]] && break
-			[[ "!${SVCNAME}" == ${x} ]] && exit 1
-		done
-	fi
+	[[ ${RC_COLDPLUG:-yes} != "yes" ]] && exit 1
+	set -f
+	for x in ${RC_PLUG_SERVICES} ; do
+		[[ ${SVCNAME} == ${x} ]] && break
+		[[ "!${SVCNAME}" == ${x} ]] && exit 1
+	done
 	eerror "${SVCNAME} will be started in the ${BOOTLEVEL} runlevel"
 	if [[ ! -L /dev/.rcboot/"${SVCNAME}" ]] ; then
 		[[ ! -d /dev/.rcboot ]] && mkdir /dev/.rcboot
@@ -43,6 +41,24 @@
 	exit 1
 fi
 
+# Only hotplug if we're allowed to
+if [[ ${IN_HOTPLUG} == "1" ]] ; then
+	if [[ ${RC_HOTPLUG:-yes} != "yes" ]] ; then
+		eerror "${SVCNAME} is not allowed to be hotplugged"
+		exit 1
+	fi
+	
+	set -f
+	for x in ${RC_PLUG_SERVICES} ; do
+		[[ ${SVCNAME} == ${x} ]] && break
+		if [[ "!${SVCNAME}" == ${x} ]] ; then
+			eerror "${SVCNAME} is not allowed to be hotplugged"
+			exit 1
+		fi
+	done
+	set +f
+fi
+
 svc_trap() {
 	trap 'eerror "ERROR:  ${SVCNAME} caught an interrupt"; exit 1' \
 		INT QUIT TSTP
Index: sbin/rc-services.sh
===================================================================
--- sbin/rc-services.sh	(revision 2021)
+++ sbin/rc-services.sh	(working copy)
@@ -408,6 +408,7 @@
 		# if we can not start the services in parallel
 		# then just start it and return the exit status
 		( "/etc/init.d/${service}" start )
+		service_started "${service}" || service_inactive "${service}"
 		retval=$?
 		end_service "${service}" "${retval}"
 		splash "svc_started" "${service}" "${retval}"
@@ -415,7 +416,8 @@
 	else
 		# if parallel startup is allowed, start it in background
 		(
-			"/etc/init.d/${service}" start 
+			"/etc/init.d/${service}" start
+			service_started "${service}" || service_inactive "${service}"
 			retval=$?
 			end_service "${service}" "${retval}"
 			splash "svc_started" "${service}" "${retval}"
@@ -458,6 +460,7 @@
 		# if we can not start the services in parallel
 		# then just start it and return the exit status
 		( "/etc/init.d/${service}" stop )
+		service_stopped "${service}"
 		retval=$?
 		end_service "${service}" "${retval}"
 		splash "svc_stopped" "${service}" "${retval}"
@@ -466,6 +469,7 @@
 		# if parallel startup is allowed, start it in background
 		(
 			( "/etc/init.d/${service}" stop )
+			service_stopped "${service}"
 			retval=$?
 			end_service "${service}" "${retval}"
 			splash "svc_stopped" "${service}" "${retval}"
