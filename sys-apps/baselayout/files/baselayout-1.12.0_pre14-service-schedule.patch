Index: sbin/runscript.sh
===================================================================
--- sbin/runscript.sh	(revision 1820)
+++ sbin/runscript.sh	(working copy)
@@ -17,14 +17,14 @@
 
 myscript="$1"
 if [[ -L $1 && ! -L "/etc/init.d/${1##*/}" ]] ; then
-	myservice="$(readlink $1)"
+	myservice="$(readlink "$1")"
 else
 	myservice="$1"
 fi
 
 myservice="${myservice##*/}"
 export SVCNAME="${myservice}"
-mylevel="$(<${svcdir}/softlevel)"
+mylevel="$(< "${svcdir}/softlevel")"
 
 svc_trap() {
 	trap 'eerror "ERROR:  \"${myservice}\" caught an interrupt"; exit 1' \
@@ -59,7 +59,7 @@
 	conf="$(add_suffix /etc/conf.d/net)"
 	[[ -e ${conf} ]] && source "${conf}"
 fi
-conf="$(add_suffix /etc/conf.d/${myservice})"
+conf="$(add_suffix "/etc/conf.d/${myservice}")"
 [[ -e ${conf} ]] && source "${conf}"
 conf="$(add_suffix /etc/rc.conf)"
 [[ -e ${conf} ]] && source "${conf}"
@@ -67,11 +67,11 @@
 # Call svc_quit if we abort AND we have obtained a lock
 svcbegun=1
 service_started "${myservice}"
-svcstarted=$?
+svcstarted="$?"
 service_inactive "${myservice}"
-svcinactive=$?
+svcinactive="$?"
 svc_quit() {
-	eerror "ERROR:  \"${myservice}\" caught an interrupt"
+	eerror "ERROR:  ${myservice} caught an interrupt"
 	if [[ ${svcbegun} == 0 ]] ; then
 		end_service "${myservice}"
 		svcbegun=1
@@ -100,13 +100,13 @@
 }
 
 start() {
-	eerror "ERROR:  \"${myservice}\" does not have a start function."
+	eerror "ERROR:  ${myservice} does not have a start function."
 	# Return failure so the symlink doesn't get created
 	return 1
 }
 
 restart() {
-	svc_restart || return $?
+	svc_restart
 }
 
 status() {
@@ -115,10 +115,10 @@
 }
 
 svc_schedule_restart() {
-	local service="$1"
+	local service="$1" restart="$2"
 	if [[ ! -e "${svcdir}/restart/${service}" ]] \
-		|| ! grep -q "^${myservice}$" "${svcdir}/restart/${service}" ; then
-		echo "${myservice}" >> "${svcdir}/restart/${service}"
+		|| ! grep -q "^${restart}$" "${svcdir}/restart/${service}" ; then
+		echo "${restart}" >> "${svcdir}/restart/${service}"
 	fi
 }
 
@@ -147,7 +147,7 @@
 	trap "svc_quit" INT QUIT TSTP
 	
 	begin_service "${myservice}"
-	svcbegun=$?
+	svcbegun="$?"
 	
 	service_message "Stopping service ${myservice}"
 
@@ -215,13 +215,13 @@
 			eerror "DO NOT USE EXIT IN INIT.D SCRIPTS"
 			eerror "This IS a bug, please fix your broken init.d"
 			unset -f exit
-			exit $@
+			exit "$@"
 		}
 		# Stop einfo/ebegin/eend from working as parallel messes us up
 		[[ ${RC_PARALLEL_STARTUP} == "yes" ]] && RC_QUIET_STDOUT="yes"
 		stop
 		)
-		retval=$?
+		retval="$?"
 
 		# If a service has been marked inactive, exit now as something
 		# may attempt to start it again later
@@ -309,7 +309,7 @@
 	unset IN_BACKGROUND
 	
 	local startupservices="$(trace_dependencies $(ineed "${myservice}") \
-			$(valid_iuse ${myservice}))"
+			$(valid_iuse "${myservice}"))"
 	local netservices="$(dolisting "/etc/runlevels/${BOOTLEVEL}/net.*") \
 			$(dolisting "/etc/runlevels/${mylevel}/net.*")"
 	local startupnetservices=
@@ -332,7 +332,7 @@
 	# We also wait for any services we're after to finish incase they
 	# have a "before" dep but we don't dep on them.
 	if is_runlevel_start ; then
-		startupservices="${startupservices} $(valid_iafter ${myservice})"
+		startupservices="${startupservices} $(valid_iafter "${myservice}")"
 	fi
 
 	# Wait for dependencies to finish.
@@ -348,7 +348,7 @@
 					if ineed -t "${myservice}" "${x}" >/dev/null ; then
 						if ! is_net_up ; then
 							if service_inactive "${y}" ; then
-								svc_schedule_restart "${y}"
+								svc_schedule_restart "${y}" "${myservice}"
 								startinactive="${y}"
 							else
 								startfail="${y}"
@@ -397,13 +397,13 @@
 			eerror "DO NOT USE EXIT IN INIT.D SCRIPTS"
 			eerror "This IS a bug, please fix your broken init.d"
 			unset -f exit
-			exit $@
+			exit "$@"
 		}
 		# Stop einfo/ebegin/eend from working as parallel messes us up
 		[[ ${RC_PARALLEL_STARTUP} == "yes" ]] && RC_QUIET_STDOUT="yes"
 		start
 		)
-		retval=$?
+		retval="$?"
 		
 		# If a service has been marked inactive, exit now as something
 		# may attempt to start it again later
@@ -451,7 +451,7 @@
 	if ! service_stopped "${myservice}" ; then
 		svc_stop || return "$?"
 	fi
-	svc_start || return "$?"
+	svc_start
 }
 
 svc_status() {
@@ -490,9 +490,9 @@
 	[[ ${state} == "started" ]]
 }
 
-rcscript_errors="$(bash -n ${myscript} 2>&1)" || {
+rcscript_errors="$(bash -n "${myscript}" 2>&1)" || {
 	[[ -n ${rcscript_errors} ]] && echo "${rcscript_errors}" >&2
-	eerror "ERROR:  \"${myscript}\" has syntax errors in it; aborting ..."
+	eerror "ERROR:  ${myscript} has syntax errors in it; aborting ..."
 	exit 1
 }
 
@@ -571,9 +571,10 @@
 		retval="$?"
 		
 		if [[ ${IN_BACKGROUND} == "true" ]] ; then
-			res=
 			for x in $(dolisting "${svcdir}/snapshot/$$/") ; do
-				service_stopped "${x##*/}" && svc_schedule_restart "${x##*/}"
+				if service_stopped "${x##*/}" ; then
+					svc_schedule_restart "${myservice}" "${x##*/}"
+				fi
 			done
 		fi
 		
@@ -638,27 +639,23 @@
 			restart
 		fi
 
+		[[ -e "${svcdir}/restart/${myservice}" ]] \
+			&& rm -f "${svcdir}/restart/${myservice}"
+			
 		# Restart dependencies as well
-		if service_started "${myservice}" ; then
-			for x in $(trace_dependencies \
-				$(dolisting "${svcdir}/snapshot/$$/") ) ; do
-				if service_stopped "${x##*/}" ; then
-					start_service "${x##*/}"
-				fi
-			done
-		elif service_inactive "${myservice}" ; then
-			res=
+		if service_inactive "${myservice}" ; then
 			for x in $(dolisting "${svcdir}/snapshot/$$/") ; do
 				if service_stopped "${x##*/}" ; then
-					res="${res}${x##*/} "
+					svc_schedule_restart "${myservice}" "${x##*/}"
 				fi
 			done
-			[[ -n ${res} ]] && echo "${res}" > "${svcdir}/restart/${myservice}"
+		elif service_started "${myservice}" ; then
+			for x in $(trace_dependencies \
+				$(dolisting "${svcdir}/snapshot/$$/") ) ; do
+				service_stopped "${x##*/}" && start_service "${x##*/}"
+			done
 		fi
 
-		# Wait for any services that may still be running ...
-		[[ ${RC_PARALLEL_STARTUP} == "yes" ]] && wait
-
 		rm -rf "${svcdir}/snapshot/$$"
 		svcrestart="no"
 		;;
Index: sbin/rc-daemon.sh
===================================================================
--- sbin/rc-daemon.sh	(revision 1820)
+++ sbin/rc-daemon.sh	(working copy)
@@ -100,7 +100,7 @@
 
 	# We may want to launch the daemon with a custom command
 	# This is mainly useful for debugging with apps like valgrind, strace
-	local bash_service=$( bash_variable "${myservice}" )
+	local bash_service="$( bash_variable "${myservice}" )"
 	eval x=\"\$\{RC_DAEMON_${bash_service}\}\"
 	if [[ -n ${x} ]]; then
 		local -a d=( ${x} )
@@ -117,7 +117,7 @@
 			args="${args} ${d[i]}"
 			unset d[i]
 		done
-		d=$( "${d[@]}" )
+		d=( "${d[@]}" )
 
 		eval args=\"${args} --exec '${d[0]}' -- ${d[@]:1} '${cmd}' ${eargs[@]}\"
 		! ${stopping} && cmd="${d[0]}"
@@ -145,7 +145,7 @@
 				pkill "-${signal}" -s "${pid}"
 				pgrep -s "${pid}" >/dev/null || return 0
 			else
-				local pids=$(ps -eo pid,sid | sed -n 's/'${pid}'$//p')
+				local pids="$(ps -eo pid,sid | sed -n 's/'${pid}'$//p')"
 				[[ -z ${pids} ]] && return 0
 				kill -s "${signal}" ${pids} 2>/dev/null
 				e=false
@@ -216,7 +216,7 @@
 		pidfile="$1"
 	fi
 
-	pids=$( pidof ${cmd} )
+	pids="$( pidof ${cmd} )"
 	[[ -z ${pids} ]] && return 1
 
 	[[ -s ${pidfile} ]] || return 0
@@ -273,7 +273,7 @@
 		if ! is_daemon_running ${cmd} "${pidfile}" ; then
 			[[ ${RC_FAIL_ON_ZOMBIE} == "yes" ]] && return 1
 		fi
-		pids=$( pidof ${cmd} )
+		pids="$( pidof ${cmd} )"
 	fi
 
 	if [[ -s ${pidfile} ]]; then
@@ -293,11 +293,11 @@
 	# two methods
 	if [[ ${RC_KILL_CHILDREN} == "yes" ]]; then
 		if [[ -x /usr/bin/pgrep ]]; then
-			pids="${pids} $(pgrep -P ${pids// /,})"
+			pids="${pids} $(pgrep -P "${pids// /,}")"
 		else
 			local npids
 			for pid in ${pids} ; do
-				npids="${npids} $(ps -eo pid,ppid | sed -n 's/'${pid}'$//p')"
+				npids="${npids} $(ps -eo pid,ppid | sed -n 's/'"${pid}"'$//p')"
 			done
 			pids="${pids} ${npids}"
 		fi
@@ -356,7 +356,7 @@
 # Return the result of start_daemon or stop_daemon depending on
 # how we are called
 start-stop-daemon() {
-	local args=$( requote "$@" ) result i
+	local args="$( requote "$@" )" result i
 	local cmd pidfile pid stopping signal nothing=false 
 	local daemonfile="${svcdir}/daemons/${myservice}"
 	local -a RC_DAEMONS=() RC_PIDFILES=()
Index: sbin/rc-services.sh
===================================================================
--- sbin/rc-services.sh	(revision 1820)
+++ sbin/rc-services.sh	(working copy)
@@ -68,7 +68,7 @@
 	fi
 
 	for (( x=1; x<=${RC_DEPEND_TREE[0]}; x++ )); do
-		index=$(( ${x} * ${rc_index_scale} ))
+		index="$(( ${x} * ${rc_index_scale} ))"
 		if [[ ${myservice} == "${RC_DEPEND_TREE[${index}]}" ]] ; then
 			echo "${index}"
 			return 0
@@ -91,7 +91,7 @@
 	# We already have the right stuff ...
 	[[ ${myservice} == "${rc_name}" && -n ${rc_mtime} ]] && return 0
 
-	rc_index="`get_service_index "${myservice}" "${rc_index}"`"
+	rc_index="$(get_service_index "${myservice}" "${rc_index}")"
 	rc_mtime="${RC_DEPEND_TREE[$((${rc_index} + ${rc_type_mtime}))]}"
 
 	# Verify that we have the correct index (rc_index) ...
@@ -133,7 +133,7 @@
 	fi
 
 	if ! get_dep_info "${myservice}" >/dev/null ; then
-		eerror "Could not get dependency info for \"${myservice}\"!" > /dev/stderr
+		eerror "Could not get dependency info for ${myservice}!" > /dev/stderr
 		eerror "Please run:" > /dev/stderr
 		eerror "  # /sbin/depscan.sh" > /dev/stderr
 		eerror "to try and fix this." > /dev/stderr
@@ -214,10 +214,10 @@
 	[[ -z $1 || -z $2 ]] && return 1
 
 	[[ $2 != "${BOOTLEVEL}" && -e /etc/runlevels/"${BOOTLEVEL}"/.fake ]] && \
-		fake_services=$( < /etc/runlevels/"${BOOTLEVEL}"/.fake )
+		fake_services="$( < /etc/runlevels/"${BOOTLEVEL}"/.fake )"
 
 	[[ -e /etc/runlevels/"$2"/.fake ]] && \
-		fake_services="${fake_services} $( < /etc/runlevels/$2/.fake )"
+		fake_services="${fake_services} $( < /etc/runlevels/"$2"/.fake )"
 
 	for x in ${fake_services} ; do
 		[[ $1 == "${x##*/}" ]] && return 0
@@ -271,7 +271,7 @@
 	local r="${RC_QUIET_STDOUT}"
 	RC_QUIET_STDOUT="no"
 	${cmd} "$@"
-	RC_QUIET_STDOUT=${r}
+	RC_QUIET_STDOUT="${r}"
 }
 
 # bool begin_service( service )
@@ -336,8 +336,9 @@
 
 	# This will block until the service fifo is touched
 	# Otheriwse we don't block
-	$( < "${fifo}" &>/dev/null )
-	local exitstatus=$( < "${svcdir}/exitcodes/${service}" )
+	# We need to use cat instead of the bash inbuilt < so we don't see errors
+	local tmp="$( cat "${fifo}" 2>/dev/null )"
+	local exitstatus="$( < "${svcdir}/exitcodes/${service}" )"
 
 	return "${exitstatus}"
 }
@@ -647,7 +648,7 @@
 
 	# Only worry about net.* services if this is the last one running,
 	# or if RC_NET_STRICT_CHECKING is set ...
-	if [[ "${netcount}" -lt 1 || ${RC_NET_STRICT_CHECKING} == "yes" ]] ; then
+	if [[ ${netcount} -lt 1 || ${RC_NET_STRICT_CHECKING} == "yes" ]] ; then
 		return 1
 	fi
 
@@ -721,7 +722,7 @@
 		fi
 	fi
 
-	net_services=$( cd "${svcdir}"/started; ls net.* 2>/dev/null )
+	net_services="$( cd "${svcdir}"/started; ls net.* 2>/dev/null )"
 	# If no net services are running or we only have net.lo up, then
 	# assume we are in boot runlevel or starting a new runlevel
 	if [[ -z ${net_services} || ${net_services} == "net.lo" ]]; then
@@ -735,9 +736,9 @@
 		}
 
 		local mylevel="${BOOTLEVEL}"
-		local x=$( get_net_services "${mylevel}" )
+		local x="$( get_net_services "${mylevel}" )"
 
-		[[ -f "${svcdir}/softlevel" ]] && mylevel=$( < "${svcdir}/softlevel" )
+		[[ -f "${svcdir}/softlevel" ]] && mylevel="$( < "${svcdir}/softlevel" )"
 		[[ ${BOOTLEVEL} != "${mylevel}" ]] && \
 			local x="${x} $( get_net_services "${mylevel}" )"
 		[[ -n ${x} ]] && net_services="${x}"
@@ -815,7 +816,7 @@
 
 	[[ -z $1 || -z $2 ]] && return 1
 
-	list=$( trace_dependencies "$1" )
+	list="$( trace_dependencies "$1" )"
 
 	net_service "$2" && netservice="yes"
 	
