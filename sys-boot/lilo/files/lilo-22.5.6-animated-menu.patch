diff -urpN lilo-22.5.6/Makefile lilo-22.5.6.gfx/Makefile
--- lilo-22.5.6/Makefile	2003-06-30 05:45:19.000000000 +0200
+++ lilo-22.5.6.gfx/Makefile	2003-08-02 16:29:55.000000000 +0200
@@ -55,7 +55,7 @@ CONFIG=-DBDATA -DDSECS=3 -DEVMS -DIGNORE
 
 # set the compiler optimization level
 
-OPT=-O2
+OPT=-O2 -fomit-frame-pointer
 
 
 # End of configuration variables
@@ -261,15 +261,15 @@ chain.o: chain.s common.s
 first.s:	first.S read.S lilo.h version.h
 		$(CPP) $(PCONFIG) -DFIRST=0x51f92f79 -o first.s first.S
 
-second.s:	second.S read.S volume.S mapper.S biosdata.S shs3.S bdata.h lilo.h version.h \
+second.s:	second.S gfxlogo.S read.S volume.S mapper.S biosdata.S shs3.S bdata.h lilo.h version.h \
 			graph.S menu.S strlen.S bitmap.S display4.S
 		$(CPP) $(PCONFIG) -DTEXT=0x68db3d5c second.S -o second.s
 
-third.s:	second.S read.S volume.S mapper.S biosdata.S bdata.h lilo.h version.h \
+third.s:	second.S gfxlogo.S read.S volume.S mapper.S biosdata.S bdata.h lilo.h version.h \
 			graph.S menu.S strlen.S crt.S
 		$(CPP) $(PCONFIG) -DMENU=0x81cba5a8 second.S -o third.s
 
-bitmap.s:	second.S read.S volume.S mapper.S biosdata.S bdata.h lilo.h version.h \
+bitmap.s:	second.S gfxlogo.S read.S volume.S mapper.S biosdata.S bdata.h lilo.h version.h \
 			strlen.S bitmap.S display4.S
 		$(CPP) $(PCONFIG) -DBITMAP=0x6fcc6176 second.S -o bitmap.s
 
diff -urpN lilo-22.5.6/bsect.c lilo-22.5.6.gfx/bsect.c
--- lilo-22.5.6/bsect.c	2003-06-30 04:34:44.000000000 +0200
+++ lilo-22.5.6.gfx/bsect.c	2003-08-02 16:27:50.000000000 +0200
@@ -756,6 +756,7 @@ printf("MAX_IMAGES = %d\n", MAX_IMAGES);
 	    die("%s is too big (> %d bytes)",message,i);
 	param2.msg_len = bitmap ? (st.st_size+15)/16 : st.st_size;
 	map_begin_section();
+	if(!bitmap)param2.msg_len = st.st_size > 0xffff ? 0xffff : st.st_size;
 #ifndef LCF_UNIFY
 	map_add(&geo,0,((st.st_size)+SECTOR_SIZE-1)/SECTOR_SIZE);
 #else
@@ -1045,6 +1046,7 @@ if (image) { /* long section specific to
 	else if (!strcasecmp(vga,"ext") || !strcasecmp(vga,"extended"))
 		descr->vga_mode = EXTENDED_VGA;
 	else if (!strcasecmp(vga,"ask")) descr->vga_mode = ASK_VGA;
+	else if (!strcasecmp(vga,"inst")) descr->vga_mode = INST_VGA;
 	else descr->vga_mode = to_number(vga);
 #endif
     }
diff -urpN lilo-22.5.6/geometry.c lilo-22.5.6.gfx/geometry.c
--- lilo-22.5.6/geometry.c	2003-06-29 20:52:10.000000000 +0200
+++ lilo-22.5.6.gfx/geometry.c	2003-08-02 16:27:50.000000000 +0200
@@ -26,6 +26,21 @@ source directory.
 
 #include <string.h>
 
+#include <linux/kdev_t.h>      /* for major and minor macros */
+#ifndef BMAP_IOCTL
+# define BMAP_IOCTL 1          /* obsolete - kept for compatibility */
+#endif
+#ifndef FIBMAP
+# define FIBMAP     _IO(0x00,1)  /* bmap access */
+#endif
+#ifndef FIGETBSZ
+# define FIGETBSZ   _IO(0x00,2)
+#endif
+
+#include <sys/statfs.h>
+#include <linux/fd.h>          /* for fdgetprm */
+#include <linux/hdreg.h>       /* for hdio_getgeo */
+
 #include "config.h"
 #include "lilo.h"
 #include "common.h"
@@ -594,6 +609,14 @@ void geo_query_dev(GEOMETRY *geo,int dev
 	    geo->start = hdprm.start;
 	    break;
 
+        case MAJOR_LOOP:
+            geo->device = 0;
+            geo->heads = 2;
+            geo->cylinders = 80;
+            geo->sectors = 18;
+            geo->start = 0;
+            break;
+
 	default:
 	    die("Sorry, don't know how to handle device 0x%04x",device);
     }
diff -urpN lilo-22.5.6/gfxlogo.S lilo-22.5.6.gfx/gfxlogo.S
--- lilo-22.5.6/gfxlogo.S	1970-01-01 02:00:00.000000000 +0200
+++ lilo-22.5.6.gfx/gfxlogo.S	2003-08-02 16:27:50.000000000 +0200
@@ -0,0 +1,569 @@
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; gfx stuff
+;
+; Patch re-adapted and slightly edited from lilo-22.3.4
+; For problems write me: quequero@bitchx.it
+;						Quequero
+;
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+; != 0 -> everything is fine
+gfx_ok:			.byte 0
+
+; we need it at some point
+gfx_tmp:               .word 0
+
+; the memory area we are working with
+gfx_mem:		.long 0		; linear address
+gfx_mem_max:		.long 0		; end address
+gfx_mem_free:		.long 0		; start of free area for malloc (after pcx image)
+
+; interface to loadable gfx extension (seg:ofs values)
+gfx_bc_jt:		.long 0
+
+gfx_bc_init:		.long 0
+gfx_bc_done:		.long 0
+gfx_bc_input:		.long 0
+gfx_bc_menu_init:	.long 0
+gfx_bc_infobox_init:	.long 0
+gfx_bc_infobox_done:	.long 0
+gfx_bc_progress_init:	.long 0
+gfx_bc_progress_done:	.long 0
+gfx_bc_progress_update:	.long 0
+gfx_bc_progress_limit:	.long 0
+gfx_bc_password_init:	.long 0
+gfx_bc_password_done:	.long 0
+
+; system config data
+gfx_sysconfig:
+gfx_sc_vmode:		.byte 0
+gfx_sc_modes:		.byte 0
+gfx_bootloader:		.byte 0
+
+gfx_password_buf:	.blkb 32
+gfx_msg_wrong_image:	.ascii "Could not find kernel image: "
+			.byte 0
+gfx_msg_wrong_password:	.ascii "Sorry, incorrect password."
+			.byte 0
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; I really have no idea how to get as86 to do this properly
+
+		macro farcall
+		.byte 0xff
+		.byte 0x1e
+		.word ?1
+		mend
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_get_sysconfig:
+		xor ax,ax
+		ret
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_set_sysconfig:
+		ret
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; Initialize graphics code. Load and display graphics data.
+;
+;  edi		file length
+;
+;  return:	[gfx_ok] = 0/1
+;
+gfx_init:
+		push es
+
+		cld
+
+		mov byte gfx_ok,#0
+
+		; no gfx if we use a serial line
+		seg fs
+		cmp byte par2_port+SSDIFF,#0
+		jnz near gfx_init_90
+
+		; define our memory area
+		; gfx_mem _must_ be 16-byte aligned
+		mov dword gfx_mem,#0x10000
+		add edi,gfx_mem
+		mov gfx_mem_free,edi
+		mov dword gfx_mem_max,#0x80000
+
+		sub edi,gfx_mem_max
+		neg edi
+		cmp edi,#0x1000		; we need some minimum space
+		jc near gfx_init_80
+
+		; align 4
+		mov eax,gfx_mem_free
+		add eax,#3
+		and eax,#~3
+		mov gfx_mem_free,eax
+
+		push dword gfx_mem
+		call gfx_l2so
+		pop bx
+		pop es
+
+		seg es
+		cmp dword (bx),#0x0b2d97f00	; header.magic_id
+		jnz near gfx_init_80
+		seg es
+		mov al,(bx+4)			; header.version
+		cmp al,#1
+		jb near gfx_init_80
+		cmp al,#2
+		ja near gfx_init_80
+
+		seg es
+		mov eax,(bx+8)
+		or eax,eax
+		jz near gfx_init_80
+		add eax,gfx_mem
+		test al,#0xf
+		jnz near gfx_init_80
+		shr eax,4
+		mov gfx_bc_jt+2,ax
+
+
+		; setup jump table
+		les bx,gfx_bc_jt
+
+		seg es
+		mov ax,(bx)
+		mov gfx_bc_init,ax
+		mov gfx_bc_init+2,es
+
+		seg es
+		mov ax,(bx+2)
+		mov gfx_bc_done,ax
+		mov gfx_bc_done+2,es
+
+		seg es
+		mov ax,(bx+4)
+		mov gfx_bc_input,ax
+		mov gfx_bc_input+2,es
+
+		seg es
+		mov ax,(bx+6)
+		mov gfx_bc_menu_init,ax
+		mov gfx_bc_menu_init+2,es
+
+		seg es
+		mov ax,(bx+8)
+		mov gfx_bc_infobox_init,ax
+		mov gfx_bc_infobox_init+2,es
+
+		seg es
+		mov ax,(bx+10)
+		mov gfx_bc_infobox_done,ax
+		mov gfx_bc_infobox_done+2,es
+
+		seg es
+		mov ax,(bx+12)
+		mov gfx_bc_progress_init,ax
+		mov gfx_bc_progress_init+2,es
+
+		seg es
+		mov ax,(bx+14)
+		mov gfx_bc_progress_done,ax
+		mov gfx_bc_progress_done+2,es
+
+		seg es
+		mov ax,(bx+16)
+		mov gfx_bc_progress_update,ax
+		mov gfx_bc_progress_update+2,es
+
+		seg es
+		mov ax,(bx+18)
+		mov gfx_bc_progress_limit,ax
+		mov gfx_bc_progress_limit+2,es
+
+		seg es
+		mov ax,(bx+20)
+		mov gfx_bc_password_init,ax
+		mov gfx_bc_password_init+2,es
+
+		seg es
+		mov ax,(bx+22)
+		mov gfx_bc_password_done,ax
+		mov gfx_bc_password_done+2,es
+
+		mov eax,gfx_mem
+		mov ebx,gfx_mem_free
+		mov ecx,gfx_mem_max
+		mov dx,cs
+		mov si,#gfx_sysconfig
+
+		; eax	memory start
+		; ebx	free memory start
+		; ecx	memory end
+		; dx	boot loader code segment
+		; si	gfx_sysconfig offset
+
+		farcall(gfx_bc_init)
+
+		jc gfx_init_80
+
+		mov byte gfx_ok,#1
+
+		jmp gfx_init_90
+
+gfx_init_80:
+		mov byte gfx_ok,#0
+gfx_init_90:
+		pop es
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; Back to text mode.
+;
+;  return:	[gfx_ok] = 0
+;
+gfx_done:
+		cmp byte gfx_ok,#0
+		jz gfx_done_90
+		farcall(gfx_bc_done)
+		mov byte gfx_ok,#0
+		call gfx_set_sysconfig
+gfx_done_90:
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_input:
+		cmp byte gfx_ok,#0
+		jz gfx_input_90
+		call gfx_get_sysconfig
+
+		mov ax,#0xffff
+		seg fs
+		xchg ax,par2_timeout
+
+		; map 0xffff -> 0
+		add ax,#1
+		cmc
+		sbb ax,#0
+
+gfx_input_20:
+		mov di,#cmdline
+		mov cx,#CL_LENGTH
+
+		; di	buffer  ( 0 --> no buffer )
+		; cx	buffer size
+		; ax	timeout value (0 --> no timeout)
+
+		farcall(gfx_bc_input)
+
+		pushf
+		call gfx_set_sysconfig
+		popf
+		jnc gfx_input_50
+		mov ax,#1
+gfx_input_50:
+		cmp ax,#1
+		jz gfx_input_80
+
+		call find_boot_image
+		jnc gfx_input_90
+
+		mov si,#gfx_msg_wrong_image
+		mov di,#cmdline
+
+		mov al,#0
+		call gfx_infobox 
+
+		xor ax,ax
+		jmp gfx_input_20
+gfx_input_80:
+		push ax
+		call gfx_done
+		pop ax
+gfx_input_90:
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_setup_menu:
+		cmp byte gfx_ok,#0
+		jz gfx_setup_menu_90
+
+		mov si,#DESCR0
+		mov di,si
+		xor ax,ax
+		mov cx,#IMAGES
+gfx_setup_menu_20:
+		cmp byte (si),#0
+		jz gfx_setup_menu_30
+		inc ax
+		add si,#id_size
+		loop gfx_setup_menu_20
+gfx_setup_menu_30:
+		mov si,di
+		mov dx,#id_size
+
+		; al	menu entries
+		; dx	menu entry size
+		; di	menu entry list
+		; si	default menu entry
+
+		farcall(gfx_bc_menu_init)
+gfx_setup_menu_90:
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_infobox:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_infobox_90
+		farcall(gfx_bc_infobox_init)
+		xor di,di
+		xor ax,ax
+		farcall(gfx_bc_input)
+		farcall(gfx_bc_infobox_done)
+gfx_infobox_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_progress_init:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_progress_init_90
+		movzx eax,ax
+		farcall(gfx_bc_progress_init)
+gfx_progress_init_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_progress_done:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_progress_done_90
+		farcall(gfx_bc_progress_done)
+gfx_progress_done_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_progress_update:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_progress_update_90
+		movzx eax,cx
+		farcall(gfx_bc_progress_update)
+gfx_progress_update_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+gfx_progress_limit:
+		pushad
+		cmp byte gfx_ok,#0
+		jz gfx_progress_limit_90
+		movzx eax,ax
+		farcall(gfx_bc_progress_limit)
+gfx_progress_limit_90:
+		popad
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; ds:di image descr
+;
+gfx_password:
+		push es
+		pushad
+		cmp byte gfx_ok,#0
+		stc
+		jz gfx_password_90
+		push di
+		mov si,#gfx_password_buf        ; not used
+		farcall(gfx_bc_password_init)
+		mov di,#gfx_password_buf
+		mov cx,#32
+		xor ax,ax
+		farcall(gfx_bc_input)
+		mov si,#gfx_password_buf
+		farcall(gfx_bc_password_done)
+		pop di
+		call check_password
+		jnc gfx_password_90
+		mov si,#gfx_msg_wrong_password
+		xor di,di
+		mov al,#0
+		farcall(gfx_bc_infobox_init)
+		xor di,di
+		xor ax,ax
+		farcall(gfx_bc_input)
+		farcall(gfx_bc_infobox_done)
+		stc
+gfx_password_90:
+		popad
+		pop es
+		ret
+
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; Convert 32bit linear address to seg:ofs.
+;
+;  dword [esp + 2]:	linear address
+;
+; return:
+;  dword [esp + 2]:	seg:ofs
+;
+; Notes:
+;  - changes no regs
+;
+gfx_l2so:
+		push eax
+		mov eax,(esp + 6)
+		shr eax,4
+		mov (esp + 8),ax
+		and word (esp + 6),#0xf
+		pop eax
+		ret
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; locate the boot image
+;
+; return:
+;   bx		boot image index
+;   CF		error (image not found)
+;
+find_boot_image:
+		mov dx,#DESCR0
+		mov cx,#IMAGES
+
+		xor bx,bx
+
+find_boot_image_10:
+		mov si,dx
+		mov di,#cmdline
+find_boot_image_20:
+		mov al,(si)
+		or al,al
+		jz find_boot_image_60
+		cmp al,(di)
+		jnz find_boot_image_30
+		inc si
+		inc di
+		jmp find_boot_image_20
+find_boot_image_30:
+		inc bx
+		add dx,#id_size
+		cmp bx,cx
+		jb find_boot_image_10
+		; not found, strip options for fancy error message
+
+		mov si,#cmdline
+		mov cx,#MAX_IMAGE_NAME+1
+find_boot_image_40:
+		cmp byte (si),#0x20+1
+		inc si
+		jb find_boot_image_50
+		loop find_boot_image_40
+find_boot_image_50:
+		mov byte (si-1),#0
+		jmp find_boot_image_80
+find_boot_image_60:
+		mov al,(di)
+		cmp al,#0x20
+		ja find_boot_image_30
+		imul bx,bx,#id_size
+		add bx,#DESCR0
+		jmp find_boot_image_90
+find_boot_image_80:
+		stc
+find_boot_image_90:
+		ret
+
+; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+;
+; ds:di image descr
+;
+; CF = 0: password valid
+;
+check_password:
+#if defined(SHS_PASSWORDS)
+               mov bp,di
+               mov di,#gfx_password_buf
+               mov si,di
+               push ds
+               pop es
+               mov cx,#32 - 1
+               xor al,al
+               repne
+               scasb
+               sub cx,#32 - 1
+               not cx
+               mov bx,cx
+
+               push ss
+               pop es
+               mov cx,#32
+               sub sp,cx
+               mov di,sp
+               rep
+               movsb
+               mov si,sp
+
+               push bp
+
+               push bx         ; length
+               push si         ; ss:si password
+               call _shsInit
+               call _shsUpdate
+               call _shsFinal
+               pop si
+               pop bx
+
+               pop di
+
+               add di,#id_password_crc
+               mov si,#shs_digest
+               mov cx,#MAX_PW_CRC*4
+               push ds
+               pop es
+               repe
+               cmpsb
+               je check_pw_50
+               inc cx
+check_pw_50:
+               add sp,#32
+               pushad          ; clear password buffer
+               mov di,#gfx_password_buf
+               mov cx,#32
+               xor al,al
+               rep
+               stosb
+               popad
+               cmp cx,#1
+               cmc
+#endif
+               ret
+
diff -urpN lilo-22.5.6/lilo.c lilo-22.5.6.gfx/lilo.c
--- lilo-22.5.6/lilo.c	2003-06-30 05:13:13.000000000 +0200
+++ lilo-22.5.6.gfx/lilo.c	2003-08-02 16:27:50.000000000 +0200
@@ -241,6 +241,9 @@ static void show_images(char *map_file)
 			    case ASK_VGA:
 				printf("ASK\n");
 				break;
+                            case INST_VGA:
+                                 printf("INST\n");
+                                 break;
 			    default:
 				printf("%d (0x%04x)\n",
 				  descrs.d.descr[image].vga_mode,
diff -urpN lilo-22.5.6/lilo.h lilo-22.5.6.gfx/lilo.h
--- lilo-22.5.6/lilo.h	2003-06-30 05:46:30.000000000 +0200
+++ lilo-22.5.6.gfx/lilo.h	2003-08-02 16:27:50.000000000 +0200
@@ -61,6 +61,7 @@ source directory.
 #define MAJMIN_RAM	0x101 /* RAM disk */
 #define MAJOR_FD	2 /* floppy disks */
 #define MAJOR_HD	3 /* IDE-type hard disks */
+#define MAJOR_LOOP      7 /* loop device */
 #define MAJOR_SD	8 /* SCSI disks 0-15 */
 #define MAJOR_MD	9 /* multi-disk RAID sets */
 #define MAJOR_XT	13 /* XT-type hard disks */
@@ -273,13 +274,14 @@ source directory.
 
 
 #define VGA_NOCOVR	0x8000	/* VGA setting not overridden on command line */
+#define INST_VGA        0xfff0  /* test for framebuffer at vga=771 */
 
 #define SER_DFL_PRM	0xa3	/* default serial parameters: 2400n8 */
 
 #define DC_MAGIC	0xf4f2	/* magic number of default cmd. line sector */
 #define DC_MGOFF	0x6b6d	/* magic number for disabled line */
 
-#define MAX_MESSAGE	65535	/* maximum message length */
+#define MAX_MESSAGE     8*64*1024-1     /* maximum message length (512k) */
 #define MAX_MENU_TITLE	37	/* maximum MENU title length */
 
 #define NEW_HDR_SIG	"HdrS"	/* setup header signature */
diff -urpN lilo-22.5.6/partition.c lilo-22.5.6.gfx/partition.c
--- lilo-22.5.6/partition.c	2003-06-15 00:49:51.000000000 +0200
+++ lilo-22.5.6.gfx/partition.c	2003-08-02 16:27:50.000000000 +0200
@@ -22,7 +22,14 @@ source directory.
 #include <sys/types.h>
 #include <asm/unistd.h>
 #include <limits.h>
-/*#include <linux/fs.h>*/
+
+#if 0
+# define _LINUX_STRING_H_
+# include <linux/fs.h>
+#else
+# include <linux/kdev_t.h>
+#endif
+
 #include <time.h>
 #include "config.h"
 #include "lilo.h"
diff -urpN lilo-22.5.6/second.S lilo-22.5.6.gfx/second.S
--- lilo-22.5.6/second.S	2003-06-30 04:01:03.000000000 +0200
+++ lilo-22.5.6.gfx/second.S	2003-08-02 16:36:49.000000000 +0200
@@ -614,7 +614,9 @@ extp:	BEG_FS
 	seg	es
 	cmp	byte ptr (si),#0 ! empty ?
 	je	iloop		! yes -> enter interactive mode
-	jmp	niloop		! enter non-interactive mode
+
+niloop0:
+        br      niloop          ! enter non-interactive mode
 
 ! No external parameters after timeout -> boot first image
 
@@ -622,7 +624,7 @@ noex:	push	cs		! restore ES
 	pop	es
 	mov	si,#DFLCMD+2	! default command line ?
 	cmp	byte ptr (si),#0
-	jne	niloop		! yes -> use it
+	jne	niloop0 	! yes -> use it
 	mov	ax,nodfl	! no idea how to tell as86 to do jmp (addr) :-(
 	jmp	ax		! fall through
 
@@ -630,16 +632,23 @@ noex:	push	cs		! restore ES
 ! Command input processor
 
 iloop:
-#if defined(MENU) || defined(BITMAP)
+#ifdef BITMAP	
 	call	menu_setup
 #endif
 
 #ifndef BITMAP
+       cmp     byte gfx_ok,#0
+       jnz     iloop_gfx
+
+       ; load message before doing anything else
+       ; the graphics/text stuff is mixed in a rather messy way...
+
 ;;	BEG_FS
 ;;	SEG_FS		! message disabled ?
 	cmp	word ptr par2_msg_len,#0		;MSG_OFF+SSDIFF,#0
 ;;	END_FS
-	je	nomsg		! yes -> skip this
+        ; _must_ be 'jz'!
+        jz      iloop_20        ! yes -> skip this
 	call	crlf
 ;BEG_FS
 ;SEG_FS		! load the message file
@@ -653,13 +662,91 @@ iloop:
 	call	sread
 	call	loadfile
 
+; es:bx points to file end
+        movzx   ebx,bx
+        xor     edi,edi
+        mov     di,es
+        shl     edi,4
+        add     edi,ebx
+        sub     edi,#SYSSEG * 16
+
+        ; edi -> message file size
+
 	xor	bx,bx		! set the terminating NUL and disable further
 				! messages
 	xchg	bx,par2_msg_len		;MSG_OFF+SSDIFF
 
 	push	#SYSSEG
 	pop	ds
-	mov	byte ptr (bx),#0
+
+
+        cmp     dword ptr 0,#0x0b2d97f00                ; magic header
+        ; _must_ be 'jnz'!
+        jnz     iloop_10
+
+        push    cs
+        pop     ds
+
+        ; graphical message
+
+        call    gfx_init
+        push    cs
+        pop     es
+        cmp     byte gfx_ok,#0
+        jz      iloop
+        call    gfx_setup_menu
+iloop_gfx:
+        push    cs
+        pop     es
+        call    gfx_input
+        cmp     ax,#1
+        jz      iloop           ; text mode
+        mov     gfx_tmp,bx
+        jmp     near scan_cmdline
+
+        ; normal text message
+iloop_10:
+        ; keep the zero flag!
+        mov     byte ptr (bx),#0
+        push    cs
+        pop     ds
+
+iloop_20:
+#ifdef MENU
+        pushf
+        call    menu_setup
+        popf
+#endif
+        jnz     totxt
+        mov     ax,showit
+        mov     dx,showit+2
+        mov     bx,ax
+        or      bx,dx
+        jz      iloop_40
+        push    ds
+        shl     dx,12
+        mov     bx,ax
+        and     bx,#0xf
+        shr     ax,4
+        add     ax,dx
+        add     ax,#SYSSEG
+        mov     ds,ax
+        call    say
+        pop     ds
+        xor     ax,ax
+        mov     showit,ax
+        mov     showit+2,ax
+iloop_40:
+
+        jmp nomsg
+
+showit:
+        .long   0
+
+totxt:
+        push    #SYSSEG
+        pop     ds
+
 	xor	bx,bx		! display the message
 	call	say
 
@@ -695,12 +782,6 @@ input:	seg	es		! interactive mode ?
 	mov	al,(si)
 	inc	si
 	jmp	gotinp		! go on
-	
-tolist:
-#ifdef BITMAP
-	call	menu_exit
-#endif
-	br	list		! ...
 
 kbinp:	mov	cx,#brto	! get a key
 	call	getkey
@@ -727,8 +808,6 @@ gotinp:	cmp	al,#9		! TAB ?
 	je	nul		! yes -> go on
 	cmp	al,#8		! BS ?
 	je	todelch		! yes -> erase one character
-	cmp	al,#13		! CR ?
-	je	cr		! yes -> go on
 	cmp	al,#127		! DEL ?
 	je	todelch		! yes -> erase one character
 	ja	input		! non-printable -> ignore it
@@ -736,6 +815,8 @@ gotinp:	cmp	al,#9		! TAB ?
 	je	todell		! yes -> erase the line
 	cmp	al,#24		! ^X ?
 	je	todell		! yes -> erase the line
+        cmp     al,#13          ! CR ?
+	je      cr              ! yes -> go on
 	cmp	al,#32		! ignore non-printable characters except space
 	jb	input
 	ja	noblnk		! no space -> go on
@@ -778,6 +859,11 @@ sknext:	add	di,#id_size	! test next entr
 
 todelch:br	delch		! ...
 todell:	br	delline		! ...
+tolist:
+#ifdef BITMAP
+       call    menu_exit
+#endif
+       br      list            ! ...
 
 ! End of input, process the command line
 
@@ -819,6 +905,7 @@ cpsav:	lodsb			! copy one byte
 	or	al,al		! at end ?
 	jnz	cpsav		! no -> go on
 
+scan_cmdline:
 	cmp	bx,#cmdline	! empty line ?
 	je	notrspc		! yes -> boot first image
 	cmp	byte ptr (bx-1),#32 ! trailing space ?
@@ -876,6 +963,11 @@ vsknb:
 	je	chkvga		! yes -> look for options again
 	or	al,al		! at end ?
 	jnz	vsknb		! no -> go on
+
+        mov     bx,gfx_tmp
+        cmp     byte gfx_ok,#0
+        jnz     near boot
+
 	call	crlf		! write CR/LF
 	cmp	di,#cmdline+1	! empty line ?
 emptyl:	je	bfirst		! yes -> boot first image
@@ -1087,6 +1179,16 @@ dopw:
 ;;	SEG_FS
 	mov	word ptr par2_timeout,#0xffff	; cancel timeout
 ;;	END_FS
+
+       cmp     byte gfx_ok,#0
+       jz      dopw_nogfx
+       mov     di,bx
+       call    gfx_password
+       pop     bx
+       jnc     toboot
+       jmp     near iloop
+dopw_nogfx:
+
 	mov	bx,#msg_pw	! display a prompt
 	call	say
 
@@ -1257,7 +1359,8 @@ pwcleanup:
 	pop	bp
 	pop	bx
 	or	cx,cx		; test CX==0 means all okay
-	jz	doboot
+        jnz     pwfail
+        br      doboot
 ; fall into pwfail	
 
 #else
@@ -1314,16 +1417,158 @@ pwcr:	call	crlf
 	or	cl,cl		! no errors ?
 	jnz	pwfail		! no -> fail
 	cmp	byte ptr (si),#0 ! at end ?
-	je	doboot		! yes -> continue booting
+        jne     pwfail          ! yes -> continue booting
+        br      doboot
+
 #endif	/* CRC_PASSWORDS */
 
 pwfail:	mov	bx,#msg_pf	! display an error message
 	call	say
 	br	iloop		! get next input
 
+!      Test if the monitor can display a vga mode
+!      mode in ax, returns ax if success, otherwise 0
+montest:
+       push    es
+       push    di
+       push    bx
+       push    cx
+       push    dx
+       push    ax
+       push    #0
+       pop     es
+       mov     di,#0xfc00
+       xor     cx,cx
+       seg     es
+       mov     0xfc23,cx
+       xor     dx,dx
+       mov     bx,#1
+       mov     ax,#0x4f15
+       int     0x10
+       cmp     ax,#0x4f
+       pop     ax
+       jnz     monno
+       mov     bx,ax
+       sub     bx,#0x100
+       cmp     bx,#0x1c
+       jnb     monno
+       seg     cs
+       mov     bl,monbits(bx)
+       xor     bh,bh
+       seg     es
+       mov     cx,0xfc23
+       or      cx,cx
+       jnz     nofsc
+       call    fscscan
+nofsc: and     cl,#0xfe
+       bt      cx,bx
+       jc      monok
+monno: xor     ax,ax
+monok: pop     dx
+       pop     cx
+       pop     bx
+       pop     di
+       pop     es
+       ret
+
+monbits:
+       .byte   5,5,9,9,14,14,15,15,0,0,0,0,0,0,0,0
+       .byte   5,5,5,9,9,9,14,14,14,15,15,15
+
+!      return in cx the bits for FSC notebooks.
+fscscan:
+       push    ds
+       push    si
+       push    di
+       push    ax
+       push    bx
+       push    #0xf000
+       pop     ds
+       xor     di,di
+fscnn: cmp     dword ptr (di),#0x696a7546
+       jnz     fscn
+       cmp     dword ptr 4(di),#0x20757374
+       jnz     fscn
+       mov     cx,#0x20
+       xor     bx,bx
+       mov     si,di
+fscsig:        lodsb
+       add     bl,al
+       dec     cx
+       jnz     fscsig
+       or      bl,bl
+       jnz     fscn
+       mov     al,23(di)
+       and     al,#0xf0
+       jnz     fscbad
+       mov     bl,21(di)
+       and     bx,#0xf0
+       shr     bx,#3
+       seg     cs
+       mov     cx,fscbits(bx)
+       jmp     fscok
+fscn:  add     di,#0x10
+       jnz     fscnn
+fscbad:        xor     cx,cx
+fscok: pop     bx
+       pop     ax
+       pop     di
+       pop     si
+       pop     ds
+       ret
+
+fscbits:
+       .word   0,0x0020,0x0200,0x4000,0x8000,0x8000,0,0
+       .word   0x8000,0,0,0,0,0,0,0
+
+!      Test if the driver can display a vga mode
+!      mode in ax, returns ax if success, otherwise 0
+vgatest:
+       push    es
+       push    di
+       push    bx
+       push    cx
+       push    dx
+       push    ax
+       push    #0
+       pop     es
+       mov     cx,ax
+       xor     ax,ax
+       seg     es
+       mov     0xfc00+0x28,ax
+       seg     es
+       mov     0xfc00+0x2a,ax
+       mov     di,#0xfc00
+       mov     ax,#0x4f01
+       int     0x10
+       cmp     ax,#0x4f
+       jnz     vgano
+       seg     es
+       mov     ax,0xfc00
+       and     ax,#0x99
+       cmp     ax,#0x99
+       jnz     vgano
+       seg     es
+       mov     ax,0xfc00+0x28
+       seg     es
+       or      ax,0xfc00+0x2a
+       jz      vgano
+       pop     ax
+       jmp     vgayes
+vgano: pop     ax
+       xor     ax,ax
+vgayes:        pop     dx
+       pop     cx
+       pop     bx
+       pop     di
+       pop     es
+       ret
+
 ! Boot the image BX points to
 
-doboot:	mov	byte ptr prechr,#61 ! switch to equal sign
+doboot:
+       call    gfx_done
+       mov     byte ptr prechr,#61 ! switch to equal sign
 	push	bx		! save image descr
 	mov	bx,#msg_l	! say hi
 	call	say
@@ -1478,8 +1723,36 @@ cpdone:
 	jmp	vgaset
 vganorm:test	bx,#FLAG_VGA
 	jz	novga
-vgaset:	seg	es
-	 mov	[VGA_SET],ax	! magic offset in the boot sector
+vgaset:
+#ifdef NORMAL_VGA
+	cmp	ax,#INST_VGA
+	jnz	vganoi
+	mov	ax,#0x117
+	call	vgatest
+	or	ax,ax
+	jz	vga2
+	call	montest
+	or	ax,ax
+	jnz	vga3
+vga2:
+	mov	ax,#0x114
+	call	vgatest
+	or	ax,ax
+	jz	vga4
+	call	montest
+	or	ax,ax
+	jnz	vga3
+vga4:
+	mov	ax,#0x101
+	call	vgatest
+	or	ax,ax
+	jnz	vga3
+	mov	ax,#NORMAL_VGA-0x0200
+vga3:
+	add	ax,#0x200
+#endif
+vganoi: seg     es
+	mov	[VGA_SET],ax	! magic offset in the boot sector
 novga:	push	bx		! use flags (BX) later
 	test	bx,#FLAG_LOCK	! ... lock target ?
 	jnz	lockit		! yup -> do it
@@ -1492,8 +1765,8 @@ lockit:
 	push	es
 	push	si
 
-        push    ds                      ;
-        pop     es                      ;
+	push	ds                      ;
+	pop	es                      ;
 	call	cmd_write		; write out the command line
 
 	pop	si
@@ -1506,7 +1779,7 @@ nolock:
 #endif
 	xor	cx,cx
 	seg	es
-	  add	cl,[VSS_NUM]
+	add	cl,[VSS_NUM]
 ;;;	or	cx,cx
 	jnz	lsetup
 	mov	cl,#SETUPSECS	! default is to load four sectors
@@ -3246,6 +3519,8 @@ vganum:	pop	si		! get SI
 	jmp	vgaput1
 #else
 	xor	cx,cx
+        mov     bh,ch
+        mov     bl,#10          ; bx: base (_not_ bl!)
 	mov	ah,cl
 	test	byte ptr (si),#0xff ! no value ?
 	jz	vgaerr		! yes -> error
@@ -3254,17 +3529,45 @@ vgadig:	lodsb			! get the next character
 	jz	vgaput		! yes -> done
 	cmp	al,#32
 	je	vgaput
-	cmp	al,#48		! is it a digit ?  (0x30=48="0")
-	jb	vgaerr		! no -> error
-	cmp	al,#57		! 57=0x39="9"
-	ja	vgaerr
-	sub	al,#48		! cx = cx*10+al-'0'
-	imul	cx,#10
+        cmp     al,#0x61
+        jb      vgadig_10
+        sub     al,#0x20        ; upper case
+vgadig_10:
+        or      cx,cx
+        jnz vgadig_20
+        cmp     al,#0x58
+        jnz vgadig_20
+        mov     bl,#16          ; hex
+        jmp     vgadig
+vgadig_20:
+        cmp     al,#0x3a
+        jb      vgadig_30
+        sub     al,#7
+vgadig_30:
+        sub     al,#0x30
+        jb      vgaerr          ; not a digit
+        cmp     al,bl
+        jae     vgaerr          ; larger than current base
+        imul    cx,bx
+
 	add	cx,ax
 	jnc	vgadig		! next one
 #endif
 
-vgaerr:	mov	bx,#msg_v	! display an error message
+vgaerr:
+        mov     bx,#msg_v       ! display an error message
+        cmp     byte gfx_ok,#0
+        jz      vgaerr_txt
+        lea     si,(bx+1)       ; skip initial NL
+        xor     di,di
+        mov     al,#0
+        mov     msg_v1,al       ; drop final NL
+        call    gfx_infobox
+        mov     byte msg_v1,#10 ; put it back
+        stc
+        ret
+vgaerr_txt:
+
 	call	say
 /* ifdef HIGHMEM_MAX */
 	xor	eax,eax
@@ -3285,6 +3588,9 @@ vgatab:
 	.ascii	"EXT"
 	.byte	0
 	.word	NORMAL_VGA
+        .byte   0
+        .word   INST_VGA
+        .ascii  "INST"
 	.ascii	"NORMAL"
 	.byte	0
 #endif
@@ -3365,7 +3671,9 @@ getmem:
 	inc	si		! skip '@'
 	call	get_K
 	pop	edx		! restore size
-	jc	memerr
+;;;     jc      memerr
+        je       gmmull
+        br      s2lbad
 	cmp	eax,#1024	! start : 1meg
 	ja	gmcopy		! just copy if above
 	add	eax,edx		! EAX = hma/1024
@@ -3375,7 +3683,9 @@ gm22:
 	or	bl,#0x20
 	cmp	bl,#0x20	! NUL or SPACE
 #if 0
-	jne	memerr
+;;;     jne     memerr
+        je      gmmull
+        br      s2lbad
 #else
 	jne	gmcopy		! allow <size>#<start> and <size>$<start>
 #endif
@@ -3387,6 +3697,7 @@ gmret:	ret
 gmnocopy:  pop	bx
 	ret
 
+#include       "gfxlogo.S"
 
 memerr:
 	mov	bx,#msg_me	! numeric conversion error
@@ -3588,8 +3899,8 @@ msg_pf:	.ascii	"Sorry."
 
 msg_v:	.byte	10
 	.ascii	"Valid vga values are ASK, NORMAL, EXTENDED or a "
-	.ascii	"decimal number."
-	.byte	10,0
+        .ascii  "number."
+msg_v1:        .byte   10,0
 
 msg_pks:.byte	10
 	.ascii	"Invalid hexadecimal number. - Ignoring remaining items."
