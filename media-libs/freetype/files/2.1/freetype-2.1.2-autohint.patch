--- freetype-2.1.2/src/autohint/ahglobal.c.autohint	Sat Mar 30 08:16:33 2002
+++ freetype-2.1.2/src/autohint/ahglobal.c	Fri Aug  9 13:50:28 2002
@@ -368,7 +368,6 @@
       limit        = segments + outline->num_vsegments;
       widths       = globals->widths;
       p_num_widths = &globals->num_widths;
-
     }
 
     /* Now, compute the edge distance threshold as a fraction of the */
--- freetype-2.1.2/src/autohint/ahglyph.c.autohint	Mon Jun 10 19:03:35 2002
+++ freetype-2.1.2/src/autohint/ahglyph.c	Fri Aug  9 13:50:28 2002
@@ -815,7 +815,7 @@
             segment_dir = point->out_dir;
 
             /* clear all segment fields */
-            FT_MEM_SET( segment, 0, sizeof ( *segment ) );
+            FT_ZERO( segment );
 
             segment->dir      = segment_dir;
             segment->flags    = ah_edge_normal;
@@ -877,7 +877,7 @@
         if ( min_point )
         {
           /* clear all segment fields */
-          FT_MEM_SET( segment, 0, sizeof ( *segment ) );
+          FT_ZERO( segment );
 
           segment->dir   = segment_dir;
           segment->flags = ah_edge_normal;
@@ -893,7 +893,7 @@
         if ( max_point )
         {
           /* clear all segment fields */
-          FT_MEM_SET( segment, 0, sizeof ( *segment ) );
+          FT_ZERO( segment );
 
           segment->dir   = segment_dir;
           segment->flags = ah_edge_normal;
@@ -983,20 +983,20 @@
               if ( max > seg2->max_coord )
                 max = seg2->max_coord;
 
-              len   = max - min;
-              dist  = seg2->pos - seg1->pos;
-              if ( dist < 0 )
-                dist = -dist;
-
-              if ( len < 8 )
-                score = 300*8 + dist - len*3;
-              else
-                score = dist + 300/len;
-
-              if ( score < best_score )
+              len = max - min;
+              if ( len >= 8 )
               {
-                best_score   = score;
-                best_segment = seg2;
+                dist = seg2->pos - seg1->pos;
+                if ( dist < 0 )
+                  dist = -dist;
+  
+                score = dist + 3000 / len;
+  
+                if ( score < best_score )
+                {
+                  best_score   = score;
+                  best_segment = seg2;
+                }
               }
             }
           }
@@ -1009,7 +1009,6 @@
           best_segment->num_linked++;
         }
 
-
       } /* edges 1 */
 
       /* now, compute the `serif' segments */
@@ -1116,7 +1115,7 @@
           edge_limit++;
 
           /* clear all edge fields */
-          FT_MEM_SET( edge, 0, sizeof ( *edge ) );
+          FT_MEM_ZERO( edge, sizeof ( *edge ) );
 
           /* add the segment to the new edge's list */
           edge->first    = seg;
--- freetype-2.1.2/src/autohint/ahhint.c.autohint	Sat Mar 30 08:16:33 2002
+++ freetype-2.1.2/src/autohint/ahhint.c	Fri Aug  9 13:50:28 2002
@@ -30,7 +30,7 @@
 #define FACE_GLOBALS( face )  ((AH_Face_Globals*)(face)->autohint.data)
 
 #define AH_USE_IUP
-
+#define OPTIM_STEM_SNAP
 
   /*************************************************************************/
   /*************************************************************************/
@@ -40,7 +40,7 @@
   /*************************************************************************/
   /*************************************************************************/
 
-
+#if 0
   /* snap a given width in scaled coordinates to one of the */
   /* current standard widths                                */
   static FT_Pos
@@ -51,6 +51,7 @@
     int     n;
     FT_Pos  best      = 64 + 32 + 2;
     FT_Pos  reference = width;
+    FT_Pos  scaled;
 
 
     for ( n = 0; n < count; n++ )
@@ -70,41 +71,79 @@
       }
     }
 
+    scaled = (reference+32) & -64;
+
     if ( width >= reference )
     {
-      width -= 0x21;
-      if ( width < reference )
+      if ( width < scaled + 48 )
         width = reference;
     }
     else
     {
-      width += 0x21;
-      if ( width > reference )
+      if ( width > scaled - 48 )
         width = reference;
     }
 
     return width;
   }
+#endif
 
-
-  /* align one stem edge relative to the previous stem edge */
-  static void
-  ah_align_linked_edge( AH_Hinter*  hinter,
-                        AH_Edge*    base_edge,
-                        AH_Edge*    stem_edge,
-                        int         vertical )
+  /* compute the snapped width of a given stem */
+  static FT_Pos
+  ah_compute_stem_width( AH_Hinter*  hinter,
+                         int         vertical,
+                         FT_Pos      width )
   {
-    FT_Pos       dist    = stem_edge->opos - base_edge->opos;
     AH_Globals*  globals = &hinter->globals->scaled;
-    FT_Pos       sign    = 1;
+    FT_Pos       dist    = width;
+    FT_Int       sign    = 0;
 
 
     if ( dist < 0 )
     {
-      dist = -dist;
-      sign = -1;
+      dist = -width;
+      sign = 1;
     }
 
+#if 1
+    if ( dist < 64 )
+      dist = 64;
+
+    {
+      FT_Pos  delta = dist - globals->stds[vertical];
+
+
+      if ( delta < 0 )
+        delta = -delta;
+
+      if ( delta < 40 )
+      {
+        dist = globals->stds[vertical];
+        if ( dist < 32 )
+          dist = 32;
+      }
+
+      if ( dist < 3 * 64 )
+      {
+        delta = ( dist & 63 );
+        dist &= -64;
+
+        if ( delta < 10 )
+          dist += delta;
+
+        else if ( delta < 32 )
+          dist += 10;
+
+        else if ( delta < 54 )
+          dist += 54;
+
+        else
+          dist += delta;
+      }
+      else
+        dist = ( dist + 32 ) & -64;
+    }
+#else
     if ( vertical )
     {
       dist = ah_snap_width( globals->heights, globals->num_heights, dist );
@@ -138,14 +177,33 @@
           dist = ( dist + 64 ) >> 1;
 
         else if ( dist < 128 )
-          dist = ( dist + 42 ) & -64;
+          dist = ( dist + 22 ) & -64;
         else
           /* XXX: round otherwise, prevent color fringes in LCD mode */
           dist = ( dist + 32 ) & -64;
       }
     }
+#endif
+
+    if ( sign )
+      dist = -dist;
+
+    return dist;
+  }
 
-    stem_edge->pos = base_edge->pos + sign * dist;
+
+  /* align one stem edge relative to the previous stem edge */
+  static void
+  ah_align_linked_edge( AH_Hinter*  hinter,
+                        AH_Edge*    base_edge,
+                        AH_Edge*    stem_edge,
+                        int         vertical )
+  {
+    FT_Pos  dist = stem_edge->opos - base_edge->opos;
+
+
+    stem_edge->pos = base_edge->pos +
+                     ah_compute_stem_width( hinter, vertical, dist );
   }
 
 
@@ -168,6 +226,10 @@
       sign = -1;
     }
 
+#if 0
+    if ( dist < 32 )
+      dist = 32;
+#else
     /* do not strengthen serifs */
     if ( base->flags & ah_edge_done )
     {
@@ -179,6 +241,7 @@
       else
         dist = 0;
     }
+#endif
 
     serif->pos = base->pos + sign * dist;
   }
@@ -286,12 +349,12 @@
 
         /* now, align the stem */
 
-        /* this should not happen, but it's better to be safe.. */
+        /* this should not happen, but it's better to be safe. */
         if ( edge2->blue_edge || edge2 < edge )
         {
 
 #if 0
-          printf( "strange blue alignement, edge %d to %d\n",
+          printf( "strange blue alignment, edge %d to %d\n",
                   edge - edges, edge2 - edges );
 #endif
 
@@ -301,39 +364,66 @@
         }
 
         {
+#if 0
           FT_Bool  min = 0;
-          FT_Pos   delta;
+#endif
+
 
           if ( !anchor )
           {
             edge->pos = ( edge->opos + 32 ) & -64;
             anchor    = edge;
+
+            edge->flags |= ah_edge_done;
+
+            ah_align_linked_edge( hinter, edge, edge2, dimension );
           }
           else
-            edge->pos = anchor->pos +
-                        ( ( edge->opos - anchor->opos + 32 ) & -64 );
+          {
+            FT_Pos   org_pos, org_len, org_center, cur_len;
+            FT_Pos   cur_pos1, cur_pos2, delta1, delta2;
 
-          edge->flags |= ah_edge_done;
 
-          if ( edge > edges && edge->pos < edge[-1].pos )
-          {
-            edge->pos = edge[-1].pos;
-            min       = 1;
-          }
+            org_pos    = anchor->pos + (edge->opos - anchor->opos);
+            org_len    = edge2->opos - edge->opos;
+            org_center = org_pos + ( org_len >> 1 );
 
-          ah_align_linked_edge( hinter, edge, edge2, dimension );
-          delta = 0;
-          if ( edge2 + 1 < edge_limit        &&
-               edge2[1].flags & ah_edge_done )
-            delta = edge2[1].pos - edge2->pos;
+            cur_len    = ah_compute_stem_width( hinter, dimension, org_len );
 
-          if ( delta < 0 )
-          {
-            edge2->pos += delta;
-            if ( !min )
-              edge->pos += delta;
+            cur_pos1   = ( org_pos + 32 ) & -64;
+            delta1     = ( cur_pos1 + ( cur_len >> 1 ) - org_center );
+            if ( delta1 < 0 )
+              delta1 = -delta1;
+
+            cur_pos2   = ( ( org_pos + org_len + 32 ) & -64 ) - cur_len;
+            delta2     = ( cur_pos2 + ( cur_len >> 1 ) - org_center );
+            if ( delta2 < 0 )
+              delta2 = -delta2;
+
+            edge->pos  = ( delta1 <= delta2 ) ? cur_pos1 : cur_pos2;
+            edge2->pos = edge->pos + cur_len;
+
+            edge->flags  |= ah_edge_done;
+            edge2->flags |= ah_edge_done;
+
+            if ( edge > edges && edge->pos < edge[-1].pos )
+              edge->pos = edge[-1].pos;
+
+#if 0
+            delta = 0;
+            if ( edge2 + 1 < edge_limit        &&
+                 edge2[1].flags & ah_edge_done )
+              delta = edge2[1].pos - edge2->pos;
+
+            if ( delta < 0 )
+            {
+              edge2->pos += delta;
+              if ( !min )
+                edge->pos += delta;
+            }
+            edge2->flags |= ah_edge_done;
+#endif
           }
-          edge2->flags |= ah_edge_done;
         }
       }
 
@@ -348,9 +438,7 @@
           continue;
 
         if ( edge->serif )
-        {
           ah_align_serif_edge( hinter, edge->serif, edge, dimension );
-        }
         else if ( !anchor )
         {
           edge->pos = ( edge->opos + 32 ) & -64;
@@ -855,6 +943,9 @@
     for ( n = 0; n < design->num_heights; n++ )
       scaled->heights[n] = FT_MulFix( design->heights[n], y_scale );
 
+    scaled->stds[0] = ( design->num_widths  > 0 ) ? scaled->widths[0]  : 32000;
+    scaled->stds[1] = ( design->num_heights > 0 ) ? scaled->heights[0] : 32000;
+
     /* scale the blue zones */
     for ( n = 0; n < ah_blue_max; n++ )
     {
@@ -1030,6 +1121,7 @@
     {
       FT_Matrix  imatrix;
 
+
       imatrix              = internal->glyph_matrix;
       hinter->trans_delta  = internal->glyph_delta;
       hinter->trans_matrix = imatrix;
--- freetype-2.1.2/src/autohint/ahoptim.c.autohint	Fri Apr 12 05:31:45 2002
+++ freetype-2.1.2/src/autohint/ahoptim.c	Fri Aug  9 13:50:28 2002
@@ -814,7 +814,7 @@
     FT_Error  error;
 
 
-    FT_MEM_SET( optimizer, 0, sizeof ( *optimizer ) );
+    FT_MEM_ZERO( optimizer, sizeof ( *optimizer ) );
     optimizer->outline = outline;
     optimizer->memory  = memory;
 
--- freetype-2.1.2/src/autohint/ahtypes.h.autohint	Sat Mar 30 08:16:33 2002
+++ freetype-2.1.2/src/autohint/ahtypes.h	Fri Aug  9 13:50:28 2002
@@ -423,6 +423,8 @@
     FT_Int  num_widths;
     FT_Int  num_heights;
 
+    FT_Pos  stds[2];
+
     FT_Pos  widths [AH_MAX_WIDTHS];
     FT_Pos  heights[AH_MAX_HEIGHTS];
 
