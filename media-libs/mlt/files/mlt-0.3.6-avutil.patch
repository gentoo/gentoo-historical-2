http://mlt.svn.sourceforge.net/viewvc/mlt?view=rev&revision=1376

Index: src/modules/avformat/filter_swscale.c
===================================================================
--- src/modules/avformat/filter_swscale.c	(revision 1375)
+++ src/modules/avformat/filter_swscale.c	(revision 1376)
@@ -33,6 +33,11 @@
 #include <string.h>
 #include <assert.h>
 
+#if LIBAVUTIL_VERSION_INT < (50<<16)
+#define PIX_FMT_RGB32 PIX_FMT_RGBA32
+#define PIX_FMT_YUYV422 PIX_FMT_YUV422
+#endif
+
 static inline int is_big_endian( )
 {
 	union { int i; char c[ 4 ]; } big_endian_test;
@@ -51,10 +56,10 @@
 			value = PIX_FMT_RGB24;
 			break;
 		case mlt_image_rgb24a:
-			value = PIX_FMT_RGBA32;
+			value = PIX_FMT_RGB32;
 			break;
 		case mlt_image_yuv422:
-			value = PIX_FMT_YUV422;
+			value = PIX_FMT_YUYV422;
 			break;
 		case mlt_image_yuv420p:
 			value = PIX_FMT_YUV420P;
@@ -109,7 +114,7 @@
 	avpicture_fill( &output, outbuf, oformat, owidth, oheight );
 
 	// Extract the alpha channel
-	if ( iformat == PIX_FMT_RGBA32 && oformat == PIX_FMT_YUV422 )
+	if ( iformat == PIX_FMT_RGB32 && oformat == PIX_FMT_YUYV422 )
 	{
 		// Allocate the alpha mask
 		uint8_t *alpha = mlt_pool_alloc( iwidth * ( iheight + 1 ) );
@@ -118,7 +123,7 @@
 			// Convert the image and extract alpha
 			mlt_convert_rgb24a_to_yuv422( *image, iwidth, iheight, iwidth * 4, outbuf, alpha );
 			mlt_properties_set_data( properties, "alpha", alpha, iwidth * ( iheight + 1 ), ( mlt_destructor )mlt_pool_release, NULL );
-			iformat = PIX_FMT_YUV422;
+			iformat = PIX_FMT_YUYV422;
 			avpicture_fill( &input, outbuf, iformat, iwidth, iheight );
 			avpicture_fill( &output, *image, oformat, owidth, oheight );
 		}
Index: src/modules/avformat/consumer_avformat.c
===================================================================
--- src/modules/avformat/consumer_avformat.c	(revision 1375)
+++ src/modules/avformat/consumer_avformat.c	(revision 1376)
@@ -41,6 +41,11 @@
 #endif
 #include <opt.h>
 
+#if LIBAVUTIL_VERSION_INT < (50<<16)
+#define PIX_FMT_RGB32 PIX_FMT_RGBA32
+#define PIX_FMT_YUYV422 PIX_FMT_YUV422
+#endif
+
 //
 // This structure should be extended and made globally available in mlt
 //
@@ -810,7 +815,7 @@
 
 	// Need two av pictures for converting
 	AVFrame *output = NULL;
-	AVFrame *input = alloc_picture( PIX_FMT_YUV422, width, height );
+	AVFrame *input = alloc_picture( PIX_FMT_YUYV422, width, height );
 
 	// For receiving images from an mlt_frame
 	uint8_t *image;
@@ -1102,17 +1107,17 @@
 
 						// Do the colour space conversion
 #ifdef SWSCALE
-						struct SwsContext *context = sws_getContext( width, height, PIX_FMT_YUV422,
+						struct SwsContext *context = sws_getContext( width, height, PIX_FMT_YUYV422,
 							width, height, video_st->codec->pix_fmt, SWS_FAST_BILINEAR, NULL, NULL, NULL);
 						sws_scale( context, input->data, input->linesize, 0, height,
 							output->data, output->linesize);
 						sws_freeContext( context );
 #else
-						img_convert( ( AVPicture * )output, video_st->codec->pix_fmt, ( AVPicture * )input, PIX_FMT_YUV422, width, height );
+						img_convert( ( AVPicture * )output, video_st->codec->pix_fmt, ( AVPicture * )input, PIX_FMT_YUYV422, width, height );
 #endif
 
 						// Apply the alpha if applicable
-						if ( video_st->codec->pix_fmt == PIX_FMT_RGBA32 )
+						if ( video_st->codec->pix_fmt == PIX_FMT_RGB32 )
 						{
 							uint8_t *alpha = mlt_frame_get_alpha_mask( frame );
 							register int n;
Index: src/modules/avformat/filter_avcolour_space.c
===================================================================
--- src/modules/avformat/filter_avcolour_space.c	(revision 1375)
+++ src/modules/avformat/filter_avcolour_space.c	(revision 1376)
@@ -27,6 +27,11 @@
 #include <swscale.h>
 #endif
 
+#if LIBAVUTIL_VERSION_INT < (50<<16)
+#define PIX_FMT_RGB32 PIX_FMT_RGBA32
+#define PIX_FMT_YUYV422 PIX_FMT_YUV422
+#endif
+
 #include <stdio.h>
 #include <stdlib.h>
 
@@ -48,10 +53,10 @@
 			value = PIX_FMT_RGB24;
 			break;
 		case mlt_image_rgb24a:
-			value = PIX_FMT_RGBA32;
+			value = PIX_FMT_RGB32;
 			break;
 		case mlt_image_yuv422:
-			value = PIX_FMT_YUV422;
+			value = PIX_FMT_YUYV422;
 			break;
 		case mlt_image_yuv420p:
 			value = PIX_FMT_YUV420P;
Index: src/modules/avformat/filter_avdeinterlace.c
===================================================================
--- src/modules/avformat/filter_avdeinterlace.c	(revision 1375)
+++ src/modules/avformat/filter_avdeinterlace.c	(revision 1376)
@@ -81,6 +81,10 @@
                     movd_r2m(mm1,dst[0]);
 #endif
 
+#if LIBAVUTIL_VERSION_INT < (50<<16)
+#define PIX_FMT_YUYV422 PIX_FMT_YUV422
+#endif
+
 /* filter parameters: [-1 4 2 4 -1] // 8 */
 static inline void deinterlace_line(uint8_t *dst, 
 			     const uint8_t *lum_m4, const uint8_t *lum_m3, 
@@ -237,14 +241,14 @@
 
     if (pix_fmt != PIX_FMT_YUV420P &&
         pix_fmt != PIX_FMT_YUV422P &&
-        pix_fmt != PIX_FMT_YUV422 &&
+        pix_fmt != PIX_FMT_YUYV422 &&
         pix_fmt != PIX_FMT_YUV444P &&
 	pix_fmt != PIX_FMT_YUV411P)
         return -1;
     if ((width & 3) != 0 || (height & 3) != 0)
         return -1;
 
-	if ( pix_fmt != PIX_FMT_YUV422 )
+	if ( pix_fmt != PIX_FMT_YUYV422 )
 	{
       for(i=0;i<3;i++) {
           if (i == 1) {
@@ -314,8 +318,8 @@
 		// Fill the picture
 		if ( *format == mlt_image_yuv422 )
 		{
-			avpicture_fill( output, *image, PIX_FMT_YUV422, *width, *height );
-			mlt_avpicture_deinterlace( output, output, PIX_FMT_YUV422, *width, *height );
+			avpicture_fill( output, *image, PIX_FMT_YUYV422, *width, *height );
+			mlt_avpicture_deinterlace( output, output, PIX_FMT_YUYV422, *width, *height );
 		}
 
 		// Free the picture
