#!/sbin/runscript
# Copyright 1999-2004 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/dev-db/mysql/files/mysql-slot.rc6,v 1.4 2005/11/23 10:22:21 vivo Exp $

# external binaryes used: which, sed, tac

depend() {
	use dns net
}

# int in_list(char * elem, char * list)
function in_list() {
	local elem=${1:-"none"}
	local list=${2:-","}

	[[ "${list}" == "${list/,${elem},/}" ]] \
		&& return 1 \
		|| return 0
}

# int get_slot_config(srv_slot=0, srv_num)
get_slot_config() {
	srv_slot="${1:-"0"}"
	srv_num="${2}"
	basedir=""
	datadir=""
	pidfile=""
	socket=""
	CHROOT=""
	NICE=""
	# grab the parameters from conf.d/mysql definition
	local tmp_eval="mysql_slot_${srv_slot}${srv_num:+"_"}${srv_num}[@]"
	local conf_d_parameters="${!tmp_eval}"
	[[ ${conf_d_parameters[*]} == '()' ]] && conf_d_parameters=''
	MY_SUFFIX="-${srv_slot}"
	[[ "${MY_SUFFIX}" == '-0' ]] && MY_SUFFIX=''
	MY_CNF="/etc/mysql${MY_SUFFIX}/my.cnf"
	unmanagedparams=""
	local my_print_defaults="$(which my_print_defaults${MY_SUFFIX} 2>/dev/null)"
	local paramlist=","
	local mycnf

	# check my_print_defaults executable
	if [[ ! -x "${my_print_defaults}" ]]; then
		eerror "my_print_defaults NOT found or not executable"
		return 1
	fi
	my_print_defaults="${my_print_defaults} --loose-verbose"

	#  svc script force bash sourcing of same-name conf.d file ...
	#> so it's not possible to use my_print_defaults with that one
	for my_default in ${conf_d_parameters[*]}; do
		case "${my_default}" in
			nice=*)
				NICE="${my_default#nice=}"
				nice -n $NICE ls /tmp &>/dev/null || NICE=""
				;;
			mycnf=*)
				MY_CNF="${my_default#mycnf=}"
				;;
			chroot=*)
				# do not pass this to the mysqld it has different meanings
				CHROOT="${my_default#chroot=}"
				#TODO
				CHROOT=''
				;;

			basedir=*)
				basedir="${my_default#basedir=}"
				paramlist="${paramlist}--${my_default%%=*},"
				;;
			datadir=*)
				datadir="${my_default#datadir=}"
				paramlist="${paramlist}--${my_default%%=*},"
				;;
			pid-file=*)
				pidfile="${my_default#pid-file=}"
				paramlist="${paramlist}--${my_default%%=*},"
				;;
			socket=*)
				socket="${my_default#socket=}"
				paramlist="${paramlist}--${my_default%%=*},"
				;;
			*=*)
				# list of parameters we already have
				# prepend "--" because my_print_defaults do it
				paramlist="${paramlist}--${my_default%%=*},"
				# little trick from mysqld_safe
				unmanagedparams="${unmanagedparams} $(echo "--${my_default}" | sed -e 's,\([^=/a-zA-Z0-9_:.-]\),\\\1,g')"
				;;
			*)
				paramlist="${paramlist}--${my_default},"
				unmanagedparams="${unmanagedparams} --${my_default}"
				;;
		esac
	done

	if [[ ! -r "${MY_CNF}" ]]; then
		ewarn "Cannot access ${MY_CNF} ! Using automatic defaults!"
		my_defaults=$(${my_print_defaults} mysqld server)
	else
		my_defaults=$(${my_print_defaults} --config-file=${MY_CNF} mysqld server)
	fi

	for my_default in ${my_defaults}; do
		case "${my_default}" in
			--basedir=*)
				if ! in_list "${my_default%%=*}" "${paramlist}" ; then
					basedir="${my_default#--basedir=}"
				fi ;;
			--datadir=*)
				if ! in_list "${my_default%%=*}" "${paramlist}" ; then
					datadir="${my_default#--datadir=}"
				fi ;;
			--pid-file=*)
				if ! in_list "${my_default%%=*}" "${paramlist}" ; then
					pidfile="${my_default#--pid-file=}"
				fi ;;
			--socket=*)
				if ! in_list "${my_default%%=*}" "${paramlist}" ; then
					socket="${my_default#--socket=}"
				fi ;;
			*=*)
				# check into the list of parameters we already have
				if ! in_list "${my_default%%=*}" "${paramlist}"; then
					paramlist="${paramlist}${my_default%%=*},"
					unmanagedparams="${unmanagedparams} $(echo "${my_default}" | sed -e 's,\([^=/a-zA-Z0-9_:.-]\),\\\1,g')"
				fi
				;;
			*)
				if ! in_list "${my_default}" "${paramlist}"; then
					paramlist="${paramlist}${my_default%%=*},"
					unmanagedparams="${unmanagedparams} $(echo "${my_default}" | sed -e 's,\([^=/a-zA-Z0-9_.-]\),\\\1,g')"
				fi
				;;
		esac
	done

	for i in basedir datadir pidfile socket ; do
		if [[ -z "${!i}" ]] ; then
			eerror "undefined $i"
			return 1
		fi
	done

	for i in "server-id" "log-bin" ; do
		if ! in_list "--${i}" "${paramlist}" ; then
			ewarn "undefined $i, it's good practice set it"
		fi
	done

	# push these out to the script
	export MY_SUFFIX NICE MY_CNF pidfile datadir basedir socket CHROOT unmanagedparams
	return 0
}

checkconfig() {
	local datadir="$1"
	if [ ! -d "${datadir}" ]; then
		eerror "MySQL datadir is empty or invalid"
		eerror "Please check your my.cnf : ${MY_CNF}"
		return 1
	fi

	if [ ! -d "$datadir/mysql" ]; then
		eerror "You don't appear to have the mysql database installed yet."
		eerror "Please run /usr/bin/mysql_install_db to have this done..."
		return 1
	fi
	return 0
}

start() {
	MYSQL_GLOB_PID_FILE=${MYSQL_GLOB_PID_FILE:-"/var/run/svc-started-mysqld"}
	# servers are defined in /etc/conf.d/mysql
	local serverlist=${!mysql_slot_*}
	# provide default for empty conf.d/mysql
	if [[ -z "${serverlist}" ]] ; then
		serverlist=0
		export mysql_slot_0=()
	fi
	local maxtry retstatus
	local globretstatus=1
	local srv_slot srv_num
	# server MUST NOT share same location for these
	local pidfilelist=',' datadirlist=',' socketlist=','

	# additional security
	rm -f "${MYSQL_GLOB_PID_FILE}" ; touch "${MYSQL_GLOB_PID_FILE}"
	if [[ $? -ne 0 ]] ; then
		eerror "cannot create MYSQL_GLOB_PID_FILE: ${MYSQL_GLOB_PID_FILE}"
		return 1
	fi

	# try to start each server
	for srv in ${serverlist[*]} ; do
		einfo "working on ${srv}"

		srv_slot="${srv#mysql_slot_}"
		if [[ "${srv_slot}" == "${srv_slot#*_}" ]] ; then
			srv_num=''
		else
			srv_num="${srv_slot#*_}"
		fi
		srv_slot="${srv_slot%%_*}"

		# timeout (seconds) before declare failed the startup
		maxtry=10
		retstatus=0

		get_slot_config "${srv_slot}" "${srv_num}" || retstatus=1
		# pre_run checks
		[[ "$retstatus" -eq 0 ]] && checkconfig "${datadir}" || retstatus=2
		if [[ "$retstatus" -eq 0 ]] ; then
			if in_list "${pidfile}" "${pidfilelist}" ; then
				retstatus=3
				eerror "Cowardly refusing to start another server with same ${pidfile}"
			fi
			if in_list "${datadir}" "${datadirlist}" ; then
				retstatus=4
				eerror "Cowardly refusing to start another server with same ${datadir}"
			fi
			if in_list "${socket}" "${socketlist}" ; then
				retstatus=5
				eerror "Cowardly refusing to start another server with same ${socket}"
			fi
		fi

		if [[ $retstatus -eq 0 ]] ; then
			# additional security
			rm -f ${pidfile} ${socket}
			ebegin "Starting mysqld${MY_SUFFIX:+"_"}${srv_slot}${srv_num:+"_"}${srv_num} (${MY_CNF})"

			start-stop-daemon --start --quiet --background \
				${NICE:+"--nicelevel="}${NICE} \
				--pidfile="${pidfile}" \
				--exec  ${basedir}/sbin/mysqld${MY_SUFFIX} -- \
					--basedir="${basedir}" \
					--datadir="${datadir}" \
					--pid-file="${pidfile}" \
					--socket="${socket}" \
					${unmanagedparams} >/dev/null 2>&1
			retstatus=$?
			# wait for socket creation
			while ! [[ -S "${socket}" || "${maxtry}" -lt 1 || "${retstatus}" -ne 0 ]] ; do
				maxtry=$(($maxtry - 1))
				echo -n "."
				sleep 1
			done
			if [[ ! -S "${socket}" ]] ; then
				eerror "MySQL${MY_SUFFIX} NOT started (${retstatus})"
				retstatus=1
			else
				pidfilelist="${pidfilelist}${pidfile},"
				datadirlist="${datadirlist}${datadir},"
				socketlist="${socketlist}${socket},"
			fi
		fi

		if [[ $retstatus -eq 0 ]]; then
			globretstatus=0
			echo "${srv_slot}${srv_num:+"_"}${srv_num}=${pidfile}" >> "${MYSQL_GLOB_PID_FILE}"
		fi
	done
	# successfull if at least one mysqld started
	eend $globretstatus
}

stop () {
	MYSQL_GLOB_PID_FILE=${MYSQL_GLOB_PID_FILE:-"/var/run/svc-started-mysqld"}
	local runwhat pidfile shutdown_elem
	local PID cnt
	local retstatus=0
	local shutdown_list="$(tac "${MYSQL_GLOB_PID_FILE}")"
	# shutdown in reverse order
	for shutdown_elem in $shutdown_list; do
		runwhat=${shutdown_elem%%=*}
		pidfile=${shutdown_elem#*=}
		ebegin "Stopping mysqld (${runwhat})"
		# following code grabbed from the squid rc script
		PID=$(cat /var/run/squid.pid 2>/dev/null)
		start-stop-daemon --stop --quiet --pidfile="${pidfile}"
        sleep 2
		if test -n "$PID" && kill -0 $PID 2>/dev/null
		then
			einfon "Waiting ."
			cnt=0
			while kill -0 $PID 2>/dev/null
			do
				cnt=`expr $cnt + 1`
				if [ $cnt -gt 60 ]
				then
					# Waited 120 seconds now. Fail.
					eend 1 "Failed."
					break
				fi
				sleep 2
				echo -n "."
			done
			echo -n "done."
				eend 0
		else
			eend 0
		fi
		# end stolen code
		retstatus=$(( $retstatus + $? ))
	done
	[[ "$retstatus" -eq 0 ]] && rm -f "$MYSQL_GLOB_PID_FILE"
	eend $retstatus
}
