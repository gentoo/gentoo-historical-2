###MY_VER_RANGE [4.1,)
diff -Nurp mysql/strings/longlong2str-x86.s mysql-fixed/strings/longlong2str-x86.s
--- mysql/strings/longlong2str-x86.s	2005-05-13 12:32:11.000000000 +0100
+++ mysql-fixed/strings/longlong2str-x86.s	2005-05-25 01:19:32.000000000 +0100
@@ -19,6 +19,13 @@
 	.file	"longlong2str.s"
 	.version "1.01"
 
+	.section	.rodata
+	.align 32
+	.type	_dig_vec_upper, @object
+	.size	_dig_vec_upper, 37
+_dig_vec_upper:
+	.string "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+
 .text
 	.align 4
 
@@ -31,11 +38,14 @@ longlong2str:
 	pushl %esi
 	pushl %edi
 	pushl %ebx
+
+	call __i686.get_pc_thunk.bx
+	addl $_GLOBAL_OFFSET_TABLE_,%ebx
+
 	movl 100(%esp),%esi	# Lower part of val 
 	movl 104(%esp),%ebp	# Higher part of val 
 	movl 108(%esp),%edi	# get dst 
-	movl 112(%esp),%ebx	# Radix 
-	movl %ebx,%eax
+	movl 112(%esp),%eax	# Radix 
 	testl %eax,%eax
 	jge .L144
 
@@ -50,7 +60,7 @@ longlong2str:
 	adcl $0,%ebp
 	negl %ebp
 .L146:
-	negl %ebx		# Change radix to positive 
+	negl 112(%esp)		# Change radix to positive 
 	jmp .L148
 	.align 4
 .L144:
@@ -77,13 +87,13 @@ longlong2str:
 
 	movl %ebp,%eax		# High part of value 
 	xorl %edx,%edx
-	divl %ebx
+	divl 112(%esp)
 	movl %eax,%ebp
 	movl %esi,%eax
-	divl %ebx
+	divl 112(%esp)
 	decl %ecx
 	movl %eax,%esi		# quotent in ebp:esi 
-	movb _dig_vec_upper(%edx),%al   # al is faster than dl 
+	movb _dig_vec_upper@GOTOFF(%ebx,%edx),%al   # al is faster than dl
 	movb %al,(%ecx)		# store value in buff 
 	.align 4
 .L155:
@@ -93,14 +103,13 @@ longlong2str:
 	jl .L153
 	je .L10_mov		# Ready 
 	movl %esi,%eax
-	movl $_dig_vec_upper,%ebp
 	.align 4
 
 .L154:				# Do rest with integer precision 
 	cltd
-	divl %ebx
+	divl 112(%esp)
 	decl %ecx
-	movb (%edx,%ebp),%dl	# bh is always zero as ebx=radix < 36 
+	movb _dig_vec_upper@GOTOFF(%ebx,%edx),%dl
 	testl %eax,%eax
 	movb %dl,(%ecx)
 	jne .L154
@@ -137,9 +146,6 @@ longlong2str:
 #	
 
 	.align 4
-.Ltmp:
-        .long 0xcccccccd
-	.align 4
 	
 .globl	longlong10_to_str
 	.type	 longlong10_to_str,@function
@@ -202,7 +208,7 @@ longlong10_to_str:
 
 	# The following code uses some tricks to change division by 10 to
 	# multiplication and shifts
-	movl .Ltmp,%esi		# set %esi to 0xcccccccd
+	movl $0xcccccccd,%esi	# set %esi to 0xcccccccd
 	
 .L10_40:
         movl %ebx,%eax
@@ -221,3 +227,13 @@ longlong10_to_str:
 
 .L10end:
 	.size	 longlong10_to_str,.L10end-longlong10_to_str
+
+	.section .gnu.linkonce.t.__i686.get_pc_thunk.bx,"ax",@progbits
+.globl __i686.get_pc_thunk.bx
+	.hidden	__i686.get_pc_thunk.bx
+	.type	__i686.get_pc_thunk.bx, @function
+__i686.get_pc_thunk.bx:
+	movl	(%esp), %ebx
+	ret
+
+	.section	.note.GNU-stack,"",@progbits
diff -Nurp mysql/strings/my_strtoll10-x86.s mysql-fixed/strings/my_strtoll10-x86.s
--- mysql/strings/my_strtoll10-x86.s	2005-05-13 12:32:22.000000000 +0100
+++ mysql-fixed/strings/my_strtoll10-x86.s	2005-05-25 01:13:23.000000000 +0100
@@ -18,7 +18,7 @@
 	
 	.file	"my_strtoll10-x86.s"
 	.version "01.01"
-.data
+.section .rodata
 	.align 32
 	.type	 lfactor,@object
 	.size	 lfactor,36
@@ -315,7 +315,11 @@ my_strtoll10:
 .Lend_i_and_j:
 	movl %esi,%ecx
 	subl -12(%ebp),%ecx	# ecx= number of digits in second part
-	movl lfactor(,%ecx,4),%eax
+
+	call __i686.get_pc_thunk.bx
+	addl $_GLOBAL_OFFSET_TABLE_,%ebx
+
+	movl lfactor@GOTOFF(%ebx,%ecx,4),%eax
 	jmp .L523
 
 	# Return -8(%ebp) * $1000000000 + edi
@@ -400,3 +404,13 @@ my_strtoll10:
         .comm   end_ptr,120,32
         .comm   error,120,32
 	.ident	"Monty"
+
+	.section .gnu.linkonce.t.__i686.get_pc_thunk.bx,"ax",@progbits
+.globl __i686.get_pc_thunk.bx
+	.hidden	__i686.get_pc_thunk.bx
+	.type	__i686.get_pc_thunk.bx, @function
+__i686.get_pc_thunk.bx:
+	movl	(%esp), %ebx
+	ret
+
+	.section	.note.GNU-stack,"",@progbits
diff -Nurp mysql/strings/strings-x86.s mysql-fixed/strings/strings-x86.s
--- mysql/strings/strings-x86.s	2005-05-13 12:32:40.000000000 +0100
+++ mysql-fixed/strings/strings-x86.s	2005-05-23 23:19:13.000000000 +0100
@@ -415,3 +415,5 @@ next_str:
 	ret
 .strxmov_end:
 	.size	 strxmov,.strxmov_end-strxmov
+
+	.section	.note.GNU-stack,"",@progbits
