diff -rc mysql++-1.7.9-gcc3.0/configure.in mysql++-1.7.9-gcc3.2/configure.in
*** mysql++-1.7.9-gcc3.0/configure.in	2001-05-19 18:44:46.000000000 +0200
--- mysql++-1.7.9-gcc3.2/configure.in	2002-10-13 22:58:08.000000000 +0200
***************
*** 14,20 ****
  
  AC_PROG_MAKE_SET
  
! AM_PROG_LIBTOOL
  
  dnl Initialize maintainer mode
  AM_MAINTAINER_MODE
--- 14,20 ----
  
  AC_PROG_MAKE_SET
  
! AC_PROG_LIBTOOL
  
  dnl Initialize maintainer mode
  AM_MAINTAINER_MODE
diff -rc mysql++-1.7.9-gcc3.0/sqlplusint/coldata1.hh mysql++-1.7.9-gcc3.2/sqlplusint/coldata1.hh
*** mysql++-1.7.9-gcc3.0/sqlplusint/coldata1.hh	2002-10-14 13:15:41.000000000 +0200
--- mysql++-1.7.9-gcc3.2/sqlplusint/coldata1.hh	2002-10-17 12:11:15.000000000 +0200
***************
*** 43,51 ****
  	std::string buf;
  	bool _null;
  public:
!   mysql_ColData (bool n, mysql_type_info t = mysql_type_info::string_type) 
      : _type(t), _null(n) {}
!   mysql_ColData (const char *str, 
  		 mysql_type_info t = mysql_type_info::string_type, bool n = false)
      : Str(str), _type(t), _null(n) {buf=str;}
    mysql_ColData () {}
--- 43,51 ----
  	std::string buf;
  	bool _null;
  public:
!   explicit mysql_ColData (bool n, mysql_type_info t = mysql_type_info::string_type) 
      : _type(t), _null(n) {}
!   explicit mysql_ColData (const char *str, 
  		 mysql_type_info t = mysql_type_info::string_type, bool n = false)
      : Str(str), _type(t), _null(n) {buf=str;}
    mysql_ColData () {}
Nur in mysql++-1.7.9-gcc3.2/sqlplusint: coldata1.hh~.
diff -rc mysql++-1.7.9-gcc3.0/sqlplusint/compare1.hh mysql++-1.7.9-gcc3.2/sqlplusint/compare1.hh
*** mysql++-1.7.9-gcc3.0/sqlplusint/compare1.hh	2002-10-14 13:15:41.000000000 +0200
--- mysql++-1.7.9-gcc3.2/sqlplusint/compare1.hh	2002-10-17 12:32:37.000000000 +0200
***************
*** 1,12 ****
  #ifndef __compare1_hh__
  #define __compare1_hh__
  
! #include <function.h>
  #include <cstring>
  #include "row1.hh"
  
  template <class BinaryPred, class CmpType>
! class MysqlCmp : public unary_function<const MysqlRow&, bool>
  {
  protected:
    unsigned int index;
--- 1,12 ----
  #ifndef __compare1_hh__
  #define __compare1_hh__
  
! #include <functional>
  #include <cstring>
  #include "row1.hh"
  
  template <class BinaryPred, class CmpType>
! class MysqlCmp : public std::unary_function<const MysqlRow&, bool>
  {
  protected:
    unsigned int index;
***************
*** 37,43 ****
    return MysqlCmp<BinaryPred, CmpType>(i, func, cmp2);
  }
  
! typedef binary_function<const char*, const char*, bool> bin_char_pred;
  
  struct cstr_equal_to : bin_char_pred {
    bool operator () (const char *x, const char *y) const
--- 37,43 ----
    return MysqlCmp<BinaryPred, CmpType>(i, func, cmp2);
  }
  
! typedef std::binary_function<const char*, const char*, bool> bin_char_pred;
  
  struct cstr_equal_to : bin_char_pred {
    bool operator () (const char *x, const char *y) const
Nur in mysql++-1.7.9-gcc3.2/sqlplusint: compare1.hh~.
diff -rc mysql++-1.7.9-gcc3.0/sqlplusint/connection.cc mysql++-1.7.9-gcc3.2/sqlplusint/connection.cc
*** mysql++-1.7.9-gcc3.0/sqlplusint/connection.cc	2002-10-14 13:15:41.000000000 +0200
--- mysql++-1.7.9-gcc3.2/sqlplusint/connection.cc	2002-10-13 23:01:00.000000000 +0200
***************
*** 20,28 ****
  }
  
  Connection::Connection (const char *db, const char *host, const char *user, 
! 			const char *passwd, uint port, my_bool compress = 0,
! 			unsigned int connect_timeout = 60, bool te = true,
! 			const char *socket_name = "", unsigned client_flag = 0)
    : throw_exceptions(te), locked(false)
  {
  	mysql_init(&mysql);
--- 20,28 ----
  }
  
  Connection::Connection (const char *db, const char *host, const char *user, 
! 			const char *passwd, uint port, my_bool compress,
! 			unsigned int connect_timeout, bool te,
! 			const char *socket_name, unsigned client_flag)
    : throw_exceptions(te), locked(false)
  {
  	mysql_init(&mysql);
***************
*** 39,47 ****
  }
  
  bool Connection::real_connect (cchar *db, cchar *host, cchar *user,
! 			       cchar *passwd, uint port, my_bool compress = 0,
! 			       unsigned int connect_timeout = 60,
! 			       const char *socket_name = "", unsigned int client_flag = 0)
  {
    mysql.options.compress = compress;
    mysql.options.connect_timeout=connect_timeout;
--- 39,47 ----
  }
  
  bool Connection::real_connect (cchar *db, cchar *host, cchar *user,
! 			       cchar *passwd, uint port, my_bool compress,
! 			       unsigned int connect_timeout,
! 			       const char *socket_name, unsigned int client_flag)
  {
    mysql.options.compress = compress;
    mysql.options.connect_timeout=connect_timeout;
diff -rc mysql++-1.7.9-gcc3.0/sqlplusint/exceptions.hh.in mysql++-1.7.9-gcc3.2/sqlplusint/exceptions.hh.in
*** mysql++-1.7.9-gcc3.0/sqlplusint/exceptions.hh.in	2002-10-14 13:15:41.000000000 +0200
--- mysql++-1.7.9-gcc3.2/sqlplusint/exceptions.hh.in	2002-10-17 00:11:47.000000000 +0200
***************
*** 10,61 ****
                                // with --enable-exception flag.
  
  //: Exception thrown when a BadQuery is encountered
! class BadQuery : public exception {
  public:
!   BadQuery(const string &er = "") : error(er) {}
!   const string error; //: The error message
!   virtual const char* what( void ) const { return error.c_str(); }
  };
  
  //: Exception structure thrown when a bad conversion takes place
! class BadConversion : public exception {
!   const string _what;
  public:
    const char*  type_name;  //:
!   const string data;       //:
    size_t       retrieved;  //:
    size_t       actual_size;//:
    BadConversion(const char* tn, const char* d, size_t r, size_t a)
!     : _what(string("Tried to convert \"") + string(d ? d : "") + "\" to a \"" + string(tn ? tn : "")),
        type_name(tn), data(d), retrieved(r), actual_size(a) {};
  
!   BadConversion(const string &wt, const char* tn, const char* d, size_t r, size_t a)
      : _what(wt), type_name(tn), data(d), retrieved(r), actual_size(a) {};
  
!   BadConversion(const string& wt = "")
      : _what(wt), type_name("unknown"), data(""), retrieved(0), actual_size(0) {};
  
!   virtual const char* what( void ) const { return _what.c_str(); }
  };
  
  //: Thrown when a *Null* value is trying to be converted into a type 
  //: it can't convert to.
! class BadNullConversion : public exception {
!   const string _what;
  public:
!   BadNullConversion(const string &wt = "") : _what(wt) {}
!   virtual const char* what( void ) const { return _what.c_str(); }
  };
  
  //: Exception thrown when not enough parameters are provided
  // Thrown when not enough parameters are provided for a 
  // template query.
! class SQLQueryNEParms : public exception {
!   const string _what;
  public:
!   SQLQueryNEParms(const char *c) : _what(string(c ? c : "")), error(c) {}
    const char* error; //:
!   virtual const char* what( void ) const { return _what.c_str(); }
  };
  
  #else //origional, default exception style
--- 10,65 ----
                                // with --enable-exception flag.
  
  //: Exception thrown when a BadQuery is encountered
! class BadQuery : public std::exception {
  public:
!   BadQuery(const std::string &er = "") : error(er) {}
!   ~BadQuery() throw () {}
!   const std::string error; //: The error message
!   virtual const char* what( void ) const throw () { return error.c_str(); }
  };
  
  //: Exception structure thrown when a bad conversion takes place
! class BadConversion : public std::exception {
!   const std::string _what;
  public:
    const char*  type_name;  //:
!   const std::string data;       //:
    size_t       retrieved;  //:
    size_t       actual_size;//:
    BadConversion(const char* tn, const char* d, size_t r, size_t a)
!     : _what(std::string("Tried to convert \"") + std::string(d ? d : "") + "\" to a \"" + std::string(tn ? tn : "")),
        type_name(tn), data(d), retrieved(r), actual_size(a) {};
  
!   BadConversion(const std::string &wt, const char* tn, const char* d, size_t r, size_t a)
      : _what(wt), type_name(tn), data(d), retrieved(r), actual_size(a) {};
  
!   BadConversion(const std::string& wt = "")
      : _what(wt), type_name("unknown"), data(""), retrieved(0), actual_size(0) {};
+   ~BadConversion() throw () {}
  
!   virtual const char* what( void ) const throw () { return _what.c_str(); }
  };
  
  //: Thrown when a *Null* value is trying to be converted into a type 
  //: it can't convert to.
! class BadNullConversion : public std::exception {
!   const std::string _what;
  public:
!   BadNullConversion(const std::string &wt = "") : _what(wt) {}
!   ~BadNullConversion() throw () {}
!   virtual const char* what( void ) const throw () { return _what.c_str(); }
  };
  
  //: Exception thrown when not enough parameters are provided
  // Thrown when not enough parameters are provided for a 
  // template query.
! class SQLQueryNEParms : public std::exception {
!   const std::string _what;
  public:
!   SQLQueryNEParms(const char *c) : _what(std::string(c ? c : "")), error(c) {}
!   ~SQLQueryNEParms() throw () {}
    const char* error; //:
!   virtual const char* what( void ) const throw () { return _what.c_str(); }
  };
  
  #else //origional, default exception style
Nur in mysql++-1.7.9-gcc3.2/sqlplusint: exceptions.hh.in~.
diff -rc mysql++-1.7.9-gcc3.0/sqlplusint/null1.hh mysql++-1.7.9-gcc3.2/sqlplusint/null1.hh
*** mysql++-1.7.9-gcc3.0/sqlplusint/null1.hh	2001-05-19 18:44:48.000000000 +0200
--- mysql++-1.7.9-gcc3.2/sqlplusint/null1.hh	2002-10-17 12:31:55.000000000 +0200
***************
*** 1,7 ****
  #ifndef __null1_hh__
  #define __null1_hh__
  
! #include <ostream.h>
  #include "exceptions.hh"
  #include "define_short"
  
--- 1,7 ----
  #ifndef __null1_hh__
  #define __null1_hh__
  
! #include <ostream>
  #include "exceptions.hh"
  #include "define_short"
  
***************
*** 18,36 ****
  //: Type to use for the behavior parameter for *Null<>*
  struct NullisNull {
    static null_type null_is() {return null_type();}
!   static ostream&  null_ostr(ostream& o) {o << "(NULL)"; return o;}
  };
  
  //: Type to use for the behavior parameter for *Null<>*
  struct NullisZero {
    static int   null_is() {return 0;}
!   static ostream& null_ostr(ostream &o) {o << 0; return o;}
  };
  
  //: Type to use for the behavior parameter for *Null<>*
  struct NullisBlank {
    static const char * null_is() {return "";}
!   static ostream& null_ostr(ostream &o) {o << ""; return o;}
  };
  
  //: Container class for holding null types.
--- 18,36 ----
  //: Type to use for the behavior parameter for *Null<>*
  struct NullisNull {
    static null_type null_is() {return null_type();}
!   static std::ostream&  null_ostr(std::ostream& o) {o << "(NULL)"; return o;}
  };
  
  //: Type to use for the behavior parameter for *Null<>*
  struct NullisZero {
    static int   null_is() {return 0;}
!   static std::ostream& null_ostr(std::ostream &o) {o << 0; return o;}
  };
  
  //: Type to use for the behavior parameter for *Null<>*
  struct NullisBlank {
    static const char * null_is() {return "";}
!   static std::ostream& null_ostr(std::ostream &o) {o << ""; return o;}
  };
  
  //: Container class for holding null types.
Nur in mysql++-1.7.9-gcc3.2/sqlplusint: null1.hh~.
diff -rc mysql++-1.7.9-gcc3.0/sqlplusint/null2.hh mysql++-1.7.9-gcc3.2/sqlplusint/null2.hh
*** mysql++-1.7.9-gcc3.0/sqlplusint/null2.hh	2001-05-19 18:44:48.000000000 +0200
--- mysql++-1.7.9-gcc3.2/sqlplusint/null2.hh	2002-10-17 12:36:42.000000000 +0200
***************
*** 4,10 ****
  #include "null1.hh"
  
  template <class Type, class Behavior>
! inline ostream& operator << (ostream &o, const Null<Type,Behavior> &n) {
    if (n.is_null) return Behavior::null_ostr(o);
    else return o << n.data;
  }
--- 4,10 ----
  #include "null1.hh"
  
  template <class Type, class Behavior>
! inline std::ostream& operator << (std::ostream &o, const Null<Type,Behavior> &n) {
    if (n.is_null) return Behavior::null_ostr(o);
    else return o << n.data;
  }
Nur in mysql++-1.7.9-gcc3.2/sqlplusint: null2.hh~.
diff -rc mysql++-1.7.9-gcc3.0/sqlplusint/set3.hh mysql++-1.7.9-gcc3.2/sqlplusint/set3.hh
*** mysql++-1.7.9-gcc3.0/sqlplusint/set3.hh	2001-05-19 18:44:48.000000000 +0200
--- mysql++-1.7.9-gcc3.2/sqlplusint/set3.hh	2002-10-17 12:17:50.000000000 +0200
***************
*** 6,14 ****
  
  template <class Insert>
  void set2container (const char *str, Insert insert) {
-   MutableColData s(false);
    while (1) {
!     s = "";
      while (*str != ',' && *str) {
        s += *str;
        str++;
--- 6,13 ----
  
  template <class Insert>
  void set2container (const char *str, Insert insert) {
    while (1) {
!     MutableColData s("");
      while (*str != ',' && *str) {
        s += *str;
        str++;
Nur in mysql++-1.7.9-gcc3.2/sqlplusint: set3.hh~.
