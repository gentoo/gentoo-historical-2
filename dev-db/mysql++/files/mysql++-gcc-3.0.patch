diff -rc mysql++-1.7.9/examples/Makefile.in mysql++-1.7.9-patched/examples/Makefile.in
*** mysql++-1.7.9/examples/Makefile.in	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/Makefile.in	Mon Aug 27 13:27:47 2001
***************
*** 64,81 ****
  CC = @CC@
  CXX = @CXX@
  DLLTOOL = @DLLTOOL@
! LD = @LD@
  LIBTOOL = @LIBTOOL@
  LN_S = @LN_S@
  MAINT = @MAINT@
  MAKEINFO = @MAKEINFO@
- NM = @NM@
  OBJDUMP = @OBJDUMP@
  PACKAGE = @PACKAGE@
  RANLIB = @RANLIB@
  SQLPLUS_MAJOR_VERSION = @SQLPLUS_MAJOR_VERSION@
  SQLPLUS_MICRO_VERSION = @SQLPLUS_MICRO_VERSION@
  SQLPLUS_MINOR_VERSION = @SQLPLUS_MINOR_VERSION@
  VERSION = @VERSION@
  
  INCLUDES = -I$(top_srcdir)/sqlplusint
--- 64,83 ----
  CC = @CC@
  CXX = @CXX@
  DLLTOOL = @DLLTOOL@
! ECHO = @ECHO@
! EXEEXT = @EXEEXT@
  LIBTOOL = @LIBTOOL@
  LN_S = @LN_S@
  MAINT = @MAINT@
  MAKEINFO = @MAKEINFO@
  OBJDUMP = @OBJDUMP@
+ OBJEXT = @OBJEXT@
  PACKAGE = @PACKAGE@
  RANLIB = @RANLIB@
  SQLPLUS_MAJOR_VERSION = @SQLPLUS_MAJOR_VERSION@
  SQLPLUS_MICRO_VERSION = @SQLPLUS_MICRO_VERSION@
  SQLPLUS_MINOR_VERSION = @SQLPLUS_MINOR_VERSION@
+ STRIP = @STRIP@
  VERSION = @VERSION@
  
  INCLUDES = -I$(top_srcdir)/sqlplusint
***************
*** 149,172 ****
  mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
  CONFIG_HEADER = ../config.h ../sqlplusint/exceptions.hh
  CONFIG_CLEAN_FILES = 
  PROGRAMS =  $(noinst_PROGRAMS)
  
  
  DEFS = @DEFS@ -I. -I$(srcdir) -I.. -I../sqlplusint
  CPPFLAGS = @CPPFLAGS@
  LDFLAGS = @LDFLAGS@
! resetdb_OBJECTS =  resetdb.o util.o
! simple1_OBJECTS =  simple1.o
! custom1_OBJECTS =  custom1.o
! custom2_OBJECTS =  custom2.o util.o
! custom3_OBJECTS =  custom3.o util.o
! custom4_OBJECTS =  custom4.o
! complic1_OBJECTS =  complic1.o
! fieldinf1_OBJECTS =  fieldinf1.o
! sinisa_ex_OBJECTS =  sinisa_ex.o
! updel_ex_OBJECTS =  updel_x_.o
! load_file_OBJECTS =  load_file.o
! cgi_image_OBJECTS =  cgi_image.o
  CXXFLAGS = @CXXFLAGS@
  CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
  LTCXXCOMPILE = $(LIBTOOL) --mode=compile $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
--- 151,178 ----
  mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
  CONFIG_HEADER = ../config.h ../sqlplusint/exceptions.hh
  CONFIG_CLEAN_FILES = 
+ noinst_PROGRAMS =  resetdb$(EXEEXT) simple1$(EXEEXT) custom1$(EXEEXT) \
+ custom2$(EXEEXT) custom3$(EXEEXT) custom4$(EXEEXT) complic1$(EXEEXT) \
+ fieldinf1$(EXEEXT) sinisa_ex$(EXEEXT) updel_ex$(EXEEXT) \
+ load_file$(EXEEXT) cgi_image$(EXEEXT)
  PROGRAMS =  $(noinst_PROGRAMS)
  
  
  DEFS = @DEFS@ -I. -I$(srcdir) -I.. -I../sqlplusint
  CPPFLAGS = @CPPFLAGS@
  LDFLAGS = @LDFLAGS@
! resetdb_OBJECTS =  resetdb.$(OBJEXT) util.$(OBJEXT)
! simple1_OBJECTS =  simple1.$(OBJEXT)
! custom1_OBJECTS =  custom1.$(OBJEXT)
! custom2_OBJECTS =  custom2.$(OBJEXT) util.$(OBJEXT)
! custom3_OBJECTS =  custom3.$(OBJEXT) util.$(OBJEXT)
! custom4_OBJECTS =  custom4.$(OBJEXT)
! complic1_OBJECTS =  complic1.$(OBJEXT)
! fieldinf1_OBJECTS =  fieldinf1.$(OBJEXT)
! sinisa_ex_OBJECTS =  sinisa_ex.$(OBJEXT)
! updel_ex_OBJECTS =  updel_x_.$(OBJEXT)
! load_file_OBJECTS =  load_file.$(OBJEXT)
! cgi_image_OBJECTS =  cgi_image.$(OBJEXT)
  CXXFLAGS = @CXXFLAGS@
  CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
  LTCXXCOMPILE = $(LIBTOOL) --mode=compile $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
***************
*** 190,196 ****
  
  all: all-redirect
  .SUFFIXES:
! .SUFFIXES: .S .c .cc .lo .o .s
  $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) $(srcdir)/../Configure
  	cd $(top_srcdir) && $(AUTOMAKE) --gnu examples/Makefile
  
--- 196,202 ----
  
  all: all-redirect
  .SUFFIXES:
! .SUFFIXES: .S .c .cc .lo .o .obj .s
  $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) $(srcdir)/../Configure
  	cd $(top_srcdir) && $(AUTOMAKE) --gnu examples/Makefile
  
***************
*** 208,213 ****
--- 214,224 ----
  
  maintainer-clean-noinstPROGRAMS:
  
+ # FIXME: We should only use cygpath when building on Windows,
+ # and only if it is available.
+ .c.obj:
+ 	$(COMPILE) -c `cygpath -w $<`
+ 
  .s.o:
  	$(COMPILE) -c $<
  
***************
*** 216,221 ****
--- 227,233 ----
  
  mostlyclean-compile:
  	-rm -f *.o core *.core
+ 	-rm -f *.$(OBJEXT)
  
  clean-compile:
  
***************
*** 240,294 ****
  
  maintainer-clean-libtool:
  
! resetdb: $(resetdb_OBJECTS) $(resetdb_DEPENDENCIES)
! 	@rm -f resetdb
  	$(CXXLINK) $(resetdb_LDFLAGS) $(resetdb_OBJECTS) $(resetdb_LDADD) $(LIBS)
  
! simple1: $(simple1_OBJECTS) $(simple1_DEPENDENCIES)
! 	@rm -f simple1
  	$(CXXLINK) $(simple1_LDFLAGS) $(simple1_OBJECTS) $(simple1_LDADD) $(LIBS)
  
! custom1: $(custom1_OBJECTS) $(custom1_DEPENDENCIES)
! 	@rm -f custom1
  	$(CXXLINK) $(custom1_LDFLAGS) $(custom1_OBJECTS) $(custom1_LDADD) $(LIBS)
  
! custom2: $(custom2_OBJECTS) $(custom2_DEPENDENCIES)
! 	@rm -f custom2
  	$(CXXLINK) $(custom2_LDFLAGS) $(custom2_OBJECTS) $(custom2_LDADD) $(LIBS)
  
! custom3: $(custom3_OBJECTS) $(custom3_DEPENDENCIES)
! 	@rm -f custom3
  	$(CXXLINK) $(custom3_LDFLAGS) $(custom3_OBJECTS) $(custom3_LDADD) $(LIBS)
  
! custom4: $(custom4_OBJECTS) $(custom4_DEPENDENCIES)
! 	@rm -f custom4
  	$(CXXLINK) $(custom4_LDFLAGS) $(custom4_OBJECTS) $(custom4_LDADD) $(LIBS)
  
! complic1: $(complic1_OBJECTS) $(complic1_DEPENDENCIES)
! 	@rm -f complic1
  	$(CXXLINK) $(complic1_LDFLAGS) $(complic1_OBJECTS) $(complic1_LDADD) $(LIBS)
  
! fieldinf1: $(fieldinf1_OBJECTS) $(fieldinf1_DEPENDENCIES)
! 	@rm -f fieldinf1
  	$(CXXLINK) $(fieldinf1_LDFLAGS) $(fieldinf1_OBJECTS) $(fieldinf1_LDADD) $(LIBS)
  
! sinisa_ex: $(sinisa_ex_OBJECTS) $(sinisa_ex_DEPENDENCIES)
! 	@rm -f sinisa_ex
  	$(CXXLINK) $(sinisa_ex_LDFLAGS) $(sinisa_ex_OBJECTS) $(sinisa_ex_LDADD) $(LIBS)
  
! updel_ex: $(updel_ex_OBJECTS) $(updel_ex_DEPENDENCIES)
! 	@rm -f updel_ex
  	$(CXXLINK) $(updel_ex_LDFLAGS) $(updel_ex_OBJECTS) $(updel_ex_LDADD) $(LIBS)
  
! load_file: $(load_file_OBJECTS) $(load_file_DEPENDENCIES)
! 	@rm -f load_file
  	$(CXXLINK) $(load_file_LDFLAGS) $(load_file_OBJECTS) $(load_file_LDADD) $(LIBS)
  
! cgi_image: $(cgi_image_OBJECTS) $(cgi_image_DEPENDENCIES)
! 	@rm -f cgi_image
  	$(CXXLINK) $(cgi_image_LDFLAGS) $(cgi_image_OBJECTS) $(cgi_image_LDADD) $(LIBS)
  .cc.o:
  	$(CXXCOMPILE) -c $<
  .cc.lo:
  	$(LTCXXCOMPILE) -c $<
  
--- 252,308 ----
  
  maintainer-clean-libtool:
  
! resetdb$(EXEEXT): $(resetdb_OBJECTS) $(resetdb_DEPENDENCIES)
! 	@rm -f resetdb$(EXEEXT)
  	$(CXXLINK) $(resetdb_LDFLAGS) $(resetdb_OBJECTS) $(resetdb_LDADD) $(LIBS)
  
! simple1$(EXEEXT): $(simple1_OBJECTS) $(simple1_DEPENDENCIES)
! 	@rm -f simple1$(EXEEXT)
  	$(CXXLINK) $(simple1_LDFLAGS) $(simple1_OBJECTS) $(simple1_LDADD) $(LIBS)
  
! custom1$(EXEEXT): $(custom1_OBJECTS) $(custom1_DEPENDENCIES)
! 	@rm -f custom1$(EXEEXT)
  	$(CXXLINK) $(custom1_LDFLAGS) $(custom1_OBJECTS) $(custom1_LDADD) $(LIBS)
  
! custom2$(EXEEXT): $(custom2_OBJECTS) $(custom2_DEPENDENCIES)
! 	@rm -f custom2$(EXEEXT)
  	$(CXXLINK) $(custom2_LDFLAGS) $(custom2_OBJECTS) $(custom2_LDADD) $(LIBS)
  
! custom3$(EXEEXT): $(custom3_OBJECTS) $(custom3_DEPENDENCIES)
! 	@rm -f custom3$(EXEEXT)
  	$(CXXLINK) $(custom3_LDFLAGS) $(custom3_OBJECTS) $(custom3_LDADD) $(LIBS)
  
! custom4$(EXEEXT): $(custom4_OBJECTS) $(custom4_DEPENDENCIES)
! 	@rm -f custom4$(EXEEXT)
  	$(CXXLINK) $(custom4_LDFLAGS) $(custom4_OBJECTS) $(custom4_LDADD) $(LIBS)
  
! complic1$(EXEEXT): $(complic1_OBJECTS) $(complic1_DEPENDENCIES)
! 	@rm -f complic1$(EXEEXT)
  	$(CXXLINK) $(complic1_LDFLAGS) $(complic1_OBJECTS) $(complic1_LDADD) $(LIBS)
  
! fieldinf1$(EXEEXT): $(fieldinf1_OBJECTS) $(fieldinf1_DEPENDENCIES)
! 	@rm -f fieldinf1$(EXEEXT)
  	$(CXXLINK) $(fieldinf1_LDFLAGS) $(fieldinf1_OBJECTS) $(fieldinf1_LDADD) $(LIBS)
  
! sinisa_ex$(EXEEXT): $(sinisa_ex_OBJECTS) $(sinisa_ex_DEPENDENCIES)
! 	@rm -f sinisa_ex$(EXEEXT)
  	$(CXXLINK) $(sinisa_ex_LDFLAGS) $(sinisa_ex_OBJECTS) $(sinisa_ex_LDADD) $(LIBS)
  
! updel_ex$(EXEEXT): $(updel_ex_OBJECTS) $(updel_ex_DEPENDENCIES)
! 	@rm -f updel_ex$(EXEEXT)
  	$(CXXLINK) $(updel_ex_LDFLAGS) $(updel_ex_OBJECTS) $(updel_ex_LDADD) $(LIBS)
  
! load_file$(EXEEXT): $(load_file_OBJECTS) $(load_file_DEPENDENCIES)
! 	@rm -f load_file$(EXEEXT)
  	$(CXXLINK) $(load_file_LDFLAGS) $(load_file_OBJECTS) $(load_file_LDADD) $(LIBS)
  
! cgi_image$(EXEEXT): $(cgi_image_OBJECTS) $(cgi_image_DEPENDENCIES)
! 	@rm -f cgi_image$(EXEEXT)
  	$(CXXLINK) $(cgi_image_LDFLAGS) $(cgi_image_OBJECTS) $(cgi_image_LDADD) $(LIBS)
  .cc.o:
  	$(CXXCOMPILE) -c $<
+ .cc.obj:
+ 	$(CXXCOMPILE) -c `cygpath -w $<`
  .cc.lo:
  	$(LTCXXCOMPILE) -c $<
  
***************
*** 334,340 ****
  	@for file in $(DISTFILES); do \
  	  d=$(srcdir); \
  	  if test -d $$d/$$file; then \
! 	    cp -pr $$/$$file $(distdir)/$$file; \
  	  else \
  	    test -f $(distdir)/$$file \
  	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
--- 348,354 ----
  	@for file in $(DISTFILES); do \
  	  d=$(srcdir); \
  	  if test -d $$d/$$file; then \
! 	    cp -pr $$d/$$file $(distdir)/$$file; \
  	  else \
  	    test -f $(distdir)/$$file \
  	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
diff -rc mysql++-1.7.9/examples/cgi_image.cc mysql++-1.7.9-patched/examples/cgi_image.cc
*** mysql++-1.7.9/examples/cgi_image.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/examples/cgi_image.cc	Mon Aug 27 13:44:32 2001
***************
*** 18,24 ****
  	try {
  		con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
  		Query query = con.query();
! 		query << "SELECT " << MY_FIELD << " FROM " << MY_TABLE << " WHERE " << MY_KEY << " = " << argv[1];
  		ResUse res = query.use(); Row row=res.fetch_row(); long unsigned int *jj = res.fetch_lengths();
  		cout << "Content-length: " << *jj << endl << endl; 
  		fwrite(row.raw_data(0),1,*jj,stdout);
--- 18,24 ----
  	try {
  		con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
  		Query query = con.query();
! 		(std::ostream&)query << "SELECT " << MY_FIELD << " FROM " << MY_TABLE << " WHERE " << MY_KEY << " = " << argv[1];
  		ResUse res = query.use(); Row row=res.fetch_row(); long unsigned int *jj = res.fetch_lengths();
  		cout << "Content-length: " << *jj << endl << endl; 
  		fwrite(row.raw_data(0),1,*jj,stdout);
diff -rc mysql++-1.7.9/examples/complic1.cc mysql++-1.7.9-patched/examples/complic1.cc
*** mysql++-1.7.9/examples/complic1.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/complic1.cc	Mon Aug 27 13:44:36 2001
***************
*** 15,21 ****
      
      Query query = con.query();
      
!     query << "select * from stock";
      Result res = query.store();
      
      cout << "Query: " << query.preview() << endl;
--- 15,21 ----
      
      Query query = con.query();
      
!     (std::ostream&)query << "select * from stock";
      Result res = query.store();
      
      cout << "Query: " << query.preview() << endl;
***************
*** 23,32 ****
      
      Row row;
      cout.setf(ios::left);
!     cout << setw(17) << "Item" 
!        << setw(4)  << "Num"
!        << setw(7)  << "Weight"
!        << setw(7)  << "Price" 
         << "Date" << endl
         << endl;
    
--- 23,32 ----
      
      Row row;
      cout.setf(ios::left);
!     cout << std::setw(17) << "Item"
!        << std::setw(4)  << "Num"
!        << std::setw(7)  << "Weight"
!        << std::setw(7)  << "Price"
         << "Date" << endl
         << endl;
    
***************
*** 35,42 ****
      cout.precision(3);
      for (i = res.begin(); i != res.end(); i++) {
        row = *i;
!       cout << setw(17) << row["ITEM"] << "," << setw(4) << row[1] 
! 	   << setw(7)  << (double) row[2]
  	// This is converting the row to a double so that we
  	// can set the precision of it.  
  	// ColData has the nice feature that it will convert to
--- 35,42 ----
      cout.precision(3);
      for (i = res.begin(); i != res.end(); i++) {
        row = *i;
!       cout << std::setw(17) << row["ITEM"] << "," << std::setw(4) << row[1]
! 	   << std::setw(7)  << (double) row[2]
  	// This is converting the row to a double so that we
  	// can set the precision of it.  
  	// ColData has the nice feature that it will convert to
***************
*** 44,55 ****
  	// in the conversion it will throw an exception (which I 
  	// cache below).  To test it try changing the 2 in row[2]
  	// to row[0]
! 	   << setw(7) << (double)row[3];
        Date date = row["SDATE"]; 
        // The ColData is implicitly converted to a date here.
        cout.setf(ios::right);
        cout.fill('0');
!       cout << setw(2) << date.month << "-" << setw(2) << date.day << endl;
        cout.fill(' ');
        cout.unsetf(ios::right);
      }
--- 44,55 ----
  	// in the conversion it will throw an exception (which I 
  	// cache below).  To test it try changing the 2 in row[2]
  	// to row[0]
! 	   << std::setw(7) << (double)row[3];
        Date date = row["SDATE"]; 
        // The ColData is implicitly converted to a date here.
        cout.setf(ios::right);
        cout.fill('0');
!       cout << std::setw(2) << date.month << "-" << std::setw(2) << date.day << endl;
        cout.fill(' ');
        cout.unsetf(ios::right);
      }
diff -rc mysql++-1.7.9/examples/custom1.cc mysql++-1.7.9-patched/examples/custom1.cc
*** mysql++-1.7.9/examples/custom1.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/custom1.cc	Mon Aug 27 13:44:40 2001
***************
*** 4,18 ****
  #include <vector>
  #include <sqlplus.hh>
  #include <custom.hh>
! 
! sql_create_5 (stock,		// struct name, 
  	      1, 5,		// I'll explain these latter
! 	      string, item,	// type, id
  	      longlong, num,
  	      double, weight,
  	      double, price,
  	      Date, sdate)
! 
  // this is calling a very complex macro which will create a custom
  // struct "stock" which has the variables:
  //   string item
--- 4,18 ----
  #include <vector>
  #include <sqlplus.hh>
  #include <custom.hh>
! /*
! sql_create_5 (stock,    // struct name,
  	      1, 5,		// I'll explain these latter
! 	      std::string, item,	// type, id
  	      longlong, num,
  	      double, weight,
  	      double, price,
  	      Date, sdate)
!   */
  // this is calling a very complex macro which will create a custom
  // struct "stock" which has the variables:
  //   string item
***************
*** 23,33 ****
  // among other things that I'll get too in a latter example
  
  int main () {
!   try {				// its in one big try block
      Connection con (use_exceptions);
      con.connect ("mysql_cpp_data");
      Query query = con.query ();
!     query << "select * from stock";
  
      vector < stock > res;
      query.storein (res);
--- 23,33 ----
  // among other things that I'll get too in a latter example
  
  int main () {
! /*  try {				// its in one big try block
      Connection con (use_exceptions);
      con.connect ("mysql_cpp_data");
      Query query = con.query ();
!     (std::ostream&)query << "select * from stock";
  
      vector < stock > res;
      query.storein (res);
***************
*** 35,44 ****
      // "stock" which was created my the macro above.
  
      cout.setf (ios::left);
!     cout << setw (17) << "Item"
! 	 << setw (4) << "Num"
! 	 << setw (7) << "Weight"
! 	 << setw (7) << "Price"
  	 << "Date" << endl
  	 << endl;
  
--- 35,44 ----
      // "stock" which was created my the macro above.
  
      cout.setf (ios::left);
!     cout << std::setw (17) << "Item"
! 	 << std::setw (4) << "Num"
! 	 << std::setw (7) << "Weight"
! 	 << std::setw (7) << "Price"
  	 << "Date" << endl
  	 << endl;
  
***************
*** 52,63 ****
      cout.precision(3);
      vector <stock>::iterator i;
      for (i = res.begin (); i != res.end (); i++) {
!       cout << setw (17) << i->item.c_str ()
  	// unfortunally the gnu string class does not respond to format
  	// modifers so I have to convert it to a conat char *.
! 	   << setw (4) << i->num
! 	   << setw (7) << i->weight
! 	   << setw (7) << i->price
  	   << i->sdate
  	   << endl;
      }
--- 52,63 ----
      cout.precision(3);
      vector <stock>::iterator i;
      for (i = res.begin (); i != res.end (); i++) {
!       cout << std::setw (17) << i->item.c_str ()
  	// unfortunally the gnu string class does not respond to format
  	// modifers so I have to convert it to a conat char *.
! 	   << std::setw (4) << i->num
! 	   << std::setw (7) << i->weight
! 	   << std::setw (7) << i->price
  	   << i->sdate
  	   << endl;
      }
***************
*** 86,90 ****
      cerr << "Error: " << er.what() << endl;
      return -1;
  #endif		
!   }
  }
--- 86,90 ----
      cerr << "Error: " << er.what() << endl;
      return -1;
  #endif		
!   }*/
  }
diff -rc mysql++-1.7.9/examples/custom2.cc mysql++-1.7.9-patched/examples/custom2.cc
*** mysql++-1.7.9/examples/custom2.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/custom2.cc	Mon Aug 27 13:44:44 2001
***************
*** 6,16 ****
  #include "util.hh"
  // util.hh/cc contains the print_stock_table function
  
! sql_create_5(stock, 1, 5, string, item, longlong, num, 
  	     double, weight, double, price, Date, sdate)
! 
  int main() {
!   try { // its in one big try block
  
      Connection con(use_exceptions);
      con.connect("mysql_cpp_data");
--- 6,17 ----
  #include "util.hh"
  // util.hh/cc contains the print_stock_table function
  
! /*sql_create_5(stock, 1, 5, string, item, longlong, num,
  	     double, weight, double, price, Date, sdate)
!   */
  int main() {
! #if 0
!     try { // its in one big try block
  
      Connection con(use_exceptions);
      con.connect("mysql_cpp_data");
***************
*** 62,65 ****
--- 63,67 ----
      return -1;
  #endif		
    }
+ #endif
  }
diff -rc mysql++-1.7.9/examples/custom3.cc mysql++-1.7.9-patched/examples/custom3.cc
*** mysql++-1.7.9/examples/custom3.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/custom3.cc	Mon Aug 27 13:44:49 2001
***************
*** 5,15 ****
  #include <custom.hh>
  #include "util.hh"
  // util.hh/cc contains the print_stock_table function
! 
  sql_create_5(stock, 1, 5, string, item, longlong, num, 
  	     double, weight, double, price, Date, sdate)
! 
  int main() {
    try { // its in one big try block
  
      Connection con(use_exceptions);
--- 5,16 ----
  #include <custom.hh>
  #include "util.hh"
  // util.hh/cc contains the print_stock_table function
! /*
  sql_create_5(stock, 1, 5, string, item, longlong, num, 
  	     double, weight, double, price, Date, sdate)
!   */
  int main() {
+ #if 0
    try { // its in one big try block
  
      Connection con(use_exceptions);
***************
*** 69,72 ****
--- 70,74 ----
      return -1;
  #endif		
    }
+ #endif
  }
diff -rc mysql++-1.7.9/examples/custom4.cc mysql++-1.7.9-patched/examples/custom4.cc
*** mysql++-1.7.9/examples/custom4.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/custom4.cc	Mon Aug 27 13:44:53 2001
***************
*** 4,10 ****
  #include <vector>
  #include <sqlplus.hh>
  #include <custom.hh>
! 
  sql_create_5(stock, 
  	     1, // This number is used to make a SSQLS less-than-comparable.
  	        // If this number is n then if the first n elements are the 
--- 4,10 ----
  #include <vector>
  #include <sqlplus.hh>
  #include <custom.hh>
! /*
  sql_create_5(stock, 
  	     1, // This number is used to make a SSQLS less-than-comparable.
  	        // If this number is n then if the first n elements are the 
***************
*** 15,22 ****
  	        // elements in the list unless you have a good reason not to.
  
  	     string,item,  longlong,num,  double,weight,  double,price,  Date,sdate)
! 
  int main() {
    try { // its in one big try block
  		
      Connection con(use_exceptions);
--- 15,23 ----
  	        // elements in the list unless you have a good reason not to.
  
  	     string,item,  longlong,num,  double,weight,  double,price,  Date,sdate)
!   */
  int main() {
+ #if 0
    try { // its in one big try block
  		
      Connection con(use_exceptions);
***************
*** 86,89 ****
--- 87,91 ----
      return -1;
  #endif		
    }
+ #endif		
  }
diff -rc mysql++-1.7.9/examples/fieldinf1.cc mysql++-1.7.9-patched/examples/fieldinf1.cc
*** mysql++-1.7.9/examples/fieldinf1.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/fieldinf1.cc	Mon Aug 27 13:44:58 2001
***************
*** 2,15 ****
  #include <iostream>
  #include <iomanip>
  #include <sqlplus.hh>
! 
  int main() {
    try { // its in one big try block
  
      Connection con(use_exceptions);
      con.connect("mysql_cpp_data");
      Query query = con.query();
!     query << "select * from stock";
      Result res = query.store();
      
      cout << "Query: " << query.preview() << endl;
--- 2,16 ----
  #include <iostream>
  #include <iomanip>
  #include <sqlplus.hh>
! using std::setw;
! using std::string;
  int main() {
    try { // its in one big try block
  
      Connection con(use_exceptions);
      con.connect("mysql_cpp_data");
      Query query = con.query();
!     (std::ostream&)query << "select * from stock";
      Result res = query.store();
      
      cout << "Query: " << query.preview() << endl;
diff -rc mysql++-1.7.9/examples/load_file.cc mysql++-1.7.9-patched/examples/load_file.cc
*** mysql++-1.7.9/examples/load_file.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/load_file.cc	Mon Aug 27 13:45:03 2001
***************
*** 18,30 ****
  	try {
  		con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
  		Query query = con.query(); ostrstream strbuf;
! 		ifstream In (argv[1],ios::in | ios::binary); struct stat for_len;
  		if ((In.rdbuf())->is_open()) {
  			if (stat (argv[1],&for_len) == -1) return -1;
! 			unsigned int blen = for_len.st_size;  if (!blen) return -1;
! 			char  *read_buffer = new char[blen];	In.read(read_buffer,blen); string fill(read_buffer,blen);
  			strbuf  << "INSERT INTO " << MY_TABLE << " (" << MY_FIELD << ") VALUES(\""  << escape << fill  << "\")" << ends;
!       query.exec(strbuf.str());
  			delete[] read_buffer;
  		}
  		else 
--- 18,33 ----
  	try {
  		con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
  		Query query = con.query(); ostrstream strbuf;
! 		std::ifstream In (argv[1],ios::in | ios::binary); struct stat for_len;
  		if ((In.rdbuf())->is_open()) {
  			if (stat (argv[1],&for_len) == -1) return -1;
! 			unsigned int blen = for_len.st_size;
! 			if (!blen) return -1;
! 			char  *read_buffer = new char[blen];
! 			In.read(read_buffer,blen);
! 			std::string fill(read_buffer,blen);
  			strbuf  << "INSERT INTO " << MY_TABLE << " (" << MY_FIELD << ") VALUES(\""  << escape << fill  << "\")" << ends;
! 			query.exec(strbuf.str());
  			delete[] read_buffer;
  		}
  		else 
diff -rc mysql++-1.7.9/examples/populate.cc mysql++-1.7.9-patched/examples/populate.cc
*** mysql++-1.7.9/examples/populate.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/populate.cc	Mon Aug 27 13:45:09 2001
***************
*** 1,9 ****
  #include <vector>
  #include <string>
! vector<string> yy;
  #include <iostream>
  #include <iomanip>
  #include <mysql++>
  
  int main() {
    Connection con(use_exceptions);
--- 1,13 ----
  #include <vector>
  #include <string>
! using std::string;
! std::vector<string> yy;
  #include <iostream>
  #include <iomanip>
+ using std::setw;
  #include <mysql++>
+ #include <cstring>
+ using std::memset;
  
  int main() {
    Connection con(use_exceptions);
***************
*** 18,24 ****
  		query.exec("CREATE TABLE dva   (id2 int(11), pisanije char(12), vreme timestamp, INDEX(id2))");
  		query.exec("CREATE TABLE tri   (id3 int(11), pisanije char(12), vreme timestamp, INDEX(id3))");
  		for (unsigned int i=0; i<1000;i++) {
! 			char c = 'a' + i % 25; char xx[11]; memset(xx,c,10); xx[10]='\0'; 
  			char buff [100];
  			sprintf (buff,"INSERT INTO jedan (pisanije) VALUES('%s')",xx);
  			query.exec(buff);
--- 22,31 ----
  		query.exec("CREATE TABLE dva   (id2 int(11), pisanije char(12), vreme timestamp, INDEX(id2))");
  		query.exec("CREATE TABLE tri   (id3 int(11), pisanije char(12), vreme timestamp, INDEX(id3))");
  		for (unsigned int i=0; i<1000;i++) {
! 			char c = 'a' + i % 25;
! 			char xx[11];
! 			memset(xx,c,10);
! 			xx[10]='\0';
  			char buff [100];
  			sprintf (buff,"INSERT INTO jedan (pisanije) VALUES('%s')",xx);
  			query.exec(buff);
diff -rc mysql++-1.7.9/examples/resetdb.cc mysql++-1.7.9-patched/examples/resetdb.cc
*** mysql++-1.7.9/examples/resetdb.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/resetdb.cc	Mon Aug 27 13:45:13 2001
***************
*** 29,42 ****
        query.execute("drop table stock");
      } catch (BadQuery &er) {}
      
!     query << "create table stock  (item char(20) not null, num bigint,"
  	  << "weight double, price double, sdate date)";
      query.execute(RESET_QUERY);
      // send the query to create the table and execute it.  The
      // RESET_QUERY tells the query object to reset it self after
      // execution
      
!     query << "insert into %5:table values (%0q, %1q, %2, %3, %4q)";
      query.parse();
      // set up the template query I will use to insert the data.  The
      // parse method call is important as it is what lets the query
--- 29,42 ----
        query.execute("drop table stock");
      } catch (BadQuery &er) {}
      
!     (std::ostream&)query << "create table stock  (item char(20) not null, num bigint,"
  	  << "weight double, price double, sdate date)";
      query.execute(RESET_QUERY);
      // send the query to create the table and execute it.  The
      // RESET_QUERY tells the query object to reset it self after
      // execution
      
!     (std::ostream&)query << "insert into %5:table values (%0q, %1q, %2, %3, %4q)";
      query.parse();
      // set up the template query I will use to insert the data.  The
      // parse method call is important as it is what lets the query
diff -rc mysql++-1.7.9/examples/simple1.cc mysql++-1.7.9-patched/examples/simple1.cc
*** mysql++-1.7.9/examples/simple1.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/simple1.cc	Mon Aug 27 13:45:17 2001
***************
*** 14,20 ****
  		Query query = con.query();
  		// This creates a query object that is bound to con.
  
! 		query << "select * from stock";
  		// You can write to the query object like you would any other ostrem
  
  		Result res = query.store();
--- 14,20 ----
  		Query query = con.query();
  		// This creates a query object that is bound to con.
  
! 		(std::ostream&)query << "select * from stock";
  		// You can write to the query object like you would any other ostrem
  
  		Result res = query.store();
***************
*** 28,37 ****
    
  		Row row;
  		cout.setf(ios::left);
! 		cout << setw(17) << "Item" 
! 			<< setw(4)  << "Num"
! 			<< setw(7)  << "Weight"
! 			<< setw(7)  << "Price" 
  			<< "Date" << endl
  			<< endl;
    
--- 28,37 ----
    
  		Row row;
  		cout.setf(ios::left);
! 		cout << std::setw(17) << "Item"
! 			<< std::setw(4)  << "Num"
! 			<< std::setw(7)  << "Weight"
! 			<< std::setw(7)  << "Price"
  			<< "Date" << endl
  			<< endl;
    
***************
*** 39,50 ****
  		// The Result class has a read-only Random Access Iterator
  		for (i = res.begin(); i != res.end(); i++) {
  			row = *i;
! 			cout << setw(17) << row[0].c_str()
! 				<< setw(4)  << row[1].c_str()
! 				<< setw(7)  << row["weight"].c_str()
  				// you can use either the index number or column name when
  				// retrieving the colume data as demonstrated above.
! 				<< setw(7)  << row[3].c_str()
  				<< row[4] << endl;
  		}
    } catch (BadQuery &er) { // handle any connection or
--- 39,50 ----
  		// The Result class has a read-only Random Access Iterator
  		for (i = res.begin(); i != res.end(); i++) {
  			row = *i;
! 			cout << std::setw(17) << row[0].c_str()
! 				<< std::setw(4)  << row[1].c_str()
! 				<< std::setw(7)  << row["weight"].c_str()
  				// you can use either the index number or column name when
  				// retrieving the colume data as demonstrated above.
! 				<< std::setw(7)  << row[3].c_str()
  				<< row[4] << endl;
  		}
    } catch (BadQuery &er) { // handle any connection or
diff -rc mysql++-1.7.9/examples/sinisa_ex.cc mysql++-1.7.9-patched/examples/sinisa_ex.cc
*** mysql++-1.7.9/examples/sinisa_ex.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/examples/sinisa_ex.cc	Mon Aug 27 13:45:23 2001
***************
*** 1,8 ****
  #include <vector>
  #include <string>
! vector<string> yy;
  #include <iostream>
  #include <iomanip>
  #include <sqlplus.hh>
  
  int main() {
--- 1,10 ----
  #include <vector>
  #include <string>
! using std::string;
! std::vector<string> yy;
  #include <iostream>
  #include <iomanip>
+ using std::setw;
  #include <sqlplus.hh>
  
  int main() {
***************
*** 13,19 ****
  	cout << con.client_info() << endl << endl;
    Query query = con.query();
  
!   query << "show databases";
  
    Result res = query.store();
  
--- 15,21 ----
  	cout << con.client_info() << endl << endl;
    Query query = con.query();
  
!   (std::ostream&)query << "show databases";
  
    Result res = query.store();
  
***************
*** 33,39 ****
  	char database [] = "mysql";
    con.select_db (database);
  
!   query << "show tables";
  
    res = query.store();
  
--- 35,41 ----
  	char database [] = "mysql";
    con.select_db (database);
  
!   (std::ostream&)query << "show tables";
  
    res = query.store();
  
***************
*** 51,57 ****
  		yy.insert(yy.end(),xx);
    }
  	for (unsigned int j = 0; j < yy.size();j++) {
! 		query << "describe " << yy[j] << "";
  		cout << query.preview() << endl << endl;
  		res = query.store();
  		unsigned int columns = res.num_fields(), counter;
--- 53,59 ----
  		yy.insert(yy.end(),xx);
    }
  	for (unsigned int j = 0; j < yy.size();j++) {
! 		(std::ostream&)query << "describe " << yy[j] << "";
  		cout << query.preview() << endl << endl;
  		res = query.store();
  		unsigned int columns = res.num_fields(), counter;
***************
*** 68,74 ****
  			cout << endl;
  		}
  	}
! 		query << "select * from user";
  		res  =  query.store(); int columns =  res.num_fields();
  		cout << query.preview() << endl << endl;
  		cout << "fields = " << res.num_fields() << "rows = " << res.size() << endl;
--- 70,76 ----
  			cout << endl;
  		}
  	}
! 		(std::ostream&)query << "select * from user";
  		res  =  query.store(); int columns =  res.num_fields();
  		cout << query.preview() << endl << endl;
  		cout << "fields = " << res.num_fields() << "rows = " << res.size() << endl;
diff -rc mysql++-1.7.9/examples/updel_x_.cc mysql++-1.7.9-patched/examples/updel_x_.cc
*** mysql++-1.7.9/examples/updel_x_.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/examples/updel_x_.cc	Mon Aug 27 13:45:27 2001
***************
*** 1,5 ****
  #include <sqlplus.hh>
! 
  #define MY_DATABASE	"telcent"
  #define MY_TABLE		"nazivi"
  #define MY_HOST    "localhost"
--- 1,6 ----
  #include <sqlplus.hh>
! #include <string>
! using std::string;
  #define MY_DATABASE	"telcent"
  #define MY_TABLE		"nazivi"
  #define MY_HOST    "localhost"
***************
*** 13,19 ****
  	try {
  		ostrstream strbuf; unsigned int i=0; 
  		con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
! 		Query query = con.query(); query << MY_QUERY; 
  		ResUse res = query.use(); Row row; 
  		strbuf << "delete from " << MY_TABLE << " where " << MY_FIELD << " in (";
  //  for UPDATE just replace the above DELETE FROM with UPDATE statement
--- 14,20 ----
  	try {
  		ostrstream strbuf; unsigned int i=0; 
  		con.real_connect (MY_DATABASE,MY_HOST,MY_USER,MY_PASSWORD,3306,(int)0,60,NULL);
! 		Query query = con.query(); (std::ostream&)query << MY_QUERY;
  		ResUse res = query.use(); Row row; 
  		strbuf << "delete from " << MY_TABLE << " where " << MY_FIELD << " in (";
  //  for UPDATE just replace the above DELETE FROM with UPDATE statement
diff -rc mysql++-1.7.9/examples/util.cc mysql++-1.7.9-patched/examples/util.cc
*** mysql++-1.7.9/examples/util.cc	Sat May 19 12:44:47 2001
--- mysql++-1.7.9-patched/examples/util.cc	Mon Aug 27 13:45:30 2001
***************
*** 4,10 ****
  
  void print_stock_table(Query& query) {
    query.reset();
!   query << "select * from stock";
    // You can write to the query object like you would any other ostrem
  
    Result res = query.store();
--- 4,10 ----
  
  void print_stock_table(Query& query) {
    query.reset();
!   (std::ostream&)query << "select * from stock";
    // You can write to the query object like you would any other ostrem
  
    Result res = query.store();
***************
*** 18,27 ****
    
    Row row;
    cout.setf(ios::left);
!   cout << setw(20) << "Item" 
!        << setw(9)  << "Num"
!        << setw(9)  << "Weight"
!        << setw(9)  << "Price" 
         << "Date" << endl
         << endl;
    
--- 18,27 ----
    
    Row row;
    cout.setf(ios::left);
!   cout << std::setw(20) << "Item"
!        << std::setw(9)  << "Num"
!        << std::setw(9)  << "Weight"
!        << std::setw(9)  << "Price"
         << "Date" << endl
         << endl;
    
***************
*** 29,40 ****
    // The Result class has a read-only Random Access Iterator
    for (i = res.begin(); i != res.end(); i++) {
      row = *i; 
!     cout << setw(20) << row[0].c_str()
! 	 << setw(9)  << row[1].c_str()
! 	 << setw(9)  << row["weight"].c_str()
        // you can use either the index number or column name when
        // retrieving the colume data as demonstrated above.
! 	 << setw(9)  << row[3].c_str()
  	 << row[4] << endl;
    }
  }
--- 29,40 ----
    // The Result class has a read-only Random Access Iterator
    for (i = res.begin(); i != res.end(); i++) {
      row = *i; 
!     cout << std::setw(20) << row[0].c_str()
! 	 << std::setw(9)  << row[1].c_str()
! 	 << std::setw(9)  << row["weight"].c_str()
        // you can use either the index number or column name when
        // retrieving the colume data as demonstrated above.
! 	 << std::setw(9)  << row[3].c_str()
  	 << row[4] << endl;
    }
  }
diff -rc mysql++-1.7.9/sqlplusint/Makefile.in mysql++-1.7.9-patched/sqlplusint/Makefile.in
*** mysql++-1.7.9/sqlplusint/Makefile.in	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/Makefile.in	Mon Aug 27 13:46:16 2001
***************
*** 64,81 ****
  CC = @CC@
  CXX = @CXX@
  DLLTOOL = @DLLTOOL@
! LD = @LD@
  LIBTOOL = @LIBTOOL@
  LN_S = @LN_S@
  MAINT = @MAINT@
  MAKEINFO = @MAKEINFO@
- NM = @NM@
  OBJDUMP = @OBJDUMP@
  PACKAGE = @PACKAGE@
  RANLIB = @RANLIB@
  SQLPLUS_MAJOR_VERSION = @SQLPLUS_MAJOR_VERSION@
  SQLPLUS_MICRO_VERSION = @SQLPLUS_MICRO_VERSION@
  SQLPLUS_MINOR_VERSION = @SQLPLUS_MINOR_VERSION@
  VERSION = @VERSION@
  
  INCLUDES = -I$(top_srcdir)/sqlplusint
--- 64,83 ----
  CC = @CC@
  CXX = @CXX@
  DLLTOOL = @DLLTOOL@
! ECHO = @ECHO@
! EXEEXT = @EXEEXT@
  LIBTOOL = @LIBTOOL@
  LN_S = @LN_S@
  MAINT = @MAINT@
  MAKEINFO = @MAKEINFO@
  OBJDUMP = @OBJDUMP@
+ OBJEXT = @OBJEXT@
  PACKAGE = @PACKAGE@
  RANLIB = @RANLIB@
  SQLPLUS_MAJOR_VERSION = @SQLPLUS_MAJOR_VERSION@
  SQLPLUS_MICRO_VERSION = @SQLPLUS_MICRO_VERSION@
  SQLPLUS_MINOR_VERSION = @SQLPLUS_MINOR_VERSION@
+ STRIP = @STRIP@
  VERSION = @VERSION@
  
  INCLUDES = -I$(top_srcdir)/sqlplusint
***************
*** 131,137 ****
  
  all: all-redirect
  .SUFFIXES:
! .SUFFIXES: .S .c .cc .lo .o .s
  $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) $(top_srcdir)/Configure
  	cd $(top_srcdir) && $(AUTOMAKE) --gnu sqlplusint/Makefile
  
--- 133,139 ----
  
  all: all-redirect
  .SUFFIXES:
! .SUFFIXES: .S .c .cc .lo .o .obj .s
  $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) $(top_srcdir)/Configure
  	cd $(top_srcdir) && $(AUTOMAKE) --gnu sqlplusint/Makefile
  
***************
*** 193,198 ****
--- 195,205 ----
  	  $(LIBTOOL)  --mode=uninstall rm -f $(DESTDIR)$(libdir)/$$p; \
  	done
  
+ # FIXME: We should only use cygpath when building on Windows,
+ # and only if it is available.
+ .c.obj:
+ 	$(COMPILE) -c `cygpath -w $<`
+ 
  .s.o:
  	$(COMPILE) -c $<
  
***************
*** 201,206 ****
--- 208,214 ----
  
  mostlyclean-compile:
  	-rm -f *.o core *.core
+ 	-rm -f *.$(OBJEXT)
  
  clean-compile:
  
***************
*** 229,234 ****
--- 237,244 ----
  	$(CXXLINK) -rpath $(libdir) $(libsqlplus_la_LDFLAGS) $(libsqlplus_la_OBJECTS) $(libsqlplus_la_LIBADD) $(LIBS)
  .cc.o:
  	$(CXXCOMPILE) -c $<
+ .cc.obj:
+ 	$(CXXCOMPILE) -c `cygpath -w $<`
  .cc.lo:
  	$(LTCXXCOMPILE) -c $<
  
***************
*** 289,295 ****
  	@for file in $(DISTFILES); do \
  	  d=$(srcdir); \
  	  if test -d $$d/$$file; then \
! 	    cp -pr $$/$$file $(distdir)/$$file; \
  	  else \
  	    test -f $(distdir)/$$file \
  	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
--- 299,305 ----
  	@for file in $(DISTFILES); do \
  	  d=$(srcdir); \
  	  if test -d $$d/$$file; then \
! 	    cp -pr $$d/$$file $(distdir)/$$file; \
  	  else \
  	    test -f $(distdir)/$$file \
  	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
diff -rc mysql++-1.7.9/sqlplusint/coldata.cc mysql++-1.7.9-patched/sqlplusint/coldata.cc
*** mysql++-1.7.9/sqlplusint/coldata.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/coldata.cc	Mon Aug 27 13:46:29 2001
***************
*** 2,6 ****
  #include "const_string3.hh"
  #include "coldata4.hh"
  
! template class mysql_ColData<string>;
  template class mysql_ColData<const_string>;
--- 2,6 ----
  #include "const_string3.hh"
  #include "coldata4.hh"
  
! template class mysql_ColData<std::string>;
  template class mysql_ColData<const_string>;
diff -rc mysql++-1.7.9/sqlplusint/coldata1.hh mysql++-1.7.9-patched/sqlplusint/coldata1.hh
*** mysql++-1.7.9/sqlplusint/coldata1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/coldata1.hh	Mon Aug 27 13:46:35 2001
***************
*** 40,53 ****
  class mysql_ColData : public Str {
  private:
    mysql_type_info _type;
! 	string buf;
  	bool _null;
  public:
    mysql_ColData (bool n, mysql_type_info t = mysql_type_info::string_type) 
      : _type(t), _null(n) {}
    mysql_ColData (const char *str, 
  		 mysql_type_info t = mysql_type_info::string_type, bool n = false)
!     : Str(str), _type(t), _null(n) {buf=(string)str;}
    mysql_ColData () {}
    mysql_type_info type() {return _type;}
    //: Returns the current mysql type of current item
--- 40,53 ----
  class mysql_ColData : public Str {
  private:
    mysql_type_info _type;
! 	std::string buf;
  	bool _null;
  public:
    mysql_ColData (bool n, mysql_type_info t = mysql_type_info::string_type) 
      : _type(t), _null(n) {}
    mysql_ColData (const char *str, 
  		 mysql_type_info t = mysql_type_info::string_type, bool n = false)
!     : Str(str), _type(t), _null(n) {buf=str;}
    mysql_ColData () {}
    mysql_type_info type() {return _type;}
    //: Returns the current mysql type of current item
***************
*** 72,78 ****
    // (Note, This is not an actual template)
    void it_is_null (void) {_null=true;}
  	inline const bool is_null(void) const {return _null;}
! 	inline const string&  get_string(void) const {return buf;}
    operator cchar*() const {return buf.c_str();}
    operator  signed char() const {return conv((signed char)0);}
    operator  unsigned char() const {return conv((unsigned char)0);}
--- 72,78 ----
    // (Note, This is not an actual template)
    void it_is_null (void) {_null=true;}
  	inline const bool is_null(void) const {return _null;}
! 	inline const std::string&  get_string(void) const {return buf;}
    operator cchar*() const {return buf.c_str();}
    operator  signed char() const {return conv((signed char)0);}
    operator  unsigned char() const {return conv((unsigned char)0);}
***************
*** 95,101 ****
  //: The Type that is returned by constant rows
  typedef mysql_ColData<const_string> ColData;
  //: The Type that is returned by mutable rows
! typedef mysql_ColData<string>       MutableColData;
  //: For backwards compatibility. Do not use.
  typedef ColData MysqlString;
  //: For backwards compatibility. Do not use.
--- 95,101 ----
  //: The Type that is returned by constant rows
  typedef mysql_ColData<const_string> ColData;
  //: The Type that is returned by mutable rows
! typedef mysql_ColData<std::string>       MutableColData;
  //: For backwards compatibility. Do not use.
  typedef ColData MysqlString;
  //: For backwards compatibility. Do not use.
diff -rc mysql++-1.7.9/sqlplusint/coldata4.hh mysql++-1.7.9-patched/sqlplusint/coldata4.hh
*** mysql++-1.7.9/sqlplusint/coldata4.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/coldata4.hh	Mon Aug 27 13:46:41 2001
***************
*** 9,15 ****
  
  template <class Str> template<class Type> 
  Type mysql_ColData<Str>::conv (Type dummy) const {
! 	string strbuf(buf);
  	strip_all_blanks(strbuf);
    size_t len = strbuf.size();
    const char *str = strbuf.c_str();
--- 9,15 ----
  
  template <class Str> template<class Type> 
  Type mysql_ColData<Str>::conv (Type dummy) const {
! 	std::string strbuf = buf;
  	strip_all_blanks(strbuf);
    size_t len = strbuf.size();
    const char *str = strbuf.c_str();
diff -rc mysql++-1.7.9/sqlplusint/compare1.hh mysql++-1.7.9-patched/sqlplusint/compare1.hh
*** mysql++-1.7.9/sqlplusint/compare1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/compare1.hh	Mon Aug 27 13:46:50 2001
***************
*** 2,7 ****
--- 2,8 ----
  #define __compare1_hh__
  
  #include <function.h>
+ #include <cstring>
  #include "row1.hh"
  
  template <class BinaryPred, class CmpType>
***************
*** 40,66 ****
  
  struct cstr_equal_to : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return !strcmp(x,y);}
  };
  struct cstr_not_equal_to : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return strcmp(x,y);}
  };
  struct cstr_less : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return strcmp(x,y) > 0; }
  };
  struct cstr_less_equal : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return strcmp(x,y) >= 0; }
  };
  struct cstr_greater : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return strcmp(x,y) < 0; }
  };
  struct cstr_greater_equal : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return strcmp(x,y) <= 0; }
  };
  
  //:A special function for using in find_if fucntion where i is the field index
--- 41,67 ----
  
  struct cstr_equal_to : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return !std::strcmp(x,y);}
  };
  struct cstr_not_equal_to : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return std::strcmp(x,y);}
  };
  struct cstr_less : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return std::strcmp(x,y) > 0; }
  };
  struct cstr_less_equal : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return std::strcmp(x,y) >= 0; }
  };
  struct cstr_greater : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return std::strcmp(x,y) < 0; }
  };
  struct cstr_greater_equal : bin_char_pred {
    bool operator () (const char *x, const char *y) const
!     {return std::strcmp(x,y) <= 0; }
  };
  
  //:A special function for using in find_if fucntion where i is the field index
diff -rc mysql++-1.7.9/sqlplusint/connection.cc mysql++-1.7.9-patched/sqlplusint/connection.cc
*** mysql++-1.7.9/sqlplusint/connection.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/connection.cc	Mon Aug 27 13:47:02 2001
***************
*** 108,122 ****
    return Success;
  }
  
! string Connection::info () {
    char *i = mysql_info(&mysql);
    if (!i)
!     return string();
    else
!     return string(i);
  }
  
! ResNSel Connection::execute(const string &str, bool throw_excptns) {
    Success = false;
    if (lock()) 
      if (throw_excptns) throw BadQuery(error());
--- 108,122 ----
    return Success;
  }
  
! std::string Connection::info () {
    char *i = mysql_info(&mysql);
    if (!i)
!     return std::string();
    else
!     return std::string(i);
  }
  
! ResNSel Connection::execute(const std::string &str, bool throw_excptns) {
    Success = false;
    if (lock()) 
      if (throw_excptns) throw BadQuery(error());
***************
*** 129,141 ****
    return ResNSel(this);
  }
  
! bool Connection::exec(const string &str) {
  	Success = !mysql_query(&mysql,str.c_str());
  	if (!Success && throw_exceptions) throw BadQuery(error());
  	return Success;
  }
  
! Result Connection::store(const string &str, bool throw_excptns) {
    Success = false;
    if (lock()) 
      if (throw_excptns) throw BadQuery(error());
--- 129,141 ----
    return ResNSel(this);
  }
  
! bool Connection::exec(const std::string &str) {
  	Success = !mysql_query(&mysql,str.c_str());
  	if (!Success && throw_exceptions) throw BadQuery(error());
  	return Success;
  }
  
! Result Connection::store(const std::string &str, bool throw_excptns) {
    Success = false;
    if (lock()) 
      if (throw_excptns) throw BadQuery(error());
***************
*** 148,154 ****
    return Result(mysql_store_result(&mysql));
  }
    
! ResUse Connection::use(const string &str, bool throw_excptns) {
    Success = false;
    if (lock()) 
      if (throw_excptns) throw BadQuery(error());
--- 148,154 ----
    return Result(mysql_store_result(&mysql));
  }
    
! ResUse Connection::use(const std::string &str, bool throw_excptns) {
    Success = false;
    if (lock()) 
      if (throw_excptns) throw BadQuery(error());
diff -rc mysql++-1.7.9/sqlplusint/connection1.hh mysql++-1.7.9-patched/sqlplusint/connection1.hh
*** mysql++-1.7.9/sqlplusint/connection1.hh	Sat May 19 12:44:49 2001
--- mysql++-1.7.9-patched/sqlplusint/connection1.hh	Mon Aug 27 13:47:09 2001
***************
*** 22,30 ****
  
  //: The main database handle
  class Connection {
!   friend ResNSel;
!   friend ResUse;
!   friend Query;
    
  private:
    bool throw_exceptions;
--- 22,30 ----
  
  //: The main database handle
  class Connection {
!   friend class ResNSel;
!   friend class ResUse;
!   friend class Query;
    
  private:
    bool throw_exceptions;
***************
*** 52,58 ****
  				
    ~Connection (); //:
    void         close() {mysql_close(&mysql);}	 //:
!   string       info ();	//:
  
    bool   connected() const {return is_connected;}
    //: returns true if a successful connection was made
--- 52,58 ----
  				
    ~Connection (); //:
    void         close() {mysql_close(&mysql);}	 //:
!   std::string       info ();	//:
  
    bool   connected() const {return is_connected;}
    //: returns true if a successful connection was made
***************
*** 74,132 ****
    //:
  
    operator bool () {return success();}                  //: returns success()
!   string error () {return string(mysql_error(&mysql));} //: last error message()
  	int errnum () {return mysql_errno(&mysql);}
  	int   refresh (unsigned int refresh_options){ return mysql_refresh (&mysql,refresh_options); }
  	int ping (void) { return mysql_ping(&mysql);}
  	int kill (unsigned long pid) { return mysql_kill (&mysql,pid);}
!   string client_info () {return string(mysql_get_client_info());} //:
    
!   string host_info () {return string(mysql_get_host_info(&mysql));} //:
    
    int    proto_info () {return mysql_get_proto_info(&mysql);} //:
    
!   string server_info () {return string(mysql_get_server_info(&mysql));} //:
   
!   string stat() {return string(mysql_stat(&mysql));} //:
   
!   Result  store(const string &str) {return store(str, throw_exceptions);} //:
!   ResUse  use(const string &str)   {return use(str, throw_exceptions);} //:
!   ResNSel execute(const string &str) {return execute(str, throw_exceptions);} //:
! 	bool exec (const string &str);
!   Result  store(const string &str, bool te); //:
!   ResUse  use(const string &str, bool te); //:
!   ResNSel execute(const string &str, bool te); //:
   
!   bool   create_db (string db) {return !(execute( "CREATE DATABASE " + db ));} //:
!   bool   drop_db (string db) {return !(execute( "DROP DATABASE " + db ));} //:
!   bool   select_db (string db) {return select_db(db.c_str());} //:
    bool   select_db (const char *db); //:
    bool   reload(); //:
    bool   shutdown (); //:
! 	string infoo (void) {return info ();}
  	st_mysql_options get_options (void) const {return mysql.options;}
  	int read_options(enum mysql_option option,const char *arg) {return  mysql_options(&mysql, option,arg);}
    int          affected_rows()  {return mysql_affected_rows((MYSQL*) &mysql);}
    int          insert_id () {return mysql_insert_id(&mysql);}
  
!   template <class Sequence> void storein_sequence(Sequence &, const string &); //:
!   template <class Set>      void storein_set(Set &, const string &);  //:
  
    //!dummy: void storein(TYPE &con, const string &s);
    //: Stores the results in TYPE.  
    // Stores the result in TYPE. TYPE must be some sort of STL container.  
  
!   template <class T>        void storein(vector<T> &con, const string &s)
      {storein_sequence(con,s);}
!   template <class T>        void storein(deque<T> &con, const string &s)
       {storein_sequence(con,s);}
!   template <class T>        void storein(list<T> &con, const string &s)
      {storein_sequence(con,s);}
!   template <class T>        void storein(slist<T> &con, const string &s)
      {storein_sequence(con,s);}
!   template <class T>        void storein(set<T> &con, const string &s)
      {storein_set(con,s);}
!   template <class T>        void storein(multiset<T> &con, const string &s)
      {storein_set(con,s);}
  };
  
--- 74,134 ----
    //:
  
    operator bool () {return success();}                  //: returns success()
!   std::string error () {return mysql_error(&mysql);} //: last error message()
  	int errnum () {return mysql_errno(&mysql);}
  	int   refresh (unsigned int refresh_options){ return mysql_refresh (&mysql,refresh_options); }
  	int ping (void) { return mysql_ping(&mysql);}
  	int kill (unsigned long pid) { return mysql_kill (&mysql,pid);}
!   std::string client_info () {return std::string(mysql_get_client_info());} //:
    
!   std::string host_info () {return std::string(mysql_get_host_info(&mysql));} //:
    
    int    proto_info () {return mysql_get_proto_info(&mysql);} //:
    
!   std::string server_info () {return std::string(mysql_get_server_info(&mysql));} //:
   
!   std::string stat() {return std::string(mysql_stat(&mysql));} //:
   
!   Result  store(const std::string &str) {return store(str, throw_exceptions);} //:
!   ResUse  use(const std::string &str)   {return use(str, throw_exceptions);} //:
!   ResNSel execute(const std::string &str) {return execute(str, throw_exceptions);} //:
! 	bool exec (const std::string &str);
!   Result  store(const std::string &str, bool te); //:
!   ResUse  use(const std::string &str, bool te); //:
!   ResNSel execute(const std::string &str, bool te); //:
   
!   bool   create_db (std::string db) {return !(execute( "CREATE DATABASE " + db ));} //:
!   bool   drop_db (std::string db) {return !(execute( "DROP DATABASE " + db ));} //:
!   bool   select_db (std::string db) {return select_db(db.c_str());} //:
    bool   select_db (const char *db); //:
    bool   reload(); //:
    bool   shutdown (); //:
! 	std::string infoo (void) {return info ();}
  	st_mysql_options get_options (void) const {return mysql.options;}
  	int read_options(enum mysql_option option,const char *arg) {return  mysql_options(&mysql, option,arg);}
    int          affected_rows()  {return mysql_affected_rows((MYSQL*) &mysql);}
    int          insert_id () {return mysql_insert_id(&mysql);}
  
!   template <class Sequence> void storein_sequence(Sequence &, const std::string &); //:
!   template <class Set>      void storein_set(Set &, const std::string &);  //:
  
    //!dummy: void storein(TYPE &con, const string &s);
    //: Stores the results in TYPE.  
    // Stores the result in TYPE. TYPE must be some sort of STL container.  
  
!   template <class T>        void storein(std::vector<T> &con, const std::string &s)
      {storein_sequence(con,s);}
!   template <class T>        void storein(std::deque<T> &con, const std::string &s)
       {storein_sequence(con,s);}
!   template <class T>        void storein(std::list<T> &con, const std::string &s)
      {storein_sequence(con,s);}
! #ifdef HAVE_STD_SLIST
!   template <class T>        void storein(std::slist<T> &con, const std::string &s)
      {storein_sequence(con,s);}
! #endif
!   template <class T>        void storein(std::set<T> &con, const std::string &s)
      {storein_set(con,s);}
!   template <class T>        void storein(std::multiset<T> &con, const std::string &s)
      {storein_set(con,s);}
  };
  
diff -rc mysql++-1.7.9/sqlplusint/connection2.hh mysql++-1.7.9-patched/sqlplusint/connection2.hh
*** mysql++-1.7.9/sqlplusint/connection2.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/connection2.hh	Mon Aug 27 13:47:13 2001
***************
*** 7,13 ****
  inline Query Connection::query() {return Query(this, throw_exceptions);}
  
  template <class Sequence>
! void Connection::storein_sequence (Sequence &seq, const string &str) {
    ResUse result = use(str);
    while (1) {
  	  MYSQL_ROW d = mysql_fetch_row(result.mysql_res);
--- 7,13 ----
  inline Query Connection::query() {return Query(this, throw_exceptions);}
  
  template <class Sequence>
! void Connection::storein_sequence (Sequence &seq, const std::string &str) {
    ResUse result = use(str);
    while (1) {
  	  MYSQL_ROW d = mysql_fetch_row(result.mysql_res);
***************
*** 19,25 ****
  }
  
  template <class Set>
! void Connection::storein_set (Set &sett, const string &str) {
    ResUse result = use(str);
  	while (1) {
  	  MYSQL_ROW d = mysql_fetch_row(result.mysql_res);	
--- 19,25 ----
  }
  
  template <class Set>
! void Connection::storein_set (Set &sett, const std::string &str) {
    ResUse result = use(str);
  	while (1) {
  	  MYSQL_ROW d = mysql_fetch_row(result.mysql_res);	
diff -rc mysql++-1.7.9/sqlplusint/const_string1.hh mysql++-1.7.9-patched/sqlplusint/const_string1.hh
*** mysql++-1.7.9/sqlplusint/const_string1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/const_string1.hh	Mon Aug 27 13:47:16 2001
***************
*** 47,53 ****
    const_reference operator[](size_type pos) const {return str_data[pos];} //:
    const_reference at(size_type pos) const //: 
    {
!     if (pos >= size()) throw out_of_range("");
      else return str_data[pos];
    }
    
--- 47,53 ----
    const_reference operator[](size_type pos) const {return str_data[pos];} //:
    const_reference at(size_type pos) const //: 
    {
!     if (pos >= size()) throw std::out_of_range("");
      else return str_data[pos];
    }
    
***************
*** 67,73 ****
  //! with_class = const_string
  
  //:
! inline ostream& operator << (ostream &o, const const_string &str) {
    return o << str.c_str();
  }
  
--- 67,73 ----
  //! with_class = const_string
  
  //:
! inline std::ostream& operator << (std::ostream &o, const const_string &str) {
    return o << str.c_str();
  }
  
diff -rc mysql++-1.7.9/sqlplusint/custom.hh mysql++-1.7.9-patched/sqlplusint/custom.hh
*** mysql++-1.7.9/sqlplusint/custom.hh	Sat May 19 12:44:49 2001
--- mysql++-1.7.9-patched/sqlplusint/custom.hh	Mon Aug 27 13:47:23 2001
***************
*** 8,14 ****
  enum sql_dummy_type {sql_dummy};
  enum sql_cmp_type {sql_use_compare};
  
! inline int sql_cmp(const string &a, const string &b) {
    return a.compare(b);
  }
  
--- 8,14 ----
  enum sql_dummy_type {sql_dummy};
  enum sql_cmp_type {sql_use_compare};
  
! inline int sql_cmp(const std::string &a, const std::string &b) {
    return a.compare(b);
  }
  
diff -rc mysql++-1.7.9/sqlplusint/custom.pl mysql++-1.7.9-patched/sqlplusint/custom.pl
*** mysql++-1.7.9/sqlplusint/custom.pl	Sat May 19 12:44:49 2001
--- mysql++-1.7.9-patched/sqlplusint/custom.pl	Mon Aug 27 13:47:26 2001
***************
*** 13,19 ****
  enum sql_dummy_type {sql_dummy};
  enum sql_cmp_type {sql_use_compare};
  
! inline int sql_cmp(const string &a, const string &b) {
    return a.compare(b);
  }
  ---
--- 13,19 ----
  enum sql_dummy_type {sql_dummy};
  enum sql_cmp_type {sql_use_compare};
  
! inline int sql_cmp(const std::string &a, const std::string &b) {
    return a.compare(b);
  }
  ---
diff -rc mysql++-1.7.9/sqlplusint/datetime1.hh mysql++-1.7.9-patched/sqlplusint/datetime1.hh
*** mysql++-1.7.9/sqlplusint/datetime1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/datetime1.hh	Mon Aug 27 13:47:30 2001
***************
*** 18,26 ****
  #include "tiny_int1.hh"
  
  struct mysql_dt_base {
!   virtual ostream& out_stream(ostream&) const = 0;
  
!   operator string ();
  };
  
  template <class T>
--- 18,26 ----
  #include "tiny_int1.hh"
  
  struct mysql_dt_base {
!   virtual std::ostream& out_stream(std::ostream&) const = 0;
  
!   operator std::string ();
  };
  
  template <class T>
***************
*** 40,46 ****
    tiny_int  month;
    tiny_int  day;
  
!   ostream& out_stream(ostream&) const;
    cchar* convert (cchar*);
  protected:
    short int compare(const mysql_date *other) const;
--- 40,46 ----
    tiny_int  month;
    tiny_int  day;
  
!   std::ostream& out_stream(std::ostream&) const;
    cchar* convert (cchar*);
  protected:
    short int compare(const mysql_date *other) const;
***************
*** 71,83 ****
    Date () {};
    Date (cchar* str) {convert(str);}
    Date (const ColData &str);
!   Date (const string &str);
  
    short int compare(const Date& other) const 
      {return mysql_date::compare(&other);}
  };
  
! inline ostream& operator << (ostream& s, const Date& d) 
                                                    {return d.out_stream(s);}
  
  struct mysql_time : virtual public mysql_dt_base {
--- 71,83 ----
    Date () {};
    Date (cchar* str) {convert(str);}
    Date (const ColData &str);
!   Date (const std::string &str);
  
    short int compare(const Date& other) const 
      {return mysql_date::compare(&other);}
  };
  
! inline std::ostream& operator << (std::ostream& s, const Date& d)
                                                    {return d.out_stream(s);}
  
  struct mysql_time : virtual public mysql_dt_base {
***************
*** 85,91 ****
    tiny_int minute;  
    tiny_int second;
  
!   ostream& out_stream(ostream&) const;
    cchar* convert (cchar*);
  protected:
    short int compare(const mysql_time *other) const;
--- 85,91 ----
    tiny_int minute;  
    tiny_int second;
  
!   std::ostream& out_stream(std::ostream&) const;
    cchar* convert (cchar*);
  protected:
    short int compare(const mysql_time *other) const;
***************
*** 116,129 ****
    Time () {};
    Time (cchar* str) {convert(str);}
    Time (const ColData &str);
!   Time (const string &str);
  
    short int compare(const Time& other) const 
      {return mysql_time::compare(&other);}
  };
  
  
! inline ostream& operator << (ostream& s, const Time& d)
                                                   {return d.out_stream(s);}
  
  //: A combinate of Date and Time for holding mysql DateTime's
--- 116,129 ----
    Time () {};
    Time (cchar* str) {convert(str);}
    Time (const ColData &str);
!   Time (const std::string &str);
  
    short int compare(const Time& other) const 
      {return mysql_time::compare(&other);}
  };
  
  
! inline std::ostream& operator << (std::ostream& s, const Time& d)
                                                   {return d.out_stream(s);}
  
  //: A combinate of Date and Time for holding mysql DateTime's
***************
*** 135,149 ****
    DateTime () {}
    DateTime (cchar* str) {convert(str);}
    DateTime (const ColData &str);
!   DateTime (const string &str);
  
    short int compare(const DateTime& other) const;
  
!   ostream& out_stream(ostream&) const;
    cchar* convert (cchar*);
  };
  
! inline ostream& operator << (ostream& s, const DateTime& d)
                                                     {return d.out_stream(s);}
  
  #endif
--- 135,149 ----
    DateTime () {}
    DateTime (cchar* str) {convert(str);}
    DateTime (const ColData &str);
!   DateTime (const std::string &str);
  
    short int compare(const DateTime& other) const;
  
!   std::ostream& out_stream(std::ostream&) const;
    cchar* convert (cchar*);
  };
  
! inline std::ostream& operator << (std::ostream& s, const DateTime& d)
                                                     {return d.out_stream(s);}
  
  #endif
diff -rc mysql++-1.7.9/sqlplusint/datetime2.hh mysql++-1.7.9-patched/sqlplusint/datetime2.hh
*** mysql++-1.7.9/sqlplusint/datetime2.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/datetime2.hh	Mon Aug 27 13:47:33 2001
***************
*** 5,21 ****
  #include "coldata2.hh"
  #include "stream2string2.hh"
  
! inline mysql_dt_base::operator string () {
!   return stream2string<string>(*this);
  }
  
  inline Date::Date (const ColData &str) {convert(str.c_str());}
! inline Date::Date (const string &str)  {convert(str.c_str());}
  
  inline Time::Time (const ColData &str) {convert(str.c_str());}
! inline Time::Time (const string &str)  {convert(str.c_str());}
  
  inline DateTime::DateTime (const ColData &str) {convert(str.c_str());}
! inline DateTime::DateTime (const string &str) {convert(str.c_str());}
  
  #endif
--- 5,21 ----
  #include "coldata2.hh"
  #include "stream2string2.hh"
  
! inline mysql_dt_base::operator std::string () {
!   return stream2string<std::string>(*this);
  }
  
  inline Date::Date (const ColData &str) {convert(str.c_str());}
! inline Date::Date (const std::string &str)  {convert(str.c_str());}
  
  inline Time::Time (const ColData &str) {convert(str.c_str());}
! inline Time::Time (const std::string &str)  {convert(str.c_str());}
  
  inline DateTime::DateTime (const ColData &str) {convert(str.c_str());}
! inline DateTime::DateTime (const std::string &str) {convert(str.c_str());}
  
  #endif
diff -rc mysql++-1.7.9/sqlplusint/exceptions.hh mysql++-1.7.9-patched/sqlplusint/exceptions.hh
*** mysql++-1.7.9/sqlplusint/exceptions.hh	Sat May 19 12:44:49 2001
--- mysql++-1.7.9-patched/sqlplusint/exceptions.hh	Mon Aug 27 13:47:36 2001
***************
*** 39,45 ****
    virtual const char* what( void ) const { return _what.c_str(); }
  };
  
! //: Thrown when a *Null* value is trying to be converted into a type 
  //: it can't convert to.
  class BadNullConversion : public exception {
    const string _what;
--- 39,45 ----
    virtual const char* what( void ) const { return _what.c_str(); }
  };
  
! //: Thrown when a *Null* value is trying to be converted into a type
  //: it can't convert to.
  class BadNullConversion : public exception {
    const string _what;
***************
*** 49,55 ****
  };
  
  //: Exception thrown when not enough parameters are provided
! // Thrown when not enough parameters are provided for a 
  // template query.
  class SQLQueryNEParms : public exception {
    const string _what;
--- 49,55 ----
  };
  
  //: Exception thrown when not enough parameters are provided
! // Thrown when not enough parameters are provided for a
  // template query.
  class SQLQueryNEParms : public exception {
    const string _what;
***************
*** 62,90 ****
  #else //origional, default exception style
  
  struct BadQuery {
!   BadQuery(string er) : error(er) {}
!   string error; //: The error message
  };
  
  
  //: Exception structure thrown when a bad conversion takes place
  struct BadConversion {
    const char*  type_name;  //:
!   const string data;       //:
    size_t       retrieved;  //:
    size_t       actual_size;//:
    BadConversion(const char* tn, const char* d, size_t r, size_t a) : type_name(tn), data(d), retrieved(r), actual_size(a) {};
  };
  
  
! //: Thrown when a *Null* value is trying to be converted into a type 
  //: it can't convert to.
  class BadNullConversion {};
  
  
  
  //: Exception thrown when not enough parameters are provided
! // Thrown when not enough parameters are provided for a 
  // template query.
  struct SQLQueryNEParms {
    SQLQueryNEParms(const char *c) : error(c) {}
--- 62,90 ----
  #else //origional, default exception style
  
  struct BadQuery {
!   BadQuery(std::string er) : error(er) {}
!   std::string error; //: The error message
  };
  
  
  //: Exception structure thrown when a bad conversion takes place
  struct BadConversion {
    const char*  type_name;  //:
!   const std::string data;       //:
    size_t       retrieved;  //:
    size_t       actual_size;//:
    BadConversion(const char* tn, const char* d, size_t r, size_t a) : type_name(tn), data(d), retrieved(r), actual_size(a) {};
  };
  
  
! //: Thrown when a *Null* value is trying to be converted into a type
  //: it can't convert to.
  class BadNullConversion {};
  
  
  
  //: Exception thrown when not enough parameters are provided
! // Thrown when not enough parameters are provided for a
  // template query.
  struct SQLQueryNEParms {
    SQLQueryNEParms(const char *c) : error(c) {}
diff -rc mysql++-1.7.9/sqlplusint/exceptions.hh.in mysql++-1.7.9-patched/sqlplusint/exceptions.hh.in
*** mysql++-1.7.9/sqlplusint/exceptions.hh.in	Sat May 19 12:44:49 2001
--- mysql++-1.7.9-patched/sqlplusint/exceptions.hh.in	Mon Aug 27 13:47:41 2001
***************
*** 61,75 ****
  #else //origional, default exception style
  
  struct BadQuery {
!   BadQuery(string er) : error(er) {}
!   string error; //: The error message
  };
  
  
  //: Exception structure thrown when a bad conversion takes place
  struct BadConversion {
    const char*  type_name;  //:
!   const string data;       //:
    size_t       retrieved;  //:
    size_t       actual_size;//:
    BadConversion(const char* tn, const char* d, size_t r, size_t a) : type_name(tn), data(d), retrieved(r), actual_size(a) {};
--- 61,75 ----
  #else //origional, default exception style
  
  struct BadQuery {
!   BadQuery(std::string er) : error(er) {}
!   std::string error; //: The error message
  };
  
  
  //: Exception structure thrown when a bad conversion takes place
  struct BadConversion {
    const char*  type_name;  //:
!   const std::string data;       //:
    size_t       retrieved;  //:
    size_t       actual_size;//:
    BadConversion(const char* tn, const char* d, size_t r, size_t a) : type_name(tn), data(d), retrieved(r), actual_size(a) {};
diff -rc mysql++-1.7.9/sqlplusint/field_names.cc mysql++-1.7.9-patched/sqlplusint/field_names.cc
*** mysql++-1.7.9/sqlplusint/field_names.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/field_names.cc	Mon Aug 27 13:47:45 2001
***************
*** 13,19 ****
    int num = res->num_fields();
    reserve(num);
    for (int i = 0; i < num; i++) {
! 		string p(res->fields()[i].name); str_to_lwr(p);   push_back(p);
    }
  	
  }
--- 13,19 ----
    int num = res->num_fields();
    reserve(num);
    for (int i = 0; i < num; i++) {
! 		std::string p(res->fields()[i].name); str_to_lwr(p);   push_back(p);
    }
  	
  }
diff -rc mysql++-1.7.9/sqlplusint/field_names1.hh mysql++-1.7.9-patched/sqlplusint/field_names1.hh
*** mysql++-1.7.9/sqlplusint/field_names1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/field_names1.hh	Mon Aug 27 13:47:48 2001
***************
*** 10,39 ****
  #include "string_util.hh"
  
  //: A vector of the field names.
! class FieldNames : public vector<string> {
  private:
    void init (const ResUse *res);
  public:
    FieldNames () {}
    FieldNames (const ResUse *res) {init(res);}
!   FieldNames (int i) : vector<string>(i) {}
  
    FieldNames& operator = (const ResUse *res) {init(res); return *this;}  
    //: Creates a new list from the data in res.
    FieldNames& operator = (int i) {insert(begin(), i, ""); return *this;} 
    //: Creates a new list with i field names.
    
!   string&  operator [] (int i) {return vector<string>::operator [] (i);}
    //: returns the field name of the field with that index number
  
!   const string&  operator [] (int i) const 
!     {return vector<string>::operator [] (i);}
    //: returns the field name of the field with that index number
  
!   uint     operator [] (string i) const
    {
! 	  string temp(i); str_to_lwr(temp);
! 	  return find(begin(),end(), temp) - begin();
  	}
    //: returns the index number of the field with that name
  };
--- 10,39 ----
  #include "string_util.hh"
  
  //: A vector of the field names.
! class FieldNames : public std::vector<std::string> {
  private:
    void init (const ResUse *res);
  public:
    FieldNames () {}
    FieldNames (const ResUse *res) {init(res);}
!   FieldNames (int i) : std::vector<std::string>(i) {}
  
    FieldNames& operator = (const ResUse *res) {init(res); return *this;}  
    //: Creates a new list from the data in res.
    FieldNames& operator = (int i) {insert(begin(), i, ""); return *this;} 
    //: Creates a new list with i field names.
    
!   std::string&  operator [] (int i) {return std::vector<std::string>::operator [] (i);}
    //: returns the field name of the field with that index number
  
!   const std::string&  operator [] (int i) const
!     {return std::vector<std::string>::operator [] (i);}
    //: returns the field name of the field with that index number
  
!   uint     operator [] (std::string i) const
    {
! 	  std::string temp(i); str_to_lwr(temp);
! 	  return std::find(begin(),end(), temp) - begin();
  	}
    //: returns the index number of the field with that name
  };
diff -rc mysql++-1.7.9/sqlplusint/manip.cc mysql++-1.7.9-patched/sqlplusint/manip.cc
*** mysql++-1.7.9/sqlplusint/manip.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/manip.cc	Mon Aug 27 13:47:51 2001
***************
*** 27,33 ****
  }
  
  template <>
! ostream& operator << (quote_type1 o, const string &in) {
    char* s = new char[in.size()*2+1];
    mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
    *o.ostr << "'" << s << "'";
--- 27,33 ----
  }
  
  template <>
! std::ostream& operator << (quote_type1 o, const std::string &in) {
    char* s = new char[in.size()*2+1];
    mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
    *o.ostr << "'" << s << "'";
***************
*** 36,42 ****
  }
  
  template <>
! ostream& operator << (quote_type1 o, const char* const &in) {
    unsigned int size;
    for (size=0; in[size]; size++);
    char* s = new char[size*2+1];
--- 36,42 ----
  }
  
  template <>
! std::ostream& operator << (quote_type1 o, const char* const &in) {
    unsigned int size;
    for (size=0; in[size]; size++);
    char* s = new char[size*2+1];
***************
*** 47,53 ****
  }
  
  template <class Str>
! inline ostream& _manip (quote_type1 o, const mysql_ColData<Str>& in) {
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
      mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
--- 47,53 ----
  }
  
  template <class Str>
! inline std::ostream& _manip (quote_type1 o, const mysql_ColData<Str>& in) {
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
      mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
***************
*** 65,80 ****
  }
  
  template <>
! ostream& operator << (quote_type1 o, const mysql_ColData<string>& in) {
    return _manip(o,in);
  }
  
  template <>
! ostream& operator << (quote_type1 o, const mysql_ColData<const_string>& in) {
    return _manip(o,in);
  }
  
! ostream& operator << (ostream& o, const mysql_ColData<string>& in) {
  	if (dont_quote_auto || (o.rdbuf() == cout.rdbuf()) || (o.rdbuf() == cerr.rdbuf())) return o << in.get_string();
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
--- 65,80 ----
  }
  
  template <>
! std::ostream& operator << (quote_type1 o, const mysql_ColData<std::string>& in) {
    return _manip(o,in);
  }
  
  template <>
! std::ostream& operator << (quote_type1 o, const mysql_ColData<const_string>& in) {
    return _manip(o,in);
  }
  
! std::ostream& operator << (std::ostream& o, const mysql_ColData<std::string>& in) {
  	if (dont_quote_auto || (o.rdbuf() == cout.rdbuf()) || (o.rdbuf() == cerr.rdbuf())) return o << in.get_string();
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
***************
*** 93,99 ****
  }
  
  
! ostream& operator << (ostream& o, const mysql_ColData<const_string>& in) {
  	if (dont_quote_auto || (o.rdbuf() == cout.rdbuf()) || (o.rdbuf() == cerr.rdbuf())) return o << in.get_string();
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
--- 93,99 ----
  }
  
  
! std::ostream& operator << (std::ostream& o, const mysql_ColData<const_string>& in) {
  	if (dont_quote_auto || (o.rdbuf() == cout.rdbuf()) || (o.rdbuf() == cerr.rdbuf())) return o << in.get_string();
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
***************
*** 111,130 ****
    return o;
  }
  
! SQLQuery& operator << (SQLQuery& o, const mysql_ColData<string>& in) {
  	if (dont_quote_auto) {o << in.get_string(); return o;}
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
      mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
      if (in.quote_q())
!       o << "'" << s << "'";
      else
!       o << s;
      delete[] s;
    } else if (in.quote_q()) {
!     o << "'" << in.get_string() << "'";
    } else {
!     o << in.get_string();
    }
    return o;
  }
--- 111,130 ----
    return o;
  }
  
! SQLQuery& operator << (SQLQuery& o, const mysql_ColData<std::string>& in) {
  	if (dont_quote_auto) {o << in.get_string(); return o;}
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
      mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
      if (in.quote_q())
!       (std::ostream&)o << "'" << s << "'";
      else
!       (std::ostream&)o << s;
      delete[] s;
    } else if (in.quote_q()) {
!     (std::ostream&)o << "'" << in.get_string() << "'";
    } else {
!     (std::ostream&)o << in.get_string();
    }
    return o;
  }
***************
*** 136,149 ****
      char *s = new char[in.size()*2+1];
      mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
      if (in.quote_q())
!       o << "'" << s << "'";
      else
!       o << s;
      delete[] s;
    } else if (in.quote_q()) {
!     o << "'" << in.get_string() << "'";
    } else {
!     o << in.get_string();
    }
    return o;
  }
--- 136,149 ----
      char *s = new char[in.size()*2+1];
      mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
      if (in.quote_q())
!       (std::ostream&)o << "'" << s << "'";
      else
!       (std::ostream&)o << s;
      delete[] s;
    } else if (in.quote_q()) {
!     (std::ostream&)o << "'" << in.get_string() << "'";
    } else {
!     (std::ostream&)o << in.get_string();
    }
    return o;
  }
***************
*** 162,168 ****
  }
  
  template <>
! ostream& operator << (quote_only_type1 o, const mysql_ColData<string>& in) {
    if (in.quote_q()) {
      *o.ostr << "'" << in << "'";
    } else {
--- 162,168 ----
  }
  
  template <>
! std::ostream& operator << (quote_only_type1 o, const mysql_ColData<std::string>& in) {
    if (in.quote_q()) {
      *o.ostr << "'" << in << "'";
    } else {
***************
*** 172,178 ****
  }
  
  template <>
! ostream& operator << (quote_only_type1 o, const mysql_ColData<const_string>& in) {
    if (in.quote_q()) {
      *o.ostr << "'" << in << "'";
    } else {
--- 172,178 ----
  }
  
  template <>
! std::ostream& operator << (quote_only_type1 o, const mysql_ColData<const_string>& in) {
    if (in.quote_q()) {
      *o.ostr << "'" << in << "'";
    } else {
***************
*** 196,202 ****
  
  
  template <>
! ostream& operator << (quote_double_only_type1 o, const mysql_ColData<string>& in) {
    if (in.quote_q()) {
      *o.ostr << "'" << in << "'";
    } else {
--- 196,202 ----
  
  
  template <>
! std::ostream& operator << (quote_double_only_type1 o, const mysql_ColData<std::string>& in) {
    if (in.quote_q()) {
      *o.ostr << "'" << in << "'";
    } else {
***************
*** 206,212 ****
  }
  
  template <>
! ostream& operator << (quote_double_only_type1 o, const mysql_ColData<const_string>& in) {
    if (in.quote_q()) {
      *o.ostr << "'" << in << "'";
    } else {
--- 206,212 ----
  }
  
  template <>
! std::ostream& operator << (quote_double_only_type1 o, const mysql_ColData<const_string>& in) {
    if (in.quote_q()) {
      *o.ostr << "'" << in << "'";
    } else {
***************
*** 238,244 ****
  }
  
  template <>
! ostream& operator << (escape_type1 o, const string &in) {
    char* s = new char[in.size()*2+1];
    mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size());
    *o.ostr << s;
--- 238,244 ----
  }
  
  template <>
! std::ostream& operator << (escape_type1 o, const std::string &in) {
    char* s = new char[in.size()*2+1];
    mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size());
    *o.ostr << s;
***************
*** 247,253 ****
  }
  
  template <>
! ostream& operator << (escape_type1 o, const char* const &in) {
    unsigned int size;
    for (size=0; in[size]; size++);
    char* s = new char[size*2+1];
--- 247,253 ----
  }
  
  template <>
! std::ostream& operator << (escape_type1 o, const char* const &in) {
    unsigned int size;
    for (size=0; in[size]; size++);
    char* s = new char[size*2+1];
***************
*** 259,265 ****
  
  
  template <class Str>
! inline ostream& _manip (escape_type1 o, const mysql_ColData<Str>& in) {
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
      mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
--- 259,265 ----
  
  
  template <class Str>
! inline std::ostream& _manip (escape_type1 o, const mysql_ColData<Str>& in) {
    if (in.escape_q()) {
      char *s = new char[in.size()*2+1];
      mysql_escape_string(s, const_cast<char *>(in.c_str()), in.size() );
***************
*** 271,282 ****
  }
  
  template <>
! ostream& operator << (escape_type1 o, const mysql_ColData<string>& in) {
    return _manip(o,in);
  }
  
  template <>
! ostream& operator << (escape_type1 o, const mysql_ColData<const_string>& in) {
    return _manip(o,in);
  }
  
--- 271,282 ----
  }
  
  template <>
! std::ostream& operator << (escape_type1 o, const mysql_ColData<std::string>& in) {
    return _manip(o,in);
  }
  
  template <>
! std::ostream& operator << (escape_type1 o, const mysql_ColData<const_string>& in) {
    return _manip(o,in);
  }
  
diff -rc mysql++-1.7.9/sqlplusint/manip1.hh mysql++-1.7.9-patched/sqlplusint/manip1.hh
*** mysql++-1.7.9/sqlplusint/manip1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/manip1.hh	Mon Aug 27 13:47:53 2001
***************
*** 48,95 ****
    return *o.ostr << in;
  }
  
! ostream& operator << (ostream& o,const mysql_ColData<string>& in);
  
! ostream& operator << (ostream& o, const mysql_ColData<const_string>& in);
  
! SQLQuery& operator << (SQLQuery& o, const mysql_ColData<string>& in);
  
  SQLQuery& operator << (SQLQuery& o, const mysql_ColData<const_string>& in);
  
  template <>
! ostream& operator << (quote_type1 o, const string &in);
  
  template <>
! ostream& operator << (quote_type1 o, const char* const &in);
  
  template <>
! ostream& operator << (quote_type1 o, const mysql_ColData<string>& in);
  
  template <>
! ostream& operator << (quote_type1 o, const mysql_ColData<const_string>& in);
  
  template <>
! inline ostream& operator << (quote_type1 o, char* const &in) {
    return operator << (o, const_cast<const char* const &>(in));
  }
  
  template <>
! inline ostream& operator << (quote_type1 o, const Date &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! inline ostream& operator << (quote_type1 o, const Time &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! inline ostream& operator << (quote_type1 o, const DateTime &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <class ST>
! inline ostream& operator << (quote_type1 o, const MysqlSet<ST> &in) {
    return *o.ostr << "'" << in << "'";
  }
  
--- 48,95 ----
    return *o.ostr << in;
  }
  
! std::ostream& operator << (std::ostream& o,const mysql_ColData<std::string>& in);
  
! std::ostream& operator << (std::ostream& o, const mysql_ColData<const_string>& in);
  
! SQLQuery& operator << (SQLQuery& o, const mysql_ColData<std::string>& in);
  
  SQLQuery& operator << (SQLQuery& o, const mysql_ColData<const_string>& in);
  
  template <>
! std::ostream& operator << (quote_type1 o, const std::string &in);
  
  template <>
! std::ostream& operator << (quote_type1 o, const char* const &in);
  
  template <>
! std::ostream& operator << (quote_type1 o, const mysql_ColData<std::string>& in);
  
  template <>
! std::ostream& operator << (quote_type1 o, const mysql_ColData<const_string>& in);
  
  template <>
! inline std::ostream& operator << (quote_type1 o, char* const &in) {
    return operator << (o, const_cast<const char* const &>(in));
  }
  
  template <>
! inline std::ostream& operator << (quote_type1 o, const Date &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! inline std::ostream& operator << (quote_type1 o, const Time &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! inline std::ostream& operator << (quote_type1 o, const DateTime &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <class ST>
! inline std::ostream& operator << (quote_type1 o, const MysqlSet<ST> &in) {
    return *o.ostr << "'" << in << "'";
  }
  
***************
*** 102,108 ****
    quote_only_type1(ostream *o) : ostr(o) {}
  }; 
  
! inline quote_only_type1 operator << (ostream &o, quote_only_type0 esc) {
    return quote_only_type1(&o);
  }
  
--- 102,108 ----
    quote_only_type1(ostream *o) : ostr(o) {}
  }; 
  
! inline quote_only_type1 operator << (std::ostream &o, quote_only_type0 esc) {
    return quote_only_type1(&o);
  }
  
***************
*** 118,155 ****
  SQLQueryParms & operator << (quote_only_type2 p, SQLString &in);
  
  template <class T>
! inline ostream& operator << (quote_only_type1 o, const T &in) {
    return *o.ostr << in;
  }
  
  template <>
! inline ostream& operator << (quote_only_type1 o, const string &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! ostream& operator << (quote_only_type1 o, const mysql_ColData<string>& in);
  
  template <>
! ostream& operator << (quote_only_type1 o, const mysql_ColData<const_string>& in);
  
  template <>
! inline ostream& operator << (quote_only_type1 o, const Date &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! inline ostream& operator << (quote_only_type1 o, const Time &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! inline ostream& operator << (quote_only_type1 o, const DateTime &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <class ST>
! inline ostream& operator << (quote_only_type1 o, const MysqlSet<ST> &in) {
    return *o.ostr << "'" << in << "'";
  }
  
--- 118,155 ----
  SQLQueryParms & operator << (quote_only_type2 p, SQLString &in);
  
  template <class T>
! inline std::ostream& operator << (quote_only_type1 o, const T &in) {
    return *o.ostr << in;
  }
  
  template <>
! inline std::ostream& operator << (quote_only_type1 o, const std::string &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! std::ostream& operator << (quote_only_type1 o, const mysql_ColData<std::string>& in);
  
  template <>
! std::ostream& operator << (quote_only_type1 o, const mysql_ColData<const_string>& in);
  
  template <>
! inline std::ostream& operator << (quote_only_type1 o, const Date &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! inline std::ostream& operator << (quote_only_type1 o, const Time &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <>
! inline std::ostream& operator << (quote_only_type1 o, const DateTime &in) {
    return *o.ostr << "'" << in << "'";
  }
  
  template <class ST>
! inline std::ostream& operator << (quote_only_type1 o, const MysqlSet<ST> &in) {
    return *o.ostr << "'" << in << "'";
  }
  
***************
*** 157,167 ****
  
  enum quote_double_only_type0 {mysql_quote_double_only};
  struct quote_double_only_type1 {
!   ostream *ostr;
!   quote_double_only_type1(ostream *o) : ostr(o) {}
  }; 
  
! inline quote_double_only_type1 operator << (ostream &o, 
  					    quote_double_only_type0 esc) {
    return quote_double_only_type1(&o);
  }
--- 157,167 ----
  
  enum quote_double_only_type0 {mysql_quote_double_only};
  struct quote_double_only_type1 {
!   std::ostream *ostr;
!   quote_double_only_type1(std::ostream *o) : ostr(o) {}
  }; 
  
! inline quote_double_only_type1 operator << (std::ostream &o,
  					    quote_double_only_type0 esc) {
    return quote_double_only_type1(&o);
  }
***************
*** 179,217 ****
  SQLQueryParms & operator << (quote_double_only_type2 p, SQLString &in);
  
  template <class T>
! inline ostream& operator << (quote_double_only_type1 o, const T &in) {
    return *o.ostr << in;
  }
  
  template <>
! inline ostream& operator << (quote_double_only_type1 o, const string &in) {
    return *o.ostr << "\"" << in << "\"";
  }
  
  template <>
! ostream& operator << (quote_double_only_type1 o, const mysql_ColData<string>& in);
  
  template <>
! ostream& operator << (quote_double_only_type1 o, const mysql_ColData<const_string>& in);
  
  template <>
! inline ostream& operator << (quote_double_only_type1 o, const Date &in) {
    return *o.ostr << "\"" << in << "\"";
  }
  
  template <>
! inline ostream& operator << (quote_double_only_type1 o, const Time &in) {
    return *o.ostr << "\"" << in << "\"";
  }
  
  template <>
! inline ostream& operator << (quote_double_only_type1 o, 
  			     const DateTime &in) {
    return *o.ostr << "\"" << in << "\"";
  }
  
  template <class ST>
! inline ostream& operator << (quote_double_only_type1 o, 
  			     const MysqlSet<ST> &in) {
    return *o.ostr << "\"" << in << "\"";
  }
--- 179,217 ----
  SQLQueryParms & operator << (quote_double_only_type2 p, SQLString &in);
  
  template <class T>
! inline std::ostream& operator << (quote_double_only_type1 o, const T &in) {
    return *o.ostr << in;
  }
  
  template <>
! inline std::ostream& operator << (quote_double_only_type1 o, const std::string &in) {
    return *o.ostr << "\"" << in << "\"";
  }
  
  template <>
! std::ostream& operator << (quote_double_only_type1 o, const mysql_ColData<std::string>& in);
  
  template <>
! std::ostream& operator << (quote_double_only_type1 o, const mysql_ColData<const_string>& in);
  
  template <>
! inline std::ostream& operator << (quote_double_only_type1 o, const Date &in) {
    return *o.ostr << "\"" << in << "\"";
  }
  
  template <>
! inline std::ostream& operator << (quote_double_only_type1 o, const Time &in) {
    return *o.ostr << "\"" << in << "\"";
  }
  
  template <>
! inline std::ostream& operator << (quote_double_only_type1 o,
  			     const DateTime &in) {
    return *o.ostr << "\"" << in << "\"";
  }
  
  template <class ST>
! inline std::ostream& operator << (quote_double_only_type1 o,
  			     const MysqlSet<ST> &in) {
    return *o.ostr << "\"" << in << "\"";
  }
***************
*** 220,230 ****
  
  enum escape_type0 {mysql_escape};
  struct escape_type1 {
!   ostream *ostr;
!   escape_type1(ostream *o) : ostr(o) {}
  }; 
  
! inline escape_type1 operator << (ostream &o, escape_type0 esc) {
    return escape_type1(&o);
  }
  
--- 220,230 ----
  
  enum escape_type0 {mysql_escape};
  struct escape_type1 {
!   std::ostream *ostr;
!   escape_type1(std::ostream *o) : ostr(o) {}
  }; 
  
! inline escape_type1 operator << (std::ostream &o, escape_type0 esc) {
    return escape_type1(&o);
  }
  
***************
*** 240,263 ****
  SQLQueryParms & operator << (escape_type2 p, SQLString &in);
  
  template <class T>
! inline ostream& operator << (escape_type1 o, const T &in) {
    return *o.ostr << in;
  }
  
  template <>
! ostream& operator << (escape_type1 o, const string &in);
  
  template <>
! ostream& operator << (escape_type1 o, const char* const &in);
  
  template <>
! ostream& operator << (escape_type1 o, const mysql_ColData<string>& in);
  
  template <>
! ostream& operator << (escape_type1 o, const mysql_ColData<const_string>& in);
  
  template <>
! inline ostream& operator << (escape_type1 o, char* const &in) {
    return operator << (o, const_cast<const char* const &>(in));
  }
  
--- 240,263 ----
  SQLQueryParms & operator << (escape_type2 p, SQLString &in);
  
  template <class T>
! inline std::ostream& operator << (escape_type1 o, const T &in) {
    return *o.ostr << in;
  }
  
  template <>
! std::ostream& operator << (escape_type1 o, const std::string &in);
  
  template <>
! std::ostream& operator << (escape_type1 o, const char* const &in);
  
  template <>
! std::ostream& operator << (escape_type1 o, const mysql_ColData<std::string>& in);
  
  template <>
! std::ostream& operator << (escape_type1 o, const mysql_ColData<const_string>& in);
  
  template <>
! inline std::ostream& operator << (escape_type1 o, char* const &in) {
    return operator << (o, const_cast<const char* const &>(in));
  }
  
***************
*** 266,281 ****
  
  enum do_nothing_type0 {mysql_do_nothing};
  struct do_nothing_type1 {
!   ostream *ostr;
!   do_nothing_type1(ostream *o) : ostr(o) {}
  }; 
  
! inline do_nothing_type1 operator << (ostream &o, do_nothing_type0 esc) {
    return do_nothing_type1(&o);
  }
  
  template <class T>
! inline ostream& operator << (do_nothing_type1 o, const T &in) {
    return *o.ostr << in;
  }
  
--- 266,281 ----
  
  enum do_nothing_type0 {mysql_do_nothing};
  struct do_nothing_type1 {
!   std::ostream *ostr;
!   do_nothing_type1(std::ostream *o) : ostr(o) {}
  }; 
  
! inline do_nothing_type1 operator << (std::ostream &o, do_nothing_type0 esc) {
    return do_nothing_type1(&o);
  }
  
  template <class T>
! inline std::ostream& operator << (do_nothing_type1 o, const T &in) {
    return *o.ostr << in;
  }
  
diff -rc mysql++-1.7.9/sqlplusint/query.cc mysql++-1.7.9-patched/sqlplusint/query.cc
*** mysql++-1.7.9/sqlplusint/query.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/query.cc	Mon Aug 27 13:47:57 2001
***************
*** 13,19 ****
    return *this;
  }
  
! bool MysqlQuery::exec (const string& str) { return mysql->exec(str);}
  
  
  
--- 13,19 ----
    return *this;
  }
  
! bool MysqlQuery::exec (const std::string& str) { return mysql->exec(str);}
  
  
  
diff -rc mysql++-1.7.9/sqlplusint/query1.hh mysql++-1.7.9-patched/sqlplusint/query1.hh
*** mysql++-1.7.9/sqlplusint/query1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/query1.hh	Mon Aug 27 13:47:59 2001
***************
*** 25,31 ****
  
    int     affected_rows() const;
    int     insert_id ();
!   string  info ();
    bool    lock();
    void    unlock();
  
--- 25,31 ----
  
    int     affected_rows() const;
    int     insert_id ();
!   std::string  info ();
    bool    lock();
    void    unlock();
  
***************
*** 36,48 ****
    Query(const Query &q); //:
    Query& operator = (const Query &q); //:
  
!   string   error ();  //: The error message if the query was not successful.
    bool     success(); //: Displays the string currently in the buffer.
    // Same thing as string().
  
!   string   preview () {return str(def);}       //:
!   string   preview (parms &p) {return str(p);} //:
! 	bool     exec (const string &str);
    //!dummy: MysqlResNSel execute (...);
    //: Executes the query in the string buffer.
    // Executes the query in the string buffer and returns a structure
--- 36,48 ----
    Query(const Query &q); //:
    Query& operator = (const Query &q); //:
  
!   std::string   error ();  //: The error message if the query was not successful.
    bool     success(); //: Displays the string currently in the buffer.
    // Same thing as string().
  
!   std::string   preview () {return str(def);}       //:
!   std::string   preview (parms &p) {return str(p);} //:
! 	bool     exec (const std::string &str);
    //!dummy: MysqlResNSel execute (...);
    //: Executes the query in the string buffer.
    // Executes the query in the string buffer and returns a structure
***************
*** 67,73 ****
    //
    // The parameters can be anything in a valid SQLQuery::str.
  
!   mysql_query_define0(string,preview)
  
    mysql_query_define1(ResNSel, execute)
    mysql_query_define1(ResUse, use)
--- 67,73 ----
    //
    // The parameters can be anything in a valid SQLQuery::str.
  
!   mysql_query_define0(std::string,preview)
  
    mysql_query_define1(ResNSel, execute)
    mysql_query_define1(ResUse, use)
diff -rc mysql++-1.7.9/sqlplusint/query2.hh mysql++-1.7.9-patched/sqlplusint/query2.hh
*** mysql++-1.7.9/sqlplusint/query2.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/query2.hh	Mon Aug 27 13:48:02 2001
***************
*** 47,58 ****
    return mysql->insert_id();
  }
  
! inline string Query::info() {
    return mysql->info();
  }
  
! inline string Query::error () {
!   if (errmsg) return string(errmsg);
    return mysql->error();
  }
  
--- 47,58 ----
    return mysql->insert_id();
  }
  
! inline std::string Query::info() {
    return mysql->info();
  }
  
! inline std::string Query::error () {
!   if (errmsg) return std::string(errmsg);
    return mysql->error();
  }
  
diff -rc mysql++-1.7.9/sqlplusint/result1.hh mysql++-1.7.9-patched/sqlplusint/result1.hh
*** mysql++-1.7.9/sqlplusint/result1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/result1.hh	Mon Aug 27 13:48:06 2001
***************
*** 20,26 ****
  #include "exceptions.hh"
  //:
  class ResUse  {
!   friend Connection;
  protected:
    Connection            *mysql;
    mutable MYSQL_RES     *mysql_res;
--- 20,26 ----
  #include "exceptions.hh"
  //:
  class ResUse  {
!   friend class Connection;
  protected:
    Connection            *mysql;
    mutable MYSQL_RES     *mysql_res;
***************
*** 28,34 ****
    mutable FieldNames    *_names;
    mutable FieldTypes    *_types;
    Fields                _fields;
!   string                _table;       
    void copy(const ResUse& other);  //: not to be used on the self. self - copy is not allowed
  public:
    ResUse () : mysql(0), mysql_res(0), throw_exceptions(false),initialized(false), _names(NULL), _types(NULL), _fields(this) {}
--- 28,34 ----
    mutable FieldNames    *_names;
    mutable FieldTypes    *_types;
    Fields                _fields;
!   std::string                _table;
    void copy(const ResUse& other);  //: not to be used on the self. self - copy is not allowed
  public:
    ResUse () : mysql(0), mysql_res(0), throw_exceptions(false),initialized(false), _names(NULL), _types(NULL), _fields(this) {}
***************
*** 72,88 ****
    operator bool() const {if (mysql_res) return true; return false;} //:
    unsigned int columns() const {return num_fields();} //:
  
!   string& table() {return _table;}
    //: table name
!   const string& table() const {return _table;}
    //: table name
  
    /* methods for working with field names */
!   inline int               field_num(const string&) const;
    //: Returns the offset of the filed which equals str.
!   inline string&           field_name(int);
    //: Returns the field with an offset of i.
!   inline const string&     field_name(int) const;
    //: Returns the field with an offset of i.
    inline FieldNames&       field_names();
    //: Returns a reference to the underlying FieldNames class.
--- 72,88 ----
    operator bool() const {if (mysql_res) return true; return false;} //:
    unsigned int columns() const {return num_fields();} //:
  
!   std::string& table() {return _table;}
    //: table name
!   const std::string& table() const {return _table;}
    //: table name
  
    /* methods for working with field names */
!   inline int               field_num(const std::string&) const;
    //: Returns the offset of the filed which equals str.
!   inline std::string&           field_name(int);
    //: Returns the field with an offset of i.
!   inline const std::string&     field_name(int) const;
    //: Returns the field with an offset of i.
    inline FieldNames&       field_names();
    //: Returns a reference to the underlying FieldNames class.
***************
*** 104,114 ****
    //: Resets the field_types to their original values.
  
    /* short names for the above methods */
!   inline int               names(const string& s) const;
    //: Returns the offset of the filed which equals str.
!   inline string&           names(int i);
    //: Returns the field with an offset of i.
!   inline const string&     names(int i) const;
    //: Returns the field with an offset of i.
    inline FieldNames&       names();
    //: Returns a reference to the underlying FieldNames class.
--- 104,114 ----
    //: Resets the field_types to their original values.
  
    /* short names for the above methods */
!   inline int               names(const std::string& s) const;
    //: Returns the offset of the filed which equals str.
!   inline std::string&           names(int i);
    //: Returns the field with an offset of i.
!   inline const std::string&     names(int i) const;
    //: Returns the field with an offset of i.
    inline FieldNames&       names();
    //: Returns a reference to the underlying FieldNames class.
***************
*** 151,157 ****
  class Result : public ResUse, 
  	       public const_subscript_container<Result,Row,const Row>
  {
!   friend Connection;
  public:
    Result () {} //:
    Result (MYSQL_RES *result, bool te = false) 
--- 151,157 ----
  class Result : public ResUse, 
  	       public const_subscript_container<Result,Row,const Row>
  {
!   friend class Connection;
  public:
    Result () {} //:
    Result (MYSQL_RES *result, bool te = false) 
***************
*** 210,216 ****
    bool     success;   
    int      insert_id; //: 
    int      rows;      //: Number of rows affected
!   string   info;      //: Additional info
  
    ResNSel() : success(false) {};
    ResNSel (Connection *q);
--- 210,216 ----
    bool     success;   
    int      insert_id; //: 
    int      rows;      //: Number of rows affected
!   std::string   info;      //: Additional info
  
    ResNSel() : success(false) {};
    ResNSel (Connection *q);
diff -rc mysql++-1.7.9/sqlplusint/result2.hh mysql++-1.7.9-patched/sqlplusint/result2.hh
*** mysql++-1.7.9/sqlplusint/result2.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/result2.hh	Mon Aug 27 13:48:13 2001
***************
*** 8,24 ****
  
  // field name info
  
! inline int ResUse::field_num(const string &i) const {
    if (!_names) _names = new FieldNames(this);
    return (*_names)[i];
  }
  
! inline string& ResUse::field_name(int i) {
    if (!_names) _names = new FieldNames(this);
    return (*_names)[i];
  }
  
! inline const string& ResUse::field_name(int i) const {
    if (!_names) _names = new FieldNames(this);
    return (*_names)[i];
  }
--- 8,24 ----
  
  // field name info
  
! inline int ResUse::field_num(const std::string &i) const {
    if (!_names) _names = new FieldNames(this);
    return (*_names)[i];
  }
  
! inline std::string& ResUse::field_name(int i) {
    if (!_names) _names = new FieldNames(this);
    return (*_names)[i];
  }
  
! inline const std::string& ResUse::field_name(int i) const {
    if (!_names) _names = new FieldNames(this);
    return (*_names)[i];
  }
***************
*** 65,73 ****
    _types = new FieldTypes(this);
  }
  
! inline int               ResUse::names(const string& s) const {return field_num(s);}
! inline string&           ResUse::names(int i) {return field_name(i);}
! inline const string&     ResUse::names(int i) const {return field_name(i);}
  inline FieldNames&       ResUse::names() {return field_names();}
  inline const FieldNames& ResUse::names() const {return field_names();}
  inline void              ResUse::reset_names() {reset_field_names();}
--- 65,73 ----
    _types = new FieldTypes(this);
  }
  
! inline int               ResUse::names(const std::string& s) const {return field_num(s);}
! inline std::string&           ResUse::names(int i) {return field_name(i);}
! inline const std::string&     ResUse::names(int i) const {return field_name(i);}
  inline FieldNames&       ResUse::names() {return field_names();}
  inline const FieldNames& ResUse::names() const {return field_names();}
  inline void              ResUse::reset_names() {reset_field_names();}
diff -rc mysql++-1.7.9/sqlplusint/row1.hh mysql++-1.7.9-patched/sqlplusint/row1.hh
*** mysql++-1.7.9/sqlplusint/row1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/row1.hh	Mon Aug 27 13:48:16 2001
***************
*** 35,51 ****
  
    template <class Manip>  
    value_list_b<ThisType,Manip> 
!   value_list(const char *d, Manip m, const vector<bool> &vb) const {
      return value_list_b<ThisType,Manip> (self(), vb, d, m);
    }
  
    value_list_b<ThisType,quote_type0> 
!   value_list(const char *d, const vector<bool> &vb) const {
      return value_list_b<ThisType,quote_type0> (self(), vb, d, quote);
    }
  
    value_list_b<ThisType,quote_type0> 
!   value_list(const vector<bool> &vb) const {
      return value_list_b<ThisType,quote_type0> (self(), vb, ",", quote);
    }
  
--- 35,51 ----
  
    template <class Manip>  
    value_list_b<ThisType,Manip> 
!   value_list(const char *d, Manip m, const std::vector<bool> &vb) const {
      return value_list_b<ThisType,Manip> (self(), vb, d, m);
    }
  
    value_list_b<ThisType,quote_type0> 
!   value_list(const char *d, const std::vector<bool> &vb) const {
      return value_list_b<ThisType,quote_type0> (self(), vb, d, quote);
    }
  
    value_list_b<ThisType,quote_type0> 
!   value_list(const std::vector<bool> &vb) const {
      return value_list_b<ThisType,quote_type0> (self(), vb, ",", quote);
    }
  
***************
*** 55,61 ****
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     vector<bool> vb;
      create_vector(self().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<ThisType, Manip>(self(), vb, d, m);
    }
--- 55,61 ----
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     std::vector<bool> vb;
      create_vector(self().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<ThisType, Manip>(self(), vb, d, m);
    }
***************
*** 65,71 ****
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     vector<bool> vb;
      create_vector(self().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<ThisType, quote_type0>(self(), vb, d, quote);
    }
--- 65,71 ----
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     std::vector<bool> vb;
      create_vector(self().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<ThisType, quote_type0>(self(), vb, d, quote);
    }
***************
*** 75,112 ****
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     vector<bool> vb;
      create_vector(self().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<ThisType, quote_type0>(self(), vb, ",", quote);
    }
  
    template <class Manip>
    value_list_b<ThisType,Manip> 
!   value_list(const char *d, Manip m, string s0,
! 	     string s1="", string s2="", string s3="", string s4="",
! 	     string s5="", string s6="", string s7="", string s8="",
! 	     string s9="", string sa="", string sb="", string sc="") const {
!     vector<bool> vb;
      create_vector(self(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<ThisType, Manip>(self(), vb, d, m);
    }
  
    value_list_b<ThisType,quote_type0> 
!   value_list(const char *d, string s0,
! 	     string s1="", string s2="", string s3="", string s4="",
! 	     string s5="", string s6="", string s7="", string s8="",
! 	     string s9="", string sa="", string sb="", string sc="") const {
!     vector<bool> vb;
      create_vector(self(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<ThisType, quote_type0>(self(), vb, d, quote);
    }
  
    value_list_b<ThisType,quote_type0> 
!   value_list(string s0,
! 	     string s1="", string s2="", string s3="", string s4="",
! 	     string s5="", string s6="", string s7="", string s8="",
! 	     string s9="", string sa="", string sb="", string sc="") const {
!     vector<bool> vb;
      create_vector(self(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<ThisType, quote_type0>(self(), vb, ",", quote);
    }
--- 75,112 ----
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     std::vector<bool> vb;
      create_vector(self().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<ThisType, quote_type0>(self(), vb, ",", quote);
    }
  
    template <class Manip>
    value_list_b<ThisType,Manip> 
!   value_list(const char *d, Manip m, std::string s0,
! 	     std::string s1="", std::string s2="", std::string s3="", std::string s4="",
! 	     std::string s5="", std::string s6="", std::string s7="", std::string s8="",
! 	     std::string s9="", std::string sa="", std::string sb="", std::string sc="") const {
!     std::vector<bool> vb;
      create_vector(self(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<ThisType, Manip>(self(), vb, d, m);
    }
  
    value_list_b<ThisType,quote_type0> 
!   value_list(const char *d, std::string s0,
! 	     std::string s1="", std::string s2="", std::string s3="", std::string s4="",
! 	     std::string s5="", std::string s6="", std::string s7="", std::string s8="",
! 	     std::string s9="", std::string sa="", std::string sb="", std::string sc="") const {
!     std::vector<bool> vb;
      create_vector(self(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<ThisType, quote_type0>(self(), vb, d, quote);
    }
  
    value_list_b<ThisType,quote_type0> 
!   value_list(std::string s0,
! 	     std::string s1="", std::string s2="", std::string s3="", std::string s4="",
! 	     std::string s5="", std::string s6="", std::string s7="", std::string s8="",
! 	     std::string s9="", std::string sa="", std::string sb="", std::string sc="") const {
!     std::vector<bool> vb;
      create_vector(self(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<ThisType, quote_type0>(self(), vb, ",", quote);
    }
***************
*** 129,145 ****
  
    template <class Manip>  
    value_list_b<FieldNames,Manip> 
!   field_list(const char *d, Manip m, const vector<bool> &vb) const {
      return value_list_b<FieldNames,Manip> (parent().names(), vb, d, m);
    }
  
    value_list_b<FieldNames,quote_type0> 
!   field_list(const char *d, const vector<bool> &vb) const {
      return value_list_b<FieldNames,quote_type0> (parent().names(), vb, d, quote);
    }
  
    value_list_b<FieldNames,quote_type0> 
!   field_list(const vector<bool> &vb) const {
      return value_list_b<FieldNames,quote_type0> (parent().names(), vb, ",", quote);
    }
  
--- 129,145 ----
  
    template <class Manip>  
    value_list_b<FieldNames,Manip> 
!   field_list(const char *d, Manip m, const std::vector<bool> &vb) const {
      return value_list_b<FieldNames,Manip> (parent().names(), vb, d, m);
    }
  
    value_list_b<FieldNames,quote_type0> 
!   field_list(const char *d, const std::vector<bool> &vb) const {
      return value_list_b<FieldNames,quote_type0> (parent().names(), vb, d, quote);
    }
  
    value_list_b<FieldNames,quote_type0> 
!   field_list(const std::vector<bool> &vb) const {
      return value_list_b<FieldNames,quote_type0> (parent().names(), vb, ",", quote);
    }
  
***************
*** 149,155 ****
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     vector<bool> vb;
      create_vector(parent().names().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<FieldNames, Manip>(parent().names(), vb, d, m);
    }
--- 149,155 ----
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     std::vector<bool> vb;
      create_vector(parent().names().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<FieldNames, Manip>(parent().names(), vb, d, m);
    }
***************
*** 159,165 ****
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     vector<bool> vb;
      create_vector(parent().names().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<FieldNames, quote_type0>(parent().names(), vb, d, quote);
    }
--- 159,165 ----
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     std::vector<bool> vb;
      create_vector(parent().names().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<FieldNames, quote_type0>(parent().names(), vb, d, quote);
    }
***************
*** 169,206 ****
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     vector<bool> vb;
      create_vector(parent().names().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<FieldNames, quote_type0>(parent().names(), vb, ",", quote);
    }
  
    template <class Manip>
    value_list_b<FieldNames,Manip> 
!   field_list(const char *d, Manip m, string s0,
! 	     string s1="", string s2="", string s3="", string s4="",
! 	     string s5="", string s6="", string s7="", string s8="",
! 	     string s9="", string sa="", string sb="", string sc="") const {
!     vector<bool> vb;
      create_vector(parent().names(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<FieldNames, Manip>(parent().names(), vb, d, m);
    }
  
    value_list_b<FieldNames,quote_type0> 
!   field_list(const char *d, string s0,
! 	     string s1="", string s2="", string s3="", string s4="",
! 	     string s5="", string s6="", string s7="", string s8="",
! 	     string s9="", string sa="", string sb="", string sc="") const {
!     vector<bool> vb;
      create_vector(parent().names(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<FieldNames, quote_type0>(parent().names(), vb, d, quote);
    }
  
    value_list_b<FieldNames,quote_type0> 
!   field_list(string s0,
! 	     string s1="", string s2="", string s3="", string s4="",
! 	     string s5="", string s6="", string s7="", string s8="",
! 	     string s9="", string sa="", string sb="", string sc="") const {
!     vector<bool> vb;
      create_vector(parent().names(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<FieldNames, quote_type0>(parent().names(), vb, ",", quote);
    }
--- 169,206 ----
  	     bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  	     bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	     bool t9=false, bool ta=false, bool tb=false, bool tc=false) const {
!     std::vector<bool> vb;
      create_vector(parent().names().size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
      return value_list_b<FieldNames, quote_type0>(parent().names(), vb, ",", quote);
    }
  
    template <class Manip>
    value_list_b<FieldNames,Manip> 
!   field_list(const char *d, Manip m, std::string s0,
! 	     std::string s1="", std::string s2="", std::string s3="", std::string s4="",
! 	     std::string s5="", std::string s6="", std::string s7="", std::string s8="",
! 	     std::string s9="", std::string sa="", std::string sb="", std::string sc="") const {
!     std::vector<bool> vb;
      create_vector(parent().names(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<FieldNames, Manip>(parent().names(), vb, d, m);
    }
  
    value_list_b<FieldNames,quote_type0> 
!   field_list(const char *d, std::string s0,
! 	     std::string s1="", std::string s2="", std::string s3="", std::string s4="",
! 	     std::string s5="", std::string s6="", std::string s7="", std::string s8="",
! 	     std::string s9="", std::string sa="", std::string sb="", std::string sc="") const {
!     std::vector<bool> vb;
      create_vector(parent().names(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<FieldNames, quote_type0>(parent().names(), vb, d, quote);
    }
  
    value_list_b<FieldNames,quote_type0> 
!   field_list(std::string s0,
! 	     std::string s1="", std::string s2="", std::string s3="", std::string s4="",
! 	     std::string s5="", std::string s6="", std::string s7="", std::string s8="",
! 	     std::string s9="", std::string sa="", std::string sb="", std::string sc="") const {
!     std::vector<bool> vb;
      create_vector(parent().names(), vb, s0,s1,s2,s3,s4,s5,s6,s7,s8,s9,sa,sb,sc);
      return value_list_b<FieldNames, quote_type0>(parent().names(), vb, ",", quote);
    }
***************
*** 229,236 ****
  	    public RowTemplate<Row, ResUse>
  {
  private:
!   vector <string> data;
! 	vector <bool> is_nulls;
    const ResUse *res;
    bool         throw_exceptions, initialized;
  
--- 229,236 ----
  	    public RowTemplate<Row, ResUse>
  {
  private:
!   std::vector <std::string> data;
! 	std::vector <bool> is_nulls;
    const ResUse *res;
    bool         throw_exceptions, initialized;
  
***************
*** 246,252 ****
  		  data.clear(); is_nulls.clear(); initialized=true;
  		  for (unsigned int i=0;i<size();i++) 
  			{
! 			  data.insert(data.end(),(d[i]) ? string(d[i],jj[i]) : (string)"NULL");
  				is_nulls.insert(is_nulls.end(),d[i] ? false : true);
  			}
  		}
--- 246,252 ----
  		  data.clear(); is_nulls.clear(); initialized=true;
  		  for (unsigned int i=0;i<size();i++) 
  			{
! 			  data.insert(data.end(),(d[i]) ? std::string(d[i],jj[i]) : (std::string)"NULL");
  				is_nulls.insert(is_nulls.end(),d[i] ? false : true);
  			}
  		}
***************
*** 268,274 ****
    inline const ColData   operator [] (const char *) const;
    //: Returns the value of the field with the field name of i.
    // This method is not nearly as efficient as using the index number. Use sparingly. 
!   inline const ColData   operator [] (const string &i) const;
    //: Returns the value of the field with the field name of i.
    // This method is not nearly as effecent as using the index number. Use sparingly. 
  
--- 268,274 ----
    inline const ColData   operator [] (const char *) const;
    //: Returns the value of the field with the field name of i.
    // This method is not nearly as efficient as using the index number. Use sparingly. 
!   inline const ColData   operator [] (const std::string &i) const;
    //: Returns the value of the field with the field name of i.
    // This method is not nearly as effecent as using the index number. Use sparingly. 
  
diff -rc mysql++-1.7.9/sqlplusint/row2.hh mysql++-1.7.9-patched/sqlplusint/row2.hh
*** mysql++-1.7.9/sqlplusint/row2.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/row2.hh	Mon Aug 27 13:48:19 2001
***************
*** 11,22 ****
    return ColData(data[i].c_str(), res->types(i),is_nulls[i]);
  }
  
! inline const ColData Row::operator[] (const string &i) const {
    return (*this)[res->field_num(i)];
  }
  
  inline const ColData Row::operator[] (const char *i) const {
!   return (*this)[res->field_num(string(i))];
  }
  
  // RowTemplate
--- 11,22 ----
    return ColData(data[i].c_str(), res->types(i),is_nulls[i]);
  }
  
! inline const ColData Row::operator[] (const std::string &i) const {
    return (*this)[res->field_num(i)];
  }
  
  inline const ColData Row::operator[] (const char *i) const {
!   return (*this)[res->field_num(std::string(i))];
  }
  
  // RowTemplate
diff -rc mysql++-1.7.9/sqlplusint/set.cc mysql++-1.7.9-patched/sqlplusint/set.cc
*** mysql++-1.7.9/sqlplusint/set.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/set.cc	Mon Aug 27 13:48:30 2001
***************
*** 1,4 ****
  
  #include "set3.hh"
  
! template class Set<set<string> >;
--- 1,4 ----
  
  #include "set3.hh"
  
! template class Set<std::set<std::string> >;
diff -rc mysql++-1.7.9/sqlplusint/set1.hh mysql++-1.7.9-patched/sqlplusint/set1.hh
*** mysql++-1.7.9/sqlplusint/set1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/set1.hh	Mon Aug 27 13:48:35 2001
***************
*** 32,68 ****
  };
  
  template <class T>
! inline MysqlSetInsert<set<T> > set_insert(set<T> *o) {
!   return MysqlSetInsert<set<T> >(o);
  }
  
  template <class T>
! inline MysqlListInsert<vector<T> > set_insert(vector<T> *o) {
!   return MysqlListInsert<vector<T> >(o);
  }
  
  template <class Insert>
  void set2container (const char *str, Insert insert);
  
  //: A Special Set for holding mysql sets.
! template <class Container = set<string> >
  class Set : public Container {
  public:
    Set(const char* str) {set2container(str,set_insert(this));}           //:
!   Set(const string &str) {set2container(str.c_str(),set_insert(this));} //:
    Set(const ColData &str) 
      {set2container(str.c_str(),set_insert(this));}                      //:
    
!   ostream& out_stream(ostream &s) const;
    
!   operator string ();
  };
  
  //! with_class = Set
  
  //:
  template <class Container>
! inline ostream& operator << (ostream &s, const Set<Container> &d) 
  { 
    return d.out_stream(s); 
  }
--- 32,68 ----
  };
  
  template <class T>
! inline MysqlSetInsert<std::set<T> > set_insert(std::set<T> *o) {
!   return MysqlSetInsert<std::set<T> >(o);
  }
  
  template <class T>
! inline MysqlListInsert<std::vector<T> > set_insert(std::vector<T> *o) {
!   return MysqlListInsert<std::vector<T> >(o);
  }
  
  template <class Insert>
  void set2container (const char *str, Insert insert);
  
  //: A Special Set for holding mysql sets.
! template <class Container = std::set<std::string> >
  class Set : public Container {
  public:
    Set(const char* str) {set2container(str,set_insert(this));}           //:
!   Set(const std::string &str) {set2container(str.c_str(),set_insert(this));} //:
    Set(const ColData &str) 
      {set2container(str.c_str(),set_insert(this));}                      //:
    
!   std::ostream& out_stream(std::ostream &s) const;
    
!   operator std::string ();
  };
  
  //! with_class = Set
  
  //:
  template <class Container>
! inline std::ostream& operator << (std::ostream &s, const Set<Container> &d)
  { 
    return d.out_stream(s); 
  }
diff -rc mysql++-1.7.9/sqlplusint/set2.hh mysql++-1.7.9-patched/sqlplusint/set2.hh
*** mysql++-1.7.9/sqlplusint/set2.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/set2.hh	Mon Aug 27 13:48:40 2001
***************
*** 5,12 ****
  #include "stream2string3.hh"
  
  template <class Container> 
! inline Set<Container>::operator string () {
!   return stream2string<string>(*this);
  }
  
  #endif
--- 5,12 ----
  #include "stream2string3.hh"
  
  template <class Container> 
! inline Set<Container>::operator std::string () {
!   return stream2string<std::string>(*this);
  }
  
  #endif
diff -rc mysql++-1.7.9/sqlplusint/sql_query.cc mysql++-1.7.9-patched/sqlplusint/sql_query.cc
*** mysql++-1.7.9/sqlplusint/sql_query.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/sql_query.cc	Mon Aug 27 13:48:45 2001
***************
*** 27,40 ****
  
  
  void SQLQuery::reset() {
!   seekg (0L,ios::beg);
!   seekp (0L,ios::beg);
    parsed.erase(parsed.begin(), parsed.end());
    def.clear(); clear();
  }
  
  char * SQLQuery::preview_char() {
!   *this << ends;
  #ifdef __USLC__
    strstreambuf *tmpbuf = rdbuf();
    uint length = tmpbuf->pcount();
--- 27,40 ----
  
  
  void SQLQuery::reset() {
!   seekg (0L,std::ios::beg);
!   seekp (0L,std::ios::beg);
    parsed.erase(parsed.begin(), parsed.end());
    def.clear(); clear();
  }
  
  char * SQLQuery::preview_char() {
!   *this << std::ends;
  #ifdef __USLC__
    strstreambuf *tmpbuf = rdbuf();
    uint length = tmpbuf->pcount();
***************
*** 43,50 ****
  #endif
    char *s = new char[length+1]; 
    get(s, length, '\0'); 
!   seekg (0,ios::beg);
!   seekp (-1,ios::cur);
    return s;
  }
  
--- 43,50 ----
  #endif
    char *s = new char[length+1]; 
    get(s, length, '\0'); 
!   seekg (0,std::ios::beg);
!   seekp (-1,std::ios::cur);
    return s;
  }
  
***************
*** 70,81 ****
  }
  
  void SQLQuery::proc(SQLQueryParms& p) {
!   seekg (0,ios::beg);
!   seekp (0,ios::beg);
    char      num;
    SQLString *ss;
    SQLQueryParms *c;
!   for (vector<SQLParseElement>::iterator i = parsed.begin();
         i != parsed.end(); i++) {
      *this << i->before;
      num    = i->num;
--- 70,81 ----
  }
  
  void SQLQuery::proc(SQLQueryParms& p) {
!   seekg (0,std::ios::beg);
!   seekp (0,std::ios::beg);
    char      num;
    SQLString *ss;
    SQLQueryParms *c;
!   for (std::vector<SQLParseElement>::iterator i = parsed.begin();
         i != parsed.end(); i++) {
      *this << i->before;
      num    = i->num;
***************
*** 95,104 ****
    }
  } 
  
! string SQLQuery::str(const SQLQueryParms &p) const {
    SQLQuery *const_this = const_cast<SQLQuery *>(this);
    if (!parsed.empty()) const_this->proc(const_cast<SQLQueryParms&>(p));
!   *const_this << ends;
  #ifdef __USLC__
    strstreambuf *tmpbuf = const_this->rdbuf();
    uint length = tmpbuf->pcount() + 1;
--- 95,104 ----
    }
  } 
  
! std::string SQLQuery::str(const SQLQueryParms &p) const {
    SQLQuery *const_this = const_cast<SQLQuery *>(this);
    if (!parsed.empty()) const_this->proc(const_cast<SQLQueryParms&>(p));
!   *const_this << std::ends;
  #ifdef __USLC__
    strstreambuf *tmpbuf = const_this->rdbuf();
    uint length = tmpbuf->pcount() + 1;
***************
*** 108,120 ****
    char s[length]; 
  #endif
    const_this->get(s, length, '\0'); 
!   const_this->seekg (0,ios::beg);
!   const_this->seekp (-1,ios::cur);
!   return string(s);
  }
  
! string SQLQuery::str(const SQLQueryParms &p, query_reset r) {
!   string tmp = str(p);
    if (r==RESET_QUERY) reset();
    return tmp;
  }
--- 108,120 ----
    char s[length]; 
  #endif
    const_this->get(s, length, '\0'); 
!   const_this->seekg (0,std::ios::beg);
!   const_this->seekp (-1,std::ios::cur);
!   return std::string(s);
  }
  
! std::string SQLQuery::str(const SQLQueryParms &p, query_reset r) {
!   std::string tmp = str(p);
    if (r==RESET_QUERY) reset();
    return tmp;
  }
***************
*** 130,140 ****
  }
  
  void SQLQuery::parse() {
!   string str = "";
    char num[4];
    long int n;
    char option;
!   string name;
    char *s, *s0;
    s0 = s = preview_char();
    while (*s) {
--- 130,140 ----
  }
  
  void SQLQuery::parse() {
!   std::string str = "";
    char num[4];
    long int n;
    char option;
!   std::string name;
    char *s, *s0;
    s0 = s = preview_char();
    while (*s) {
***************
*** 170,177 ****
  	  if (*s == ':') s++;
            if (n >= (long int)parsed_names.size())
  	    parsed_names.insert(parsed_names.end(),
! 				(vector<string>::size_type)(n+1) 
! 				- parsed_names.size(), string());
  	  parsed_names[n] = name;
  	  parsed_nums[name] = n;
  	}
--- 170,177 ----
  	  if (*s == ':') s++;
            if (n >= (long int)parsed_names.size())
  	    parsed_names.insert(parsed_names.end(),
! 				(std::vector<std::string>::size_type)(n+1)
! 				- parsed_names.size(), std::string());
  	  parsed_names[n] = name;
  	  parsed_nums[name] = n;
  	}
diff -rc mysql++-1.7.9/sqlplusint/sql_query1.hh mysql++-1.7.9-patched/sqlplusint/sql_query1.hh
*** mysql++-1.7.9/sqlplusint/sql_query1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/sql_query1.hh	Mon Aug 27 13:48:48 2001
***************
*** 16,23 ****
  
  //: This class holds the parameter values for filling template queries. 
  // It is a subclass of a vector of *SQLStrings*.
! class SQLQueryParms : public vector<SQLString> {
!   friend Query;
  private:
    typedef const SQLString&      ss;
    SQLQuery                 *parent;
--- 16,23 ----
  
  //: This class holds the parameter values for filling template queries. 
  // It is a subclass of a vector of *SQLStrings*.
! class SQLQueryParms : public std::vector<SQLString> {
!   friend class Query;
  private:
    typedef const SQLString&      ss;
    SQLQuery                 *parent;
***************
*** 28,37 ****
    void               clear() {erase(begin(),end());} //: Clears the list
    SQLString &operator [] (size_type n) {
      if (n >= size()) insert(end(),(n+1) - size(), "");
!     return vector<SQLString>::operator [] (n);
    } //: Access element number n
    const SQLString &operator [] (size_type n) const 
!     {return vector<SQLString>::operator [] (n);}     
    //: Access element number n
    SQLString &operator [] (const char *str); 
    //: Access the value of the element with a key of str.
--- 28,37 ----
    void               clear() {erase(begin(),end());} //: Clears the list
    SQLString &operator [] (size_type n) {
      if (n >= size()) insert(end(),(n+1) - size(), "");
!     return std::vector<SQLString>::operator [] (n);
    } //: Access element number n
    const SQLString &operator [] (size_type n) const 
!     {return std::vector<SQLString>::operator [] (n);}
    //: Access element number n
    SQLString &operator [] (const char *str); 
    //: Access the value of the element with a key of str.
***************
*** 81,88 ****
  enum query_reset {DONT_RESET, RESET_QUERY};
  
  struct SQLParseElement {
!   SQLParseElement(string b, char o, char n) : before(b),option(o),num(n) {}
!   string before;
    char   option;
    char   num;
  };
--- 81,88 ----
  enum query_reset {DONT_RESET, RESET_QUERY};
  
  struct SQLParseElement {
!   SQLParseElement(std::string b, char o, char n) : before(b),option(o),num(n) {}
!   std::string before;
    char   option;
    char   num;
  };
***************
*** 108,122 ****
  // methods except for *error()* and *success()*.
  
  class SQLQuery : public strstream { 
!   friend SQLQueryParms; 
  private:
    char* preview_char();
  protected:
    bool    Success;
    char*   errmsg;
!   vector<SQLParseElement> parsed;
!   vector<string>          parsed_names;
!   map<string,int>         parsed_nums;
    typedef  const SQLString&  ss;
    typedef  SQLQueryParms  parms;
    void     proc(parms &p);
--- 108,122 ----
  // methods except for *error()* and *success()*.
  
  class SQLQuery : public strstream { 
!   friend class SQLQueryParms;
  private:
    char* preview_char();
  protected:
    bool    Success;
    char*   errmsg;
!   std::vector<SQLParseElement> parsed;
!   std::vector<std::string>          parsed_names;
!   std::map<std::string,int>         parsed_nums;
    typedef  const SQLString&  ss;
    typedef  SQLQueryParms  parms;
    void     proc(parms &p);
***************
*** 130,136 ****
  
    void     parse();  
  
!   string   error () const {return errmsg;}
    bool     success() const {return Success;}
  
    operator bool () {return success();}
--- 130,136 ----
  
    void     parse();  
  
!   std::string   error () const {return errmsg;}
    bool     success() const {return Success;}
  
    operator bool () {return success();}
***************
*** 184,190 ****
      return *this;
    } //:
  
!   mysql_query_define_const1(string,str)
  };  
  
  #endif
--- 184,190 ----
      return *this;
    } //:
  
!   mysql_query_define_const1(std::string,str)
  };  
  
  #endif
diff -rc mysql++-1.7.9/sqlplusint/sql_string1.hh mysql++-1.7.9-patched/sqlplusint/sql_string1.hh
*** mysql++-1.7.9/sqlplusint/sql_string1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/sql_string1.hh	Mon Aug 27 13:48:50 2001
***************
*** 10,31 ****
  // A class subclassed from string that has the additional ability to
  // convert from any valid mysql type.
  
! class SQLString : public string {
  public:
    bool is_string;
    bool dont_escape;
    bool processed;
  
    SQLString() : is_string(false) , processed(false) {}
!   SQLString (const string& str) :string (str)
      {is_string=true;processed=false;dont_escape=false;}
!   SQLString (const char *str) :string (str) 
      {is_string=true;processed=false;dont_escape=false;}
    SQLString& operator = (const char *str) {
!     string::operator = (str); return *this;
    }
!   SQLString& operator = (const string& str) {
!     string::operator = (str); return *this;
    }
    SQLString (char i) : is_string(false), processed(false)
      {char s[6]; sprintf(s,"%dh",(short int)i); *this=s;}
--- 10,31 ----
  // A class subclassed from string that has the additional ability to
  // convert from any valid mysql type.
  
! class SQLString : public std::string {
  public:
    bool is_string;
    bool dont_escape;
    bool processed;
  
    SQLString() : is_string(false) , processed(false) {}
!   SQLString (const std::string& str) :std::string (str)
      {is_string=true;processed=false;dont_escape=false;}
!   SQLString (const char *str) :std::string (str)
      {is_string=true;processed=false;dont_escape=false;}
    SQLString& operator = (const char *str) {
!     std::string::operator = (str); return *this;
    }
!   SQLString& operator = (const std::string& str) {
!     std::string::operator = (str); return *this;
    }
    SQLString (char i) : is_string(false), processed(false)
      {char s[6]; sprintf(s,"%dh",(short int)i); *this=s;}
diff -rc mysql++-1.7.9/sqlplusint/string_util.cc mysql++-1.7.9-patched/sqlplusint/string_util.cc
*** mysql++-1.7.9/sqlplusint/string_util.cc	Sat May 19 12:44:49 2001
--- mysql++-1.7.9-patched/sqlplusint/string_util.cc	Mon Aug 27 13:48:53 2001
***************
*** 1,7 ****
  #include <string>
  
  
! void strip (string& s) {
  	int i,j = s.size() - 1;  if (!s.size()) return;
  	for (i = 0; s[i] == ' ';i++);
  	if (i) s.erase(0,i); j = s.size(); if (!j) return; j--;
--- 1,7 ----
  #include <string>
  
  
! void strip (std::string& s) {
  	int i,j = s.size() - 1;  if (!s.size()) return;
  	for (i = 0; s[i] == ' ';i++);
  	if (i) s.erase(0,i); j = s.size(); if (!j) return; j--;
***************
*** 9,15 ****
  	if (i != j) s.erase(i+1,(size_t)-1);
  }
  
! void escape_string (string& s) {
  	if (!s.size()) return;
  	for (unsigned int i = 0;i<s.size();i++)
  	{
--- 9,15 ----
  	if (i != j) s.erase(i+1,(size_t)-1);
  }
  
! void escape_string (std::string& s) {
  	if (!s.size()) return;
  	for (unsigned int i = 0;i<s.size();i++)
  	{
diff -rc mysql++-1.7.9/sqlplusint/string_util.hh mysql++-1.7.9-patched/sqlplusint/string_util.hh
*** mysql++-1.7.9/sqlplusint/string_util.hh	Sat May 19 12:44:49 2001
--- mysql++-1.7.9-patched/sqlplusint/string_util.hh	Mon Aug 27 13:48:56 2001
***************
*** 3,30 ****
  #include <ctype.h>
  #include <string>
  
! extern void strip (string& s); // Strips blanks at left and right ends
  
! extern void escape_string (string& s); // C++ equivalent of mysql_escape_string
  
! inline void str_to_upr (string& s) { // Changes case of string to upper
  	for (unsigned int cnt=0; cnt < s.length(); cnt++) {
  		char c = s[cnt]; s[cnt]=toupper(c);
  	}
  }
  
! inline void str_to_lwr (string& s) { // Changes case of string to lower
  	for (unsigned int cnt=0; cnt < s.length(); cnt++) {
  		char c = s[cnt]; s[cnt]=tolower(c);
  	}
  }
  
! inline void strip_all_blanks (string& s) { // Removes all blanks
  	for (unsigned int counter=0;counter < s.size();counter++)
  		if (s[counter] == ' ') { s.erase(counter,1); counter--;}
  }
  
! inline void strip_all_non_num (string& s) { // Removes all non-numerics
  	for (unsigned int counter=0;counter < s.size();counter++)
  		if (!isdigit(s[counter])) { s.erase(counter,1); counter--;}
  }
--- 3,30 ----
  #include <ctype.h>
  #include <string>
  
! extern void strip (std::string& s); // Strips blanks at left and right ends
  
! extern void escape_string (std::string& s); // C++ equivalent of mysql_escape_string
  
! inline void str_to_upr (std::string& s) { // Changes case of string to upper
  	for (unsigned int cnt=0; cnt < s.length(); cnt++) {
  		char c = s[cnt]; s[cnt]=toupper(c);
  	}
  }
  
! inline void str_to_lwr (std::string& s) { // Changes case of string to lower
  	for (unsigned int cnt=0; cnt < s.length(); cnt++) {
  		char c = s[cnt]; s[cnt]=tolower(c);
  	}
  }
  
! inline void strip_all_blanks (std::string& s) { // Removes all blanks
  	for (unsigned int counter=0;counter < s.size();counter++)
  		if (s[counter] == ' ') { s.erase(counter,1); counter--;}
  }
  
! inline void strip_all_non_num (std::string& s) { // Removes all non-numerics
  	for (unsigned int counter=0;counter < s.size();counter++)
  		if (!isdigit(s[counter])) { s.erase(counter,1); counter--;}
  }
diff -rc mysql++-1.7.9/sqlplusint/type_info.cc mysql++-1.7.9-patched/sqlplusint/type_info.cc
*** mysql++-1.7.9/sqlplusint/type_info.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/type_info.cc	Mon Aug 27 13:48:59 2001
***************
*** 10,17 ****
  #include "set1.hh"
  #include "type_info3.hh"
  
! typedef string Enum;
! 
  const mysql_type_info::sql_type_info mysql_type_info::types[62] = {
    sql_type_info("DECIMAL NOT NULL", typeid(double), 0),
    sql_type_info("TINYINT NOT NULL", typeid(signed char), 1, true),
--- 10,17 ----
  #include "set1.hh"
  #include "type_info3.hh"
  
! typedef std::string Enum;
! using std::string;
  const mysql_type_info::sql_type_info mysql_type_info::types[62] = {
    sql_type_info("DECIMAL NOT NULL", typeid(double), 0),
    sql_type_info("TINYINT NOT NULL", typeid(signed char), 1, true),
diff -rc mysql++-1.7.9/sqlplusint/type_info1.hh mysql++-1.7.9-patched/sqlplusint/type_info1.hh
*** mysql++-1.7.9/sqlplusint/type_info1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/type_info1.hh	Mon Aug 27 13:49:01 2001
***************
*** 19,29 ****
  class mysql_ti_sql_type_info_lookup;
  
  class mysql_ti_sql_type_info {
!   friend mysql_type_info;
!   friend mysql_ti_sql_type_info_lookup;
  private:
    const char          *_sql_name;
!   const type_info     *_c_type;
    const unsigned char  _base_type;
    const bool           _default;
    mysql_ti_sql_type_info (const mysql_ti_sql_type_info &b);           // can't do
--- 19,29 ----
  class mysql_ti_sql_type_info_lookup;
  
  class mysql_ti_sql_type_info {
!   friend class mysql_type_info;
!   friend class mysql_ti_sql_type_info_lookup;
  private:
    const char          *_sql_name;
!   const std::type_info     *_c_type;
    const unsigned char  _base_type;
    const bool           _default;
    mysql_ti_sql_type_info (const mysql_ti_sql_type_info &b);           // can't do
***************
*** 33,59 ****
    // all private, only mysql_type_info can
    // create because there *must* be only one copy
    // of each.
!   mysql_ti_sql_type_info (const char *s, const type_info &t, 
  			  const unsigned char bt = 0,  const bool d = false )
      : _sql_name(s), _c_type(&t), _base_type(bt), _default(d) {}
  };
  
  struct type_info_cmp {
!   bool operator() (const type_info *lhs, const type_info *rhs) const {
      return lhs->before(*rhs);
    }
  };
  
  class mysql_ti_sql_type_info_lookup {
!   friend mysql_type_info;
  private:
    typedef mysql_ti_sql_type_info sql_type_info;
  
!   map<const type_info *, unsigned char, type_info_cmp> _map;
    
    mysql_ti_sql_type_info_lookup(const sql_type_info types[], const int size);
  
!   const unsigned char& operator [] (const type_info &ti) const {
      return _map.find(&ti)->second;
    }
  };
--- 33,59 ----
    // all private, only mysql_type_info can
    // create because there *must* be only one copy
    // of each.
!   mysql_ti_sql_type_info (const char *s, const std::type_info &t,
  			  const unsigned char bt = 0,  const bool d = false )
      : _sql_name(s), _c_type(&t), _base_type(bt), _default(d) {}
  };
  
  struct type_info_cmp {
!   bool operator() (const std::type_info *lhs, const std::type_info *rhs) const {
      return lhs->before(*rhs);
    }
  };
  
  class mysql_ti_sql_type_info_lookup {
!   friend class mysql_type_info;
  private:
    typedef mysql_ti_sql_type_info sql_type_info;
  
!   std::map<const std::type_info *, unsigned char, type_info_cmp> _map;
    
    mysql_ti_sql_type_info_lookup(const sql_type_info types[], const int size);
  
!   const unsigned char& operator [] (const std::type_info &ti) const {
      return _map.find(&ti)->second;
    }
  };
***************
*** 94,107 ****
    //:
    mysql_type_info(const mysql_type_info &t) : num(t.num) {}
    //:
!   mysql_type_info(const type_info &t) {num = lookups[t]; }
    //: 
    mysql_type_info& operator = (unsigned char n) {num=n; return *this;}
    //:
    mysql_type_info& operator = (const mysql_type_info &t) 
      {num = t.num; return *this;}
    //:
!   mysql_type_info& operator = (const type_info &t)
      {num = lookups[t]; return *this;}
    //:
    inline const char*           name()      const;
--- 94,107 ----
    //:
    mysql_type_info(const mysql_type_info &t) : num(t.num) {}
    //:
!   mysql_type_info(const std::type_info &t) {num = lookups[t]; }
    //: 
    mysql_type_info& operator = (unsigned char n) {num=n; return *this;}
    //:
    mysql_type_info& operator = (const mysql_type_info &t) 
      {num = t.num; return *this;}
    //:
!   mysql_type_info& operator = (const std::type_info &t)
      {num = lookups[t]; return *this;}
    //:
    inline const char*           name()      const;
***************
*** 110,116 ****
    // associated with the sql type.
    inline const char*           sql_name()  const;
    //: Returns the name for the sql type.
!   inline const type_info&      c_type()    const;
  	inline const unsigned int length() const;
  	inline const unsigned int max_length() const;
    //: Returns the type_info for the C++ type associated with the sql type.
--- 110,116 ----
    // associated with the sql type.
    inline const char*           sql_name()  const;
    //: Returns the name for the sql type.
!   inline const std::type_info&      c_type()    const;
  	inline const unsigned int length() const;
  	inline const unsigned int max_length() const;
    //: Returns the type_info for the C++ type associated with the sql type.
***************
*** 146,152 ****
  inline const unsigned int    mysql_type_info::max_length()  const {
    return _max_length;
  }
! inline const type_info&      mysql_type_info::c_type()    const {
    return *deref()._c_type;
  }
  inline const mysql_type_info mysql_type_info::base_type() const 
--- 146,152 ----
  inline const unsigned int    mysql_type_info::max_length()  const {
    return _max_length;
  }
! inline const std::type_info&      mysql_type_info::c_type()    const {
    return *deref()._c_type;
  }
  inline const mysql_type_info mysql_type_info::base_type() const 
***************
*** 172,190 ****
    return a.id() != b.id();
  }
  
! inline bool operator == (const type_info &a, const mysql_type_info &b) {
    return a == b.c_type();
  }
  
! inline bool operator != (const type_info &a, const mysql_type_info &b) {
    return a != b.c_type();
  }
  
! inline bool operator == (const mysql_type_info &a, const type_info &b) {
    return a.c_type() == b;
  }
  
! inline bool operator != (const mysql_type_info &a, const type_info &b) {
    return a.c_type() != b;
  }
  
--- 172,190 ----
    return a.id() != b.id();
  }
  
! inline bool operator == (const std::type_info &a, const mysql_type_info &b) {
    return a == b.c_type();
  }
  
! inline bool operator != (const std::type_info &a, const mysql_type_info &b) {
    return a != b.c_type();
  }
  
! inline bool operator == (const mysql_type_info &a, const std::type_info &b) {
    return a.c_type() == b;
  }
  
! inline bool operator != (const mysql_type_info &a, const std::type_info &b) {
    return a.c_type() != b;
  }
  
diff -rc mysql++-1.7.9/sqlplusint/vallist.cc mysql++-1.7.9-patched/sqlplusint/vallist.cc
*** mysql++-1.7.9/sqlplusint/vallist.cc	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/vallist.cc	Mon Aug 27 13:49:04 2001
***************
*** 1,7 ****
  #include "vallist3.hh"
  #include "row2.hh"
! 
! void create_vector(int size, vector<bool>& v, bool t0, 
  		   bool t1, bool t2, bool t3, bool t4,
  		   bool t5, bool t6, bool t7, bool t8,
  		   bool t9, bool ta, bool tb, bool tc)
--- 1,7 ----
  #include "vallist3.hh"
  #include "row2.hh"
! using std::string;
! void create_vector(int size, std::vector<bool>& v, bool t0,
  		   bool t1, bool t2, bool t3, bool t4,
  		   bool t5, bool t6, bool t7, bool t8,
  		   bool t9, bool ta, bool tb, bool tc)
***************
*** 23,29 ****
  }
  
  template <class Container>
! void create_vector(const Container&c, vector<bool>&v, string s0, string s1, 
  		   string s2, string s3, string s4, string s5, string s6,
  		   string s7, string s8, string s9, string sa, string sb,
  		   string sc)
--- 23,29 ----
  }
  
  template <class Container>
! void create_vector(const Container&c, std::vector<bool>&v, string s0, string s1,
  		   string s2, string s3, string s4, string s5, string s6,
  		   string s7, string s8, string s9, string sa, string sb,
  		   string sc)
***************
*** 44,50 ****
    v[c.parent().field_num(sc)] = true;
  }
  
! template void create_vector (const Row &c, vector<bool>&v, string s0, string s1, 
  		   string s2, string s3, string s4, string s5, string s6,
  		   string s7, string s8, string s9, string sa, string sb,
  		   string sc);
--- 44,50 ----
    v[c.parent().field_num(sc)] = true;
  }
  
! template void create_vector (const Row &c, std::vector<bool>&v, string s0, string s1,
  		   string s2, string s3, string s4, string s5, string s6,
  		   string s7, string s8, string s9, string sa, string sb,
  		   string sc);
diff -rc mysql++-1.7.9/sqlplusint/vallist1.hh mysql++-1.7.9-patched/sqlplusint/vallist1.hh
*** mysql++-1.7.9/sqlplusint/vallist1.hh	Sat May 19 12:44:48 2001
--- mysql++-1.7.9-patched/sqlplusint/vallist1.hh	Mon Aug 27 13:49:07 2001
***************
*** 8,17 ****
  template <class Seq, class Manip>
  struct value_list_b {
    const Seq          *list;
!   const vector<bool> fields;
    const char         *delem;
    Manip              manip;
!   value_list_b(const Seq &s, const vector<bool> &f, const char *d, Manip m) 
      : list(&s), fields(f), delem(d), manip(m) {}
  };
  
--- 8,17 ----
  template <class Seq, class Manip>
  struct value_list_b {
    const Seq          *list;
!   const std::vector<bool> fields;
    const char         *delem;
    Manip              manip;
!   value_list_b(const Seq &s, const std::vector<bool> &f, const char *d, Manip m)
      : list(&s), fields(f), delem(d), manip(m) {}
  };
  
***************
*** 19,29 ****
  struct equal_list_b {
    const Seq1         *list1;
    const Seq2         *list2;
!   const vector<bool> fields;
    const char         *delem;
    const char         *equl;
    Manip              manip;
!   equal_list_b(const Seq1 &s1, const Seq2 &s2, const vector<bool> &f,
  	       const char *d, const char *e, Manip m) 
      : list1(&s1), list2(&s2), fields(f), delem(d), equl(e), manip(m) {}
  };
--- 19,29 ----
  struct equal_list_b {
    const Seq1         *list1;
    const Seq2         *list2;
!   const std::vector<bool> fields;
    const char         *delem;
    const char         *equl;
    Manip              manip;
!   equal_list_b(const Seq1 &s1, const Seq2 &s2, const std::vector<bool> &f,
  	       const char *d, const char *e, Manip m) 
      : list1(&s1), list2(&s2), fields(f), delem(d), equl(e), manip(m) {}
  };
***************
*** 52,58 ****
  //
  
  template <class Seq, class Manip>
! ostream& operator << (ostream &o, const value_list_b<Seq, Manip> &cl) {
    typename Seq::const_iterator i =  cl.list->begin();
    register int k = 0;
    for (;;) {
--- 52,58 ----
  //
  
  template <class Seq, class Manip>
! std::ostream& operator << (std::ostream &o, const value_list_b<Seq, Manip> &cl) {
    typename Seq::const_iterator i =  cl.list->begin();
    register int k = 0;
    for (;;) {
***************
*** 67,73 ****
  }
  
  template <class Seq1, class Seq2, class Manip>
! ostream& operator << (ostream &o, const equal_list_b<Seq1, Seq2, Manip> &el) {
    typename Seq1::const_iterator i = el.list1->begin();
    typename Seq2::const_iterator j = el.list2->begin();
    register int k = 0;
--- 67,73 ----
  }
  
  template <class Seq1, class Seq2, class Manip>
! std::ostream& operator << (std::ostream &o, const equal_list_b<Seq1, Seq2, Manip> &el) {
    typename Seq1::const_iterator i = el.list1->begin();
    typename Seq2::const_iterator j = el.list2->begin();
    register int k = 0;
***************
*** 84,90 ****
  }
  
  template <class Seq, class Manip>
! ostream& operator << (ostream &o, const value_list_ba<Seq, Manip> &cl) {
    typename Seq::const_iterator i =  cl.list->begin();
    for (;;) {
      o << cl.manip << *i;
--- 84,90 ----
  }
  
  template <class Seq, class Manip>
! std::ostream& operator << (std::ostream &o, const value_list_ba<Seq, Manip> &cl) {
    typename Seq::const_iterator i =  cl.list->begin();
    for (;;) {
      o << cl.manip << *i;
***************
*** 95,101 ****
  }
  
  template <class Seq1, class Seq2, class Manip>
! ostream& operator << (ostream &o, const equal_list_ba<Seq1, Seq2, Manip> &el) {
    typename Seq1::const_iterator i = el.list1->begin();
    typename Seq2::const_iterator j = el.list2->begin();
    for (;;) {
--- 95,101 ----
  }
  
  template <class Seq1, class Seq2, class Manip>
! std::ostream& operator << (std::ostream &o, const equal_list_ba<Seq1, Seq2, Manip> &el) {
    typename Seq1::const_iterator i = el.list1->begin();
    typename Seq2::const_iterator j = el.list2->begin();
    for (;;) {
***************
*** 123,138 ****
  // create vector
  //
  
! void create_vector(int size, vector<bool>& v, bool t0, 
  		   bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  		   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  		   bool t9=false, bool ta=false, bool tb=false, bool tc=false);
  
  template <class Container>
! void create_vector(const Container&c, vector<bool>&v, string s0, string s1, 
! 		   string s2, string s3, string s4, string s5, string s6,
! 		   string s7, string s8, string s9, string sa, string sb,
! 		   string sc);
  
  //
  // value list
--- 123,138 ----
  // create vector
  //
  
! void create_vector(int size, std::vector<bool>& v, bool t0,
  		   bool t1=false, bool t2=false, bool t3=false, bool t4=false,
  		   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  		   bool t9=false, bool ta=false, bool tb=false, bool tc=false);
  
  template <class Container>
! void create_vector(const Container&c, std::vector<bool>&v, std::string s0, std::string s1,
! 		   std::string s2, std::string s3, std::string s4, std::string s5, std::string s6,
! 		   std::string s7, std::string s8, std::string s9, std::string sa, std::string sb,
! 		   std::string sc);
  
  //
  // value list
***************
*** 155,161 ****
  template <class Seq, class Manip>
  inline
  value_list_b<Seq,Manip>
! value_list(const Seq &s, const char *d, Manip m, const vector<bool> &vb)
  {
    return value_list_b<Seq, Manip>(s, vb, d, m);
  }
--- 155,161 ----
  template <class Seq, class Manip>
  inline
  value_list_b<Seq,Manip>
! value_list(const Seq &s, const char *d, Manip m, const std::vector<bool> &vb)
  {
    return value_list_b<Seq, Manip>(s, vb, d, m);
  }
***************
*** 167,173 ****
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   vector<bool> vb;
    create_vector(s.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return value_list_b<Seq, Manip>(s, vb, d, m);
  }
--- 167,173 ----
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   std::vector<bool> vb;
    create_vector(s.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return value_list_b<Seq, Manip>(s, vb, d, m);
  }
***************
*** 179,185 ****
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   vector<bool> vb;
    create_vector(s.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return value_list_b<Seq, do_nothing_type0> (s, vb, d, do_nothing);
  }
--- 179,185 ----
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   std::vector<bool> vb;
    create_vector(s.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return value_list_b<Seq, do_nothing_type0> (s, vb, d, do_nothing);
  }
***************
*** 191,197 ****
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   vector<bool> vb;
    create_vector(s.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return value_list_b<Seq, do_nothing_type0> (s, vb, ",",do_nothing);
  }
--- 191,197 ----
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   std::vector<bool> vb;
    create_vector(s.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return value_list_b<Seq, do_nothing_type0> (s, vb, ",",do_nothing);
  }
***************
*** 220,226 ****
  inline
  equal_list_b<Seq1, Seq2, Manip>
  equal_list(const Seq1 &s1, const Seq2 &s2, const char *d, const char *e, 
! 	   Manip m, const vector<bool> &vb)
  {
    return equal_list_b<Seq1,Seq2,Manip>(s1, s2, vb, d, e, m);
  }
--- 220,226 ----
  inline
  equal_list_b<Seq1, Seq2, Manip>
  equal_list(const Seq1 &s1, const Seq2 &s2, const char *d, const char *e, 
! 	   Manip m, const std::vector<bool> &vb)
  {
    return equal_list_b<Seq1,Seq2,Manip>(s1, s2, vb, d, e, m);
  }
***************
*** 234,240 ****
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   vector<bool> vb;
    create_vector(s1.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return equal_list_b<Seq1,Seq2,Manip>(s1, s2, vb, d, e, m);
  }
--- 234,240 ----
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   std::vector<bool> vb;
    create_vector(s1.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return equal_list_b<Seq1,Seq2,Manip>(s1, s2, vb, d, e, m);
  }
***************
*** 248,254 ****
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   vector<bool> vb;
    create_vector(s1.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return equal_list_b<Seq1,Seq2,do_nothing_type0>
      (s1, s2, vb, d, e, do_nothing);
--- 248,254 ----
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   std::vector<bool> vb;
    create_vector(s1.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return equal_list_b<Seq1,Seq2,do_nothing_type0>
      (s1, s2, vb, d, e, do_nothing);
***************
*** 262,268 ****
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   vector<bool> vb;
    create_vector(s1.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return equal_list_b<Seq1,Seq2,do_nothing_type0> 
      (s1, s2, vb, d, " = ", do_nothing);
--- 262,268 ----
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   std::vector<bool> vb;
    create_vector(s1.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return equal_list_b<Seq1,Seq2,do_nothing_type0> 
      (s1, s2, vb, d, " = ", do_nothing);
***************
*** 276,282 ****
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   vector<bool> vb;
    create_vector(s1.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return equal_list_b<Seq1,Seq2,do_nothing_type0> 
      (s1, s2, vb,"," ," = " ,do_nothing);
--- 276,282 ----
  	   bool t5=false, bool t6=false, bool t7=false, bool t8=false,
  	   bool t9=false, bool ta=false, bool tb=false, bool tc=false)
  {
!   std::vector<bool> vb;
    create_vector(s1.size(), vb, t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,ta,tb,tc);
    return equal_list_b<Seq1,Seq2,do_nothing_type0> 
      (s1, s2, vb,"," ," = " ,do_nothing);
