diff -uNr firebird-1.5.1.4481-orig/src/common/classes/alloc.h firebird-1.5.1.4481/src/common/classes/alloc.h
--- firebird-1.5.1.4481-orig/src/common/classes/alloc.h	2003-10-30 22:25:52.000000000 +0000
+++ firebird-1.5.1.4481/src/common/classes/alloc.h	2004-09-12 11:26:47.351584232 +0000
@@ -237,12 +237,14 @@
 // loaded by host application using STL
 
 // This is to prevent inclusion of <new> header
-#ifdef __NEW__
+#ifdef _NEW
 #error "alloc.h must be included before <new>"
 #endif
-#define __NEW__
+#define _NEW
 namespace std {
 	class bad_alloc : public exception {};
+	struct nothrow_t { };
+	extern const nothrow_t nothrow;    
 }
 // Define operators as static inline to prevent replacement of STL versions
 static inline void* operator new(size_t s) {
@@ -258,6 +260,19 @@
 	);
 }
 
+static inline void* operator new(size_t s, const std::nothrow_t&) {
+#if defined(DEV_BUILD)
+// Do not complain here. It causes client tools to crash on Red Hat 8.0
+//	fprintf(stderr, "You MUST allocate all memory from a pool.  Don't use the default global new().\n");
+#endif	// DEV_BUILD
+//	return getDefaultMemoryPool()->calloc(s, 0
+	return getDefaultMemoryPool()->allocate(s, 0
+#ifdef DEBUG_GDS_ALLOC
+	  ,__FILE__,__LINE__
+#endif
+	);
+}
+
 static inline void* operator new[](size_t s) {
 #if defined(DEV_BUILD)
 // Do not complain here. It causes client tools to crash on Red Hat 8.0
diff -uNr firebird-1.5.1.4481-orig/src/common/classes/array.h firebird-1.5.1.4481/src/common/classes/array.h
--- firebird-1.5.1.4481-orig/src/common/classes/array.h	2004-03-29 07:40:23.000000000 +0000
+++ firebird-1.5.1.4481/src/common/classes/array.h	2004-09-12 11:31:34.555922536 +0000
@@ -60,15 +60,15 @@
 class Array : private Storage {
 public:
 	Array(MemoryPool* p) : 
-	  count(0), capacity(getStorageSize()), data(getStorage()), pool(p)  {}
+	  count(0), capacity(Storage::getStorageSize()), data(Storage::getStorage()), pool(p)  {}
 	Array(MemoryPool* p, int InitialCapacity) : count(0), 
-		capacity(getStorageSize()), data(getStorage()), pool(p)  
+		capacity(Storage::getStorageSize()), data(Storage::getStorage()), pool(p)  
 	{
 		ensureCapacity(InitialCapacity);
 	}
 	~Array()
 	{
-		if (data != getStorage())
+		if (data != Storage::getStorage())
 			pool->deallocate(data);
 	}
 	void clear() { count = 0; };
@@ -170,7 +170,7 @@
 #endif
 						));
 			memcpy(newdata, data, sizeof(T) * count);
-			if (data != getStorage())
+			if (data != Storage::getStorage())
 				pool->deallocate(data);
 			data = newdata;
 			capacity = newcapacity;
@@ -188,17 +188,17 @@
 	SortedArray(MemoryPool* p, int s) : Array<Value>(p, s) {}
 	SortedArray(MemoryPool* p) : Array<Value>(p) {}
 	bool find(const Key& item, int& pos) {
-		int highBound = count, lowBound = 0;
+		int highBound = Array<Value>::count, lowBound = 0;
 		while (highBound > lowBound) {
 			int temp = (highBound + lowBound) >> 1;
-			if (Cmp::compare(item, KeyOfValue::generate(this, data[temp])))
+			if (Cmp::compare(item, KeyOfValue::generate(this, Array<Value>::data[temp])))
 				lowBound = temp + 1;
 			else
 				highBound = temp;
 		}
 		pos = lowBound;
-		return highBound != count &&
-			!Cmp::compare(KeyOfValue::generate(this, data[lowBound]), item);
+		return highBound != Array<Value>::count &&
+			!Cmp::compare(KeyOfValue::generate(this, Array<Value>::data[lowBound]), item);
 	}
 	int add(const Value& item) {
 	    int pos;
diff -uNr firebird-1.5.1.4481-orig/src/common/classes/tree.h firebird-1.5.1.4481/src/common/classes/tree.h
--- firebird-1.5.1.4481-orig/src/common/classes/tree.h	2003-10-30 22:25:52.000000000 +0000
+++ firebird-1.5.1.4481/src/common/classes/tree.h	2004-09-12 11:22:54.754944296 +0000
@@ -215,7 +215,7 @@
 	}
     Value& current() const { return (*curr)[curPos]; }
 	Value& getAddErrorValue() { return addErrorValue; }
-    int getCount() const { return count; }
+//    int getCount() const { return count; }
 private:
 	BePlusTree(Allocator *_pool, void *rootPage) : 	pool(_pool), level(0), 
 		curr(new(rootPage) ItemList()), root(rootPage),	curPos(0)/*, count(0)*/  {};
@@ -260,7 +260,7 @@
 		static const Key& generate(void *sender, void *item) { 
 			for (int lev = ((NodeList *)sender)->level; lev > 0; lev--)
 				item = *((NodeList *)item)->begin();
-			return KeyOfValue::generate(item,*((BePlusTree::ItemList *)item)->begin());
+			return KeyOfValue::generate(item,*(reinterpret_cast<typename BePlusTree<Value,Key,Allocator,KeyOfValue,Cmp,LeafCount,NodeCount>::ItemList *>(item))->begin());
 		}
 		static void setNodeParentAndLevel(void *node, int level, NodeList *parent) {
 			if (level) {
diff -uNr firebird-1.5.1.4481-orig/src/common/classes/vector.h firebird-1.5.1.4481/src/common/classes/vector.h
--- firebird-1.5.1.4481-orig/src/common/classes/vector.h	2002-12-14 21:43:18.000000000 +0000
+++ firebird-1.5.1.4481/src/common/classes/vector.h	2004-09-12 11:23:25.422282152 +0000
@@ -100,17 +100,17 @@
 public:
 	SortedVector() : Vector<Value, Capacity>() {}
 	bool find(const Key& item, int& pos) {
-		int highBound=count, lowBound=0;
+		int highBound=Vector<Value, Capacity>::count, lowBound=0;
 		while (highBound > lowBound) {
 			int temp = (highBound + lowBound) >> 1;
-			if (Cmp::compare(item, KeyOfValue::generate(this,data[temp])))
+			if (Cmp::compare(item, KeyOfValue::generate(this,Vector<Value, Capacity>::data[temp])))
 				lowBound = temp+1;
 			else
 				highBound = temp;
 		}
 		pos = lowBound;
-		return highBound != count &&
-			!Cmp::compare(KeyOfValue::generate(this,data[lowBound]), item);
+		return highBound != Vector<Value, Capacity>::count &&
+			!Cmp::compare(KeyOfValue::generate(this,Vector<Value, Capacity>::data[lowBound]), item);
 	}
 	int add(const Value& item) {
 	    int pos;
