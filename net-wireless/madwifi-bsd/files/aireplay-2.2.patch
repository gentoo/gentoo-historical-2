--- madwifi-bsd/ath/if_ath.c.orig	2005-06-02 08:23:52.000000000 +0200
+++ madwifi-bsd/ath/if_ath.c	2005-06-04 14:37:13.000000000 +0200
@@ -1750,7 +1750,8 @@
 			/*
 			 * Encapsulate the packet for transmission.
 			 */
-			skb = ieee80211_encap(ic, skb, ni);
+			if (ic->ic_opmode != IEEE80211_M_MONITOR)
+				skb = ieee80211_encap(ic, skb, ni);
 			if (skb == NULL) {
 				DPRINTF(sc, ATH_DEBUG_ANY,
 					"%s: encapsulation failure\n",
@@ -3968,7 +3969,7 @@
 	//TODO: ??? pktlen = m0->m_pkthdr.len - (hdrlen & 3);
 	pktlen = skb->len - (hdrlen & 3);
 	
-	if (iswep) {
+	if (iswep && ic->ic_opmode != IEEE80211_M_MONITOR) {
 		const struct ieee80211_cipher *cip;
 		struct ieee80211_key *k;
 
@@ -4038,7 +4039,7 @@
 	 * use short preamble based on the current mode and
 	 * negotiated parameters.
 	 */
-	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
+	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) && ni != NULL &&
 	    (ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_PREAMBLE)) {
 		shortPreamble = AH_TRUE;
 		sc->sc_stats.ast_tx_shortpre++;
@@ -4054,6 +4055,11 @@
 	 */
 	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
 	case IEEE80211_FC0_TYPE_MGT:
+        if (ic->ic_opmode == IEEE80211_M_MONITOR) {
+		    atype = HAL_PKT_TYPE_NORMAL;		/* default */
+			txq = sc->sc_ac2q[skb->priority];
+            break;
+        }
 		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
 		if (subtype == IEEE80211_FC0_SUBTYPE_BEACON)
 			atype = HAL_PKT_TYPE_BEACON;
@@ -4077,6 +4083,11 @@
 		flags |= HAL_TXDESC_INTREQ;	/* force interrupt */
 		break;
 	case IEEE80211_FC0_TYPE_CTL:
+        if (ic->ic_opmode == IEEE80211_M_MONITOR) {
+		    atype = HAL_PKT_TYPE_NORMAL;		/* default */
+			txq = sc->sc_ac2q[skb->priority];
+            break;
+        }
 		atype = HAL_PKT_TYPE_PSPOLL;	/* stop setting of duration */
 		rix = 0;			/* XXX lowest rate */
 		try0 = ATH_TXMAXTRY;
@@ -4111,11 +4122,14 @@
 			flags |= HAL_TXDESC_INTREQ;	/* force interrupt */
 		} else {
 			if (ic->ic_fixed_rate == -1) {
+				rix = 0;		/* XXX lowest rate */
+				try0 = ATH_TXMAXTRY;
 				/*
 				 * Data frames; consult the rate control module.
 				 */
-				ath_rate_findrate(sc, an, shortPreamble, pktlen,
-					  &rix, &try0, &txrate);
+				if (ic->ic_opmode != IEEE80211_M_MONITOR)
+					ath_rate_findrate(sc, an, shortPreamble, pktlen,
+						&rix, &try0, &txrate);
 			}
 			else {
 				rix = ic->ic_fixed_rate;
@@ -4140,6 +4154,11 @@
 			pri = WME_AC_BE;
 		break;
 	default:
+		if (ic->ic_opmode == IEEE80211_M_MONITOR) {
+			atype = HAL_PKT_TYPE_NORMAL;                /* default */
+			txq = sc->sc_ac2q[skb->priority];
+			break;
+		}
 		if_printf(dev, "bogus frame type 0x%x (%s)\n",
 			wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK, __func__);
 		/* XXX statistic */
@@ -4260,6 +4279,12 @@
 		ieee80211_dump_pkt(skb->data, skb->len,
 			sc->sc_hwmap[txrate].ieeerate, -1);
 
+    /* Let those crazy kids transmit frames in monitor mode */
+	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
+        /* Only transmit one frame, disable retrans */
+        try0 = 1;
+    }
+
 	/* 
 	 * Determine if a tx interrupt should be generated for
 	 * this descriptor.  We take a tx interrupt to reap
@@ -4290,7 +4315,7 @@
 		, pktlen		/* packet length */
 		, hdrlen		/* header length */
 		, atype			/* Atheros packet type */
-		, ni->ni_txpower	/* txpower */
+		, 60			/* txpower */
 		, txrate, try0		/* series 0 rate/tries */
 		, keyix			/* key cache index */
 		, sc->sc_txantenna	/* antenna mode */
@@ -4298,6 +4323,7 @@
 		, ctsrate		/* rts/cts rate */
 		, ctsduration		/* rts/cts duration */
 	);
+
 	/*
 	 * Setup the multi-rate retry state only when we're
 	 * going to use it.  This assumes ath_hal_setuptxdesc
@@ -4305,7 +4331,7 @@
 	 * when the hardware supports multi-rate retry and
 	 * we don't use it.
 	 */
-	if (try0 != ATH_TXMAXTRY)
+	if (try0 != ATH_TXMAXTRY && ic->ic_opmode != IEEE80211_M_MONITOR)
 		ath_rate_setupxtxdesc(sc, an, ds, shortPreamble, rix);
 
 	/*
