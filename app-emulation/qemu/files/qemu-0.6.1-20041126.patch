diff -ruN /qemu-0.6.1/work/qemu-0.6.1/.cvsignore qemu-snapshot-2004-11-26_23/.cvsignore
--- /qemu-0.6.1/work/qemu-0.6.1/.cvsignore	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/.cvsignore	2004-11-15 23:57:26.000000000 +0100
@@ -10,6 +10,8 @@
 qemu-tech.html
 qemu.1
 qemu.pod
+qemu-img.1
+qemu-img.pod
 sparc-user
 qemu-img
 sparc-softmmu
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/Changelog qemu-snapshot-2004-11-26_23/Changelog
--- /qemu-0.6.1/work/qemu-0.6.1/Changelog	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/Changelog	2004-11-24 20:31:21.000000000 +0100
@@ -1,3 +1,9 @@
+version 0.6.2:
+
+  - better BIOS translation and HDD geometry auto-detection
+  - user mode networking bug fix
+  - undocumented FPU ops support
+
 version 0.6.1:
 
   - Mac OS X port (Pierre d'Herbemont)
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/Makefile qemu-snapshot-2004-11-26_23/Makefile
--- /qemu-0.6.1/work/qemu-0.6.1/Makefile	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/Makefile	2004-11-16 02:44:03.000000000 +0100
@@ -10,18 +10,18 @@
 LDFLAGS=-g
 LIBS=
 DEFINES+=-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE
-TOOLS=qemu-img
+TOOLS=qemu-img$(EXESUF)
 ifdef CONFIG_STATIC
 LDFLAGS+=-static
 endif
-DOCS=qemu-doc.html qemu-tech.html qemu.1
+DOCS=qemu-doc.html qemu-tech.html qemu.1 qemu-img.1
 
 all: dyngen$(EXESUF) $(TOOLS) $(DOCS)
 	for d in $(TARGET_DIRS); do \
 	$(MAKE) -C $$d $@ || exit 1 ; \
         done
 
-qemu-img: qemu-img.c block.c block-cow.c block-qcow.c aes.c block-vmdk.c block-cloop.c
+qemu-img$(EXESUF): qemu-img.c block.c block-cow.c block-qcow.c aes.c block-vmdk.c block-cloop.c
 	$(CC) -DQEMU_TOOL $(CFLAGS) $(LDFLAGS) $(DEFINES) -o $@ $^ -lz $(LIBS)
 
 dyngen$(EXESUF): dyngen.c
@@ -30,7 +30,7 @@
 clean:
 # avoid old build problems by removing potentially incorrect old files
 	rm -f config.mak config.h op-i386.h opc-i386.h gen-op-i386.h op-arm.h opc-arm.h gen-op-arm.h 
-	rm -f *.o *.a $(TOOLS) dyngen$(EXESUF) TAGS qemu.pod *~ */*~
+	rm -f *.o *.a $(TOOLS) dyngen$(EXESUF) TAGS *.pod *~ */*~
 	$(MAKE) -C tests clean
 	for d in $(TARGET_DIRS); do \
 	$(MAKE) -C $$d $@ || exit 1 ; \
@@ -44,9 +44,7 @@
 
 install: all 
 	mkdir -p "$(bindir)"
-ifndef CONFIG_WIN32
 	install -m 755 -s $(TOOLS) "$(bindir)"
-endif
 	mkdir -p "$(datadir)"
 	install -m 644 pc-bios/bios.bin pc-bios/vgabios.bin \
                        pc-bios/vgabios-cirrus.bin \
@@ -57,7 +55,7 @@
 	install -m 644 qemu-doc.html  qemu-tech.html "$(docdir)"
 ifndef CONFIG_WIN32
 	mkdir -p "$(mandir)/man1"
-	install qemu.1 qemu-mkcow.1 "$(mandir)/man1"
+	install qemu.1 qemu-img.1 "$(mandir)/man1"
 endif
 	for d in $(TARGET_DIRS); do \
 	$(MAKE) -C $$d $@ || exit 1 ; \
@@ -78,6 +76,10 @@
 	./texi2pod.pl $< qemu.pod
 	pod2man --section=1 --center=" " --release=" " qemu.pod > $@
 
+qemu-img.1: qemu-img.texi
+	./texi2pod.pl $< qemu-img.pod
+	pod2man --section=1 --center=" " --release=" " qemu-img.pod > $@
+
 FILE=qemu-$(shell cat VERSION)
 
 # tar release (use 'make -k tar' on a checkouted tree)
@@ -92,6 +94,7 @@
 	( cd / ; tar zcvf ~/qemu-$(VERSION)-i386.tar.gz \
 	$(bindir)/qemu $(bindir)/qemu-fast \
 	$(bindir)/qemu-system-ppc \
+	$(bindir)/qemu-system-sparc \
 	$(bindir)/qemu-i386 \
         $(bindir)/qemu-arm \
         $(bindir)/qemu-sparc \
@@ -105,7 +108,7 @@
 	$(datadir)/linux_boot.bin \
 	$(docdir)/qemu-doc.html \
 	$(docdir)/qemu-tech.html \
-	$(mandir)/man1/qemu.1 $(mandir)/man1/qemu-mkcow.1 )
+	$(mandir)/man1/qemu.1 $(mandir)/man1/qemu-img.1 )
 
 ifneq ($(wildcard .depend),)
 include .depend
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/VERSION qemu-snapshot-2004-11-26_23/VERSION
--- /qemu-0.6.1/work/qemu-0.6.1/VERSION	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/VERSION	2004-11-24 20:31:52.000000000 +0100
@@ -1 +1 @@
-0.6.1
\ No newline at end of file
+0.6.2
\ No newline at end of file
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/block.c qemu-snapshot-2004-11-26_23/block.c
--- /qemu-0.6.1/work/qemu-0.6.1/block.c	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/block.c	2004-11-16 02:45:27.000000000 +0100
@@ -348,6 +348,11 @@
                       type == BDRV_TYPE_FLOPPY));
 }
 
+void bdrv_set_translation_hint(BlockDriverState *bs, int translation)
+{
+    bs->translation = translation;
+}
+
 void bdrv_get_geometry_hint(BlockDriverState *bs, 
                             int *pcyls, int *pheads, int *psecs)
 {
@@ -361,6 +366,11 @@
     return bs->type;
 }
 
+int bdrv_get_translation_hint(BlockDriverState *bs)
+{
+    return bs->translation;
+}
+
 int bdrv_is_removable(BlockDriverState *bs)
 {
     return bs->removable;
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/block_int.h qemu-snapshot-2004-11-26_23/block_int.h
--- /qemu-0.6.1/work/qemu-0.6.1/block_int.h	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/block_int.h	2004-11-16 02:45:27.000000000 +0100
@@ -68,7 +68,7 @@
     
     /* NOTE: the following infos are only hints for real hardware
        drivers. They are not used by the block driver */
-    int cyls, heads, secs;
+    int cyls, heads, secs, translation;
     int type;
     char device_name[32];
     BlockDriverState *next;
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/hw/cirrus_vga.c qemu-snapshot-2004-11-26_23/hw/cirrus_vga.c
--- /qemu-0.6.1/work/qemu-0.6.1/hw/cirrus_vga.c	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/hw/cirrus_vga.c	2004-11-15 22:43:57.000000000 +0100
@@ -737,7 +737,8 @@
             else
                 s->cirrus_blt_srcpitch = ((w + 7) >> 3);
 	} else {
-	    s->cirrus_blt_srcpitch = s->cirrus_blt_width;
+            /* always align input size to 32 bits */
+	    s->cirrus_blt_srcpitch = (s->cirrus_blt_width + 3) & ~3;
 	}
         s->cirrus_srccounter = s->cirrus_blt_srcpitch * s->cirrus_blt_height;
     }
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/hw/ide.c qemu-snapshot-2004-11-26_23/hw/ide.c
--- /qemu-0.6.1/work/qemu-0.6.1/hw/ide.c	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/hw/ide.c	2004-11-17 23:35:32.000000000 +0100
@@ -1826,37 +1826,45 @@
 	uint32_t nr_sects;		/* nr of sectors in partition */
 } __attribute__((packed));
 
-/* try to guess the IDE geometry from the MSDOS partition table */
-static void ide_guess_geometry(IDEState *s)
+/* try to guess the disk logical geometry from the MSDOS partition table. Return 0 if OK, -1 if could not guess */
+static int guess_disk_lchs(IDEState *s, 
+                           int *pcylinders, int *pheads, int *psectors)
 {
     uint8_t buf[512];
-    int ret, i;
+    int ret, i, heads, sectors, cylinders;
     struct partition *p;
     uint32_t nr_sects;
 
-    if (s->cylinders != 0)
-        return;
     ret = bdrv_read(s->bs, 0, buf, 1);
     if (ret < 0)
-        return;
+        return -1;
     /* test msdos magic */
     if (buf[510] != 0x55 || buf[511] != 0xaa)
-        return;
+        return -1;
     for(i = 0; i < 4; i++) {
         p = ((struct partition *)(buf + 0x1be)) + i;
         nr_sects = le32_to_cpu(p->nr_sects);
         if (nr_sects && p->end_head) {
             /* We make the assumption that the partition terminates on
                a cylinder boundary */
-            s->heads = p->end_head + 1;
-            s->sectors = p->end_sector & 63;
-            s->cylinders = s->nb_sectors / (s->heads * s->sectors);
+            heads = p->end_head + 1;
+            sectors = p->end_sector & 63;
+            if (sectors == 0)
+                continue;
+            cylinders = s->nb_sectors / (heads * sectors);
+            if (cylinders < 1 || cylinders > 16383)
+                continue;
+            *pheads = heads;
+            *psectors = sectors;
+            *pcylinders = cylinders;
 #if 0
-            printf("guessed partition: CHS=%d %d %d\n", 
-                   s->cylinders, s->heads, s->sectors);
+            printf("guessed geometry: LCHS=%d %d %d\n", 
+                   cylinders, heads, sectors);
 #endif
+            return 0;
         }
     }
+    return -1;
 }
 
 static void ide_init2(IDEState *ide_state, int irq,
@@ -1864,7 +1872,7 @@
 {
     IDEState *s;
     static int drive_serial = 1;
-    int i, cylinders, heads, secs;
+    int i, cylinders, heads, secs, translation;
     int64_t nb_sectors;
 
     for(i = 0; i < 2; i++) {
@@ -1883,9 +1891,27 @@
                 s->heads = heads;
                 s->sectors = secs;
             } else {
-                ide_guess_geometry(s);
-                if (s->cylinders == 0) {
-                    /* if no geometry, use a LBA compatible one */
+                if (guess_disk_lchs(s, &cylinders, &heads, &secs) == 0) {
+                    if (heads > 16) {
+                        /* if heads > 16, it means that a BIOS LBA
+                           translation was active, so the default
+                           hardware geometry is OK */
+                        goto default_geometry;
+                    } else {
+                        s->cylinders = cylinders;
+                        s->heads = heads;
+                        s->sectors = secs;
+                        /* disable any translation to be in sync with
+                           the logical geometry */
+                        translation = bdrv_get_translation_hint(s->bs);
+                        if (translation == BIOS_ATA_TRANSLATION_AUTO) {
+                            bdrv_set_translation_hint(s->bs,
+                                                      BIOS_ATA_TRANSLATION_NONE);
+                        }
+                    }
+                } else {
+                default_geometry:
+                    /* if no geometry, use a standard physical disk geometry */
                     cylinders = nb_sectors / (16 * 63);
                     if (cylinders > 16383)
                         cylinders = 16383;
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/hw/pc.c qemu-snapshot-2004-11-26_23/hw/pc.c
--- /qemu-0.6.1/work/qemu-0.6.1/hw/pc.c	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/hw/pc.c	2004-11-16 02:45:27.000000000 +0100
@@ -217,19 +217,23 @@
     val = 0;
     for (i = 0; i < 4; i++) {
         if (hd_table[i]) {
-            int cylinders, heads, sectors;
-            uint8_t translation;
-            /* NOTE: bdrv_get_geometry_hint() returns the geometry
-               that the hard disk returns. It is always such that: 1 <=
-               sects <= 63, 1 <= heads <= 16, 1 <= cylinders <=
-               16383. The BIOS geometry can be different. */
-            bdrv_get_geometry_hint(hd_table[i], &cylinders, &heads, &sectors);
-            if (cylinders <= 1024 && heads <= 16 && sectors <= 63) {
-                /* No translation. */
-                translation = 0;
+            int cylinders, heads, sectors, translation;
+            /* NOTE: bdrv_get_geometry_hint() returns the physical
+                geometry.  It is always such that: 1 <= sects <= 63, 1
+                <= heads <= 16, 1 <= cylinders <= 16383. The BIOS
+                geometry can be different if a translation is done. */
+            translation = bdrv_get_translation_hint(hd_table[i]);
+            if (translation == BIOS_ATA_TRANSLATION_AUTO) {
+                bdrv_get_geometry_hint(hd_table[i], &cylinders, &heads, &sectors);
+                if (cylinders <= 1024 && heads <= 16 && sectors <= 63) {
+                    /* No translation. */
+                    translation = 0;
+                } else {
+                    /* LBA translation. */
+                    translation = 1;
+                }
             } else {
-                /* LBA translation. */
-                translation = 1;
+                translation--;
             }
             val |= translation << (i * 2);
         }
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/qemu-doc.texi qemu-snapshot-2004-11-26_23/qemu-doc.texi
--- /qemu-0.6.1/work/qemu-0.6.1/qemu-doc.texi	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/qemu-doc.texi	2004-11-16 02:45:27.000000000 +0100
@@ -343,6 +343,12 @@
 Do not start CPU at startup (you must type 'c' in the monitor).
 @item -d             
 Output log in /tmp/qemu.log
+@item -hdachs c,h,s,[,t]
+Force hard disk 0 physical geometry (1 <= @var{c} <= 16383, 1 <=
+@var{h} <= 16, 1 <= @var{s} <= 63) and optionally force the BIOS
+translation mode (@var{t}=none, lba or auto). Usually QEMU can guess
+all thoses parameters. This option is useful for old MS-DOS disk
+images.
 @item -isa
 Simulate an ISA-only system (default is PCI system).
 @item -std-vga
@@ -584,81 +590,34 @@
 @node disk_images
 @section Disk Images
 
-@subsection Raw disk images
+Since version 0.6.1, QEMU supports many disk image formats, including
+growable disk images (their size increase as non empty sectors are
+written), compressed and encrypted disk images.
 
-The disk images can simply be raw images of the hard disk. You can
-create them with the command:
+@subsection Quick start for disk image creation
+
+You can create a disk image with the command:
 @example
-dd of=myimage bs=1024 seek=mysize count=0
+qemu-img create myimage.img mysize
 @end example
-where @var{myimage} is the image filename and @var{mysize} is its size
-in kilobytes.
+where @var{myimage.img} is the disk image filename and @var{mysize} is its
+size in kilobytes. You can add an @code{M} suffix to give the size in
+megabytes and a @code{G} suffix for gigabytes.
+
+@xref{qemu_img_invocation} for more information.
 
 @subsection Snapshot mode
 
 If you use the option @option{-snapshot}, all disk images are
 considered as read only. When sectors in written, they are written in
 a temporary file created in @file{/tmp}. You can however force the
-write back to the raw disk images by pressing @key{C-a s}.
-
-NOTE: The snapshot mode only works with raw disk images.
-
-@subsection Copy On Write disk images
-
-QEMU also supports user mode Linux
-(@url{http://user-mode-linux.sourceforge.net/}) Copy On Write (COW)
-disk images. The COW disk images are much smaller than normal images
-as they store only modified sectors. They also permit the use of the
-same disk image template for many users.
-
-To create a COW disk images, use the command:
-
-@example
-qemu-mkcow -f myrawimage.bin mycowimage.cow
-@end example
-
-@file{myrawimage.bin} is a raw image you want to use as original disk
-image. It will never be written to.
-
-@file{mycowimage.cow} is the COW disk image which is created by
-@code{qemu-mkcow}. You can use it directly with the @option{-hdx}
-options. You must not modify the original raw disk image if you use
-COW images, as COW images only store the modified sectors from the raw
-disk image. QEMU stores the original raw disk image name and its
-modified time in the COW disk image so that chances of mistakes are
-reduced.
-
-If the raw disk image is not read-only, by pressing @key{C-a s} you
-can flush the COW disk image back into the raw disk image, as in
-snapshot mode.
+write back to the raw disk images by using the @code{commit} monitor
+command (or @key{C-a s} in the serial console).
 
-COW disk images can also be created without a corresponding raw disk
-image. It is useful to have a big initial virtual disk image without
-using much disk space. Use:
+@node qemu_img_invocation
+@subsection @code{qemu-img} Invocation
 
-@example
-qemu-mkcow mycowimage.cow 1024
-@end example
-
-to create a 1 gigabyte empty COW disk image.
-
-NOTES: 
-@enumerate
-@item
-COW disk images must be created on file systems supporting
-@emph{holes} such as ext2 or ext3.
-@item 
-Since holes are used, the displayed size of the COW disk image is not
-the real one. To know it, use the @code{ls -ls} command.
-@end enumerate
-
-@subsection Convert VMware disk images to raw disk images
-
-You can use the tool @file{vmdk2raw} to convert VMware disk images to
-raw disk images directly usable by QEMU. The syntax is:
-@example
-vmdk2raw vmware_image output_image
-@end example
+@include qemu-img.texi
 
 @section Network emulation
 
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/qemu-img.texi qemu-snapshot-2004-11-26_23/qemu-img.texi
--- /qemu-0.6.1/work/qemu-0.6.1/qemu-img.texi	1970-01-01 01:00:00.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/qemu-img.texi	2004-11-15 23:57:26.000000000 +0100
@@ -0,0 +1,127 @@
+@example
+@c man begin SYNOPSIS
+usage: qemu-img command [command options]
+@c man end
+@end example
+
+@c man begin OPTIONS
+
+The following commands are supported:
+@table @option
+@item create [-e] [-b @var{base_image}] [-f @var{fmt}] @var{filename} [@var{size}]
+@item commit [-f @var{fmt}] @var{filename}
+@item convert [-c] [-e] [-f @var{fmt}] @var{filename} [-O @var{output_fmt}] @var{output_filename}
+@item info [-f @var{fmt}] @var{filename}
+@end table
+
+Command parameters:
+@table @var
+@item filename
+ is a disk image filename
+@item base_image 
+is the read-only disk image which is used as base for a copy on
+    write image; the copy on write image only stores the modified data
+
+@item fmt 
+is the disk image format. It is guessed automatically in most cases. The following formats are supported:
+
+@table @code
+@item raw
+
+Raw disk image format (default). This format has the advantage of
+being simple and easily exportable to all other emulators. If your file
+system supports @emph{holes} (for example in ext2 or ext3 on Linux),
+then only the written sectors will reserve space. Use @code{qemu-img
+info} to know the real size used by the image or @code{ls -ls} on
+Unix/Linux.
+
+@item qcow
+QEMU image format, the most versatile format. Use it to have smaller
+images (useful if your filesystem does not supports holes, for example
+on Windows), optional AES encryption and zlib based compression.
+@item cow
+User Mode Linux Copy On Write image format. Used to be the only growable
+image format in QEMU. It is supported only for compatibility with
+previous versions. It does not work on win32.
+@item vmdk
+VMware 3 and 4 compatible image format. Currently only supported as
+read-only.
+@item cloop
+Linux Compressed Loop image, useful only to reuse directly compressed
+CD-ROM images present for example in the Knoppix CD-ROMs.
+@end table
+
+@item size 
+is the disk image size in kilobytes. Optional suffixes @code{M}
+(megabyte) and @code{G} (gigabyte) are supported 
+
+@item output_filename
+is the destination disk image filename 
+
+@item output_fmt
+ is the destination format
+
+@item -c
+indicates that target image must be compressed (qcow format only)
+@item -e 
+indicates that the target image must be encrypted (qcow format only)
+@end table
+
+Command description:
+
+@table @option
+@item create [-e] [-b @var{base_image}] [-f @var{fmt}] @var{filename} [@var{size}]
+
+Create the new disk image @var{filename} of size @var{size} and format
+@var{fmt}. 
+
+If @var{base_image} is specified, then the image will record only the
+differences from @var{base_image}. No size needs to be specified in
+this case. @var{base_image} will never be modified unless you use the
+@code{commit} monitor command.
+
+@item commit [-f @var{fmt}] @var{filename}
+
+Commit the changes recorded in @var{filename} in its base image.
+
+@item convert [-c] [-e] [-f @var{fmt}] @var{filename} [-O @var{output_fmt}] @var{output_filename}
+
+Convert the disk image @var{filename} to disk image @var{output_filename}
+using format @var{output_fmt}. It can be optionnaly encrypted
+(@code{-e} option) or compressed (@code{-c} option).
+
+Only the format @code{qcow} supports encryption or compression. The
+compression is read-only. It means that if a compressed sector is
+rewritten, then it is rewritten as uncompressed data.
+
+Encryption uses the AES format which is very secure (128 bit keys). Use
+a long password (16 characters) to get maximum protection.
+
+Image conversion is also useful to get smaller image when using a
+growable format such as @code{qcow} or @code{cow}: the empty sectors
+are detected and suppressed from the destination image.
+
+@item info [-f @var{fmt}] @var{filename}
+
+Give information about the disk image @var{filename}. Use it in
+particular to know the size reserved on disk which can be different
+from the displayed size.
+@end table
+
+@c man end
+
+@ignore
+
+@setfilename qemu-img
+@settitle QEMU disk image utility
+
+@c man begin SEEALSO
+The HTML documentation of QEMU for more precise information and Linux
+user mode emulator invocation.
+@c man end
+
+@c man begin AUTHOR
+Fabrice Bellard
+@c man end
+
+@end ignore
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/qemu-mkcow.1 qemu-snapshot-2004-11-26_23/qemu-mkcow.1
--- /qemu-0.6.1/work/qemu-0.6.1/qemu-mkcow.1	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/qemu-mkcow.1	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-.\" $Header: /var/cvsroot/gentoo-x86/app-emulation/qemu/files/qemu-0.6.1-20041126.patch,v 1.1 2004/11/28 01:23:22 lu_zero Exp $
-.\"
-.\"	transcript compatibility for postscript use.
-.\"
-.\"	synopsis:  .P! <file.ps>
-.\"
-.de P!
-.fl
-\!!1 setgray
-.fl
-\\&.\"
-.fl
-\!!0 setgray
-.fl			\" force out current output buffer
-\!!save /psv exch def currentpoint translate 0 0 moveto
-\!!/showpage{}def
-.fl			\" prolog
-.sy sed -e 's/^/!/' \\$1\" bring in postscript file
-\!!psv restore
-.
-.de pF
-.ie     \\*(f1 .ds f1 \\n(.f
-.el .ie \\*(f2 .ds f2 \\n(.f
-.el .ie \\*(f3 .ds f3 \\n(.f
-.el .ie \\*(f4 .ds f4 \\n(.f
-.el .tm ? font overflow
-.ft \\$1
-..
-.de fP
-.ie     !\\*(f4 \{\
-.	ft \\*(f4
-.	ds f4\"
-'	br \}
-.el .ie !\\*(f3 \{\
-.	ft \\*(f3
-.	ds f3\"
-'	br \}
-.el .ie !\\*(f2 \{\
-.	ft \\*(f2
-.	ds f2\"
-'	br \}
-.el .ie !\\*(f1 \{\
-.	ft \\*(f1
-.	ds f1\"
-'	br \}
-.el .tm ? font underflow
-..
-.ds f1\"
-.ds f2\"
-.ds f3\"
-.ds f4\"
-'\" t 
-.ta 8n 16n 24n 32n 40n 48n 56n 64n 72n  
-.TH "QEMU" "8" 
-.SH "NAME" 
-qemu-mkcow \(em create a copy-on-write file for qemu 
-.SH "SYNOPSIS" 
-.PP 
-\fBqemu-mkcow\fR [\fB-h\fP]  [\fB-f \fImaster_disk_image\fR\fP]  [\fIcow_image\fR]  [\fB\fIcow_size\fR\fP]  
-.SH "DESCRIPTION" 
-.PP 
-The \fBqemu-mkcow\fR command creates a 
-persistent copy-on-write file for \fBqemu\fR. 
- 
-.PP 
-\fBqemu\fR can be used in a "copy-on-write" mode, 
-where changes made by \fBqemu\fR do not actually 
-change the disk image file.  One way is to invoke 
-\fBqemu\fR with -snapshot: these changes 
-are stored in a temporary file, which is discarded when  
-\fBqemu\fR exits. 
- 
-.PP 
-\fBqemu-mkcow\fR creates an explicit copy-on-write 
-file where changes are to be stored: this way, changes made 
-inside \fBqemu\fR will still be there next time you 
-run it, although the master disk image isn't ever changed. 
- 
-.PP 
-The usual method is to create the master image, then create a 
-copy-on-write file using \fBqemu-mkcow\fR with 
-\fB-f\fP.  The filename of the master image is stored 
-inside the generated copy-on-write file: it must not be modified 
-after this is run! 
- 
-.PP 
-If no master file is specified, the effect is that of a 
-blank master of size \fIcow_size\fR. 
- 
-.SH "SEE ALSO" 
-.PP 
-qemu(1), qemu-fast(1). 
-.SH "AUTHOR" 
-.PP 
-This manual page was written by Paul Russell prussell@debian.org for 
-the \fBDebian\fP system (but may be used by others).  Permission is 
-granted to copy, distribute and/or modify this document under 
-the terms of the GNU General Public License, Version 2 any  
-later version published by the Free Software Foundation. 
- 
-.PP 
-On Debian systems, the complete text of the GNU General Public 
-License can be found in /usr/share/common-licenses/GPL. 
- 
-.\" created by instant / docbook-to-man, Fri 12 Mar 2004, 05:58 
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/qemu.1 qemu-snapshot-2004-11-26_23/qemu.1
--- /qemu-0.6.1/work/qemu-0.6.1/qemu.1	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/qemu.1	1970-01-01 01:00:00.000000000 +0100
@@ -1,457 +0,0 @@
-.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
-.\"
-.\" Standard preamble:
-.\" ========================================================================
-.de Sh \" Subsection heading
-.br
-.if t .Sp
-.ne 5
-.PP
-\fB\\$1\fR
-.PP
-..
-.de Sp \" Vertical space (when we can't use .PP)
-.if t .sp .5v
-.if n .sp
-..
-.de Vb \" Begin verbatim text
-.ft CW
-.nf
-.ne \\$1
-..
-.de Ve \" End verbatim text
-.ft R
-.fi
-..
-.\" Set up some character translations and predefined strings.  \*(-- will
-.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
-.\" double quote, and \*(R" will give a right double quote.  | will give a
-.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
-.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
-.\" expand to `' in nroff, nothing in troff, for use with C<>.
-.tr \(*W-|\(bv\*(Tr
-.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
-.ie n \{\
-.    ds -- \(*W-
-.    ds PI pi
-.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
-.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
-.    ds L" ""
-.    ds R" ""
-.    ds C` ""
-.    ds C' ""
-'br\}
-.el\{\
-.    ds -- \|\(em\|
-.    ds PI \(*p
-.    ds L" ``
-.    ds R" ''
-'br\}
-.\"
-.\" If the F register is turned on, we'll generate index entries on stderr for
-.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
-.\" entries marked with X<> in POD.  Of course, you'll have to process the
-.\" output yourself in some meaningful fashion.
-.if \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
-..
-.    nr % 0
-.    rr F
-.\}
-.\"
-.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
-.\" way too many mistakes in technical documents.
-.hy 0
-.if n .na
-.\"
-.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
-.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
-.    \" fudge factors for nroff and troff
-.if n \{\
-.    ds #H 0
-.    ds #V .8m
-.    ds #F .3m
-.    ds #[ \f1
-.    ds #] \fP
-.\}
-.if t \{\
-.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
-.    ds #V .6m
-.    ds #F 0
-.    ds #[ \&
-.    ds #] \&
-.\}
-.    \" simple accents for nroff and troff
-.if n \{\
-.    ds ' \&
-.    ds ` \&
-.    ds ^ \&
-.    ds , \&
-.    ds ~ ~
-.    ds /
-.\}
-.if t \{\
-.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
-.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
-.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
-.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
-.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
-.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
-.\}
-.    \" troff and (daisy-wheel) nroff accents
-.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
-.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
-.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
-.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
-.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
-.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
-.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
-.ds ae a\h'-(\w'a'u*4/10)'e
-.ds Ae A\h'-(\w'A'u*4/10)'E
-.    \" corrections for vroff
-.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
-.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
-.    \" for low resolution devices (crt and lpr)
-.if \n(.H>23 .if \n(.V>19 \
-\{\
-.    ds : e
-.    ds 8 ss
-.    ds o a
-.    ds d- d\h'-1'\(ga
-.    ds D- D\h'-1'\(hy
-.    ds th \o'bp'
-.    ds Th \o'LP'
-.    ds ae ae
-.    ds Ae AE
-.\}
-.rm #[ #] #H #V #F C
-.\" ========================================================================
-.\"
-.IX Title "QEMU 1"
-.TH QEMU 1 "2004-11-14" " " " "
-.SH "NAME"
-qemu  \- QEMU System Emulator
-.SH "SYNOPSIS"
-.IX Header "SYNOPSIS"
-usage: qemu [options] [disk_image]
-.SH "DESCRIPTION"
-.IX Header "DESCRIPTION"
-The \s-1QEMU\s0 System emulator simulates a complete \s-1PC\s0.
-.PP
-In order to meet specific user needs, two versions of \s-1QEMU\s0 are
-available:
-.IP "1." 4
-\&\f(CW\*(C`qemu\-fast\*(C'\fR uses the host Memory Management Unit (\s-1MMU\s0) to
-simulate the x86 \s-1MMU\s0. It is \fIfast\fR but has limitations because
-the whole 4 \s-1GB\s0 address space cannot be used and some memory mapped
-peripherials cannot be emulated accurately yet. Therefore, a specific
-guest Linux kernel can be used  
-.Sp
-Moreover there is no separation between the host and target address
-spaces, so it offers no security (the target \s-1OS\s0 can modify the
-\&\f(CW\*(C`qemu\-fast\*(C'\fR code by writing at the right addresses).
-.IP "2." 4
-\&\f(CW\*(C`qemu\*(C'\fR uses a software \s-1MMU\s0. It is about \fItwo times slower\fR
-but gives a more accurate emulation and a complete separation between
-the host and target address spaces.
-.PP
-\&\s-1QEMU\s0 emulates the following \s-1PC\s0 peripherials:
-.IP "\-" 4
-i440FX host \s-1PCI\s0 bridge and \s-1PIIX3\s0 \s-1PCI\s0 to \s-1ISA\s0 bridge
-.IP "\-" 4
-Cirrus \s-1CLGD\s0 5446 \s-1PCI\s0 \s-1VGA\s0 card or dummy \s-1VGA\s0 card with Bochs \s-1VESA\s0
-extensions (hardware level, including all non standard modes).
-.IP "\-" 4
-\&\s-1PS/2\s0 mouse and keyboard
-.IP "\-" 4
-2 \s-1PCI\s0 \s-1IDE\s0 interfaces with hard disk and CD-ROM support
-.IP "\-" 4
-Floppy disk
-.IP "\-" 4
-\&\s-1NE2000\s0 \s-1PCI\s0 network adapters
-.IP "\-" 4
-Serial ports
-.IP "\-" 4
-Soundblaster 16 card
-.PP
-\&\s-1QEMU\s0 uses the \s-1PC\s0 \s-1BIOS\s0 from the Bochs project and the Plex86/Bochs \s-1LGPL\s0
-\&\s-1VGA\s0 \s-1BIOS\s0.
-.SH "OPTIONS"
-.IX Header "OPTIONS"
-\&\fIdisk_image\fR is a raw hard disk image for \s-1IDE\s0 hard disk 0.
-.PP
-General options:
-.IP "\fB\-fda file\fR" 4
-.IX Item "-fda file"
-.PD 0
-.IP "\fB\-fdb file\fR" 4
-.IX Item "-fdb file"
-.PD
-Use \fIfile\fR as floppy disk 0/1 image  You can
-use the host floppy by using \fI/dev/fd0\fR as filename.
-.IP "\fB\-hda file\fR" 4
-.IX Item "-hda file"
-.PD 0
-.IP "\fB\-hdb file\fR" 4
-.IX Item "-hdb file"
-.IP "\fB\-hdc file\fR" 4
-.IX Item "-hdc file"
-.IP "\fB\-hdd file\fR" 4
-.IX Item "-hdd file"
-.PD
-Use \fIfile\fR as hard disk 0, 1, 2 or 3 image 
-.IP "\fB\-cdrom file\fR" 4
-.IX Item "-cdrom file"
-Use \fIfile\fR as CD-ROM image (you cannot use \fB\-hdc\fR and and
-\&\fB\-cdrom\fR at the same time). You can use the host CD-ROM by
-using \fI/dev/cdrom\fR as filename.
-.IP "\fB\-boot [a|c|d]\fR" 4
-.IX Item "-boot [a|c|d]"
-Boot on floppy (a), hard disk (c) or CD-ROM (d). Hard disk boot is
-the default.
-.IP "\fB\-snapshot\fR" 4
-.IX Item "-snapshot"
-Write to temporary files instead of disk image files. In this case,
-the raw disk image you use is not written back. You can however force
-the write back by pressing \fBC\-a s\fR  
-.IP "\fB\-m megs\fR" 4
-.IX Item "-m megs"
-Set virtual \s-1RAM\s0 size to \fImegs\fR megabytes. Default is 128 \s-1MB\s0.
-.IP "\fB\-nographic\fR" 4
-.IX Item "-nographic"
-Normally, \s-1QEMU\s0 uses \s-1SDL\s0 to display the \s-1VGA\s0 output. With this option,
-you can totally disable graphical output so that \s-1QEMU\s0 is a simple
-command line application. The emulated serial port is redirected on
-the console. Therefore, you can still use \s-1QEMU\s0 to debug a Linux kernel
-with a serial console.
-.IP "\fB\-enable\-audio\fR" 4
-.IX Item "-enable-audio"
-The \s-1SB16\s0 emulation is disabled by default as it may give problems with
-Windows. You can enable it manually with this option.
-.IP "\fB\-localtime\fR" 4
-.IX Item "-localtime"
-Set the real time clock to local time (the default is to \s-1UTC\s0
-time). This option is needed to have correct date in MS-DOS or
-Windows.
-.IP "\fB\-full\-screen\fR" 4
-.IX Item "-full-screen"
-Start in full screen.
-.PP
-Network options:
-.IP "\fB\-n script\fR" 4
-.IX Item "-n script"
-Set \s-1TUN/TAP\s0 network init script [default=/etc/qemu\-ifup]. This script
-is launched to configure the host network interface (usually tun0)
-corresponding to the virtual \s-1NE2000\s0 card.
-.IP "\fB\-macaddr addr\fR" 4
-.IX Item "-macaddr addr"
-Set the mac address of the first interface (the format is
-aa:bb:cc:dd:ee:ff in hexa). The mac address is incremented for each
-new network interface.
-.IP "\fB\-tun\-fd fd\fR" 4
-.IX Item "-tun-fd fd"
-Assumes \fIfd\fR talks to a tap/tun host network interface and use
-it. Read <\fBhttp://bellard.org/qemu/tetrinet.html\fR> to have an
-example of its use.
-.IP "\fB\-user\-net\fR" 4
-.IX Item "-user-net"
-Use the user mode network stack. This is the default if no tun/tap
-network init script is found.
-.IP "\fB\-tftp prefix\fR" 4
-.IX Item "-tftp prefix"
-When using the user mode network stack, activate a built-in \s-1TFTP\s0
-server. All filenames beginning with \fIprefix\fR can be downloaded
-from the host to the guest using a \s-1TFTP\s0 client. The \s-1TFTP\s0 client on the
-guest must be configured in binary mode (use the command \f(CW\*(C`bin\*(C'\fR of
-the Unix \s-1TFTP\s0 client). The host \s-1IP\s0 address on the guest is as usual
-10.0.2.2.
-.IP "\fB\-smb dir\fR" 4
-.IX Item "-smb dir"
-When using the user mode network stack, activate a built-in \s-1SMB\s0
-server so that Windows OSes can access to the host files in \fIdir\fR
-transparently.
-.Sp
-In the guest Windows \s-1OS\s0, the line:
-.Sp
-.Vb 1
-\&        10.0.2.4 smbserver
-.Ve
-.Sp
-must be added in the file \fIC:\eWINDOWS\eLMHOSTS\fR (for windows 9x/Me)
-or \fIC:\eWINNT\eSYSTEM32\eDRIVERS\eETC\eLMHOSTS\fR (Windows \s-1NT/2000\s0).
-.Sp
-Then \fIdir\fR can be accessed in \fI\e\esmbserver\eqemu\fR.
-.Sp
-Note that a \s-1SAMBA\s0 server must be installed on the host \s-1OS\s0 in
-\&\fI/usr/sbin/smbd\fR. \s-1QEMU\s0 was tested succesfully with smbd version
-2.2.7a from the Red Hat 9.
-.IP "\fB\-redir [tcp|udp]:host\-port:[guest\-host]:guest\-port\fR" 4
-.IX Item "-redir [tcp|udp]:host-port:[guest-host]:guest-port"
-When using the user mode network stack, redirect incoming \s-1TCP\s0 or \s-1UDP\s0
-connections to the host port \fIhost-port\fR to the guest
-\&\fIguest-host\fR on guest port \fIguest-port\fR. If \fIguest-host\fR
-is not specified, its value is 10.0.2.15 (default address given by the
-built-in \s-1DHCP\s0 server).
-.Sp
-For example, to redirect host X11 connection from screen 1 to guest
-screen 0, use the following:
-.Sp
-.Vb 4
-\&        # on the host
-\&        qemu -redir tcp:6001::6000 [...]
-\&        # this host xterm should open in the guest X11 server
-\&        xterm -display :1
-.Ve
-.Sp
-To redirect telnet connections from host port 5555 to telnet port on
-the guest, use the following:
-.Sp
-.Vb 3
-\&        # on the host
-\&        qemu -redir tcp:5555::23 [...]
-\&        telnet localhost 5555
-.Ve
-.Sp
-Then when you use on the host \f(CW\*(C`telnet localhost 5555\*(C'\fR, you
-connect to the guest telnet server.
-.IP "\fB\-dummy\-net\fR" 4
-.IX Item "-dummy-net"
-Use the dummy network stack: no packet will be received by the network
-cards.
-.PP
-Linux boot specific. When using this options, you can use a given
-Linux kernel without installing it in the disk image. It can be useful
-for easier testing of various kernels.
-.IP "\fB\-kernel bzImage\fR" 4
-.IX Item "-kernel bzImage"
-Use \fIbzImage\fR as kernel image.
-.IP "\fB\-append cmdline\fR" 4
-.IX Item "-append cmdline"
-Use \fIcmdline\fR as kernel command line
-.IP "\fB\-initrd file\fR" 4
-.IX Item "-initrd file"
-Use \fIfile\fR as initial ram disk.
-.PP
-Debug/Expert options:
-.IP "\fB\-serial dev\fR" 4
-.IX Item "-serial dev"
-Redirect the virtual serial port to host device \fIdev\fR. Available
-devices are:
-.RS 4
-.ie n .IP """vc""" 4
-.el .IP "\f(CWvc\fR" 4
-.IX Item "vc"
-Virtual console
-.ie n .IP """pty""" 4
-.el .IP "\f(CWpty\fR" 4
-.IX Item "pty"
-[Linux only] Pseudo \s-1TTY\s0 (a new \s-1PTY\s0 is automatically allocated)
-.ie n .IP """null""" 4
-.el .IP "\f(CWnull\fR" 4
-.IX Item "null"
-void device
-.ie n .IP """stdio""" 4
-.el .IP "\f(CWstdio\fR" 4
-.IX Item "stdio"
-[Unix only] standard input/output
-.RE
-.RS 4
-.Sp
-The default device is \f(CW\*(C`vc\*(C'\fR in graphical mode and \f(CW\*(C`stdio\*(C'\fR in
-non graphical mode.
-.Sp
-This option can be used several times to simulate up to 4 serials
-ports.
-.RE
-.IP "\fB\-monitor dev\fR" 4
-.IX Item "-monitor dev"
-Redirect the monitor to host device \fIdev\fR (same devices as the
-serial port).
-The default device is \f(CW\*(C`vc\*(C'\fR in graphical mode and \f(CW\*(C`stdio\*(C'\fR in
-non graphical mode.
-.IP "\fB\-s\fR" 4
-.IX Item "-s"
-Wait gdb connection to port 1234  
-.IP "\fB\-p port\fR" 4
-.IX Item "-p port"
-Change gdb connection port.
-.IP "\fB\-S\fR" 4
-.IX Item "-S"
-Do not start \s-1CPU\s0 at startup (you must type 'c' in the monitor).
-.IP "\fB\-d\fR" 4
-.IX Item "-d"
-Output log in /tmp/qemu.log
-.IP "\fB\-isa\fR" 4
-.IX Item "-isa"
-Simulate an ISA-only system (default is \s-1PCI\s0 system).
-.IP "\fB\-std\-vga\fR" 4
-.IX Item "-std-vga"
-Simulate a standard \s-1VGA\s0 card with Bochs \s-1VBE\s0 extensions (default is
-Cirrus Logic \s-1GD5446\s0 \s-1PCI\s0 \s-1VGA\s0)
-.IP "\fB\-loadvm file\fR" 4
-.IX Item "-loadvm file"
-Start right away with a saved state (\f(CW\*(C`loadvm\*(C'\fR in monitor)
-.PP
-During the graphical emulation, you can use the following keys:
-.IP "\fBCtrl-Alt-f\fR" 4
-.IX Item "Ctrl-Alt-f"
-Toggle full screen
-.IP "\fBCtrl-Alt-n\fR" 4
-.IX Item "Ctrl-Alt-n"
-Switch to virtual console 'n'. Standard console mappings are:
-.RS 4
-.IP "\fI1\fR" 4
-.IX Item "1"
-Target system display
-.IP "\fI2\fR" 4
-.IX Item "2"
-Monitor
-.IP "\fI3\fR" 4
-.IX Item "3"
-Serial port
-.RE
-.RS 4
-.RE
-.IP "\fBCtrl-Alt\fR" 4
-.IX Item "Ctrl-Alt"
-Toggle mouse and keyboard grab.
-.PP
-In the virtual consoles, you can use \fBCtrl-Up\fR, \fBCtrl-Down\fR,
-\&\fBCtrl-PageUp\fR and \fBCtrl-PageDown\fR to move in the back log.
-.PP
-During emulation, if you are using the \fB\-nographic\fR option, use
-\&\fBCtrl-a h\fR to get terminal commands:
-.IP "\fBCtrl-a h\fR" 4
-.IX Item "Ctrl-a h"
-Print this help
-.IP "\fBCtrl-a x\fR" 4
-.IX Item "Ctrl-a x"
-Exit emulatior
-.IP "\fBCtrl-a s\fR" 4
-.IX Item "Ctrl-a s"
-Save disk data back to file (if \-snapshot)
-.IP "\fBCtrl-a b\fR" 4
-.IX Item "Ctrl-a b"
-Send break (magic sysrq in Linux)
-.IP "\fBCtrl-a c\fR" 4
-.IX Item "Ctrl-a c"
-Switch between console and monitor
-.IP "\fBCtrl-a Ctrl-a\fR" 4
-.IX Item "Ctrl-a Ctrl-a"
-Send Ctrl-a
-.PP
-The following options are specific to the PowerPC emulation:
-.IP "\fB\-prep\fR" 4
-.IX Item "-prep"
-Simulate a \s-1PREP\s0 system (default is PowerMAC)
-.IP "\fB\-g WxH[xDEPTH]\fR" 4
-.IX Item "-g WxH[xDEPTH]"
-Set the initial \s-1VGA\s0 graphic mode. The default is 800x600x15.
-.SH "SEE ALSO"
-.IX Header "SEE ALSO"
-The \s-1HTML\s0 documentation of \s-1QEMU\s0 for more precise information and Linux
-user mode emulator invocation.
-.SH "AUTHOR"
-.IX Header "AUTHOR"
-Fabrice Bellard
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/slirp/socket.c qemu-snapshot-2004-11-26_23/slirp/socket.c
--- /qemu-0.6.1/work/qemu-0.6.1/slirp/socket.c	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/slirp/socket.c	2004-11-24 21:39:26.000000000 +0100
@@ -175,8 +175,12 @@
 	 * a close will be detected on next iteration.
 	 * A return of -1 wont (shouldn't) happen, since it didn't happen above
 	 */
-	if (n == 2 && nn == iov[0].iov_len)
-	   nn += recv(so->s, iov[1].iov_base, iov[1].iov_len,0);
+	if (n == 2 && nn == iov[0].iov_len) {
+            int ret;
+            ret = recv(so->s, iov[1].iov_base, iov[1].iov_len,0);
+            if (ret > 0)
+                nn += ret;
+        }
 	
 	DEBUG_MISC((dfd, " ... read nn = %d bytes\n", nn));
 #endif
@@ -348,8 +352,12 @@
 	}
 	
 #ifndef HAVE_READV
-	if (n == 2 && nn == iov[0].iov_len)
-	   nn += send(so->s, iov[1].iov_base, iov[1].iov_len,0);
+	if (n == 2 && nn == iov[0].iov_len) {
+            int ret;
+            ret = send(so->s, iov[1].iov_base, iov[1].iov_len,0);
+            if (ret > 0)
+                nn += ret;
+        }
         DEBUG_MISC((dfd, "  ... wrote nn = %d bytes\n", nn));
 #endif
 	
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/target-i386/translate.c qemu-snapshot-2004-11-26_23/target-i386/translate.c
--- /qemu-0.6.1/work/qemu-0.6.1/target-i386/translate.c	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/target-i386/translate.c	2004-11-24 20:28:52.000000000 +0100
@@ -2958,6 +2958,8 @@
                 gen_op_fmov_ST0_STN((opreg + 1) & 7);
                 break;
             case 0x09: /* fxchg sti */
+            case 0x29: /* fxchg4 sti, undocumented op */
+            case 0x39: /* fxchg7 sti, undocumented op */
                 gen_op_fxchg_ST0_STN(opreg);
                 break;
             case 0x0a: /* grp d9/2 */
@@ -3104,10 +3106,13 @@
                 }
                 break;
             case 0x02: /* fcom */
+            case 0x22: /* fcom2, undocumented op */
                 gen_op_fmov_FT0_STN(opreg);
                 gen_op_fcom_ST0_FT0();
                 break;
             case 0x03: /* fcomp */
+            case 0x23: /* fcomp3, undocumented op */
+            case 0x32: /* fcomp5, undocumented op */
                 gen_op_fmov_FT0_STN(opreg);
                 gen_op_fcom_ST0_FT0();
                 gen_op_fpop();
@@ -3163,6 +3168,9 @@
                 gen_op_fmov_STN_ST0(opreg);
                 break;
             case 0x2b: /* fstp sti */
+            case 0x0b: /* fstp1 sti, undocumented op */
+            case 0x3a: /* fstp8 sti, undocumented op */
+            case 0x3b: /* fstp9 sti, undocumented op */
                 gen_op_fmov_STN_ST0(opreg);
                 gen_op_fpop();
                 break;
@@ -3187,6 +3195,10 @@
                     goto illegal_op;
                 }
                 break;
+            case 0x38: /* ffreep sti, undocumented op */
+                gen_op_ffree_STN(opreg);
+                gen_op_fpop();
+                break;
             case 0x3c: /* df/4 */
                 switch(rm) {
                 case 0:
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/vl.c qemu-snapshot-2004-11-26_23/vl.c
--- /qemu-0.6.1/work/qemu-0.6.1/vl.c	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/vl.c	2004-11-16 02:45:27.000000000 +0100
@@ -2537,7 +2537,8 @@
            "-s              wait gdb connection to port %d\n"
            "-p port         change gdb connection port\n"
            "-d item1,...    output log to %s (use -d ? for a list of log items)\n"
-           "-hdachs c,h,s   force hard disk 0 geometry (usually qemu can guess it)\n"
+           "-hdachs c,h,s[,t]  force hard disk 0 physical geometry and the optional BIOS\n"
+           "                translation (t=none or lba) (usually qemu can guess them)\n"
            "-L path         set the directory for the BIOS and VGA BIOS\n"
 #ifdef USE_CODE_COPY
            "-no-code-copy   disable code copy acceleration\n"
@@ -2753,7 +2754,7 @@
     const char *hd_filename[MAX_DISKS], *fd_filename[MAX_FD];
     const char *kernel_filename, *kernel_cmdline;
     DisplayState *ds = &display_state;
-    int cyls, heads, secs;
+    int cyls, heads, secs, translation;
     int start_emulation = 1;
     uint8_t macaddr[6];
     int net_if_type, nb_tun_fds, tun_fds[MAX_NICS];
@@ -2788,6 +2789,7 @@
     kernel_cmdline = "";
     has_cdrom = 1;
     cyls = heads = secs = 0;
+    translation = BIOS_ATA_TRANSLATION_AUTO;
     pstrcpy(monitor_device, sizeof(monitor_device), "vc");
 
     pstrcpy(serial_devices[0], sizeof(serial_devices[0]), "vc");
@@ -2857,17 +2859,34 @@
                     const char *p;
                     p = optarg;
                     cyls = strtol(p, (char **)&p, 0);
+                    if (cyls < 1 || cyls > 16383)
+                        goto chs_fail;
                     if (*p != ',')
                         goto chs_fail;
                     p++;
                     heads = strtol(p, (char **)&p, 0);
+                    if (heads < 1 || heads > 16)
+                        goto chs_fail;
                     if (*p != ',')
                         goto chs_fail;
                     p++;
                     secs = strtol(p, (char **)&p, 0);
-                    if (*p != '\0') {
+                    if (secs < 1 || secs > 63)
+                        goto chs_fail;
+                    if (*p == ',') {
+                        p++;
+                        if (!strcmp(p, "none"))
+                            translation = BIOS_ATA_TRANSLATION_NONE;
+                        else if (!strcmp(p, "lba"))
+                            translation = BIOS_ATA_TRANSLATION_LBA;
+                        else if (!strcmp(p, "auto"))
+                            translation = BIOS_ATA_TRANSLATION_AUTO;
+                        else
+                            goto chs_fail;
+                    } else if (*p != '\0') {
                     chs_fail:
-                        cyls = 0;
+                        fprintf(stderr, "qemu: invalid physical CHS format\n");
+                        exit(1);
                     }
                 }
                 break;
@@ -3230,8 +3249,10 @@
                         hd_filename[i]);
                 exit(1);
             }
-            if (i == 0 && cyls != 0) 
+            if (i == 0 && cyls != 0) {
                 bdrv_set_geometry_hint(bs_table[i], cyls, heads, secs);
+                bdrv_set_translation_hint(bs_table[i], translation);
+            }
         }
     }
 
diff -ruN /qemu-0.6.1/work/qemu-0.6.1/vl.h qemu-snapshot-2004-11-26_23/vl.h
--- /qemu-0.6.1/work/qemu-0.6.1/vl.h	2004-11-14 21:51:33.000000000 +0100
+++ qemu-snapshot-2004-11-26_23/vl.h	2004-11-16 02:45:27.000000000 +0100
@@ -383,13 +383,18 @@
 #define BDRV_TYPE_HD     0
 #define BDRV_TYPE_CDROM  1
 #define BDRV_TYPE_FLOPPY 2
+#define BIOS_ATA_TRANSLATION_AUTO 0
+#define BIOS_ATA_TRANSLATION_NONE 1
+#define BIOS_ATA_TRANSLATION_LBA  2
 
 void bdrv_set_geometry_hint(BlockDriverState *bs, 
                             int cyls, int heads, int secs);
 void bdrv_set_type_hint(BlockDriverState *bs, int type);
+void bdrv_set_translation_hint(BlockDriverState *bs, int translation);
 void bdrv_get_geometry_hint(BlockDriverState *bs, 
                             int *pcyls, int *pheads, int *psecs);
 int bdrv_get_type_hint(BlockDriverState *bs);
+int bdrv_get_translation_hint(BlockDriverState *bs);
 int bdrv_is_removable(BlockDriverState *bs);
 int bdrv_is_read_only(BlockDriverState *bs);
 int bdrv_is_inserted(BlockDriverState *bs);
