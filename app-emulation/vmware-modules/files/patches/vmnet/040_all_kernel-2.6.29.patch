diff -ruN vmnet-only-patched/bridge.c vmnet-only-refixed/bridge.c
--- vmnet-only-patched/bridge.c	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/bridge.c	2009-04-21 18:30:03.000000000 +0300
@@ -275,11 +275,7 @@
                         struct net_device *net)  // IN: Network device
 {
 #ifdef VMW_NETDEV_HAS_NET
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
    if (dev_net(net) != dev_net(bridge->internalDev)) {
-#else
-   if (net->nd_net != bridge->internalDev->nd_net) {
-#endif
       return 0;
    }
 #endif
@@ -857,6 +853,9 @@
 static Bool
 VNetBridgeIsDeviceWireless(struct net_device *dev) //IN: sock
 {
+	return FALSE;
+}
+#if 0
 #ifdef CONFIG_WIRELESS_EXT
    return dev->wireless_handlers != NULL;
 #elif !defined CONFIG_NET_RADIO && !defined CONFIG_WLAN_80211
@@ -869,7 +868,7 @@
    return dev->get_wireless_stats != NULL;
 #endif
 }
-
+#endif
 /*
  *----------------------------------------------------------------------
  *
diff -ruN vmnet-only-patched/compat_semaphore.h vmnet-only-refixed/compat_semaphore.h
--- vmnet-only-patched/compat_semaphore.h	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/compat_semaphore.h	2008-10-20 16:35:18.000000000 +0300
@@ -6,11 +6,7 @@
 #   define __COMPAT_SEMAPHORE_H__
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
 #include <linux/semaphore.h>
-#else
-#include <asm/semaphore.h>
-#endif
 
 
 /*
diff -ruN vmnet-only-patched/compat_wait.h vmnet-only-refixed/compat_wait.h
--- vmnet-only-patched/compat_wait.h	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/compat_wait.h	2009-04-21 18:16:24.000000000 +0300
@@ -37,14 +37,12 @@
  * /dev/epoll interface was added.  It was backported to the
  * 2.4.20-wolk4.0s.
  */
-
-#ifdef VMW_HAVE_EPOLL // {
+#if VMW_HAVE_EPOLL // {
 #define compat_poll_wqueues struct poll_wqueues
 #else // } {
 #define compat_poll_wqueues poll_table
 #endif // }
-
-#ifdef VMW_HAVE_EPOLL // {
+#if VMW_HAVE_EPOLL // {
 
 /* If prototype does not match, build will abort here */
 extern void poll_initwait(compat_poll_wqueues *);
diff -ruN vmnet-only-patched/filter.c vmnet-only-refixed/filter.c
--- vmnet-only-patched/filter.c	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/filter.c	2008-07-24 18:21:23.000000000 +0300
@@ -13,11 +13,9 @@
 #include "compat_skbuff.h"
 #include <linux/netdevice.h>
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
-#   define NF_IP_LOCAL_OUT NF_INET_LOCAL_OUT
-#   define NF_IP_LOCAL_IN NF_INET_LOCAL_IN
-#   define NF_IP_POST_ROUTING NF_INET_POST_ROUTING
-#endif
+#define NF_IP_LOCAL_OUT NF_INET_LOCAL_OUT
+#define NF_IP_LOCAL_IN NF_INET_LOCAL_IN
+#define NF_IP_POST_ROUTING NF_INET_POST_ROUTING
 
 /*
  * All this makes sense only if NETFILTER support is configured in our kernel.
diff -ruN vmnet-only-patched/Makefile vmnet-only-refixed/Makefile
--- vmnet-only-patched/Makefile	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/Makefile	2007-11-28 12:19:12.000000000 +0200
@@ -15,7 +15,7 @@
 VM_UNAME = $(shell uname -r)
 
 # Header directory for the running kernel
-HEADER_DIR = ${KERNEL_DIR}/include
+HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
 
 BUILD_DIR = $(HEADER_DIR)/..
 
diff -ruN vmnet-only-patched/Makefile.kernel vmnet-only-refixed/Makefile.kernel
--- vmnet-only-patched/Makefile.kernel	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/Makefile.kernel	2009-04-21 18:27:50.000000000 +0300
@@ -12,7 +12,8 @@
 INCLUDE := -I$(SRCROOT)
 
 EXTRA_CFLAGS := $(CC_OPTS) $(INCLUDE)
-EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/epoll.c,   -DVMW_HAVE_EPOLL, )
+#EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/epoll.c,   -DVMW_HAVE_EPOLL, )
+EXTRA_CFLAGS += -I$(HEADER_DIR) -DVMW_HAVE_EPOLL 
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/socket.c,  -DVMW_HAVE_SK_WMEM_ALLOC, )
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/sk_alloc.c,-DVMW_HAVE_SK_ALLOC_WITH_PROTO, )
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/netdev_has_net.c,-DVMW_NETDEV_HAS_NET, )
diff -ruN vmnet-only-patched/Makefile.normal vmnet-only-refixed/Makefile.normal
--- vmnet-only-patched/Makefile.normal	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/Makefile.normal	2009-04-21 18:28:04.000000000 +0300
@@ -37,7 +37,8 @@
 	   | sed -n -e 's!^APATH!-I$(HEADER_DIR)/asm!p')
 
 CC_OPTS += -DVME_DEFAULT=$(VMWARE_VER)
-CC_OPTS += $(call vm_check_build, $(SRCROOT)/epoll.c,   -DVMW_HAVE_EPOLL, )
+#CC_OPTS += $(call vm_check_build, $(SRCROOT)/epoll.c,   -DVMW_HAVE_EPOLL, )
+EXTRA_CFLAGS += -I$(HEADER_DIR) -DVMW_HAVE_EPOLL
 CC_OPTS += $(call vm_check_build, $(SRCROOT)/socket.c,  -DVMW_HAVE_SK_WMEM_ALLOC, )
 CC_OPTS += $(call vm_check_build, $(SRCROOT)/sk_alloc.c,-DVMW_HAVE_SK_ALLOC_WITH_PROTO, )
 CC_OPTS += $(call vm_check_build, $(SRCROOT)/netdev_has_net.c,-DVMW_NETDEV_HAS_NET, )
diff -ruN vmnet-only-patched/Module.markers vmnet-only-refixed/Module.markers
--- vmnet-only-patched/Module.markers	1970-01-01 02:00:00.000000000 +0200
+++ vmnet-only-refixed/Module.markers	2008-10-20 16:35:37.000000000 +0300
@@ -0,0 +1,4 @@
+core_marker_format	vmlinux	name %s format %s
+kernel_sched_schedule	vmlinux	prev_pid %d next_pid %d prev_state %ld ## rq %p prev %p next %p
+kernel_sched_wakeup	vmlinux	pid %d state %ld ## rq %p task %p rq->curr %p
+kernel_sched_wakeup_new	vmlinux	pid %d state %ld ## rq %p task %p rq->curr %p
diff -ruN vmnet-only-patched/modules.order vmnet-only-refixed/modules.order
--- vmnet-only-patched/modules.order	1970-01-01 02:00:00.000000000 +0200
+++ vmnet-only-refixed/modules.order	2009-04-21 18:30:09.000000000 +0300
@@ -0,0 +1 @@
+kernel//home/kang/tmp/vmware-update-2.6.27-5.5.7-2/vmnet-only/vmnet.ko
diff -ruN vmnet-only-patched/netif.c vmnet-only-refixed/netif.c
--- vmnet-only-patched/netif.c	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/netif.c	2009-04-21 18:03:24.000000000 +0300
@@ -310,7 +310,7 @@
       goto out;
    }
 
-   dev->priv = netIf;
+   dev->ml_priv = netIf;
    netIf->dev = dev;
    
    memcpy(dev->dev_addr, netIf->port.paddr, sizeof netIf->port.paddr);
@@ -552,7 +552,7 @@
 VNetNetifStartXmit(struct sk_buff    *skb, // IN:
                    struct net_device *dev) // IN:
 {
-   VNetNetIF *netIf = (VNetNetIF*)dev->priv;
+   VNetNetIF *netIf = (VNetNetIF*)dev->ml_priv;
 
    if(skb == NULL) {
       return 0;
@@ -604,7 +604,7 @@
 VNetNetifSetMAC(struct net_device *dev, // IN:
                 void *p)                // IN:
 {
-   VNetNetIF *netIf = (VNetNetIF*)dev->priv;
+   VNetNetIF *netIf = (VNetNetIF*)dev->ml_priv;
    struct sockaddr const *addr = p;
    if (!VMX86_IS_STATIC_MAC(addr->sa_data)) {
       return -EINVAL;
@@ -661,7 +661,7 @@
 struct net_device_stats *
 VNetNetifGetStats(struct net_device *dev) // IN:
 {
-   VNetNetIF *netIf = (VNetNetIF*)dev->priv;
+   VNetNetIF *netIf = (VNetNetIF*)dev->ml_priv;
    return &(netIf->stats);
 }
 
diff -ruN vmnet-only-patched/vmnetInt.h vmnet-only-refixed/vmnetInt.h
--- vmnet-only-patched/vmnetInt.h	2009-07-08 16:21:02.000000000 +0300
+++ vmnet-only-refixed/vmnetInt.h	2008-07-24 18:31:28.000000000 +0300
@@ -63,11 +63,7 @@
 #   define dev_lock_list()    read_lock(&dev_base_lock)
 #   define dev_unlock_list()  read_unlock(&dev_base_lock)
 #   ifdef VMW_NETDEV_HAS_NET
-#     if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
-#      define DEV_GET(x)      __dev_get_by_name((x)->internalDev->nd_net, (x)->name)
-#     else
 #      define DEV_GET(x)      __dev_get_by_name(dev_net((x)->internalDev), (x)->name)
-#     endif
 #   else
 #      define DEV_GET(x)      __dev_get_by_name((x)->name)
 #   endif
@@ -91,13 +87,8 @@
 
 #ifdef VMW_NETDEV_HAS_NET
 extern struct proto vmnet_proto;
-#  if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
 #   define compat_sk_alloc(_bri, _pri) sk_alloc(dev_net((_bri)->internalDev), \
                                                 PF_NETLINK, _pri, &vmnet_proto)
-#  else
-#   define compat_sk_alloc(_bri, _pri) sk_alloc((_bri)->internalDev->nd_net, \
-                                                PF_NETLINK, _pri, &vmnet_proto)
-#  endif
 #elif defined(VMW_HAVE_SK_ALLOC_WITH_PROTO)
 extern struct proto vmnet_proto;
 #   define compat_sk_alloc(_bri, _pri) sk_alloc(PF_NETLINK, _pri, &vmnet_proto, 1)
diff -ruN vmnet-only-patched/vmnetInt.h.orig vmnet-only-refixed/vmnetInt.h.orig
--- vmnet-only-patched/vmnetInt.h.orig	1970-01-01 02:00:00.000000000 +0200
+++ vmnet-only-refixed/vmnetInt.h.orig	2007-11-28 12:25:06.000000000 +0200
@@ -0,0 +1,144 @@
+/* **********************************************************
+ * Copyright 1998 VMware, Inc.  All rights reserved. -- VMware Confidential
+ * **********************************************************/
+
+#ifndef __VMNETINT_H__
+#define __VMNETINT_H__
+
+
+#define INCLUDE_ALLOW_MODULE
+#include "includeCheck.h"
+#include "driver-config.h"
+
+
+/*
+ * Hide all kernel compatibility stuff in those macros
+ */
+
+/* All kernels above 2.6.23 have net namespaces. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) && !defined(VMW_NETDEV_HAS_NET)
+#   define VMW_NETDEV_HAS_NET
+#endif
+
+/* All kernels above 2.6.23 have skb argument in nf_hookfn. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24) && !defined(VMW_NFHOOK_USES_SKB)
+#   define VMW_NFHOOK_USES_SKB
+#endif
+
+
+#ifdef KERNEL_2_4_0
+#   define compat_fop_set_owner(_pFop) do { \
+   (_pFop)->owner = THIS_MODULE;            \
+} while (0)
+#   define compat_mod_inc_refcount
+#   define compat_mod_dec_refcount
+#else
+#   define compat_fop_set_owner(_pFop)
+#   define compat_mod_inc_refcount do { \
+   MOD_INC_USE_COUNT;                   \
+} while (0)
+#   define compat_mod_dec_refcount do { \
+   MOD_DEC_USE_COUNT;                   \
+} while (0)
+#endif
+
+
+#ifdef skb_shinfo
+#  define SKB_IS_CLONE_OF(clone, skb)   (  \
+      skb_shinfo(clone) == skb_shinfo(skb) \
+   )
+#else
+#  define SKB_IS_CLONE_OF(clone, skb)   (      \
+      skb_datarefp(clone) == skb_datarefp(skb) \
+   )
+#endif
+#define DEV_QUEUE_XMIT(skb, dev, pri)   (                 \
+    (skb)->dev = (dev),                                   \
+    (skb)->priority = (pri),                              \
+    compat_skb_reset_mac_header(skb),                     \
+    compat_skb_set_network_header(skb, sizeof (struct ethhdr)),  \
+    dev_queue_xmit(skb)                                   \
+  )
+#ifdef KERNEL_2_3_15
+#   define dev_lock_list()    read_lock(&dev_base_lock)
+#   define dev_unlock_list()  read_unlock(&dev_base_lock)
+#   ifdef VMW_NETDEV_HAS_NET
+#      define DEV_GET(x)      __dev_get_by_name((x)->internalDev->nd_net, (x)->name)
+#   else
+#      define DEV_GET(x)      __dev_get_by_name((x)->name)
+#   endif
+#else
+#   define DEV_GET(x)         dev_get((x)->name)
+#endif
+
+
+/*
+ * Various fields (including 'dead') of struct sock are replaced with the
+ * 'flags' bitfield in 2.5.65 --hpreg
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 65)
+#   define SET_SK_DEAD(_sk, _val) (_sk)->dead = (_val)
+#else
+#   define SET_SK_DEAD(_sk, _val) sock_valbool_flag(_sk, SOCK_DEAD, _val)
+#endif
+
+
+#ifdef VMW_NETDEV_HAS_NET
+extern struct proto vmnet_proto;
+#   define compat_sk_alloc(_bri, _pri) sk_alloc((_bri)->internalDev->nd_net, \
+                                                PF_NETLINK, _pri, &vmnet_proto)
+#elif defined(VMW_HAVE_SK_ALLOC_WITH_PROTO)
+extern struct proto vmnet_proto;
+#   define compat_sk_alloc(_bri, _pri) sk_alloc(PF_NETLINK, _pri, &vmnet_proto, 1)
+#elif defined(KERNEL_2_5_5)
+#   define compat_sk_alloc(_bri, _pri) sk_alloc(PF_NETLINK, _pri, 1, NULL)
+#else
+#   define compat_sk_alloc(_bri, _pri) sk_alloc(0, _pri, 1)
+#endif
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#   define fileTraversalLock(lock) spin_lock(lock)
+#   define fileTraversalUnLock(lock) spin_unlock(lock)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#   define fileTraversalLock(lock) read_lock(lock)
+#   define fileTraversalUnLock(lock) read_unlock(lock)
+#else //2.2 kernels
+#   define fileTraversalLock(lock) lock_kernel()
+#   define fileTraversalUnLock(lock) unlock_kernel()
+#endif
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#   define taskLock(lock) task_lock(lock)
+#   define taskUnLock(lock) task_unlock(lock)
+#else //2.2 kernels
+#   define taskLock(lock) lock_kernel()
+#   define taskUnLock(lock) unlock_kernel()
+#endif
+
+
+/* 
+ * Use CHECKSUM_HW for old kernels, if they have CHECKSUM_HW.  Use CHECKSUM_PARTIAL for 
+ * new ones even if CHECKSUM_HW is defined.  We do not do decision based on kernel version
+ * only as CHECKSUM_PARTIAL was in mm tree for some time already, and we do not test
+ * for CHECKSUM_PARTIAL existence as it may get converted to enum in future.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19) && defined(CHECKSUM_HW)
+#   define VM_CHECKSUM_PARTIAL  CHECKSUM_HW
+#else
+#   define VM_CHECKSUM_PARTIAL  CHECKSUM_PARTIAL
+#endif
+
+
+/*
+ * The "owner" field in nf_hook_ops got added in 2.5.69
+ */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 69)
+#   define compat_nf_hook_owner  .owner = THIS_MODULE,
+#else
+#   define compat_nf_hook_owner
+#endif
+
+
+#endif /* __VMNETINT_H__ */

