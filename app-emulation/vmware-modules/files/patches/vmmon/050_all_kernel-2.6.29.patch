diff -ruN vmmon-only-patched/autoconf/smpcall.c vmmon-only-rerefixed/autoconf/smpcall.c
--- vmmon-only-patched/autoconf/smpcall.c	1970-01-01 02:00:00.000000000 +0200
+++ vmmon-only-rerefixed/autoconf/smpcall.c	2008-10-20 15:52:46.000000000 +0300
@@ -0,0 +1,23 @@
+/* **********************************************************
+ * Copyright (C) 2008 VMware, Inc.  All Rights Reserved. -- VMware Confidential
+ * **********************************************************/
+
+/*
+ * Detect whether smp_call_function has 4 or 3 arguments.
+ * Change happened between 2.6.26 and 2.6.27-rc1.
+ */
+
+#include <linux/autoconf.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+#   error This compile test intentionally fails.
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27)
+#   include <linux/smp.h>
+
+int
+vmware_smp_call_function(void (*func)(void *info), void *info, int wait)
+{
+   return smp_call_function(func, info, wait);
+}
+#endif
diff -ruN vmmon-only-patched/common/cpuid.c vmmon-only-rerefixed/common/cpuid.c
--- vmmon-only-patched/common/cpuid.c	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/common/cpuid.c	2008-10-20 16:23:37.000000000 +0300
@@ -8,7 +8,6 @@
 
 #   include <linux/string.h>
 #endif
-
 #include "vmware.h"
 #include "vm_assert.h"
 #include "x86.h"
diff -ruN vmmon-only-patched/common/task.c vmmon-only-rerefixed/common/task.c
--- vmmon-only-patched/common/task.c	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/common/task.c	2008-10-20 16:09:29.000000000 +0300
@@ -25,16 +25,13 @@
  * we do not need asm/page.h anymore in this file - not surprising, this
  * is common file, yes?  And Windows do not have page.h, do they?
  */
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
-#define _I386_PAGE_H
-#else
-#define _ASM_X86_PAGE_H
-#endif
+#define _ASM_X86_PAGE_H 
 /* On Linux, must come before any inclusion of asm/page.h --hpreg */
-#include "hostKernel.h"
 #ifdef linux
+#include "hostKernel.h"
+#include "driver-config.h"
 #   include <linux/string.h>
+//#   include <linux/kernel.h>
 
 #   ifdef USE_PERFCTRS_HOSTED
 #      include "perfctr.h"
diff -ruN vmmon-only-patched/common/task_compat.h vmmon-only-rerefixed/common/task_compat.h
--- vmmon-only-patched/common/task_compat.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/common/task_compat.h	2008-10-20 16:15:25.000000000 +0300
@@ -1,7 +1,8 @@
+#include <linux/init.h>
 #include "modulecall_compat.h"
 #include "x86msr.h"
 
-typedef struct SysenterStateV45 {
+struct SysenterStateV45 {
    uint64       rsp;
    uint64       rip;
    Selector     cs;
@@ -3646,5 +3647,6 @@
       return TRUE;
    }
 
+// printk("/dev/vmmon: Cannot load module. Use standard gcc compiler\n");
    return FALSE;
 }
diff -ruN vmmon-only-patched/include/compat_semaphore.h vmmon-only-rerefixed/include/compat_semaphore.h
--- vmmon-only-patched/include/compat_semaphore.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/include/compat_semaphore.h	2008-10-20 14:15:58.000000000 +0300
@@ -2,11 +2,7 @@
 #   define __COMPAT_SEMAPHORE_H__
 
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
 #include <linux/semaphore.h>
-#else
-#include <asm/semaphore.h>
-#endif
 
 
 /*
diff -ruN vmmon-only-patched/include/compat_wait.h vmmon-only-rerefixed/include/compat_wait.h
--- vmmon-only-patched/include/compat_wait.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/include/compat_wait.h	2009-04-03 19:58:51.000000000 +0300
@@ -34,13 +34,13 @@
  * 2.4.20-wolk4.0s.
  */
 
-#ifdef VMW_HAVE_EPOLL // {
+#if VMW_HAVE_EPOLL // {
 #define compat_poll_wqueues struct poll_wqueues
 #else // } {
 #define compat_poll_wqueues poll_table
 #endif // }
 
-#ifdef VMW_HAVE_EPOLL // {
+#if VMW_HAVE_EPOLL // {
 
 /* If prototype does not match, build will abort here */
 extern void poll_initwait(compat_poll_wqueues *);
@@ -57,7 +57,8 @@
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 0) // {
 
 /* If prototype does not match, build will abort here */
-extern void poll_initwait(compat_poll_wqueues *);
+//extern void poll_initwait(compat_poll_wqueues *);
+extern void poll_initwait(struct poll_wqueues *pwq);
 
 #define compat_poll_initwait(wait, table) ( \
    (wait) = (table), \
diff -ruN vmmon-only-patched/include/vcpuset.h vmmon-only-rerefixed/include/vcpuset.h
--- vmmon-only-patched/include/vcpuset.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/include/vcpuset.h	2009-04-21 13:46:14.000000000 +0300
@@ -71,9 +71,7 @@
 #define ffs(x) ffs_x86_64(x)
 
 #elif defined MODULE
-#ifndef __cplusplus
-   #include "linux/bitops.h"
-#else
+   //#include <linux/bitops.h>
 static inline int ffs_x86_hack(int x)
 {
         int r;
@@ -91,7 +89,7 @@
 }
 
 #define ffs(x) ffs_x86_hack(x)
-#endif
+
 #elif defined __APPLE__ && defined KERNEL
    /* 
     * XXXMACOS An ugly hack to resolve redefinition of PAGE_ defines 
diff -ruN vmmon-only-patched/include/x86apic.h vmmon-only-rerefixed/include/x86apic.h
--- vmmon-only-patched/include/x86apic.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/include/x86apic.h	2009-04-20 19:50:19.000000000 +0300
@@ -77,7 +77,7 @@
 #define APIC_LVT_DELVMODE(_lvt) (_lvt & 0x700)
 #define APIC_LVT_RESET_VALUE  0x00010000
 
-#define APIC_BASE_MSR         0x1b
+//#define APIC_BASE_MSR         0x1b
 
 #define APIC_MSR_BASEMASK     QWORD(0x0000000f,0xfffff000)
 #define APIC_MSR_ENABLED      0x00000800
diff -ruN vmmon-only-patched/include/x86paging.h vmmon-only-rerefixed/include/x86paging.h
--- vmmon-only-patched/include/x86paging.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/include/x86paging.h	2008-10-20 14:15:49.000000000 +0300
@@ -58,9 +58,7 @@
 
 #define PTE_AVAIL_MASK       0xe00
 #define PTE_AVAIL_SHIFT      9
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27)
-#define PTE_PFN_MASK         0xfffff000
-#endif
+//#define PTE_PFN_MASK         0xfffff000
 #define PAE_PTE_PFN_MASK     CONST64U(0xffffff000)
 #define LM_PTE_PFN_MASK      CONST64U(0xffffffffff000)
 #define PTE_PFN_SHIFT        12
diff -ruN vmmon-only-patched/linux/driver.c vmmon-only-rerefixed/linux/driver.c
--- vmmon-only-patched/linux/driver.c	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/linux/driver.c	2009-05-19 16:02:02.000000000 +0300
@@ -113,15 +113,6 @@
 #define VMWare_SetVTracer(VTrace_Set)
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
-#define VMW_NOPAGE_2624
-
-#define VMMON_MAP_OFFSET_SHIFT	0
-#define VMMON_MAP_OFFSET_MASK	0x00000FFF
-#define VMMON_MAP_OFFSET(base)	\
-		(((base) >> VMMON_MAP_OFFSET_SHIFT) & VMMON_MAP_OFFSET_MASK)
-#endif
-
 struct VMXLinuxState linuxState;
 
 static int vmversion = VME_DEFAULT;
@@ -157,10 +148,8 @@
 
 static int LinuxDriver_Close(struct inode *inode, struct file *filp);
 static unsigned int LinuxDriverPoll(struct file *file, poll_table *wait);
-#if defined(VMW_NOPAGE_2624)
-static int LinuxDriverFault(struct vm_area_struct *vma, struct vm_fault *fault);
-static int LinuxDriverLockedFault(struct vm_area_struct *vma, struct vm_fault *fault);
-#elif defined(VMW_NOPAGE_261)
+#if 0
+#if defined(VMW_NOPAGE_261)
 static struct page *LinuxDriverNoPage(struct vm_area_struct *vma,
                            unsigned long address, int *type);
 static struct page *LinuxDriverLockedNoPage(struct vm_area_struct *vma,
@@ -171,29 +160,36 @@
 static struct page *LinuxDriverLockedNoPage(struct vm_area_struct *vma,
 			   unsigned long address, int unused);
 #else
-static unsigned long LinuxDriverNoPage(struct vm_area_struct *vma,
-			   unsigned long address, int write_access);
-static unsigned long LinuxDriverLockedNoPage(struct vm_area_struct *vma,
-			   unsigned long address, int unused);
 #endif
-static int LinuxDriverMmap(struct file *filp, struct vm_area_struct *vma);
+static int LinuxDriverNoPage(struct vm_area_struct *vma,
+			struct vm_fault *fdata);
+static int LinuxDriverLockedNoPage(struct vm_area_struct *vma,
+			struct vm_fault *fdata);
+
 
-static void LinuxDriverPollTimeout(unsigned long clientData);
 
 static struct vm_operations_struct vmuser_mops = {
-#ifdef VMW_NOPAGE_2624
-	.fault  = LinuxDriverFault
-#else
-	.nopage = LinuxDriverNoPage
-#endif
+	.fault = LinuxDriverNoPage
 };
 
 struct vm_operations_struct vmuser_locked_mops = {
-#ifdef VMW_NOPAGE_2624
-	.fault = LinuxDriverLockedFault
-#else
-	.nopage = LinuxDriverLockedNoPage
+	.fault = LinuxDriverLockedNoPage
+};
 #endif
+static void LinuxDriverPollTimeout(unsigned long clientData);
+static int LinuxDriverMmap(struct file *filp, struct vm_area_struct *vma);
+
+static int LinuxDriverNoPage(struct vm_area_struct *vma,
+	                           struct vm_fault *fdata);
+static int LinuxDriverLockedNoPage(struct vm_area_struct *vma,
+				struct vm_fault *fdata);
+
+static struct vm_operations_struct vmuser_mops = {
+	        .fault = LinuxDriverNoPage
+};
+
+struct vm_operations_struct vmuser_locked_mops = {
+		.fault = LinuxDriverLockedNoPage
 };
 
 static struct file_operations vmuser_fops;
@@ -576,7 +572,7 @@
    memset(vmLinux, 0, sizeof *vmLinux);
    vmLinux->version = LinuxDriverEmulatedVersion();
    /* If caller's euid was not 0, we are running devel build */
-   vmLinux->maySetUid = current->euid != 0;
+   vmLinux->maySetUid = current->cred->euid != 0;
    vmLinux->ctType = VMCIOBJ_NOT_SET;
 
    sema_init(&vmLinux->lock4Gb, 1);
@@ -1164,53 +1160,22 @@
  *-----------------------------------------------------------------------------
  */
 
-#if defined(VMW_NOPAGE_2624)
-static int LinuxDriverFault(struct vm_area_struct *vma, //IN
-			    struct vm_fault *fault)     //IN/OUT
-#elif defined(VMW_NOPAGE_261)
-static struct page *LinuxDriverNoPage(struct vm_area_struct *vma, //IN
-				      unsigned long address, 	  //IN
-				      int *type)		  //OUT: Fault type
-#elif defined(KERNEL_2_4_0)
-static struct page *LinuxDriverNoPage(struct vm_area_struct *vma, //IN
-				      unsigned long address, 	  //IN
-				      int unused)		  //nothing
-#else
-static unsigned long LinuxDriverNoPage(struct vm_area_struct *vma,//IN
-				       unsigned long address,	  //IN
-				       int write_access)	  //IN
-#endif
+static int LinuxDriverNoPage(struct vm_area_struct *vma,//IN
+					struct vm_fault *fdata)
 {
 	VMLinux *vmLinux = (VMLinux *) vma->vm_file->private_data;
 	unsigned long pg;
 	struct page* page;
 	
-#ifdef VMW_NOPAGE_2624
-	pg = fault->pgoff;
-#else
-	pg = ((address - vma->vm_start) >> PAGE_SHIFT) + compat_vm_pgoff(vma);
-#endif
+	pg = fdata->pgoff;
 	pg = VMMON_MAP_OFFSET(pg);
 	if (pg >= vmLinux->size4Gb) {
-#ifdef VMW_NOPAGE_2624
-		return VM_FAULT_SIGBUS;
-#else
 		return 0;
-#endif
 	}
 	page = vmLinux->pages4Gb[pg];
 	get_page(page);
-#ifdef VMW_NOPAGE_2624
-	fault->page = page;
-	return 0;
-#elif defined(KERNEL_2_4_0)
-#ifdef VMW_NOPAGE_261
-        *type = VM_FAULT_MINOR;
-#endif
-	return page;
-#else
-	return page_address(page);
-#endif
+	fdata->page = page;
+        return VM_FAULT_MINOR;
 }
 
 
@@ -1393,6 +1358,7 @@
    VMLinux *vmLinux = (VMLinux *) filp->private_data;
    int retval = 0;
    Vcpuid vcpuid;
+   struct cred *new;
 
    switch (iocmd) {
    case IOCTL_VMX86_VERSION:
@@ -1527,8 +1493,14 @@
       devel_suid();
 #else
       if (vmLinux->maySetUid) {
-	 current->suid = 0;
-	 cap_set_full(current->cap_permitted);
+	 new = prepare_creds();
+	 if (!new) {
+		 retval = -ENOMEM;
+		 break;
+	 }
+	 new->suid = 0;
+	 cap_set_full(new->cap_permitted);
+	 commit_creds(new);
 	 retval = 0;
       } else {
 	 retval = -EPERM;
@@ -1793,10 +1765,10 @@
    }
 
    case IOCTL_VMX86_ALLOW_CORE_DUMP:
-      if (current->euid == current->uid &&
-	  current->fsuid == current->uid &&
-          current->egid == current->gid &&
-	  current->fsgid == current->gid) {
+      if (new->euid == current_uid() &&
+	  new->fsuid == current_uid() &&
+          new->egid == new->gid &&
+	  new->fsgid == new->gid) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) || defined(MMF_DUMPABLE)
          /* Dump core, readable by user. */
          set_bit(MMF_DUMPABLE, &current->mm->flags);
@@ -1813,7 +1785,7 @@
       break;
 
    case IOCTL_VMX86_BROADCAST_IPI:
-      retval = compat_smp_call_function(LinuxDriverIPIHandler, NULL, 1, 1);
+      retval = compat_smp_call_function(LinuxDriverIPIHandler, NULL, 1);
       break;
 
 #ifdef USE_PERFCTRS_HOSTED
diff -ruN vmmon-only-patched/linux/driver_compat.h vmmon-only-rerefixed/linux/driver_compat.h
--- vmmon-only-patched/linux/driver_compat.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/linux/driver_compat.h	2008-07-24 18:55:05.000000000 +0300
@@ -268,22 +268,8 @@
  *-----------------------------------------------------------------------------
  */
 
-#if defined(VMW_NOPAGE_2624)
-static int LinuxDriverLockedFault(struct vm_area_struct *vma, //IN
-				  struct vm_fault *fault)     //IN/OUT
-#elif defined(VMW_NOPAGE_261)
-static struct page *LinuxDriverLockedNoPage(struct vm_area_struct *vma, //IN
-				            unsigned long address,      //IN
-				            int *type)		        //OUT: Fault type
-#elif defined(KERNEL_2_4_0)
-static struct page *LinuxDriverLockedNoPage(struct vm_area_struct *vma, //IN
-				            unsigned long address,      //IN
-				            int unused)		        //nothing
-#else
-static unsigned long LinuxDriverLockedNoPage(struct vm_area_struct *vma, //IN
-				             unsigned long address,      //IN
-				             int unused)	        //nothing
-#endif
+static int LinuxDriverLockedNoPage(struct vm_area_struct *vma, //IN
+					struct vm_fault *fdata)
 {
    VMLinux *vmLinux = (VMLinux *) vma->vm_file->private_data;
    unsigned long pg;
@@ -291,67 +277,34 @@
    struct VMHostEntry* vmhe;
    struct page* result;
 	
-#ifdef VMW_NOPAGE_2624
-   pg = fault->pgoff;
-#else
-   pg = ((address - vma->vm_start) >> PAGE_SHIFT) + compat_vm_pgoff(vma);
-#endif
+   pg = fdata->pgoff;
    if (pg >= vmLinux->sizeLocked) {
       printk(KERN_DEBUG "vmmon: Something went wrong: entry %08lX out of range (>=%08X) for mapping on filp %p\n", pg, vmLinux->sizeLocked, vmLinux);
-#ifdef VMW_NOPAGE_2624
-      return VM_FAULT_SIGBUS;
-#else
       return NOPAGE_SIGBUS;
-#endif
    }
    if (!vmLinux->vm || !vmLinux->vm->vmhost) {
       printk(KERN_DEBUG "vmmon: Something went wrong: no vm or vmhost for mapping on filp %p\n", vmLinux);
-#ifdef VMW_NOPAGE_2624
-      return VM_FAULT_SIGBUS;
-#else
       return NOPAGE_SIGBUS;
-#endif
    }
    pgt = vmLinux->pagesLocked->ent[pg / VMHOST_MAPPING_PT];
    if (!pgt) {
       printk(KERN_DEBUG "vmmon: Something went wrong: missing entry %08lX from mapping on filp %p\n", pg, vmLinux);
-#ifdef VMW_NOPAGE_2624
-      return VM_FAULT_SIGBUS;
-#else
       return NOPAGE_SIGBUS;
-#endif
    }
    vmhe = kmap(pgt);
    result = vmhe->ent[pg % VMHOST_MAPPING_PT];
    kunmap(pgt);
    if (!result) {
       printk(KERN_DEBUG "vmmon: Something went wrong: attempt to access non-existing entry %08lX in mapping on filp %p\n", pg, vmLinux);
-#ifdef VMW_NOPAGE_2624
-      return VM_FAULT_SIGBUS;
-#else
       return NOPAGE_SIGBUS;
-#endif
    }
    if (!PhysTrack_Test(vmLinux->vm->vmhost->AWEPages, page_to_pfn(result))) {
       printk(KERN_DEBUG "vmmon: MPN %08lX not tracked! Someone released it before removing it from VA first!\n", pg);
-#ifdef VMW_NOPAGE_2624
-      return VM_FAULT_SIGBUS;
-#else
       return NOPAGE_SIGBUS;
-#endif
    }
    get_page(result);
-#if defined(VMW_NOPAGE_2624)
-   fault->page = result;
-   return 0;
-#elif defined(KERNEL_2_4_0)
-#ifdef VMW_NOPAGE_261
-   *type = VM_FAULT_MINOR;
-#endif
-   return result;
-#else
-   return page_address(result);
-#endif
+   fdata->page = result;
+   return VM_FAULT_MINOR;
 }
 
 
diff -ruN vmmon-only-patched/linux/driver.h vmmon-only-rerefixed/linux/driver.h
--- vmmon-only-patched/linux/driver.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/linux/driver.h	2008-10-20 14:21:26.000000000 +0300
@@ -90,7 +90,7 @@
    struct VMLinux **pollBack;
 } VMLinux;
 
-extern struct vm_operations_struct vmuser_locked_mops;
+//extern struct vm_operations_struct vmuser_locked_mops;
 #define VMHOST_MAPPING_PD	(PAGE_SIZE / sizeof(void*))
 #define VMHOST_MAPPING_PT	(PAGE_SIZE / sizeof(void*))
 struct VMHostEntry {
@@ -131,6 +131,7 @@
    spinlock_t pollListLock;
 #endif
 
+//   volatile int fastClockThread;
    volatile struct task_struct *fastClockThread;
    unsigned fastClockRate;
 
diff -ruN vmmon-only-patched/linux/hostif.c vmmon-only-rerefixed/linux/hostif.c
--- vmmon-only-patched/linux/hostif.c	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/linux/hostif.c	2009-04-21 17:47:54.000000000 +0300
@@ -18,6 +18,7 @@
 #include "compat_page.h"
 #include <linux/binfmts.h>
 #include <linux/fs.h>
+#include <linux/kthread.h>
 #include "compat_sched.h"
 #include <linux/file.h>
 #ifdef KERNEL_2_2
@@ -70,10 +71,6 @@
 #include "compat_timer.h"
 #include "x86.h"
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
-#include <linux/kthread.h>
-#include <linux/mutex.h>
-#endif
 static COMPAT_DECLARE_COMPLETION(fastClockExited);
 
 /*
@@ -140,95 +137,6 @@
 #define HOST_ISTRACKED_PFN(_vm, _pfn) (PhysTrack_Test(_vm->physTracker, _pfn))
 
 
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24))
-/*
- *-----------------------------------------------------------------------------
- *
- * MutexInit --
- *
- *      Initialize a Mutex. --hpreg
- *
- * Results:
- *      None
- *
- * Side effects:
- *      None
- *
- *-----------------------------------------------------------------------------
- */
-
-#define MutexInit(_mutex, _name) mutex_init(_mutex)
-/*
- *-----------------------------------------------------------------------------
- *
- * MutexIsLocked --
- *
- *      Determine if a Mutex is locked by the current thread. --hpreg
- *
- * Results:
- *      TRUE if yes
- *      FALSE if no
- *
- * Side effects:
- *      None
- *
- *-----------------------------------------------------------------------------
- */
-
-#define MutexIsLocked(_mutex) mutex_is_locked(_mutex)
-
-/*
- *-----------------------------------------------------------------------------
- *
- * MutexLock --
- *
- *      Acquire a Mutex. --hpreg
- *
- * Results:
- *      None
- *
- * Side effects:
- *      None
- *
- *-----------------------------------------------------------------------------
- */
-
-#define MutexLock(_mutex, _callerID) mutex_lock(_mutex)
-
-/*
- *-----------------------------------------------------------------------------
- *
- * MutexUnlock --
- *
- *      Release a Mutex. --hpreg
- *
- * Results:
- *      None
- *
- * Side effects:
- *      None
- *
- *-----------------------------------------------------------------------------
- */
-
-#define MutexUnlock(_mutex, _callerID) mutex_unlock(_mutex)
-
-/* This mutex protects the driver-wide state. --hpreg */
-static DEFINE_MUTEX(globalMutex);
-
-/*
- * This mutex protects the fast clock rate and is held while
- * creating/destroying the fastClockThread.  It ranks below
- * globalMutex.  We can't use globalMutex for this purpose because the
- * fastClockThread itself acquires the globalMutex, so trying to hold
- * the mutex while destroying the thread can cause a deadlock.
- */
-static DEFINE_MUTEX(fastClockMutex);
-
-/* This mutex protects linuxState.pollList.  */
-static DEFINE_MUTEX(pollListMutex);
-
-#else
 /*
  *-----------------------------------------------------------------------------
  *
@@ -371,7 +279,6 @@
 /* This mutex protects linuxState.pollList.  */
 static Mutex pollListMutex;
 
-#endif /* USE_KTHREAD */
 
 /*
  *-----------------------------------------------------------------------------
@@ -444,7 +351,7 @@
    MutexUnlock(&globalMutex, callerID);
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+
 #ifdef VMX86_DEBUG
 /*
  *-----------------------------------------------------------------------------
@@ -469,7 +376,6 @@
    return MutexIsLocked(&globalMutex);
 }
 #endif
-#endif
 
 
 /*
@@ -564,7 +470,6 @@
    MutexUnlock(&pollListMutex, callerID);
 }
 
-
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 3)
 static INLINE void
 down_write_mmap(void)
@@ -620,7 +525,6 @@
    up_write_mmap();
 }
 #endif
-
 /*
  *----------------------------------------------------------------------
  * 
@@ -678,7 +582,7 @@
 #else
       pte_val(*pte) &= ~_PAGE_NX;
 #endif
-      compat_smp_call_function (TLBInvalidatePage, (void *)vaddr, 1, 1);
+      smp_call_function (TLBInvalidatePage, (void *)vaddr, 1);
       TLBInvalidatePage((void *)vaddr);
    }
    if (ptemap) {
@@ -2911,7 +2815,7 @@
       if (targetHostCpu != INVALID_HOST_CPU) {
 	 ASSERT(targetHostCpu < MAX_PROCESSORS);
          (void) compat_smp_call_function(LinuxDriverIPIHandler,
-                                         NULL, 1, 1);
+                                         NULL, 1);
          return TRUE;
       }
    }
@@ -3099,7 +3003,7 @@
 {
    compat_preempt_disable();
    HostIFFillCPUID((void*)info);
-   (void)compat_smp_call_function(HostIFFillCPUID, (void*)info, 1, 1);
+   (void)compat_smp_call_function(HostIFFillCPUID, (void*)info, 1);
    compat_preempt_enable();
 }
 
@@ -3136,7 +3040,7 @@
    compat_preempt_disable();
    HostIFBrokenCPUHelper((void*)&badcpumask); // run on this machine CPU
    (void)compat_smp_call_function(HostIFBrokenCPUHelper, (void*)&badcpumask, 
-                                  1, 1); // run on all other machine CPUs
+                                  1); // run on all other machine CPUs
    compat_preempt_enable();
 
    return badcpumask;
@@ -3335,46 +3239,6 @@
 /*
  *----------------------------------------------------------------------
  *
- * HostIFDoIoctl --
- *
- *    Issue ioctl.  Assume kernel is not locked.  It is not true now,
- *    but it makes things easier to understand, and won't surprise us
- *    later when we get rid of kernel lock from our code.
- *
- * Results:
- *    Same as ioctl method.
- *
- * Side effects:
- *    none.
- *
- *---------------------------------------------------------------------- 
- */
-
-static long
-HostIFDoIoctl(struct file *filp,
-              u_int iocmd,
-              unsigned long ioarg)
-{
-#ifdef HAVE_UNLOCKED_IOCTL
-   if (filp->f_op->unlocked_ioctl) {
-      return filp->f_op->unlocked_ioctl(filp, iocmd, ioarg);
-   }
-#endif
-   if (filp->f_op->ioctl) {
-      long err;
-
-      lock_kernel();
-      err = filp->f_op->ioctl(filp->f_dentry->d_inode, filp, iocmd, ioarg);
-      unlock_kernel();
-      return err;
-   }
-   return -ENOIOCTLCMD;
-}
-
-
-/*
- *----------------------------------------------------------------------
- *
  * HostIFFastClockThread --
  *
  *      Kernel thread that provides finer-grained wakeups than the
@@ -3399,15 +3263,19 @@
    int res;
    mm_segment_t oldFS;
    unsigned rate = 0;
+   struct cred *cred;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
    compat_daemonize("vmware-rtc");
-#endif
    oldFS = get_fs();
    set_fs(KERNEL_DS);
    compat_allow_signal(SIGKILL);
-   cap_raise(current->cap_effective, CAP_SYS_RESOURCE);
-   compat_set_user_nice(current, -20);
+   cred = prepare_creds();
+   if(!cred)
+	   return -ENOMEM;
+   cap_raise(cred->cap_effective, CAP_SYS_RESOURCE);
+   commit_creds(cred);
+
+   //compat_set_user_nice(current, -20);
 
    while (linuxState.fastClockRate > HZ + HZ/16) {
       unsigned long buf;
@@ -3423,7 +3291,8 @@
             p2rate <<= 1;
          }
 
-         res = HostIFDoIoctl(filp, RTC_IRQP_SET, p2rate);
+         res = filp->f_op->ioctl(filp->f_dentry->d_inode,
+                                 filp, RTC_IRQP_SET, p2rate);
          if (res < 0) {
             Warning("/dev/rtc set rate %d failed: %d\n", p2rate, res);
             goto out;
@@ -3526,31 +3395,54 @@
    if (rate > HZ + HZ/16) {
       if (!linuxState.fastClockThread) {
          struct file *filp;
+	 struct cred *cred;
          int fsuid, res;
          Bool cap;
-		 struct task_struct *t;
+	 struct task_struct *t;
 
-         fsuid = current->fsuid;
+         /*fsuid = current->fsuid;
          current->fsuid = 0;
+	 */
+	 cred = prepare_creds();
+	 fsuid = cred->fsuid;
+	 cred->fsuid = 0;
+	 commit_creds(cred);
          filp = filp_open("/dev/rtc", O_RDONLY, 0);
-         current->fsuid = fsuid;
+	 cred = prepare_creds();
+	 cred->fsuid = fsuid;
+	 commit_creds(cred);
+         //current->fsuid = fsuid;
          if (IS_ERR(filp) || !filp) {
             Warning("/dev/rtc open failed: %d\n", (int)(VA)filp);
             return -(int)(VA)filp;
          }
-         cap = cap_raised(current->cap_effective, CAP_SYS_RESOURCE);
+ /*        cap = cap_raised(current->cap_effective, CAP_SYS_RESOURCE);
          cap_raise(current->cap_effective, CAP_SYS_RESOURCE);
-         res = HostIFDoIoctl(filp, RTC_PIE_ON, 0);
+*/
+	 cred = prepare_creds();
+	 cap = cap_raised(cred->cap_effective, CAP_SYS_RESOURCE);
+	 cap_raise(cred->cap_effective, CAP_SYS_RESOURCE);
+	 commit_creds(cred);
+	 if (filp->f_op->ioctl) {
+		lock_kernel();
+         	res = filp->f_op->ioctl(filp->f_path.dentry->d_inode, filp, RTC_PIE_ON, 0);
+		unlock_kernel();
+	}
+	 else 
+		 res = -1;
          if (!cap) {
-            cap_lower(current->cap_effective, CAP_SYS_RESOURCE);            
+		 cred = prepare_creds();
+        //    cap_lower(current->cap_effective, CAP_SYS_RESOURCE);            
+		cap_lower(cred->cap_effective, CAP_SYS_RESOURCE);
+		commit_creds(cred);
          }
          if (res < 0) {
             Warning("/dev/rtc enable interrupt failed: %d\n", res);
             compat_filp_close(filp, current->files);
             return -res;
          }
-	 	 t = kthread_create(HostIFFastClockThread, filp, "vmware-rtc");
-	 	 if (IS_ERR(t)) {
+	 t = kthread_create(HostIFFastClockThread, filp, "vmware-rtc");
+	 if (IS_ERR(t)) {
             /*
              * Ignore ERESTARTNOINTR silently, it occurs when signal is
              * pending, and syscall layer automatically reissues operation
@@ -3563,11 +3455,11 @@
             return -PTR_ERR(t);
          }
          linuxState.fastClockThread = t;
-	 	 wake_up_process(t);
+	 wake_up_process(t);
       }
    } else {
       if (linuxState.fastClockThread) {
-         send_sig(SIGKILL, linuxState.fastClockThread, 1);
+	 send_sig(SIGKILL, linuxState.fastClockThread, 1);
          compat_wait_for_completion(&fastClockExited);
          linuxState.fastClockThread = NULL;
       }
diff -ruN vmmon-only-patched/linux/hostif_compat.h vmmon-only-rerefixed/linux/hostif_compat.h
--- vmmon-only-patched/linux/hostif_compat.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/linux/hostif_compat.h	2009-04-21 13:45:08.000000000 +0300
@@ -93,11 +93,13 @@
       }
       return -EFAULT;
    }
+   /*
    if (vma->vm_ops != &vmuser_locked_mops) {
       printk(KERN_DEBUG "Found non-vmmon VMA (%#lX-%#lX) for VA %p\n", 
              vma->vm_start, vma->vm_end, (void*)va);
       return -EINVAL;
    }
+   */
    vmLinux = (VMLinux*)vma->vm_file->private_data;
    if (!vmLinux) {
       printk(KERN_DEBUG "Found vmmon VMA (%#lX-%#lX) for VA %p"
@@ -367,7 +369,7 @@
 {
    compat_preempt_disable();
    HostIFSystemCallResetMSR(regs);
-   (void)compat_smp_call_function(HostIFSystemCallResetMSR, (void *)regs, 1, 1);
+   (void)compat_smp_call_function(HostIFSystemCallResetMSR, (void *)regs, 1);
    compat_preempt_enable();
 }
 
@@ -775,7 +777,8 @@
       }
    }
    
-   mpn = PgtblVa2MPN(__fix_to_virt(VMWARE__FIX_IO_APIC_BASE));
+   //mpn = PgtblVa2MPN(__fix_to_virt(VMWARE__FIX_IO_APIC_BASE));
+   mpn = PgtblVa2MPN(__fix_to_virt(FIX_IO_APIC_BASE_0));
    if (mpn == INVALID_MPN) {
       return 0;
    }
diff -ruN vmmon-only-patched/linux/vmhost.h vmmon-only-rerefixed/linux/vmhost.h
--- vmmon-only-patched/linux/vmhost.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/linux/vmhost.h	2005-06-19 04:23:03.000000000 +0300
@@ -13,7 +13,7 @@
 #include "compat_semaphore.h"
 #include "compat_wait.h"
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+
 #ifdef VMX86_DEBUG
 /*
  * A MutexHolder object. In debug builds, we record information about the
@@ -54,7 +54,7 @@
    MutexHolder cur;
 #endif
 } Mutex;
-#endif
+
 
 /*
  * Per-vm host-specific state.
@@ -65,11 +65,7 @@
     * Used for shared modifications to VM's VMDriver data, mostly page locking.
     * It has higher rank than the global mutex.
     */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
-   struct mutex vmMutex;
-#else
    Mutex vmMutex;
-#endif
 
    atomic_t           pendingUserCalls;
    wait_queue_head_t  callQueue;
diff -ruN vmmon-only-patched/linux/vmmonInt.h vmmon-only-rerefixed/linux/vmmonInt.h
--- vmmon-only-patched/linux/vmmonInt.h	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/linux/vmmonInt.h	2009-04-20 19:14:30.000000000 +0300
@@ -31,16 +31,7 @@
 } while (0)
 #endif
 
-#if defined(CONFIG_SMP) && LINUX_VERSION_CODE >= KERNEL_VERSION(2, 2, 8)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
-#define compat_smp_call_function(_a0,_a1,_a2,_a3) smp_call_function(_a0,_a1,_a3)
-#else
-#define compat_smp_call_function smp_call_function
-#endif
-#else
-#define compat_smp_call_function(_a0,_a1,_a2,_a3) 0
-#endif
-
+#define compat_smp_call_function(fn, info, wait) smp_call_function(fn, info, wait)
 
 /*
  * Although this is not really related to kernel-compatibility, I put this
diff -ruN vmmon-only-patched/Makefile vmmon-only-rerefixed/Makefile
--- vmmon-only-patched/Makefile	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/Makefile	2007-11-28 12:39:37.000000000 +0200
@@ -15,7 +15,7 @@
 VM_UNAME = $(shell uname -r)
 
 # Header directory for the running kernel
-HEADER_DIR = ${KERNEL_DIR}/include
+HEADER_DIR = /lib/modules/$(VM_UNAME)/build/include
 
 BUILD_DIR = $(HEADER_DIR)/..
 
diff -ruN vmmon-only-patched/Makefile.kernel vmmon-only-rerefixed/Makefile.kernel
--- vmmon-only-patched/Makefile.kernel	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/Makefile.kernel	2009-04-21 18:01:30.000000000 +0300
@@ -16,18 +16,20 @@
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/nopage1.c, -DVMW_NOPAGE_261, )
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/skas1.c,   -DVMW_SKAS_MMAP, )
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/ioapic.c,	\
-		-DVMWARE__FIX_IO_APIC_BASE=FIX_IO_APIC_BASE_0,		\
-		-DVMWARE__FIX_IO_APIC_BASE=FIX_IO_APIC_BASE )
-EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/epoll.c,   -DVMW_HAVE_EPOLL, )
+		-DVMWARE__FIX_IO_APIC_BASE=FIX_IO_APIC_BASE_0)		
+#		-DVMWARE__FIX_IO_APIC_BASE=FIX_IO_APIC_BASE ) #only for UP ?
+#EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/epoll.c,   -DVMW_HAVE_EPOLL, )
+EXTRA_CFLAGS += "-DVMW_HAVE_EPOLL"
 EXTRA_CFLAGS += $(shell if [ -f $(HEADER_DIR)/linux/compile.h ]; then echo "-DVMW_HAVE_COMPILE_H"; fi)
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/setnice.c, -DVMW_HAVE_SET_USER_NICE, )
+EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/smpcall.c, -DVMW_HAVE_SMP_CALL_3ARG, )
 
 CXX_KFLAGS := $(call vm_check_gxx,-fno-exceptions,)
 
 # 2.6.x build system
 CFLAGS_task.o := -x c++ $(CXX_KFLAGS)
 # 2.4.x build system
-CFLAGS_common/task.o := $(CFLAGS_task.o)
+#CFLAGS_common/task.o := $(CFLAGS_task.o)
 
 obj-m += $(DRIVER).o
 
diff -ruN vmmon-only-patched/Makefile.normal vmmon-only-rerefixed/Makefile.normal
--- vmmon-only-patched/Makefile.normal	2009-07-08 16:21:02.000000000 +0300
+++ vmmon-only-rerefixed/Makefile.normal	2009-04-21 13:42:29.000000000 +0300
@@ -67,8 +67,8 @@
 CC_OPTS += $(call vm_check_build, $(SRCROOT)/autoconf/nopage1.c, -DVMW_NOPAGE_261, )
 CC_OPTS += $(call vm_check_build, $(SRCROOT)/autoconf/skas1.c,   -DVMW_SKAS_MMAP, )
 CC_OPTS += $(call vm_check_build, $(SRCROOT)/autoconf/ioapic.c,	\
-		-DVMWARE__FIX_IO_APIC_BASE=FIX_IO_APIC_BASE_0,	\
-		-DVMWARE__FIX_IO_APIC_BASE=FIX_IO_APIC_BASE )
+		-DVMWARE__FIX_IO_APIC_BASE=FIX_IO_APIC_BASE_0)
+#		-DVMWARE__FIX_IO_APIC_BASE=FIX_IO_APIC_BASE ) #up?
 CC_OPTS += $(call vm_check_build, $(SRCROOT)/autoconf/epoll.c,   -DVMW_HAVE_EPOLL, )
 CC_OPTS += $(shell if [ -f $(HEADER_DIR)/linux/compile.h ]; then echo "-DVMW_HAVE_COMPILE_H"; fi)
 CC_OPTS += $(call vm_check_build, $(SRCROOT)/autoconf/setnice.c, -DVMW_HAVE_SET_USER_NICE, )
diff -ruN vmmon-only-patched/Module.markers vmmon-only-rerefixed/Module.markers
--- vmmon-only-patched/Module.markers	1970-01-01 02:00:00.000000000 +0200
+++ vmmon-only-rerefixed/Module.markers	2008-10-20 16:18:10.000000000 +0300
@@ -0,0 +1,4 @@
+core_marker_format	vmlinux	name %s format %s
+kernel_sched_schedule	vmlinux	prev_pid %d next_pid %d prev_state %ld ## rq %p prev %p next %p
+kernel_sched_wakeup	vmlinux	pid %d state %ld ## rq %p task %p rq->curr %p
+kernel_sched_wakeup_new	vmlinux	pid %d state %ld ## rq %p task %p rq->curr %p
diff -ruN vmmon-only-patched/modules.order vmmon-only-rerefixed/modules.order
--- vmmon-only-patched/modules.order	1970-01-01 02:00:00.000000000 +0200
+++ vmmon-only-rerefixed/modules.order	2009-04-21 18:01:42.000000000 +0300
@@ -0,0 +1 @@
+kernel//home/kang/tmp/vmware-update-2.6.27-5.5.7-2/vmmon-only/vmmon.ko

