--- vmmon-only/linux/driver.c	2008-08-07 22:04:50.000000000 +0200
+++ vmmon-only/linux/driver.c	2008-08-07 22:06:57.000000000 +0200
@@ -23,7 +23,9 @@
 #include <linux/smp_lock.h>
 
 #include <linux/poll.h>
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+# include <linux/mm.h>
+#endif
 /*
  * Power Management: hook resume to work around
  * BIOS bugs where VT is not properly enabled after S4
@@ -179,23 +181,32 @@
 
 static int LinuxDriver_Close(struct inode *inode, struct file *filp);
 static unsigned int LinuxDriverPoll(struct file *file, poll_table *wait);
-#if defined(VMW_NOPAGE_261)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+# if defined(VMW_NOPAGE_261)
 static struct page *LinuxDriverNoPage(struct vm_area_struct *vma,
                            unsigned long address, int *type);
-#elif defined(KERNEL_2_4_0)
+# elif defined(KERNEL_2_4_0)
 static struct page *LinuxDriverNoPage(struct vm_area_struct *vma,
 			   unsigned long address, int unused);
-#else
+# else
 static unsigned long LinuxDriverNoPage(struct vm_area_struct *vma,
 			   unsigned long address, int write_access);
-#endif
-static int LinuxDriverMmap(struct file *filp, struct vm_area_struct *vma);
-
-static void LinuxDriverPollTimeout(unsigned long clientData);
+# endif
 
 static struct vm_operations_struct vmuser_mops = {
 	.nopage = LinuxDriverNoPage
 };
+#else
+static int LinuxDriverNoPage(struct vm_area_struct *vma,
+                          struct vm_fault *fdata);
+
+static struct vm_operations_struct vmuser_mops = {
+       .fault = LinuxDriverNoPage
+};
+#endif
+static int LinuxDriverMmap(struct file *filp, struct vm_area_struct *vma);
+
+static void LinuxDriverPollTimeout(unsigned long clientData);
 
 static struct file_operations vmuser_fops;
 static struct timer_list tscTimer;
@@ -1172,20 +1183,20 @@
  *
  *-----------------------------------------------------------------------------
  */
-
-#ifdef VMW_NOPAGE_261
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+# ifdef VMW_NOPAGE_261
 static struct page *LinuxDriverNoPage(struct vm_area_struct *vma, //IN
 				      unsigned long address, 	  //IN
 				      int *type)		  //OUT: Fault type
-#elif defined(KERNEL_2_4_0)
+# elif defined(KERNEL_2_4_0)
 static struct page *LinuxDriverNoPage(struct vm_area_struct *vma, //IN
 				      unsigned long address, 	  //IN
 				      int unused)		  //nothing
-#else
+# else
 static unsigned long LinuxDriverNoPage(struct vm_area_struct *vma,//IN
 				       unsigned long address,	  //IN
 				       int write_access)	  //IN
-#endif
+# endif
 {
 	VMLinux *vmLinux = (VMLinux *) vma->vm_file->private_data;
 	unsigned long pg;
@@ -1198,15 +1209,37 @@
 	}
 	page = vmLinux->pages4Gb[pg];
 	get_page(page);
-#ifdef KERNEL_2_4_0
-#ifdef VMW_NOPAGE_261
+# ifdef KERNEL_2_4_0
+#  ifdef VMW_NOPAGE_261
         *type = VM_FAULT_MINOR;
-#endif
+#  endif
 	return page;
-#else
+# else
 	return page_address(page);
-#endif
+# endif
+}
+#else
+/*  For kernel upper or equal to  2.6.26 */
+static int LinuxDriverNoPage(struct vm_area_struct *vma,
+                          struct vm_fault *fdata)
+{
+       VMLinux *vmLinux = (VMLinux *) vma->vm_file->private_data;
+       unsigned long pg;
+       struct page* page;
+
+       pg = fdata->pgoff;
+       pg = VMMON_MAP_OFFSET(pg);
+       if (pg >= vmLinux->size4Gb) {
+               return VM_FAULT_MAJOR;
+       }
+       page = vmLinux->pages4Gb[pg];
+       get_page(page);
+       fdata->page = page;
+        return VM_FAULT_MINOR;
 }
+#endif
+
+
 
 
 /*
