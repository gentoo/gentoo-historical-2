 --- src/dosext/dpmi/dpmi.h      17 Sep 2003 14:40:54 -0000      1.1.2.2
 +++ src/dosext/dpmi/dpmi.h      30 Sep 2003 00:36:51 -0000      1.1.2.3
 @@ -31,8 +31,8 @@
  /* Aargh!! Is this the only way we have to know if a signal interrupted
   * us in DPMI server or client code? */
  #ifdef __linux__
 -#define UCODESEL 0x23
 -#define UDATASEL 0x2b
 +#define UCODESEL ucodesel
 +#define UDATASEL udatasel
  #endif
 
  /* DANG_BEGIN_REMARK
 --- src/emu-i386/cpu.c       23 Jun 2003 00:02:08 -0000      1.1.1.1
 +++ src/emu-i386/cpu.c       30 Sep 2003 00:36:51 -0000      1.1.1.1.4.1
 @@ -96,6 +96,12 @@
  };
  #endif
 
 +/* DOSEMU code selector and data selector. Initialized at startup.
 + * These used to be 0x23 and 0x2b, but change to 0x73 and 0x7b
 + * in Linux kernel 2.6
 + */
 +unsigned short ucodesel, udatasel;
 +
  /*
   * DANG_BEGIN_FUNCTION cpu_trap_0f
   *
 @@ -241,6 +247,12 @@
  #else
    REG(eflags) |= (VIF | VIP);
  #endif
 +
 +  /* initialize user data & code selector values (used by DPMI code) */
 +  __asm__ volatile (
 +  " movw %%cs, ucodesel\n"
 +  " movw %%ds, udatasel\n"
 +  ::);
 
  #ifdef X86_EMULATOR
    if (config.cpuemu) {
 --- src/include/cpu.h       23 Jun 2003 21:13:15 -0000      1.2
 +++ src/include/cpu.h       30 Sep 2003 00:36:51 -0000      1.2.4.1
 @@ -301,4 +301,6 @@
  extern int write_port_w(unsigned int value,unsigned short port);
  int do_soft_int(int intno);
 
 +extern unsigned short ucodesel, udatasel;
 +
  #endif /* CPU_H */
 