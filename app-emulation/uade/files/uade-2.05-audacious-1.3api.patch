diff -ruN uade.orig/src/frontends/audacious/plugin.c uade/src/frontends/audacious/plugin.c
--- uade.orig/src/frontends/audacious/plugin.c	2006-07-02 13:51:17.000000000 +0200
+++ uade/src/frontends/audacious/plugin.c	2007-02-02 21:57:26.000000000 +0100
@@ -45,13 +45,13 @@
 static void uade_cleanup(void);
 static void uade_file_info(char *filename);
 static void uade_get_song_info(char *filename, char **title, int *length);
-static int uade_get_time(void);
+static int uade_get_time(InputPlayback *playback);
 static void uade_init(void);
 static int uade_is_our_file(char *filename);
-static void uade_pause(short paused);
-static void uade_play_file(char *filename);
-static void uade_seek(int time);
-static void uade_stop(void);
+static void uade_pause(InputPlayback *playback, short paused);
+static void uade_play_file(InputPlayback *playback);
+static void uade_seek(InputPlayback *playback, int time);
+static void uade_stop(InputPlayback *playback);
 static void uade_info_string(void);
 
 
@@ -371,6 +371,8 @@
 
 static void *play_loop(void *arg)
 {
+  InputPlayback *playback = arg;
+  
   enum uade_control_state state = UADE_S_STATE;
   int ret;
   int left = 0;
@@ -402,13 +404,13 @@
       uade_lock();
       if (uade_seek_forward) {
 	skip_bytes += uade_seek_forward * (UADE_BYTES_PER_FRAME * config.frequency);
-	uade_ip.output->flush(uade_ip.output->written_time() + uade_seek_forward * 1000);
+	playback->output->flush(playback->output->written_time() + uade_seek_forward * 1000);
 	uade_seek_forward = 0;
       }
       if (uade_select_sub != -1) {
 	uadesong->cur_subsong = uade_select_sub;
 	uade_change_subsong(uadesong->cur_subsong, &uadeipc);
-	uade_ip.output->flush(0);
+	playback->output->flush(0);
 	uade_select_sub = -1;
 	subsong_end = 0;
 	subsong_bytes = 0;
@@ -425,9 +427,9 @@
 	    song_end_trigger = 1;
 	  } else {
 	    uade_change_subsong(uadesong->cur_subsong, &uadeipc);
-	    while (uade_ip.output->buffer_playing())
+	    while (playback->output->buffer_playing())
 	      xmms_usleep(10000);
-	    uade_ip.output->flush(0);
+	    playback->output->flush(0);
 	    subsong_end = 0;
 	    subsong_bytes = 0;
 
@@ -444,7 +446,7 @@
       if (song_end_trigger) {
 	/* We must drain the audio fast if abort_playing happens (e.g.
 	   the user changes song when we are here waiting the sound device) */
-	while (uade_ip.output->buffer_playing() && abort_playing == 0)
+	while (playback->output->buffer_playing() && abort_playing == 0)
 
 	  xmms_usleep(10000);
 	break;
@@ -501,7 +503,7 @@
 	}
 
 	uade_effect_run(&effects, (int16_t *) um->data, play_bytes / framesize);
-	produce_audio(uade_ip.output->written_time(), sample_format, UADE_CHANNELS, play_bytes, um->data, &uade_thread_running);
+	produce_audio(playback->output->written_time(), sample_format, UADE_CHANNELS, play_bytes, um->data, &uade_thread_running);
 
 	if (config.timeout != -1 && config.use_timeouts) {
 	  if (song_end_trigger == 0) {
@@ -675,8 +677,9 @@
 }
 
 
-static void uade_play_file(char *filename)
+static void uade_play_file(InputPlayback *playback)
 {
+  char *filename = playback->filename;
   char tempname[PATH_MAX];
   char *t;
 
@@ -716,7 +719,7 @@
     uade_spawn(&uadeipc, &uadepid, UADE_CONFIG_UADE_CORE, configname);
   }
 
-  if (!uade_ip.output->open_audio(sample_format, config_backup.frequency, UADE_CHANNELS)) {
+  if (!playback->output->open_audio(sample_format, config_backup.frequency, UADE_CHANNELS)) {
     abort_playing = 1;
     return;
   }
@@ -748,7 +751,7 @@
   if (initialize_song(filename) == FALSE)
     goto err;
 
-  if (pthread_create(&decode_thread, NULL, play_loop, NULL)) {
+  if (pthread_create(&decode_thread, NULL, play_loop, playback)) {
     fprintf(stderr, "uade: can't create play_loop() thread\n");
     uade_unalloc_song(uadesong);
     uade_lock();
@@ -762,11 +765,11 @@
 
  err:
   /* close audio that was opened */
-  uade_ip.output->close_audio();
+  playback->output->close_audio();
   abort_playing = 1;
 }
 
-static void uade_stop(void)
+static void uade_stop(InputPlayback *playback)
 {
   /* Signal other subsystems to proceed to finished state as soon as possible
    */
@@ -803,22 +806,22 @@
     uade_unlock();
   }
 
-  uade_ip.output->close_audio();
+  playback->output->close_audio();
 }
 
 
 /* XMMS calls this function when pausing or unpausing */
-static void uade_pause(short paused)
+static void uade_pause(InputPlayback *playback, short paused)
 {
   uade_lock();
   uade_is_paused = paused;
   uade_unlock();
-  uade_ip.output->pause(paused);
+  playback->output->pause(paused);
 }
 
 
 /* XMMS calls this function when song is seeked */
-static void uade_seek(int time)
+static void uade_seek(InputPlayback *playback, int time)
 {
   uade_gui_seek_subsong(time);
 }
@@ -827,7 +830,7 @@
 /* XMMS calls this function periodically to determine current playing time.
    We use this function to report song name and title after play_file(),
    and to tell XMMS to end playing if song ends for any reason. */
-static int uade_get_time(void)
+static int uade_get_time(InputPlayback *playback)
 {
   if (abort_playing || last_beat_played)
     return -1;
@@ -842,7 +845,7 @@
     file_info_update(gui_module_filename, gui_player_filename, gui_modulename, gui_playername, gui_formatname);
   }
 
-  return uade_ip.output->output_time();
+  return playback->output->output_time();
 }
 
 
