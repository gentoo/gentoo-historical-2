--- nfs-utils/utils/exportfs/exports.man
+++ nfs-utils/utils/exportfs/exports.man
@@ -256,6 +256,28 @@
 then the nominted path must be a mountpoint for the exportpoint to be
 exported.
 
+.TP
+.IR fsid= num
+This option forces the filesystem identification portion of the file
+handle and file attributes used on the wire to be
+.I num
+instead of a number derived from the major and minor number of the
+block device on which the filesystem is mounted.  Any 32 bit number
+can be used, but it must be unique amongst all the exported filesystems.
+
+This can be useful for NFS failover, to ensure that both servers of
+the failover pair use the same NFS file handles for the shared filesystem
+thus avoiding stale file handles after failover.
+
+Some Linux filesystems are not mounted on a block device; exporting
+these via NFS requires the use of the
+.I fsid
+option (although that may still not be enough).
+
+The value  0 has a special meaning when use with NFSv4.  NFSv4 has a
+concept of a root of the overall exported filesystem. The export point
+exported with fsid=0 will be used as this root.
+
 .SS User ID Mapping
 .PP
 .I nfsd
--- nfs-utils/utils/statd/statd.c
+++ nfs-utils/utils/statd/statd.c
@@ -179,8 +179,10 @@
 	struct stat st;
 
 	if (stat(SM_DIR, &st) == -1 &&
-	    stat(DIR_BASE, &st) == -1)
+	    stat(DIR_BASE, &st) == -1) {
 		st.st_uid = 0;
+		st.st_gid = 0;
+	}
 
 	if (st.st_uid == 0) {
 		note(N_WARNING, "statd running as root. chown %s to choose different user\n",
@@ -399,6 +401,11 @@
 	signal (SIGTERM, killer);
 	/* WARNING: the following works on Linux and SysV, but not BSD! */
 	signal(SIGCHLD, SIG_IGN);
+	/*
+	 * Ignore SIGPIPE to avoid statd dying when peers close their
+	 * TCP connection while we're trying to reply to them.
+	 */
+	signal(SIGPIPE, SIG_IGN);
 
 	/* initialize out_port */
 	statd_get_socket(out_port);
--- nfs-utils/utils/rquotad/rquota_server.c
+++ nfs-utils/utils/rquotad/rquota_server.c
@@ -76,6 +76,7 @@
    char *pathname, *qfpathname;
    int fd, err, id, type;
    struct stat stm, stn;
+   struct rquota *rquota;
 
    /*
     * First check authentication.
@@ -168,8 +169,16 @@
           * Make a copy of the info into the last part of the remote quota
           * struct which is exactly the same.
           */
-         memcpy((caddr_t *)&result.getquota_rslt_u.gqr_rquota.rq_bhardlimit,
-                (caddr_t *)&dq_dqb, sizeof(struct dqblk));
+
+         rquota = &result.getquota_rslt_u.gqr_rquota;
+         rquota->rq_bhardlimit = dq_dqb.dqb_bhardlimit;
+         rquota->rq_bsoftlimit = dq_dqb.dqb_bsoftlimit;;
+         rquota->rq_curblocks = dq_dqb.dqb_curblocks;
+         rquota->rq_fhardlimit = dq_dqb.dqb_ihardlimit;
+         rquota->rq_fsoftlimit = dq_dqb.dqb_isoftlimit;
+         rquota->rq_curfiles = dq_dqb.dqb_curinodes;
+         rquota->rq_btimeleft = dq_dqb.dqb_btime;
+         rquota->rq_ftimeleft = dq_dqb.dqb_itime;
 
          return(&result);
       }
--- nfs-utils/utils/mountd/cache.c
+++ nfs-utils/utils/mountd/cache.c
@@ -67,6 +67,8 @@
 	if (inet_aton(ipaddr, &addr)==0)
 		return;
 
+	auth_reload();
+
 	/* addr is a valid, interesting address, find the domain name... */
 	client = client_compose(addr);
 
@@ -138,6 +140,8 @@
 		break;
 	}
 
+	auth_reload();
+
 	/* Now determine export point for this fsid/domain */
 	for (i=0 ; i < MCL_MAXTYPES; i++) {
 		for (exp = exportlist[i]; exp; exp = exp->m_next) {
@@ -236,6 +240,8 @@
 	if (qword_get(&cp, path, strlen(lbuf)) <= 0)
 		goto out;
 
+	auth_reload();
+
 	/* now find flags for this export point in this domain */
 	for (i=0 ; i < MCL_MAXTYPES; i++) {
 		for (exp = exportlist[i]; exp; exp = exp->m_next) {
