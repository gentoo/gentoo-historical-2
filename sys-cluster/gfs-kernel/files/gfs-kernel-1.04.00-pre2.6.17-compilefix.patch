diff -uNr cluster-1.04.00.orig/gfs-kernel/src/gfs/diaper.c cluster-1.04.00/gfs-kernel/src/gfs/diaper.c
--- cluster-1.04.00.orig/gfs-kernel/src/gfs/diaper.c	2007-02-23 21:57:29.000000000 +0100
+++ cluster-1.04.00/gfs-kernel/src/gfs/diaper.c	2007-03-09 18:50:02.000000000 +0100
@@ -363,7 +363,7 @@
 	if (!diaper)
 		goto fail_remove;
 
-	mutex_lock(&diaper->bd_mutex);
+	down(&diaper->bd_sem);
 	if (!diaper->bd_openers) {
 		diaper->bd_disk = gd;
 		diaper->bd_contains = diaper;
@@ -372,7 +372,7 @@
 	} else
 		printk("GFS: diaper: reopening\n");
 	diaper->bd_openers++;
-	mutex_unlock(&diaper->bd_mutex);
+	up(&diaper->bd_sem);
 
 	dh->dh_mempool = mempool_create(512,
 					mempool_alloc_slab, mempool_free_slab,
@@ -395,14 +395,14 @@
 	mempool_destroy(dh->dh_mempool);
 
  fail_bdput:
-	mutex_lock(&diaper->bd_mutex);
+	down(&diaper->bd_sem);
 	if (!--diaper->bd_openers) {
 		invalidate_bdev(diaper, 1);
 		diaper->bd_contains = NULL;
 		diaper->bd_disk = NULL;
 	} else
 		printk("GFS: diaper: not closed\n");
-	mutex_unlock(&diaper->bd_mutex);
+	up(&diaper->bd_sem);
 	bdput(diaper);	
 
  fail_remove:
@@ -438,14 +438,14 @@
 
 	mempool_destroy(dh->dh_mempool);
 
-	mutex_lock(&diaper->bd_mutex);
+	down(&diaper->bd_sem);
 	if (!--diaper->bd_openers) {
 		invalidate_bdev(diaper, 1);
 		diaper->bd_contains = NULL;
 		diaper->bd_disk = NULL;
 	} else
 		printk("GFS: diaper: not closed\n");
-	mutex_unlock(&diaper->bd_mutex);
+	up(&diaper->bd_sem);
 
 	bdput(diaper);
 	del_gendisk(gd);
diff -uNr cluster-1.04.00.orig/gfs-kernel/src/gfs/gfs.h cluster-1.04.00/gfs-kernel/src/gfs/gfs.h
--- cluster-1.04.00.orig/gfs-kernel/src/gfs/gfs.h	2007-02-27 20:53:00.000000000 +0100
+++ cluster-1.04.00/gfs-kernel/src/gfs/gfs.h	2007-03-09 18:50:02.000000000 +0100
@@ -67,8 +67,8 @@
 
 #define get_v2sdp(sb) ((struct gfs_sbd *)(sb)->s_fs_info)
 #define set_v2sdp(sb, sdp) (sb)->s_fs_info = (sdp)
-#define get_v2ip(inode) ((struct gfs_inode *)(inode)->i_private)
-#define set_v2ip(inode, ip) (inode)->i_private = (ip)
+#define get_v2ip(inode) ((struct gfs_inode *)(inode)->u.generic_ip)
+#define set_v2ip(inode, ip) (inode)->u.generic_ip = (ip)
 #define get_v2fp(file) ((struct gfs_file *)(file)->private_data)
 #define set_v2fp(file, fp) (file)->private_data = (fp)
 #define get_v2bd(bh) ((struct gfs_bufdata *)(bh)->b_private)
diff -uNr cluster-1.04.00.orig/gfs-kernel/src/gfs/glock.c cluster-1.04.00/gfs-kernel/src/gfs/glock.c
--- cluster-1.04.00.orig/gfs-kernel/src/gfs/glock.c	2007-02-07 16:25:05.000000000 +0100
+++ cluster-1.04.00/gfs-kernel/src/gfs/glock.c	2007-03-09 18:50:02.000000000 +0100
@@ -38,7 +38,7 @@
 
 struct greedy {
 	struct gfs_holder gr_gh;
-	struct delayed_work gr_work;
+	struct work_struct gr_work;
 };
 
 typedef void (*glock_examiner) (struct gfs_glock * gl);
@@ -1747,9 +1747,9 @@
  */
 
 static void
-greedy_work(struct work_struct *work)
+greedy_work(void *data)
 {
-	struct greedy *gr = container_of(work, struct greedy, gr_work.work);
+	struct greedy *gr = (struct greedy *)data;
 	struct gfs_holder *gh = &gr->gr_gh;
 	struct gfs_glock *gl = gh->gh_gl;
 	struct gfs_glock_operations *glops = gl->gl_ops;
@@ -1804,7 +1804,7 @@
 	gfs_holder_init(gl, 0, 0, gh);
 	set_bit(HIF_GREEDY, &gh->gh_iflags);
 	gh->gh_owner = NULL;
-	INIT_DELAYED_WORK(&gr->gr_work, greedy_work);
+	INIT_WORK(&gr->gr_work, greedy_work, gr);
 
 	set_bit(GLF_SKIP_WAITERS2, &gl->gl_flags);
 	schedule_delayed_work(&gr->gr_work, time);
diff -uNr cluster-1.04.00.orig/gfs-kernel/src/gfs/inode.c cluster-1.04.00/gfs-kernel/src/gfs/inode.c
--- cluster-1.04.00.orig/gfs-kernel/src/gfs/inode.c	2007-02-07 16:25:05.000000000 +0100
+++ cluster-1.04.00/gfs-kernel/src/gfs/inode.c	2007-03-09 18:50:02.000000000 +0100
@@ -97,6 +97,7 @@
 	inode->i_mtime.tv_sec = ip->i_di.di_mtime;
 	inode->i_ctime.tv_sec = ip->i_di.di_ctime;
 	inode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;
+	inode->i_blksize = PAGE_SIZE;
 	inode->i_blocks = ip->i_di.di_blocks <<
 		(ip->i_sbd->sd_sb.sb_bsize_shift - GFS_BASIC_BLOCK_SHIFT);
 	inode->i_generation = ip->i_di.di_header.mh_incarn;
diff -uNr cluster-1.04.00.orig/gfs-kernel/src/gfs/ops_file.c cluster-1.04.00/gfs-kernel/src/gfs/ops_file.c
--- cluster-1.04.00.orig/gfs-kernel/src/gfs/ops_file.c	2007-02-07 16:25:05.000000000 +0100
+++ cluster-1.04.00/gfs-kernel/src/gfs/ops_file.c	2007-03-09 18:50:02.000000000 +0100
@@ -74,10 +74,9 @@
 };
 
 typedef ssize_t(*do_rw_t) (struct file * file,
-						   char *buf,
-						   size_t size, loff_t * offset,
-                           struct kiocb *iocb,
-						   unsigned int num_gh, struct gfs_holder * ghs);
+			   char *buf,
+			   size_t size, loff_t * offset,
+			   unsigned int num_gh, struct gfs_holder * ghs);
 
 /**
  * gfs_llseek - seek to a location in a file
@@ -130,7 +129,7 @@
 
 static ssize_t
 walk_vm_hard(struct file *file, char *buf, size_t size, loff_t *offset,
-	     struct kiocb *iocb, do_rw_t operation)
+	     do_rw_t operation)
 {
 	struct gfs_holder *ghs;
 	unsigned int num_gh = 0;
@@ -179,7 +178,7 @@
 		gfs_assert(get_v2sdp(sb), x == num_gh,);
 	}
 
-	count = operation(file, buf, size, offset, iocb, num_gh, ghs);
+	count = operation(file, buf, size, offset, num_gh, ghs);
 
 	while (num_gh--)
 		gfs_holder_uninit(&ghs[num_gh]);
@@ -205,7 +204,7 @@
 
 static ssize_t
 walk_vm(struct file *file, char *buf, size_t size, loff_t *offset,
-		struct kiocb *iocb,	do_rw_t operation)
+	do_rw_t operation)
 {
 	if (current->mm) {
 		struct super_block *sb = file->f_dentry->d_inode->i_sb;
@@ -232,11 +231,11 @@
 
 	{
 		struct gfs_holder gh;
-		return operation(file, buf, size, offset, iocb, 0, &gh);
+		return operation(file, buf, size, offset, 0, &gh);
 	}
 
  do_locks:
-	return walk_vm_hard(file, buf, size, offset,  iocb, operation);
+	return walk_vm_hard(file, buf, size, offset, operation);
 }
 
 /**
@@ -251,8 +250,7 @@
  */
 
 static ssize_t
-do_read_readi(struct file *file, char *buf, size_t size, loff_t *offset,
-			  struct kiocb *iocb)
+do_read_readi(struct file *file, char *buf, size_t size, loff_t *offset)
 {
 	struct gfs_inode *ip = get_v2ip(file->f_mapping->host);
 	ssize_t count = 0;
@@ -293,8 +291,7 @@
 
 static ssize_t
 do_read_direct(struct file *file, char *buf, size_t size, loff_t *offset,
-			   struct kiocb *iocb,
-			   unsigned int num_gh, struct gfs_holder *ghs)
+	       unsigned int num_gh, struct gfs_holder *ghs)
 {
 	struct inode *inode = file->f_mapping->host;
 	struct gfs_inode *ip = get_v2ip(inode);
@@ -327,18 +324,10 @@
 		if (((*offset) & mask) || (((unsigned long)buf) & mask))
 			goto out_gunlock;
 
-		count = do_read_readi(file, buf, size & ~mask, offset, iocb);
-	}
-	else {
-		if (!iocb)
-			count = do_sync_read(file, buf, size, offset);
-		else {
-			struct iovec local_iov = { .iov_base = buf, .iov_len = size};
-
-			count = generic_file_aio_read(iocb, &local_iov, 1, *offset);
-			iocb->ki_pos = *offset;
-		}
+		count = do_read_readi(file, buf, size & ~mask, offset);
 	}
+	else
+		count = generic_file_read(file, buf, size, offset);
 
 	error = 0;
 
@@ -367,8 +356,7 @@
 
 static ssize_t
 do_read_buf(struct file *file, char *buf, size_t size, loff_t *offset,
-			struct kiocb *iocb,
-			unsigned int num_gh, struct gfs_holder *ghs)
+	    unsigned int num_gh, struct gfs_holder *ghs)
 {
 	struct gfs_inode *ip = get_v2ip(file->f_mapping->host);
 	ssize_t count = 0;
@@ -382,17 +370,9 @@
 
 	if (gfs_is_jdata(ip) ||
 	    (gfs_is_stuffed(ip) && !test_bit(GIF_PAGED, &ip->i_flags)))
-		count = do_read_readi(file, buf, size, offset, iocb);
-	else {
-		if (!iocb) {
-			count = do_sync_read(file, buf, size, offset);
-		} else {
-			struct iovec local_iov = { .iov_base = buf, .iov_len = size};
-
-			count = generic_file_aio_read(iocb, &local_iov, 1, *offset);
-			iocb->ki_pos = *offset;
-		}
-	}
+		count = do_read_readi(file, buf, size, offset);
+	else
+		count = generic_file_read(file, buf, size, offset);
 
 	gfs_glock_dq_m(num_gh + 1, ghs);
 
@@ -402,18 +382,6 @@
 	return (count) ? count : error;
 }
 
-static ssize_t
-__gfs_read(struct file *file, char *buf, size_t size, loff_t *offset,
-		 struct kiocb *iocb)
-{
-	atomic_inc(&get_v2sdp(file->f_mapping->host->i_sb)->sd_ops_file);
-
-	if (file->f_flags & O_DIRECT)
-		return walk_vm(file, buf, size, offset, iocb, do_read_direct);
-	else
-		return walk_vm(file, buf, size, offset, iocb, do_read_buf);
-}
-
 /**
  * gfs_read - Read bytes from a file
  * @file: The file to read from
@@ -429,21 +397,12 @@
 static ssize_t
 gfs_read(struct file *file, char *buf, size_t size, loff_t *offset)
 {
-	return(__gfs_read(file, buf, size, offset, NULL));
-}
-
-/*
- * gfs_aio_read: match with vfs generic_file_aio_read as:
- * 	(struct kiocb *iocb, char __user *buf, size_t count, loff_t pos)
- */
-static ssize_t
-gfs_aio_read(struct kiocb *iocb, const struct iovec *iov, unsigned long count,
-			 loff_t pos)
-{
-	struct file *filp = iocb->ki_filp;
+	atomic_inc(&get_v2sdp(file->f_mapping->host->i_sb)->sd_ops_file);
 
-	BUG_ON(iocb->ki_pos != pos);
-	return(__gfs_read(filp, iov->iov_base, iov->iov_len, &iocb->ki_pos, iocb));
+	if (file->f_flags & O_DIRECT)
+		return walk_vm(file, buf, size, offset, do_read_direct);
+	else
+		return walk_vm(file, buf, size, offset, do_read_buf);
 }
 
 /**
@@ -478,41 +437,6 @@
 }
 
 /**
- * gfs_file_aio_write_nolock - Call vfs aio layer to write bytes to a file
- * @file: The file to write to
- * @buf: The buffer to copy from
- * @size: The amount of data requested
- * @offset: The offset in the file to write
- * @iocb: The io control block.  If NULL, a temporary one will be used.
- *
- * Returns: The number of bytes written, errno on failure
- */
-static ssize_t
-gfs_file_aio_write_nolock(struct file *file, char *buf, size_t size,
-						  loff_t *offset, struct kiocb *iocb)
-{
-	struct iovec local_iov = { .iov_base = buf, .iov_len = size };
-	struct kiocb local_iocb, *kiocb = NULL;
-	ssize_t count;
-
-	if (!iocb) {
-		init_sync_kiocb(&local_iocb, file);
-		local_iocb.ki_nr_segs = 1;
-		kiocb = &local_iocb;
-	}
-	else
-		kiocb = iocb;
-	
-	kiocb->ki_pos = *offset;
-	count = generic_file_aio_write_nolock(kiocb, &local_iov, kiocb->ki_nr_segs,
-										  kiocb->ki_pos);
-	*offset = kiocb->ki_pos;
-	if (kiocb == &local_iocb && count == -EIOCBQUEUED)
-		count = wait_on_sync_kiocb(kiocb);
-	return count;
-}
-
-/**
  * do_write_direct_alloc - Write bytes to a file
  * @file: The file to write to
  * @buf: The buffer to copy from
@@ -525,13 +449,13 @@
  */
 
 static ssize_t
-do_write_direct_alloc(struct file *file, char *buf, size_t size, loff_t *offset,
-			struct kiocb *iocb)
+do_write_direct_alloc(struct file *file, char *buf, size_t size, loff_t *offset)
 {
 	struct inode *inode = file->f_mapping->host;
 	struct gfs_inode *ip = get_v2ip(inode);
 	struct gfs_sbd *sdp = ip->i_sbd;
 	struct gfs_alloc *al = NULL;
+	struct iovec local_iov = { .iov_base = buf, .iov_len = size };
 	struct buffer_head *dibh;
 	unsigned int data_blocks, ind_blocks;
 	ssize_t count;
@@ -584,7 +508,7 @@
 			goto fail_end_trans;
 	}
 
-	count = gfs_file_aio_write_nolock(file, buf, size, offset, iocb);
+	count = generic_file_write_nolock(file, &local_iov, 1, offset);
 	if (count < 0) {
 		error = count;
 		goto fail_end_trans;
@@ -652,7 +576,6 @@
 
 static ssize_t
 do_write_direct(struct file *file, char *buf, size_t size, loff_t *offset,
-		struct kiocb *iocb,
 		unsigned int num_gh, struct gfs_holder *ghs)
 {
 	struct gfs_inode *ip = get_v2ip(file->f_mapping->host);
@@ -723,19 +646,13 @@
 	if (alloc_required) {
 		set_bit(GFF_DID_DIRECT_ALLOC, &fp->f_flags);
 
-		/* for asynchronous IO, the buffer can not be splitted */
-		if (iocb) {
-			count = do_write_direct_alloc(file, buf, size, offset, iocb);
-			goto out_iocb_write;
-		}
-
 		/* split large writes into smaller atomic transactions */
 		while (size) {
 			s = gfs_tune_get(sdp, gt_max_atomic_write);
 			if (s > size)
 				s = size;
 
-			error = do_write_direct_alloc(file, buf, s, offset, iocb);
+			error = do_write_direct_alloc(file, buf, s, offset);
 			if (error < 0)
 				goto out_gunlock;
 
@@ -744,6 +661,7 @@
 			count += error;
 		}
 	} else {
+		struct iovec local_iov = { .iov_base = buf, .iov_len = size };
 		struct gfs_holder t_gh;
 
 		clear_bit(GFF_DID_DIRECT_ALLOC, &fp->f_flags);
@@ -752,17 +670,17 @@
 		if (error)
 			goto out_gunlock;
 
-		count = gfs_file_aio_write_nolock(file, buf, size, offset, iocb);
+		count = generic_file_write_nolock(file, &local_iov, 1, offset);
+
 		gfs_glock_dq_uninit(&t_gh);
 	}
 
-out_iocb_write:
 	error = 0;
 
-out_gunlock:
+      out_gunlock:
 	gfs_glock_dq_m(num_gh + 1, ghs);
 
-out:
+      out:
 	gfs_holder_uninit(&ghs[num_gh]);
 
 	return (count) ? count : error;
@@ -781,8 +699,7 @@
  */
 
 static ssize_t
-do_do_write_buf(struct file *file, char *buf, size_t size, loff_t *offset,
-				struct kiocb *iocb)
+do_do_write_buf(struct file *file, char *buf, size_t size, loff_t *offset)
 {
 	struct inode *inode = file->f_mapping->host;
 	struct gfs_inode *ip = get_v2ip(inode);
@@ -860,7 +777,7 @@
 	    (gfs_is_stuffed(ip) && !test_bit(GIF_PAGED, &ip->i_flags) &&
 	     *offset + size <= sdp->sd_sb.sb_bsize - sizeof(struct gfs_dinode))) {
 
-		count = gfs_writei(ip, buf, *offset, size, gfs_copy_from_user, iocb);
+		count = gfs_writei(ip, buf, *offset, size, gfs_copy_from_user,NULL);
 		if (count < 0) {
 			error = count;
 			goto fail_end_trans;
@@ -875,7 +792,9 @@
 		}
 		*offset += count;
 	} else {
-		count = gfs_file_aio_write_nolock(file, buf, size, offset, iocb);
+		struct iovec local_iov = { .iov_base = buf, .iov_len = size };
+
+		count = generic_file_write_nolock(file, &local_iov, 1, offset);
 		if (count < 0) {
 			error = count;
 			goto fail_end_trans;
@@ -950,9 +869,8 @@
 
 static ssize_t
 do_write_buf(struct file *file,
-			 char *buf, size_t size, loff_t *offset,
-			 struct kiocb *iocb,
-			 unsigned int num_gh, struct gfs_holder *ghs)
+	     char *buf, size_t size, loff_t *offset,
+	     unsigned int num_gh, struct gfs_holder *ghs)
 {
 	struct gfs_inode *ip = get_v2ip(file->f_mapping->host);
 	struct gfs_sbd *sdp = ip->i_sbd;
@@ -989,7 +907,7 @@
 		if (s > size)
 			s = size;
 
-		error = do_do_write_buf(file, buf, s, offset, iocb);
+		error = do_do_write_buf(file, buf, s, offset);
 		if (error < 0)
 			goto out_gunlock;
 
@@ -1022,7 +940,7 @@
  */
 
 static ssize_t
-__gfs_write(struct file *file, const char *buf, size_t size, loff_t *offset, struct kiocb *iocb)
+gfs_write(struct file *file, const char *buf, size_t size, loff_t *offset)
 {
 	struct inode *inode = file->f_mapping->host;
 	ssize_t count;
@@ -1036,32 +954,14 @@
 
 	mutex_lock(&inode->i_mutex);
 	if (file->f_flags & O_DIRECT)
-		count = walk_vm(file, (char *)buf, size, offset, iocb, do_write_direct);
+		count = walk_vm(file, (char *)buf, size, offset, do_write_direct);
 	else
-		count = walk_vm(file, (char *)buf, size, offset, iocb, do_write_buf);
+		count = walk_vm(file, (char *)buf, size, offset, do_write_buf);
 	mutex_unlock(&inode->i_mutex);
 
 	return count;
 }
 
-static ssize_t
-gfs_write(struct file *file, const char *buf, size_t size, loff_t *offset)
-{
-	return(__gfs_write(file, buf, size, offset, NULL));
-}
-
-static ssize_t
-gfs_aio_write(struct kiocb *iocb, const struct iovec *iov, unsigned long segs,
-			  loff_t pos)
-{
-	struct file *file = iocb->ki_filp;
-
-	BUG_ON(iocb->ki_pos != pos);
-
-	return(__gfs_write(file, iov->iov_base, iov->iov_len, &iocb->ki_pos, 
-					   iocb));
-}
-
 /**
  * filldir_reg_func - Report a directory entry to the caller of gfs_dir_read()
  * @opaque: opaque data used by the function
@@ -1565,13 +1465,12 @@
 
 	if (sdp->sd_args.ar_localflocks) {
 		if (IS_GETLK(cmd)) {
-			struct file_lock tmp;
-			int ret;
+			struct file_lock *tmp;
 			lock_kernel();
-			ret = posix_test_lock(file, fl, &tmp);
+			tmp = posix_test_lock(file, fl);
 			fl->fl_type = F_UNLCK;
-			if (ret)
-				memcpy(fl, &tmp, sizeof(struct file_lock));
+			if (tmp)
+				memcpy(fl, tmp, sizeof(struct file_lock));
 			unlock_kernel();
 		        return 0;
 		} else {
@@ -1747,8 +1646,6 @@
 	.llseek = gfs_llseek,
 	.read = gfs_read,
 	.write = gfs_write,
-	.aio_read = gfs_aio_read,
-	.aio_write = gfs_aio_write,
 	.ioctl = gfs_ioctl,
 	.mmap = gfs_mmap,
 	.open = gfs_open,
diff -uNr cluster-1.04.00.orig/gfs-kernel/src/gfs/ops_inode.c cluster-1.04.00/gfs-kernel/src/gfs/ops_inode.c
--- cluster-1.04.00.orig/gfs-kernel/src/gfs/ops_inode.c	2007-02-07 16:25:05.000000000 +0100
+++ cluster-1.04.00/gfs-kernel/src/gfs/ops_inode.c	2007-03-09 18:50:02.000000000 +0100
@@ -171,22 +171,22 @@
 	parent = dget_parent(dentry);
 
 	if (gfs_filecmp(&dentry->d_name, "@hostname", 9))
-		new = lookup_one_len(init_utsname()->nodename,
+		new = lookup_one_len(system_utsname.nodename,
 				     parent,
-				     strlen(init_utsname()->nodename));
+				     strlen(system_utsname.nodename));
 	else if (gfs_filecmp(&dentry->d_name, "@nodeid", 7))
 		new = lookup_one_len(buf, 
 				     parent, 
 				     sprintf(buf, "%s%i", "node", 
 					     get_my_nodeid()));
 	else if (gfs_filecmp(&dentry->d_name, "@mach", 5))
-		new = lookup_one_len(init_utsname()->machine,
+		new = lookup_one_len(system_utsname.machine,
 				     parent,
-				     strlen(init_utsname()->machine));
+				     strlen(system_utsname.machine));
 	else if (gfs_filecmp(&dentry->d_name, "@os", 3))
-		new = lookup_one_len(init_utsname()->sysname,
+		new = lookup_one_len(system_utsname.sysname,
 				     parent,
-				     strlen(init_utsname()->sysname));
+				     strlen(system_utsname.sysname));
 	else if (gfs_filecmp(&dentry->d_name, "@uid", 4))
 		new = lookup_one_len(buf,
 				     parent,
@@ -199,8 +199,8 @@
 		new = lookup_one_len(buf,
 				     parent,
 				     sprintf(buf, "%s_%s",
-					     init_utsname()->machine,
-					     init_utsname()->sysname));
+					     system_utsname.machine,
+					     system_utsname.sysname));
 	else if (gfs_filecmp(&dentry->d_name, "@jid", 4))
 		new = lookup_one_len(buf,
 				     parent,
@@ -235,22 +235,22 @@
 	parent = dget_parent(dentry);
 
 	if (gfs_filecmp(&dentry->d_name, "{hostname}", 10))
-		new = lookup_one_len(init_utsname()->nodename,
+		new = lookup_one_len(system_utsname.nodename,
 				     parent,
-				     strlen(init_utsname()->nodename));
+				     strlen(system_utsname.nodename));
 	else if (gfs_filecmp(&dentry->d_name, "{nodeid}", 8))
 		new = lookup_one_len(buf,
 				     parent,
 				     sprintf(buf, "%s%i", "node",
 					     get_my_nodeid()));
 	else if (gfs_filecmp(&dentry->d_name, "{mach}", 6))
-		new = lookup_one_len(init_utsname()->machine,
+		new = lookup_one_len(system_utsname.machine,
 				     parent,
-				     strlen(init_utsname()->machine));
+				     strlen(system_utsname.machine));
 	else if (gfs_filecmp(&dentry->d_name, "{os}", 4))
-		new = lookup_one_len(init_utsname()->sysname,
+		new = lookup_one_len(system_utsname.sysname,
 				     parent,
-				     strlen(init_utsname()->sysname));
+				     strlen(system_utsname.sysname));
 	else if (gfs_filecmp(&dentry->d_name, "{uid}", 5))
 		new = lookup_one_len(buf,
 				     parent,
@@ -263,8 +263,8 @@
 		new = lookup_one_len(buf,
 				     parent,
 				     sprintf(buf, "%s_%s",
-					     init_utsname()->machine,
-					     init_utsname()->sysname));
+					     system_utsname.machine,
+					     system_utsname.sysname));
 	else if (gfs_filecmp(&dentry->d_name, "{jid}", 5))
 		new = lookup_one_len(buf,
 				     parent,
diff -uNr cluster-1.04.00.orig/gfs-kernel/src/nolock/main.c cluster-1.04.00/gfs-kernel/src/nolock/main.c
--- cluster-1.04.00.orig/gfs-kernel/src/nolock/main.c	2007-02-27 20:53:41.000000000 +0100
+++ cluster-1.04.00/gfs-kernel/src/nolock/main.c	2007-03-09 18:50:02.000000000 +0100
@@ -244,14 +244,13 @@
 		 struct lm_lockname *name,
 		 struct file *file, struct file_lock *fl)
 {
-	struct file_lock tmp;
-	int ret;
+	struct file_lock *tmp;
 
 	lock_kernel();
-	ret = posix_test_lock(file, fl, &tmp);
+	tmp = posix_test_lock(file, fl);
 	fl->fl_type = F_UNLCK;
-	if (ret)
-		memcpy(fl, &tmp, sizeof(struct file_lock));
+	if (tmp)
+		memcpy(fl, tmp, sizeof(struct file_lock));
 	unlock_kernel();
 
 	return 0;
