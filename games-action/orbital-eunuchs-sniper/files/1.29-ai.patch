--- src/ai_orig.cpp	2003-03-17 17:22:17.000000000 +0100
+++ src/ai.cpp	2004-10-16 22:51:57.103455879 +0200
@@ -479,7 +480,7 @@
         int nolineofsight = 1;
 
         // Do we have line of sight to the VIP?
-        if (route((int)c.mX, (int)c.mY, (int)Game.characters[c.mTarget].mX, (int)Game.characters[c.mTarget].mY))
+        if (c.mTarget != -1 && route((int)c.mX, (int)c.mY, (int)Game.characters[c.mTarget].mX, (int)Game.characters[c.mTarget].mY))
         {
             nolineofsight = 0;
             // Calculate new vector to it
@@ -541,7 +542,30 @@
             {            
                 // Find a new waypoint
                 
-                if (nolineofsight)
+                if (c.mTarget == -1)
+                {
+		    int oldWaypoint = c.mNextWaypoint;
+
+		    // just choose the next-closest waypoint in the area (I know: we'll cycle).
+                    c.mNextWaypoint = 0;
+                    int i;
+                    float dist = distance_wp(0, c.mX, c.mY);
+                    for (i = 1; i < Game.num_waypoints; i++)
+                    {
+			if (i != oldWaypoint) {
+			    float newdist = distance_wp(i, c.mX, c.mY);
+			    if (newdist < dist && route(Game.waypoints[i].mX, Game.waypoints[i].mY, (int)c.mX, (int)c.mY))
+			    {
+				dist = newdist;
+				c.mNextWaypoint = i;
+			    }
+			}
+                    }
+                    // Calculate vector towards the closest waypoint
+                    c.mXi = ((Game.waypoints[c.mNextWaypoint].mX - c.mX) / dist) * c.mSpeed;
+                    c.mYi = ((Game.waypoints[c.mNextWaypoint].mY - c.mY) / dist) * c.mSpeed;
+                }
+                else if (nolineofsight)
                 {   
                     // Can't see the VIP, try to figure out the closest waypoint to target that's connected from here
                     int next = 0;
 
