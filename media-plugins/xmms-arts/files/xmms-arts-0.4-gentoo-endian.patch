diff -Nru xmms-arts-0.4-clean/audio.c xmms-arts-0.4/audio.c
--- xmms-arts-0.4-clean/audio.c	2002-10-25 13:11:54.000000000 -0500
+++ xmms-arts-0.4/audio.c	2002-10-25 13:13:11.000000000 -0500
@@ -1,4 +1,4 @@
-/*      xmms - esound output plugin
+/*      xmms - artsd output plugin
  *    Copyright (C) 1999      Galex Yen
  *
  *      this program is free software
@@ -11,11 +11,20 @@
  *
  *              Contains code Copyright (C) 1998-1999 Mikael Alm, Olle Hallnas,
  *              Thomas Nillson and 4Front Technologies
+ *
+ * 
+ *	    2002 Oct 13 Balint Cristian (rezso@rdsor.ro) 
+ *				- fix 16 bit endianess
+ *				- change topic to "artsd" instead "esd"
+ *
+ *
+ *
  */
 
 #include "artsout.h"
 #include "config.h"
 
+
 static gpointer buffer;
 static gboolean going = FALSE, prebuffer, paused = FALSE, remove_prebuffer = FALSE;
 static gint buffer_size, prebuffer_size, blk_size = 4096;
@@ -30,10 +39,72 @@
 static arts_stream_t stream = 0;
 static pthread_t buffer_thread;
 static gboolean realtime = FALSE;
+static void *(*artsd_translate)(void *, gint);
+int artsd_format;
+
+static void *artsd_stou8(void *data, gint length)
+{
+	int len = length;
+	unsigned char *dat = (unsigned char *)data;
+	while (len-- > 0)
+		*dat++ ^= 0x80;
+	return data;
+}
+
+static void *artsd_utos16sw(void *data, gint length)
+{
+	int len = length;
+	short *dat = data;
+	while ( len > 0 ) {
+		*dat = GUINT16_SWAP_LE_BE( *dat ) ^ 0x8000;
+		dat++;
+		len-=2;
+	}
+	return data;
+}
+static void *artsd_utos16(void *data, gint length)
+{
+	int len = length;
+	short *dat = data;
+	while ( len > 0 ) {
+		*dat ^= 0x8000;
+		dat++;
+		len-=2;
+	}
+	return data;
+}
+static void *artsd_16sw(void *data, gint length)
+{
+	int len = length;
+	short *dat = data;
+	while ( len > 0 ) {
+		*dat = GUINT16_SWAP_LE_BE( *dat );
+		dat++;
+		len-=2;
+	}
+	return data;
+}
+
+static void *artsd_none(void *data, gint length)
+{
+	int len = length;
+	short *dat = data;
+	while ( len > 0 ) {
+		*dat = *dat;
+		dat++;
+		len-=2;
+	}
+	return data;
+}
+
 
 
 static void artsd_setup_format(AFormat fmt,gint rate, gint nch)
 {
+
+	gboolean swap_sign = FALSE;
+	gboolean swap_16 = FALSE;
+
 	format = fmt;
 	frequency = rate;
 	channels = nch;
@@ -41,14 +112,16 @@
 	latency = arts_stream_get(stream,ARTS_P_SERVER_LATENCY)  * frequency / 44100 * channels;
 
 	switch(fmt) {
-	        case FMT_U8:
-		case FMT_S8:
+	        case FMT_S8:
+			swap_sign = TRUE;
+		case FMT_U8:
 			latency *= 2;
 			sample_width = 8;
 			break;
 		case FMT_U16_LE:
 		case FMT_U16_BE:
 		case FMT_U16_NE:
+			swap_sign = TRUE;
 		case FMT_S16_LE:
 		case FMT_S16_BE:
 		case FMT_S16_NE:
@@ -56,8 +129,19 @@
 			bps *= 2;
 			break;
 	}
-}
 
+if (sample_width == 16)
+
+#ifdef WORDS_BIGENDIAN
+	    artsd_translate = artsd_16sw;
+#else
+	    artsd_translate = artsd_none;
+#endif
+
+else
+	    artsd_translate = artsd_none;
+
+} 
 
 gint artsd_get_written_time(void)
 {
@@ -158,11 +242,12 @@
 	if(effects_enabled() && ep && ep->mod_samples)
 		length = ep->mod_samples(&data,length, input_format, input_frequency, input_channels);
 
-	errorcode = arts_write(stream,data,length);
+	errorcode = arts_write(stream,artsd_translate(data,length),length);
 	if(errorcode < 0)
 		fprintf(stderr,"arts_write error: %s\n",arts_error_text(errorcode));
-	else
+	else	
   		output_bytes += errorcode;
+	
 }
 
 
diff -Nru xmms-arts-0.4-clean/configure xmms-arts-0.4/configure
--- xmms-arts-0.4-clean/configure	2002-10-25 13:11:56.000000000 -0500
+++ xmms-arts-0.4/configure	2002-10-25 13:12:43.000000000 -0500
@@ -2434,6 +2434,95 @@
 echo "${ECHO_T}no, using $LN_S" >&6
 fi
 
+echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
+echo "configure:1409: checking whether byte ordering is bigendian" >&5
+if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  ac_cv_c_bigendian=unknown
+# See if sys/param.h defines the BYTE_ORDER macro.
+cat > conftest.$ac_ext <<EOF
+#line 1416 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/param.h>
+int main() {
+
+#if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
+ bogus endian macros
+#endif
+; return 0; }
+EOF
+if { (eval echo configure:1427: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  # It does; now see whether it defined to BIG_ENDIAN or not.
+cat > conftest.$ac_ext <<EOF
+#line 1431 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/param.h>
+int main() {
+
+#if BYTE_ORDER != BIG_ENDIAN
+ not big endian
+#endif
+; return 0; }
+EOF
+if { (eval echo configure:1442: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_c_bigendian=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_c_bigendian=no
+fi
+rm -f conftest*
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+fi
+rm -f conftest*
+if test $ac_cv_c_bigendian = unknown; then
+if test "$cross_compiling" = yes; then
+    { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
+else
+  cat > conftest.$ac_ext <<EOF
+#line 1462 "configure"
+#include "confdefs.h"
+main () {
+  /* Are we little or big endian?  From Harbison&Steele.  */
+  union
+  {
+    long l;
+    char c[sizeof (long)];
+  } u;
+  u.l = 1;
+  exit (u.c[sizeof (long) - 1] == 1);
+}
+EOF
+if { (eval echo configure:1475: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  ac_cv_c_bigendian=no
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  ac_cv_c_bigendian=yes
+fi
+rm -fr conftest*
+fi
+
+fi
+fi
+
+echo "$ac_t""$ac_cv_c_bigendian" 1>&6
+if test $ac_cv_c_bigendian = yes; then
+  cat >> confdefs.h <<\EOF
+#define WORDS_BIGENDIAN 1
+EOF
+
+fi
 
 
 # Check for any special flags to pass to ltconfig.
diff -Nru xmms-arts-0.4-clean/configure.in xmms-arts-0.4/configure.in
--- xmms-arts-0.4-clean/configure.in	2000-11-20 22:30:00.000000000 -0600
+++ xmms-arts-0.4/configure.in	2002-10-25 13:12:58.000000000 -0500
@@ -15,6 +15,7 @@
 dnl Checks for header files.
 AC_STDC_HEADERS
 AC_CHECK_HEADERS(fcntl.h sys/time.h)
+AC_C_BIGENDIAN
 
 dnl Checks for Gtk+
 AM_PATH_GLIB(1.2.0,,AC_MSG_ERROR([*** GLIB >= 1.2.0 not installed - please install first ***]))
