diff -ur gst-plugins-0.8.5/ext/alsa/gstalsa.c gst-plugins-0.8.5/ext/alsa.new/gstalsa.c
--- gst-plugins-0.8.5/ext/alsa/gstalsa.c	2004-08-06 17:18:46.000000000 +0100
+++ gst-plugins-0.8.5/ext/alsa.new/gstalsa.c	2004-11-11 10:27:01.000000000 +0000
@@ -51,6 +51,7 @@
 static void gst_alsa_class_init (gpointer g_class, gpointer class_data);
 static void gst_alsa_init (GstAlsa * this);
 static void gst_alsa_dispose (GObject * object);
+static void gst_alsa_finalize (GObject * object);
 static void gst_alsa_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec);
 static void gst_alsa_get_property (GObject * object,
@@ -161,6 +162,7 @@
     parent_class = g_type_class_ref (GST_TYPE_ELEMENT);
 
   object_class->dispose = gst_alsa_dispose;
+  object_class->finalize = gst_alsa_finalize;
   object_class->get_property = gst_alsa_get_property;
   object_class->set_property = gst_alsa_set_property;
 
@@ -218,15 +220,24 @@
 {
   GstAlsa *this = GST_ALSA (object);
 
-  g_free (this->device);
-
-  if (this->clock)
+  if (this->clock) {
     gst_object_unparent (GST_OBJECT (this->clock));
+    this->clock = NULL;
+  }
 
   G_OBJECT_CLASS (parent_class)->dispose (object);
 }
 
 static void
+gst_alsa_finalize (GObject * object)
+{
+  GstAlsa *this = GST_ALSA (object);
+
+  g_free (this->device);
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
 gst_alsa_set_property (GObject * object, guint prop_id, const GValue * value,
     GParamSpec * pspec)
 {
@@ -695,6 +706,7 @@
       return NULL;
 
     return gst_caps_new_simple ("audio/x-raw-float",
+        "buffer-frames", GST_TYPE_INT_RANGE, 0, G_MAXINT,
         "width", G_TYPE_INT, (gint) snd_pcm_format_width (format),
         "endianness", G_TYPE_INT, G_BYTE_ORDER, NULL);
   }
@@ -1088,9 +1100,6 @@
         return GST_STATE_FAILURE;
       break;
     case GST_STATE_READY_TO_PAUSED:
-      if (!(GST_FLAG_IS_SET (element, GST_ALSA_RUNNING) ||
-              gst_alsa_start_audio (this)))
-        return GST_STATE_FAILURE;
       this->played = 0;
       this->captured = 0;
       break;
@@ -1101,8 +1110,14 @@
               snd_strerror (err));
           return GST_STATE_FAILURE;
         }
-      } else if (!(GST_FLAG_IS_SET (element, GST_ALSA_RUNNING) ||
-              gst_alsa_start_audio (this))) {
+      }
+      /* If we were already negotiated, but we are not running, then
+       * we stopped (probably because we paused), so re-start. If
+       * there's no format, we didn't negotiate yet so don't do
+       * anything because ALSA will crash (#151288, #153227, etc.). */
+      else if (this->format != NULL &&
+          !GST_FLAG_IS_SET (element, GST_ALSA_RUNNING) &&
+          !gst_alsa_start_audio (this)) {
         return GST_STATE_FAILURE;
       }
       gst_alsa_clock_start (this->clock);
@@ -1195,8 +1195,9 @@
 gst_alsa_pcm_wait (GstAlsa * this)
 {
   int err;
+  snd_pcm_state_t state = snd_pcm_state (this->handle);
 
-  if (snd_pcm_state (this->handle) == SND_PCM_STATE_RUNNING) {
+  if (state == SND_PCM_STATE_RUNNING) {
     if ((err = snd_pcm_wait (this->handle, 1000)) < 0) {
       if (err == EINTR) {
         /* happens mostly when run under gdb, or when exiting due to a signal */
@@ -1213,6 +1214,9 @@
         return FALSE;
       }
     }
+  } else {
+    GST_INFO_OBJECT (this, "in state %s, not waiting",
+        snd_pcm_state_name (state));
   }
   return TRUE;
 }
diff -ur gst-plugins-0.8.5/ext/alsa/gstalsamixer.c gst-plugins-0.8.5/ext/alsa.new/gstalsamixer.c
--- gst-plugins-0.8.5/ext/alsa/gstalsamixer.c	2004-10-06 17:03:28.000000000 +0100
+++ gst-plugins-0.8.5/ext/alsa.new/gstalsamixer.c	2004-10-27 11:58:52.000000000 +0100
@@ -264,26 +264,45 @@
 
   /* build track list */
   for (i = 0; i < count; i++) {
-    gint channels = 0;
+    GList *item;
+    gint channels = 0, samename = 0;
     gint flags = GST_MIXER_TRACK_OUTPUT;
     gboolean got_it = FALSE;
 
     if (snd_mixer_selem_has_capture_switch (element)) {
       if (dir != GST_PAD_SRC && dir != GST_PAD_UNKNOWN)
-        continue;
+        goto next;
       flags = GST_MIXER_TRACK_INPUT;
     } else {
       if (dir != GST_PAD_SINK && dir != GST_PAD_UNKNOWN)
-        continue;
+        goto next;
+    }
+
+    /* prevent dup names */
+    for (item = mixer->tracklist; item != NULL; item = item->next) {
+      snd_mixer_elem_t *temp;
+
+      if (GST_IS_ALSA_MIXER_OPTIONS (item->data))
+        temp = GST_ALSA_MIXER_OPTIONS (item->data)->element;
+      else
+        temp = GST_ALSA_MIXER_TRACK (item->data)->element;
+
+      if (!strcmp (snd_mixer_selem_get_name (element),
+              snd_mixer_selem_get_name (temp)))
+        samename++;
     }
 
     if (snd_mixer_selem_has_capture_volume (element)) {
       while (snd_mixer_selem_has_capture_channel (element, channels))
         channels++;
-      track = gst_alsa_mixer_track_new (element, i, channels,
-          flags, GST_ALSA_MIXER_TRACK_CAPTURE);
+      track = gst_alsa_mixer_track_new (element, samename,
+          i, channels, flags, GST_ALSA_MIXER_TRACK_CAPTURE);
       mixer->tracklist = g_list_append (mixer->tracklist, track);
       got_it = TRUE;
+
+      /* there might be another volume slider; make that playback */
+      flags &= ~GST_MIXER_TRACK_INPUT;
+      flags |= GST_MIXER_TRACK_OUTPUT;
     }
 
     if (snd_mixer_selem_has_playback_volume (element)) {
@@ -293,8 +312,8 @@
         first = FALSE;
         flags |= GST_MIXER_TRACK_MASTER;
       }
-      track = gst_alsa_mixer_track_new (element, i, channels,
-          flags, GST_ALSA_MIXER_TRACK_PLAYBACK);
+      track = gst_alsa_mixer_track_new (element, samename,
+          i, channels, flags, GST_ALSA_MIXER_TRACK_PLAYBACK);
       mixer->tracklist = g_list_append (mixer->tracklist, track);
       got_it = TRUE;
     }
@@ -309,12 +328,13 @@
       if (flags == GST_MIXER_TRACK_OUTPUT &&
           snd_mixer_selem_has_playback_switch (element)) {
         /* simple mute switch */
-        track = gst_alsa_mixer_track_new (element, i, 0,
-            flags, GST_ALSA_MIXER_TRACK_PLAYBACK);
+        track = gst_alsa_mixer_track_new (element, samename,
+            i, 0, flags, GST_ALSA_MIXER_TRACK_PLAYBACK);
         mixer->tracklist = g_list_append (mixer->tracklist, track);
       }
     }
 
+  next:
     element = snd_mixer_elem_next (element);
   }
 }
diff -ur gst-plugins-0.8.5/ext/alsa/gstalsamixertrack.c gst-plugins-0.8.5/ext/alsa.new/gstalsamixertrack.c
--- gst-plugins-0.8.5/ext/alsa/gstalsamixertrack.c	2004-10-06 17:03:28.000000000 +0100
+++ gst-plugins-0.8.5/ext/alsa.new/gstalsamixertrack.c	2004-10-25 16:58:35.000000000 +0100
@@ -21,6 +21,8 @@
 #include "config.h"
 #endif
 
+#include <gst/gst-i18n-plugin.h>
+
 #include "gstalsamixertrack.h"
 
 static void gst_alsa_mixer_track_init (GstAlsaMixerTrack * alsa_track);
@@ -69,16 +71,52 @@
 
 GstMixerTrack *
 gst_alsa_mixer_track_new (snd_mixer_elem_t * element,
-    gint track_num, gint channels, gint flags, gint alsa_flags)
+    gint num, gint track_num, gint channels, gint flags, gint alsa_flags)
 {
   gint i;
   long min = 0, max = 0;
+  struct
+  {
+    gchar *orig, *trans;
+  } alsa_track_labels[] = {
+    {
+    "Master", _("Master")}, {
+    "Bass", _("Bass")}, {
+    "Treble", _("Treble")}, {
+    "PCM", _("PCM")}, {
+    "Synth", _("Synth")}, {
+    "Line", _("Line-in")}, {
+    "CD", _("CD")}, {
+    "Mic", _("Microphone")}, {
+    "PC Speaker", _("PC Speaker")}, {
+    "Playback", _("Playback")}, {
+    "Capture", _("Capture")}, {
+    NULL, NULL}
+  };
 
   GstMixerTrack *track = g_object_new (GST_ALSA_MIXER_TRACK_TYPE, NULL);
   GstAlsaMixerTrack *alsa_track = (GstAlsaMixerTrack *) track;
 
   /* set basic information */
-  track->label = g_strdup_printf ("%s", snd_mixer_selem_get_name (element));
+  if (num == 0)
+    track->label = g_strdup (snd_mixer_selem_get_name (element));
+  else
+    track->label = g_strdup_printf ("%s %d",
+        snd_mixer_selem_get_name (element), num + 1);
+  i = 0;
+  while (alsa_track_labels[i].orig != NULL) {
+    if (!g_utf8_collate (snd_mixer_selem_get_name (element),
+            alsa_track_labels[i].orig)) {
+      g_free (track->label);
+      if (num == 0)
+        track->label = g_strdup (alsa_track_labels[i].trans);
+      else
+        track->label = g_strdup_printf ("%s %d",
+            alsa_track_labels[i].trans, num);
+      break;
+    }
+    i++;
+  }
   track->num_channels = channels;
   track->flags = flags;
   alsa_track->element = element;
diff -ur gst-plugins-0.8.5/ext/alsa/gstalsamixertrack.h gst-plugins-0.8.5/ext/alsa.new/gstalsamixertrack.h
--- gst-plugins-0.8.5/ext/alsa/gstalsamixertrack.h	2004-05-27 10:04:33.000000000 +0100
+++ gst-plugins-0.8.5/ext/alsa.new/gstalsamixertrack.h	2004-10-25 16:58:35.000000000 +0100
@@ -51,6 +51,7 @@
 
 GType		gst_alsa_mixer_track_get_type	(void);
 GstMixerTrack *	gst_alsa_mixer_track_new	(snd_mixer_elem_t *	element,
+						 gint                   num,
 						 gint			track_num,
 						 gint			channels,
 						 gint			flags,
diff -ur gst-plugins-0.8.5/ext/alsa/gstalsasink.c gst-plugins-0.8.5/ext/alsa.new/gstalsasink.c
--- gst-plugins-0.8.5/ext/alsa/gstalsasink.c	2004-10-06 17:03:40.000000000 +0100
+++ gst-plugins-0.8.5/ext/alsa.new/gstalsasink.c	2004-11-12 10:07:46.000000000 +0000
@@ -230,11 +230,15 @@
         if (gst_event_discont_get_value (event, GST_FORMAT_TIME, &value)) {
           gst_element_set_time_delay (GST_ELEMENT (this), value,
               MIN (value, delay));
+        } else if (this->format && (gst_event_discont_get_value (event,
+                    GST_FORMAT_DEFAULT, &value))) {
+          value = gst_alsa_samples_to_timestamp (this, value);
+          gst_element_set_time_delay (GST_ELEMENT (this), value, MIN (value,
+                  delay));
         } else if (this->format
-            && (gst_event_discont_get_value (event, GST_FORMAT_DEFAULT, &value)
-                || gst_event_discont_get_value (event, GST_FORMAT_BYTES,
+            && (gst_event_discont_get_value (event, GST_FORMAT_BYTES,
                     &value))) {
-          value = gst_alsa_samples_to_timestamp (this, value);
+          value = gst_alsa_bytes_to_timestamp (this, value);
           gst_element_set_time_delay (GST_ELEMENT (this), value, MIN (value,
                   delay));
         } else {
@@ -302,7 +306,11 @@
     goto out;
   }
   if ((err = snd_pcm_mmap_commit (this->handle, offset, *avail)) < 0) {
-    GST_ERROR_OBJECT (this, "mmap commit failed: %s", snd_strerror (err));
+    if (err == -EPIPE) {
+      gst_alsa_xrun_recovery (GST_ALSA (this));
+    } else {
+      GST_ERROR_OBJECT (this, "mmap commit failed: %s", snd_strerror (err));
+    }
     goto out;
   }
 
@@ -356,17 +364,11 @@
     goto sink_restart;
   if (avail < 0)
     return;
-  if (avail > 0) {
 
-    /* Not enough space. We grab data nonetheless and sleep afterwards */
-    if (avail < this->period_size) {
-      avail = this->period_size;
-    }
+  if (avail > 0 || (avail == 0 && !this->format)) {
+
+    bytes = G_MAXINT;
 
-    /* check how many bytes we still have in all our bytestreams */
-    /* initialize this value to a somewhat sane state, we might alloc
-     * this much data below (which would be a bug, but who knows)... */
-    bytes = this->period_size * this->period_count * element->numpads * 8;      /* must be > max sample size in bytes */
     for (i = 0; i < element->numpads; i++) {
       GstBuffer *buf;
 
@@ -381,6 +383,7 @@
         if (GST_IS_EVENT (sink->gst_data[i])) {
           GST_LOG_OBJECT (sink, "pulled data %p is an event, checking",
               sink->gst_data[i]);
+
           if (gst_alsa_sink_check_event (sink, i))
             continue;
           return;
@@ -483,6 +486,16 @@
       bytes = MIN (bytes, sink->size[i]);
     }
 
+    /* check how many bytes we still have in all our bytestreams */
+    /* initialize this value to a somewhat sane state, we might alloc
+     * this much data below (which would be a bug, but who knows)... */
+    bytes = MIN (bytes,
+        this->period_size * this->period_count * element->numpads * 8);
+    /* must be > max sample size in bytes */
+
+    /* Not enough space. We grab data nonetheless and sleep afterwards */
+    if (avail < this->period_size)
+      avail = this->period_size;
     avail = MIN (avail, gst_alsa_bytes_to_samples (this, bytes));
 
     /* wait until the hw buffer has enough space */
@@ -532,6 +532,9 @@
       if (sink->behaviour[i] != 1)
         sink->buf_data[i] += bytes;
     }
+  } else if (avail == 0 && gst_element_get_state (element) == GST_STATE_PLAYING) {
+    if (gst_alsa_pcm_wait (this) == FALSE)
+      return;
   }
 
   if (snd_pcm_state (this->handle) != SND_PCM_STATE_RUNNING
@@ -567,7 +580,7 @@
   if (!GST_FLAG_IS_SET (this, GST_ALSA_RUNNING)) {
     delay = 0;
   } else if (snd_pcm_delay (this->handle, &delay) != 0) {
-    return this->played / this->format->rate;
+    delay = 0;
   }
   if (this->played <= delay) {
     return 0;
