diff -Naur procman/src/callbacks.c procman.new/src/callbacks.c
--- procman/src/callbacks.c	2003-01-26 19:15:39.000000000 +0100
+++ procman.new/src/callbacks.c	2003-01-26 19:13:39.000000000 +0100
@@ -35,6 +35,7 @@
 #include "memmaps.h"
 #include "favorites.h"
 #include "load-graph.h"
+#include "cellrenderer.h"
 
 void
 cb_preferences_activate               (GtkMenuItem     *menuitem,
@@ -122,6 +123,7 @@
 	const gchar *authors[] = {
 				 _("Kevin Vandersloot (kfv101@psu.edu)"),
 				 _("Erik Johnsson (zaphod@linux.nu) - icon support"),
+				 _("JÃ¶rgen Scheibengruber <mfcn@gmx.de> - nicer devices treeview"),
 				 NULL
 				 };
 
@@ -513,25 +515,37 @@
 	glibtop_mountentry *entry = NULL;
 	gchar *old_name;
 	
-	gtk_tree_model_get (model, iter, 0, &old_name, -1);
+	gtk_tree_model_get (model, iter, 1, &old_name, -1);
 		
 	entry = g_hash_table_lookup (new_disks, old_name);
 	if (entry) {
 		glibtop_fsusage usage;
-		gchar *used, *total;
+		gchar *used, *total, *unused;
+		float percentage, bused, bfree, btotal;
 		
 		glibtop_get_fsusage (&usage, entry->mountdir);
-		
-		used = get_size_string ((float)(usage.blocks - usage.bfree) * 512);
-		total = get_size_string ((float) usage.blocks * 512);
+
+		btotal = (float)usage.blocks * 512;
+		bfree = (float)usage.bfree * 512;
+		bused = (float)(usage.blocks  - usage.bfree) * 512;
+		percentage = (float) (usage.blocks - usage.bfree) / (float) usage.blocks;
+		
+		used = get_size_string (bused);
+		total = get_size_string (btotal);
+		unused = get_size_string (bfree);
 		
 		gtk_tree_store_set (GTK_TREE_STORE (model), iter,
-				    2, used,
-				    3, total, -1);
+				    4, total,
+				    5, used,
+					6, unused,
+					7, percentage,
+					8, btotal,
+					9, bfree, -1);
 		g_hash_table_remove (new_disks, old_name);
 		
 		g_free (used);
 		g_free (total);
+		g_free (unused);
 
 		g_free (old_name);
 			
@@ -548,37 +562,104 @@
 	
 }
 
+static GdkPixbuf*
+get_icon_for_device(GnomeIconTheme *icontheme, char *mountpoint, char *type)
+{
+	GdkPixbuf *tmp, *pixbuf;
+	char *i_type, *path;
+	int size = 24;
+	
+	if (strstr(mountpoint,"/zip"))
+		i_type = "gnome-dev-zipdisk";
+	else 
+	if (strstr(mountpoint,"/floppy"))
+		i_type = "gnome-dev-floppy";
+	else 
+	if (strstr(type,"iso9660"))
+		i_type = "gnome-dev-cdrom";
+	else 
+	if (strstr(type, "smbfs"))
+		i_type = "gnome-fs-smb";
+	else
+	if (strstr(type, "nfs"))
+		i_type = "gnome-fs-nfs";
+	else 
+		i_type = "gnome-dev-harddisk";
+
+	if (!(path = gnome_icon_theme_lookup_icon(icontheme, i_type, 24, NULL, &size)))
+		return NULL;
+	
+	if (!(tmp = gdk_pixbuf_new_from_file(path, NULL)))
+		return NULL;
+	
+	g_free(path);
+	
+	if (size != 24)
+	{	
+		pixbuf = gdk_pixbuf_scale_simple (tmp, 24, 24, 
+						GDK_INTERP_HYPER);
+		g_object_unref(tmp);
+		return pixbuf;
+	}
+	return tmp;
+}
+
 static void
 add_new_disks (gpointer key, gpointer value, gpointer data)
 {
 	glibtop_mountentry *entry = value;
 	GtkTreeModel *model = data;
 	glibtop_fsusage usage;
-	gchar *text[4];
-				
+	gchar *text[5];
+	GdkPixbuf *pixbuf = NULL;
+	GnomeIconTheme *icontheme;
+	icontheme  = gnome_icon_theme_new();
+	
 	glibtop_get_fsusage (&usage, entry->mountdir);
-	text[0] = g_strdup (entry->devname);
-	text[1] = g_strdup (entry->mountdir);
-	text[2] = get_size_string ((float)(usage.blocks - usage.bfree) * 512);
-	text[3] = get_size_string ((float) usage.blocks * 512);
+	
 	/* Hmm, usage.blocks == 0 seems to get rid of /proc and all
 	** the other useless entries */
 	if (usage.blocks != 0) {
 		GtkTreeIter row;
-			
+		float percentage, btotal, bfree, bused;
+
+		btotal = (float)usage.blocks * 512;
+		bfree = (float)usage.bfree * 512;
+		bused = (float)(usage.blocks  - usage.bfree) * 512;
+		percentage = (float) (usage.blocks - usage.bfree) / (float) usage.blocks;
+		
+	/*  Load an icon corresponding to the type of the device */
+		pixbuf = get_icon_for_device(icontheme, entry->mountdir, entry->type);
+	
+		text[0] = g_strdup (entry->devname);
+		text[1] = g_strdup (entry->mountdir);
+		text[2] = g_strdup (entry->type);
+		text[3] = get_size_string (btotal);
+		text[4] = get_size_string (bused);
+		text[5] = get_size_string (bfree);
+		
 		gtk_tree_store_insert (GTK_TREE_STORE (model), &row, NULL, 0); 
 		gtk_tree_store_set (GTK_TREE_STORE (model), &row,
-					    0, text[0],
-					    1, text[1],
-					    2, text[2],
-					    3, text[3], -1);
-		
+					    0, pixbuf,
+						1, text[0],
+					    2, text[1],
+					    3, text[2],
+					    4, text[3],
+					    5, text[4],
+						6, text[5],
+						7, percentage,
+						8, btotal,
+						9, bfree, -1);
+						
+		g_free (text[0]);
+		g_free (text[1]);
+		g_free (text[2]);
+		g_free (text[3]);
+		g_free (text[4]);
+		g_free (text[5]);
+		if (pixbuf)
+			g_object_unref (pixbuf);
 	}
-		
-	g_free (text[0]);
-	g_free (text[1]);
-	g_free (text[2]);
-	g_free (text[3]);
 }
 
 gint
diff -Naur procman/src/cellrenderer.c procman.new/src/cellrenderer.c
--- procman/src/cellrenderer.c	1970-01-01 01:00:00.000000000 +0100
+++ procman.new/src/cellrenderer.c	2003-01-26 19:13:39.000000000 +0100
@@ -0,0 +1,268 @@
+/* gtkcellrenderer.c
+ * Copyright (C) 2002 Naba Kumar <kh_naba@users.sourceforge.net>
+ * heavily modified by Jörgen Scheibengruber <mfcn@gmx.de>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <config.h>
+#include <stdlib.h>
+#include "cellrenderer.h"
+
+static void gtk_cell_renderer_progress_init       (GtkCellRendererProgress      *celltext);
+static void gtk_cell_renderer_progress_class_init (GtkCellRendererProgressClass *class);
+static void gtk_cell_renderer_progress_finalize   (GObject                  *object);
+
+static void gtk_cell_renderer_progress_get_property(GObject                  *object,
+						  guint                     param_id,
+						  GValue                   *value,
+						  GParamSpec               *pspec);
+static void gtk_cell_renderer_progress_set_property(GObject                  *object,
+						  guint                     param_id,
+						  const GValue             *value,
+						  GParamSpec               *pspec);
+static void gtk_cell_renderer_progress_get_size    (GtkCellRenderer          *cell,
+					       GtkWidget                *widget,
+					       GdkRectangle             *cell_area,
+					       gint                     *x_offset,
+					       gint                     *y_offset,
+					       gint                     *width,
+					       gint                     *height);
+static void gtk_cell_renderer_progress_render      (GtkCellRenderer          *cell,
+					       GdkWindow                *window,
+					       GtkWidget                *widget,
+					       GdkRectangle             *background_area,
+					       GdkRectangle             *cell_area,
+					       GdkRectangle             *expose_area,
+					       guint                     flags);
+
+enum {
+  PROP_0,
+  PROP_VALUE
+}; 
+
+struct _GtkCellRendererProgressPriv {
+	double   value;
+};
+
+static gpointer parent_class;
+
+GtkType
+gtk_cell_renderer_progress_get_type (void)
+{
+	static GtkType cell_progress_type = 0;
+
+	if (!cell_progress_type)
+	{
+		static const GTypeInfo cell_progress_info =
+		{
+			sizeof (GtkCellRendererProgressClass),
+			NULL,		/* base_init */
+			NULL,		/* base_finalize */
+			(GClassInitFunc) gtk_cell_renderer_progress_class_init,
+			NULL,		/* class_finalize */
+			NULL,		/* class_data */
+			sizeof (GtkCellRendererProgress),
+			0,              /* n_preallocs */
+			(GInstanceInitFunc) gtk_cell_renderer_progress_init,
+		};
+		cell_progress_type = g_type_register_static (GTK_TYPE_CELL_RENDERER,
+                                               "GtkCellRendererProgress",
+                                               &cell_progress_info, 0);
+	}
+
+	return cell_progress_type;
+}
+
+static void
+gtk_cell_renderer_progress_init (GtkCellRendererProgress *cellprogress)
+{
+	GtkCellRendererProgressPriv *priv;
+	
+    cellprogress->priv = (GtkCellRendererProgressPriv*)g_new0(GtkCellRendererProgressPriv, 1);
+    
+	cellprogress->priv->value = 0;
+}
+
+static void
+gtk_cell_renderer_progress_class_init (GtkCellRendererProgressClass *class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (class);
+	GtkCellRendererClass *cell_class = GTK_CELL_RENDERER_CLASS (class);
+
+	parent_class = g_type_class_peek_parent (class);
+  
+	object_class->finalize = gtk_cell_renderer_progress_finalize;
+  
+	object_class->get_property = gtk_cell_renderer_progress_get_property;
+	object_class->set_property = gtk_cell_renderer_progress_set_property;
+
+	cell_class->get_size = gtk_cell_renderer_progress_get_size;
+	cell_class->render = gtk_cell_renderer_progress_render;
+  
+	g_object_class_install_property (object_class,
+                                   PROP_VALUE,
+                                   g_param_spec_float ("value",
+                                                        "Value",
+                                                        "Value of the progress bar.",
+                                                        0, 100, 0,
+                                                        G_PARAM_READWRITE));
+}
+
+static void
+gtk_cell_renderer_progress_get_property (GObject        *object,
+                                         guint           param_id,
+                                         GValue         *value,
+                                         GParamSpec     *pspec)
+{
+	GtkCellRendererProgress *cellprogress = GTK_CELL_RENDERER_PROGRESS (object);
+
+	switch (param_id)
+	{
+		case PROP_VALUE:
+			g_value_set_float (value, cellprogress->priv->value);
+			break;
+		default:
+			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
+	}
+}
+
+static void
+gtk_cell_renderer_progress_set_property (GObject      *object,
+				     guint         param_id,
+				     const GValue *value,
+				     GParamSpec   *pspec)
+{
+	GtkCellRendererProgress *cellprogress = 
+        GTK_CELL_RENDERER_PROGRESS (object);
+
+	switch (param_id)
+	{
+		case PROP_VALUE:
+			cellprogress->priv->value = g_value_get_float (value);
+			break;
+		default:
+			G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
+	}
+	g_object_notify (object, "value");
+}
+
+static void
+gtk_cell_renderer_progress_get_size (GtkCellRenderer *cell,
+				 GtkWidget       *widget,
+				 GdkRectangle    *cell_area,
+				 gint            *x_offset,
+				 gint            *y_offset,
+				 gint            *width,
+				 gint            *height)
+{
+	GtkCellRendererProgress *cellprogress = (GtkCellRendererProgress *) cell;
+
+/* Always return 1 here. Doesn't make to much sense,
+ * but providing the real width would make it
+ * impossible for the bar to shrink again.
+ */
+	if (width)
+		*width = 1;
+	if (height)
+		*height = 26;
+}
+
+GtkCellRenderer*
+gtk_cell_renderer_progress_new (void)
+{
+	return GTK_CELL_RENDERER (g_object_new (gtk_cell_renderer_progress_get_type (), NULL));
+}
+
+static void
+gtk_cell_renderer_progress_render (GtkCellRenderer    *cell,
+			       GdkWindow          *window,
+			       GtkWidget          *widget,
+			       GdkRectangle       *background_area,
+			       GdkRectangle       *cell_area,
+			       GdkRectangle       *expose_area,
+			       guint               flags)
+{
+	GtkCellRendererProgress *cellprogress = (GtkCellRendererProgress *) cell;
+	GtkStateType state;
+	GdkGC *gc;
+	GdkColor color;
+	PangoLayout *layout;
+	PangoRectangle logical_rect;
+	char *text; 
+	int x, y, w, h, perc_w, pos;
+	
+#define MAXWIDTH 150
+#define MINWIDTH 60
+
+	gc = gdk_gc_new (window);
+
+	x = cell_area->x + 4;
+	y = cell_area->y + 2;
+	if (cell_area->width > MINWIDTH)
+		if (cell_area->width < MAXWIDTH)
+			w = cell_area->width - 8;
+		else
+			w = MAXWIDTH - 8;
+	else
+		w = MINWIDTH - 8;
+	h = cell_area->height - 4;
+	
+	gdk_gc_set_rgb_fg_color (gc, &widget->style->fg[GTK_STATE_NORMAL]);
+	gdk_draw_rectangle (window, gc, TRUE, x, y, w, h);
+
+	gdk_gc_set_rgb_fg_color (gc, &widget->style->bg[GTK_STATE_NORMAL]);
+	gdk_draw_rectangle (window, gc, TRUE, x + 1, y + 1, w - 2, h - 2);
+	gdk_gc_set_rgb_fg_color (gc, &widget->style->bg[GTK_STATE_SELECTED]);
+	perc_w = w - 4;
+	perc_w = (int) (perc_w * cellprogress->priv->value);
+	gdk_draw_rectangle (window, gc, TRUE, x + 2, y + 2, perc_w, h - 4);
+	
+	text = g_strdup_printf ("%.0f", cellprogress->priv->value * 100);
+	layout = gtk_widget_create_pango_layout (widget, text);
+	pango_layout_get_pixel_extents (layout, NULL, &logical_rect);
+	g_object_unref (G_OBJECT (layout));
+	g_free (text);
+	text = g_strdup_printf ("%.0f %%", cellprogress->priv->value * 100);
+	layout = gtk_widget_create_pango_layout (widget, text);
+	g_free (text);
+	
+	pos = (w - logical_rect.width)/2;
+	
+	if (perc_w < pos + logical_rect.width/2)
+		state = GTK_STATE_NORMAL;
+	else
+		state = GTK_STATE_SELECTED;
+	gtk_paint_layout (widget->style, window,
+						state,
+						FALSE,
+                        cell_area,
+                        widget,
+                        "progressbar",
+                        x + pos, y + (h - logical_rect.height)/2,
+                        layout);
+	g_object_unref (G_OBJECT (layout));
+	g_object_unref (G_OBJECT (gc));
+}
+
+static void
+gtk_cell_renderer_progress_finalize (GObject *object)
+{
+	GtkCellRendererProgress *cellprogress = GTK_CELL_RENDERER_PROGRESS (object);
+	g_free(cellprogress->priv);
+  
+	(* G_OBJECT_CLASS (parent_class)->finalize) (object);
+}
diff -Naur procman/src/cellrenderer.h procman.new/src/cellrenderer.h
--- procman/src/cellrenderer.h	1970-01-01 01:00:00.000000000 +0100
+++ procman.new/src/cellrenderer.h	2003-01-26 19:13:39.000000000 +0100
@@ -0,0 +1,50 @@
+/* cellrenderer.h
+ * Copyright (C) 2002 Naba Kumar <kh_naba@users.sourceforge.net>
+ * modified by Jörgen Scheibengruber <mfcn@gmx.de>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __CELL_RENDERER_H__
+#define __CELL_RENDERER_H__
+
+#include <config.h>
+#include <gtk/gtkcellrenderer.h>
+
+G_BEGIN_DECLS
+
+#define GTK_TYPE_CELL_RENDERER_PROGRESS           (gtk_cell_renderer_get_type ())
+#define GTK_CELL_RENDERER_PROGRESS(obj)		      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GTK_TYPE_CELL_RENDERER_PROGRESS, GtkCellRendererProgress))
+
+typedef struct _GtkCellRendererProgress      GtkCellRendererProgress;
+typedef struct _GtkCellRendererProgressClass GtkCellRendererProgressClass;
+typedef struct _GtkCellRendererProgressPriv  GtkCellRendererProgressPriv;
+
+struct _GtkCellRendererProgress {
+	GtkCellRenderer parent_instance;
+	GtkCellRendererProgressPriv* priv;
+};
+
+struct _GtkCellRendererProgressClass{
+	GtkCellRendererClass parent_class;
+};
+
+GtkType gtk_cell_renderer_progress_get_type (void) G_GNUC_CONST;
+GtkCellRenderer* gtk_cell_renderer_progress_new(void);
+
+G_END_DECLS
+
+#endif
diff -Naur procman/src/interface.c procman.new/src/interface.c
--- procman/src/interface.c	2003-01-26 19:15:39.000000000 +0100
+++ procman.new/src/interface.c	2003-01-26 19:13:39.000000000 +0100
@@ -40,6 +40,7 @@
 #include "favorites.h"
 #endif
 #include "load-graph.h"
+#include "cellrenderer.h"
 
 static GnomeUIInfo file1_menu_uiinfo[] =
 {
@@ -265,6 +266,42 @@
         return vbox1;
 }
 
+static int
+sort_bytes (GtkTreeModel *model, GtkTreeIter *itera, GtkTreeIter *iterb, gpointer data)
+{
+	int col = GPOINTER_TO_INT (data);
+	float btotal1, btotal2, bfree1, bfree2;
+	float a, b;
+	
+	btotal1 = btotal2 = bfree1 = bfree2 = 0.0;
+	gtk_tree_model_get (model, itera, 8, &btotal1, 9, &bfree1, -1);
+	gtk_tree_model_get (model, iterb, 8, &btotal2, 9, &bfree2, -1);
+
+	switch (col)
+	{
+		case 4: 
+			a = btotal1;
+			b = btotal2;
+			break;
+		case 5: 
+			a = btotal1 - bfree1;
+			b = btotal2 - bfree2;
+			break;
+		case 6: 
+			a = bfree1;
+			b = bfree2;
+			break;
+		default:
+			a = 0;
+			b = 0;
+	}
+
+	if (a > b)
+		return -1;
+	else if (a < b)
+		return 1;
+	return 0;	
+}
 
 static GtkWidget *
 create_sys_view (ProcData *procdata)
@@ -281,11 +318,14 @@
 	GtkTreeStore *model;
 	GtkTreeViewColumn *col;
 	GtkCellRenderer *cell;
-	gchar *titles[5] = {_("Name"),
+	gchar *titles[7] = {_("Name"),
 			    _("Directory"),
-			    _("Used Space"),
-			    _("Total Space")
-			    };
+				_("Type"),
+			    _("Total"),
+			    _("Used"),
+				_("Free"),
+				_("Used in %")
+				};
 	LoadGraph *cpu_graph, *mem_graph;
 	gint i;
 	
@@ -430,9 +470,11 @@
 	gtk_container_set_border_width (GTK_CONTAINER (scrolled), GNOME_PAD_SMALL);
 	gtk_container_add (GTK_CONTAINER (disk_frame), scrolled);
 	 
-	model = gtk_tree_store_new (5, G_TYPE_STRING, G_TYPE_STRING,
+	model = gtk_tree_store_new (10, GDK_TYPE_PIXBUF, G_TYPE_STRING, 
+					   G_TYPE_STRING, G_TYPE_STRING,
 				       G_TYPE_STRING, G_TYPE_STRING,
-				       G_TYPE_STRING); 
+				       G_TYPE_STRING, G_TYPE_FLOAT, 
+					   G_TYPE_FLOAT, G_TYPE_FLOAT);
 				       
 	disk_tree = gtk_tree_view_new_with_model (GTK_TREE_MODEL (model));
 	procdata->disk_list = disk_tree;
@@ -440,19 +482,52 @@
   	gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (disk_tree), TRUE);
   	g_object_unref (G_OBJECT (model));
   	
-  	for (i = 0; i < 4; i++) {
+ 	col = gtk_tree_view_column_new ();
+  	cell = gtk_cell_renderer_pixbuf_new ();
+	gtk_tree_view_column_pack_start (col, cell, FALSE);
+	gtk_tree_view_column_set_attributes (col, cell,
+					     "pixbuf", 0,
+					     NULL);
+		
+	cell = gtk_cell_renderer_text_new ();
+	gtk_tree_view_column_pack_start (col, cell, FALSE);
+	gtk_tree_view_column_set_attributes (col, cell,
+					     "text", 1,
+					     NULL);
+	gtk_tree_view_column_set_title (col, titles[0]);
+	gtk_tree_view_column_set_sort_column_id (col, 1);
+	gtk_tree_view_column_set_resizable (col, TRUE);
+	gtk_tree_view_append_column (GTK_TREE_VIEW (disk_tree), col);
+								
+  	for (i = 1; i < 6; i++) {
   		cell = gtk_cell_renderer_text_new ();
   		col = gtk_tree_view_column_new_with_attributes (titles[i],
 						    		cell,
-						     		"text", i,
+						     		"text", i + 1,
 						     		NULL);
 		gtk_tree_view_column_set_resizable (col, TRUE);
+		gtk_tree_view_column_set_sort_column_id (col, i + 1);
 		gtk_tree_view_append_column (GTK_TREE_VIEW (disk_tree), col);
 	}
-  	
+	cell = gtk_cell_renderer_progress_new ();
+	col = gtk_tree_view_column_new_with_attributes (titles[6],
+								cell,
+								"value", 7,
+								NULL);
+	gtk_tree_view_column_set_resizable (col, TRUE);
+	gtk_tree_view_column_set_sort_column_id (col, 7);
+	gtk_tree_view_append_column (GTK_TREE_VIEW (disk_tree), col);
+
+	gtk_tree_sortable_set_sort_func (GTK_TREE_SORTABLE (model),
+					 4, sort_bytes, GINT_TO_POINTER (4), NULL);
+	gtk_tree_sortable_set_sort_func (GTK_TREE_SORTABLE (model),
+					 5, sort_bytes, GINT_TO_POINTER (5), NULL);
+	gtk_tree_sortable_set_sort_func (GTK_TREE_SORTABLE (model),
+					 6, sort_bytes, GINT_TO_POINTER (6), NULL);
+
 	gtk_widget_show_all (disk_frame);
   	
-  	procman_get_tree_state (procdata->client, disk_tree, "/apps/procman/disktree");
+  	//procman_get_tree_state (procdata->client, disk_tree, "/apps/procman/disktree");
   	
   	cb_update_disks (procdata);
   	procdata->disk_timeout = gtk_timeout_add (procdata->config.disks_update_interval,
diff -Naur procman/src/Makefile.am procman.new/src/Makefile.am
--- procman/src/Makefile.am	2003-01-26 19:15:39.000000000 +0100
+++ procman.new/src/Makefile.am	2003-01-26 19:13:39.000000000 +0100
@@ -9,6 +9,7 @@
 bin_PROGRAMS = gnome-system-monitor
 
 gnome_system_monitor_SOURCES = \
+	cellrenderer.c cellrenderer.h \
 	procman.c  procman.h \
 	interface.c interface.h \
 	callbacks.c callbacks.h \
