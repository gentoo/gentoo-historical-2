diff -Nur unionfs-1.0.8/branchman.c unionfs-1.0.8_r1/branchman.c
--- unionfs-1.0.8/branchman.c	2005-01-19 16:03:24.000000000 +0100
+++ unionfs-1.0.8_r1/branchman.c	2005-02-08 14:26:10.544231264 +0100
@@ -109,7 +109,7 @@
 	dpd = dtopd(inode->i_sb->s_root);
 	ipd = itopd(inode->i_sb->s_root->d_inode);
 
-	addargs = KMALLOC(sizeof(struct unionfs_addbranch_args), GFP_NOFS);
+	addargs = KMALLOC(sizeof(struct unionfs_addbranch_args), GFP_KERNEL);
 	if (!addargs) {
 		err = -ENOMEM;
 		goto out;
@@ -177,12 +177,12 @@
 	gen = atomic_read(&spd->usi_generation);
 
 	/* Reallocate the dynamic structures. */
-	new_hidden_mnt = KMALLOC(sizeof(struct hidden_mnt *) * (spd->b_end + 1), GFP_NOFS);
-	new_udi_dentry = KMALLOC(sizeof(struct dentry *) * (spd->b_end + 1), GFP_NOFS);
-	new_uii_inode = KMALLOC(sizeof(struct inode *) * (spd->b_end + 1), GFP_NOFS);
-	new_usi_sb = KMALLOC(sizeof(struct super_block *) * (spd->b_end + 1), GFP_NOFS);
-	new_counts = KMALLOC(sizeof(atomic_t) * (spd->b_end + 1), GFP_NOFS);
-	new_branchperms = KMALLOC(sizeof(int) * (spd->b_end + 1), GFP_NOFS);
+	new_hidden_mnt = KMALLOC(sizeof(struct hidden_mnt *) * (spd->b_end + 1), GFP_KERNEL);
+	new_udi_dentry = KMALLOC(sizeof(struct dentry *) * (spd->b_end + 1), GFP_KERNEL);
+	new_uii_inode = KMALLOC(sizeof(struct inode *) * (spd->b_end + 1), GFP_KERNEL);
+	new_usi_sb = KMALLOC(sizeof(struct super_block *) * (spd->b_end + 1), GFP_KERNEL);
+	new_counts = KMALLOC(sizeof(atomic_t) * (spd->b_end + 1), GFP_KERNEL);
+	new_branchperms = KMALLOC(sizeof(int) * (spd->b_end + 1), GFP_KERNEL);
 	if (!new_hidden_mnt || !new_udi_dentry || !new_uii_inode || !new_counts || !new_usi_sb || !new_branchperms) {
 		err = -ENOMEM;
 		goto out;
@@ -386,7 +386,7 @@
 	dpd = dtopd(inode->i_sb->s_root);
 	ipd = itopd(inode->i_sb->s_root->d_inode);
 
-	rdwrargs = KMALLOC(sizeof(struct unionfs_rdwrbranch_args), GFP_NOFS);
+	rdwrargs = KMALLOC(sizeof(struct unionfs_rdwrbranch_args), GFP_KERNEL);
 	if (!rdwrargs) {
 		err = -ENOMEM;
 		goto out;
diff -Nur unionfs-1.0.8/copyup.c unionfs-1.0.8_r1/copyup.c
--- unionfs-1.0.8/copyup.c	2005-01-19 16:03:24.000000000 +0100
+++ unionfs-1.0.8_r1/copyup.c	2005-02-08 14:26:10.546230960 +0100
@@ -118,7 +118,7 @@
 	PASSERT(old_hidden_dentry->d_inode->i_op);
 	PASSERT(old_hidden_dentry->d_inode->i_op->readlink);
 
-	symbuf = KMALLOC(PATH_MAX, GFP_NOFS);
+	symbuf = KMALLOC(PATH_MAX, GFP_KERNEL);
 	if (!symbuf) {
 	    err = -ENOMEM;
 	    goto copyup_readlink_err;
@@ -204,7 +204,7 @@
 	}
 
 	/* allocating a buffer */
-	buf = (char *) KMALLOC(PAGE_SIZE, GFP_NOFS);
+	buf = (char *) KMALLOC(PAGE_SIZE, GFP_KERNEL);
 	if (!buf) {
 	    err = -ENOMEM;
 	    goto out;
diff -Nur unionfs-1.0.8/file.c unionfs-1.0.8_r1/file.c
--- unionfs-1.0.8/file.c	2005-01-19 16:03:24.000000000 +0100
+++ unionfs-1.0.8_r1/file.c	2005-02-08 14:26:10.552230048 +0100
@@ -77,7 +77,7 @@
 	bstart = fbstart(file) = dbstart(dentry);
 	bend = fbend(file) = dbend(dentry);
 
-	ftohf_ptr(file) = KMALLOC(sizeof(file_t *) * sbmax(sb), GFP_NOFS);
+	ftohf_ptr(file) = KMALLOC(sizeof(file_t *) * sbmax(sb), GFP_KERNEL);
 	if (!ftohf_ptr(file)) {
 	    err = -ENOMEM;
 	    goto out;
@@ -817,14 +817,14 @@
     int bindex = 0, bstart = 0, bend = 0;
 
     print_entry_location();
-    ftopd_lhs(file) = KMALLOC(sizeof(struct unionfs_file_info), GFP_NOFS);
+    ftopd_lhs(file) = KMALLOC(sizeof(struct unionfs_file_info), GFP_KERNEL);
     if (!ftopd(file)) {
 	err = -ENOMEM;
 	goto out;
     }
     init_ftopd(file);
     atomic_set(&ftopd(file)->ufi_generation, atomic_read(&itopd(inode)->uii_generation));
-    ftohf_ptr(file) = KMALLOC((sizeof(file_t *) * sbmax(inode->i_sb)), GFP_NOFS);
+    ftohf_ptr(file) = KMALLOC((sizeof(file_t *) * sbmax(inode->i_sb)), GFP_KERNEL);
     if (!ftohf_ptr(file)) {
         err = -ENOMEM;
         goto out;
diff -Nur unionfs-1.0.8/inode.c unionfs-1.0.8_r1/inode.c
--- unionfs-1.0.8/inode.c	2005-01-19 16:03:24.000000000 +0100
+++ unionfs-1.0.8_r1/inode.c	2005-02-08 14:26:10.562228528 +0100
@@ -46,7 +46,7 @@
     hidden_dentry = dtohd(dentry);
 
     /* check if whiteout exists in this branch, i.e. lookup .wh.foo first */
-    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_NOFS);
+    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_KERNEL);
     if (!name) {
 	err = -ENOMEM;
 	goto out;
@@ -244,7 +244,7 @@
 
     /* allocate space for hidden dentries */
     if (!dtopd_lhs(dentry)) {
-    	dtopd_lhs(dentry) =  (struct unionfs_dentry_info *) KMALLOC(sizeof(struct unionfs_dentry_info), GFP_NOFS);
+    	dtopd_lhs(dentry) =  (struct unionfs_dentry_info *) KMALLOC(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
         if (!dtopd_lhs(dentry)) {
 	   err = -ENOMEM;
 	   goto out;
@@ -253,7 +253,7 @@
     } else {
 	reinit_dtopd(dentry, parent->i_sb);
     }
-    dtohd_ptr(dentry) = KMALLOC(sizeof(dentry_t *) * sbmax(parent->i_sb), GFP_NOFS);
+    dtohd_ptr(dentry) = KMALLOC(sizeof(dentry_t *) * sbmax(parent->i_sb), GFP_KERNEL);
     if (!dtohd_ptr(dentry)) {
 	err = -ENOMEM;
 	goto out_free_dtopd;
@@ -281,7 +281,7 @@
 
 	/* we reuse the whiteout name for the entire function because its value doesn't change. */
 	if (!name) {
-	    name = KMALLOC(namelen + 5, GFP_NOFS);
+	    name = KMALLOC(namelen + 5, GFP_KERNEL);
 	    if (!name) {
 		err = -ENOMEM;
 		goto out_free;
@@ -512,7 +512,7 @@
     hidden_new_dentry = dtohd(new_dentry);
 
     /* check if whiteout exists in the branch of new dentry, i.e. lookup .wh.foo first. If present, delete it */
-    name = KMALLOC(sizeof(char) * (new_dentry->d_name.len + 5), GFP_NOFS);
+    name = KMALLOC(sizeof(char) * (new_dentry->d_name.len + 5), GFP_KERNEL);
 	if (!name) {
 		err = -ENOMEM;
 		goto out;
@@ -756,7 +756,7 @@
     hidden_old_dentry = unionfs_hidden_dentry(dentry);
 
     /* lookup .wh.foo first, MUST NOT EXIST */
-    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_NOFS);
+    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_KERNEL);
     if (!name) {
         err = -ENOMEM;
         goto out;
@@ -1054,7 +1054,7 @@
     hidden_dentry = dtohd(dentry);
 
     /* check if whiteout exists in this branch, i.e. lookup .wh.foo first. If present, delete it */
-    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_NOFS);
+    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_KERNEL);
     if (!name) {
 	err = -ENOMEM;
 	goto out;
@@ -1187,7 +1187,7 @@
     hidden_dentry = dtohd(dentry);
 
     // check if whiteout exists in this branch, i.e. lookup .wh.foo first
-    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_NOFS);
+    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_KERNEL);
     if (!name) {
 	err = -ENOMEM;
 	goto out;
@@ -1321,7 +1321,7 @@
     hidden_dentry = dtohd(dentry);
 
     // check if whiteout exists in this branch, i.e. lookup .wh.foo first
-    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_NOFS);
+    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_KERNEL);
     if (!name) {
 	err = -ENOMEM;
 	goto out;
@@ -1455,7 +1455,7 @@
         }
     }
 
-    wh_name = KMALLOC(new_dentry->d_name.len + 5, GFP_NOFS);
+    wh_name = KMALLOC(new_dentry->d_name.len + 5, GFP_KERNEL);
     if (!wh_name) {
 	err = -ENOMEM;
 	goto out;
@@ -2157,7 +2157,7 @@
     print_entry_location();
 //    fist_print_dentry("unionfs_follow_link dentry IN", dentry);
 
-    buf = KMALLOC(len, GFP_NOFS);
+    buf = KMALLOC(len, GFP_KERNEL);
     if (!buf) {
 	err = -ENOMEM;
 	goto out;
diff -Nur unionfs-1.0.8/main.c unionfs-1.0.8_r1/main.c
--- unionfs-1.0.8/main.c	2005-01-19 16:03:24.000000000 +0100
+++ unionfs-1.0.8_r1/main.c	2005-02-08 14:26:10.567227768 +0100
@@ -68,7 +68,7 @@
                 itopd(inode)->b_end = -1;
                 atomic_set(&itopd(inode)->uii_generation, atomic_read(&stopd(sb)->usi_generation));
 
-                itohi_ptr(inode) = KMALLOC(sizeof(inode_t *) * sbmax(sb), GFP_NOFS);
+                itohi_ptr(inode) = KMALLOC(sizeof(inode_t *) * sbmax(sb), GFP_KERNEL);
                 if (!itohi_ptr(inode)) {
                         err = -ENOMEM;
                         goto out;
@@ -245,7 +245,7 @@
         print_entry_location();
 
         /* allocate private data area */
-        hidden_root_info = KMALLOC(sizeof(struct unionfs_dentry_info), GFP_NOFS);
+        hidden_root_info = KMALLOC(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
         if (!hidden_root_info) {
                 err = -ENOMEM;
                 goto out_error;
@@ -297,7 +297,7 @@
                         }
 
                         /* allocate space for  underlying pointers to hidden dentry */
-                        hidden_root_info->udi_dentry = KMALLOC(sizeof(dentry_t *) * branches, GFP_NOFS);
+                        hidden_root_info->udi_dentry = KMALLOC(sizeof(dentry_t *) * branches, GFP_KERNEL);
                         if (IS_ERR(hidden_root_info->udi_dentry)) {
                                 err = -ENOMEM;
                                 goto out_error;
@@ -305,7 +305,7 @@
                         memset(hidden_root_info->udi_dentry, 0, sizeof(dentry_t *) * branches);
 
                         /* allocate space for underlying pointers to super block */
-                        stohs_ptr(sb) = KMALLOC(sizeof(super_block_t *) * branches, GFP_NOFS);
+                        stohs_ptr(sb) = KMALLOC(sizeof(super_block_t *) * branches, GFP_KERNEL);
                         if (IS_ERR(stohs_ptr(sb))) {
                                 err = -ENOMEM;
                                 goto out_error;
@@ -313,7 +313,7 @@
                         init_stohs_ptr(sb, branches);
 
                         /* Set all reference counts to zero. */
-                        stopd(sb)->usi_sbcount = KMALLOC(sizeof(atomic_t) * branches, GFP_NOFS);
+                        stopd(sb)->usi_sbcount = KMALLOC(sizeof(atomic_t) * branches, GFP_KERNEL);
                         if (IS_ERR(stopd(sb)->usi_sbcount)) {
                                 err = -ENOMEM;
                                 goto out_error;
@@ -323,14 +323,14 @@
                         }
 
                         /* Set the permissions to none (we'll fix them up later). */
-                        stopd(sb)->usi_branchperms = KMALLOC(sizeof(int) * branches, GFP_NOFS);
+                        stopd(sb)->usi_branchperms = KMALLOC(sizeof(int) * branches, GFP_KERNEL);
                         if (IS_ERR(stopd(sb)->usi_branchperms)) {
                                 err = -ENOMEM;
                                 goto out_error;
                         }
 
                         /* allocate space for array of pointers for underlying mount points */
-                        stohiddenmnt_ptr(sb) = KMALLOC(sizeof(struct vfsmount *) * branches, GFP_NOFS);
+                        stohiddenmnt_ptr(sb) = KMALLOC(sizeof(struct vfsmount *) * branches, GFP_KERNEL);
                         if (IS_ERR(stohiddenmnt_ptr(sb))) {
                                 err = -ENOMEM;
                                 goto out_error;
@@ -700,7 +700,7 @@
         /*
          * Allocate superblock private data
          */
-        stopd_lhs(sb) = KMALLOC(sizeof(struct unionfs_sb_info), GFP_NOFS);
+        stopd_lhs(sb) = KMALLOC(sizeof(struct unionfs_sb_info), GFP_KERNEL);
         if (!stopd(sb)) {
                 printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
 		err = -ENOMEM;
@@ -790,7 +790,7 @@
         sb->s_root->d_parent = sb->s_root;
 
         /* link the upper and lower dentries */
-        dtopd_lhs(sb->s_root) =  KMALLOC(sizeof(struct unionfs_dentry_info), GFP_NOFS);
+        dtopd_lhs(sb->s_root) =  KMALLOC(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
         if (!dtopd_lhs(sb->s_root)) {
 		err = -ENOMEM;
                 goto out_dput2;
@@ -798,7 +798,7 @@
 	init_dtopd(sb->s_root, sb);
 
         /* allocate array of dentry pointers for the root dentry */
-        dtohd_ptr(sb->s_root) = KMALLOC(sizeof(dentry_t *) * sbmax(sb), GFP_NOFS);
+        dtohd_ptr(sb->s_root) = KMALLOC(sizeof(dentry_t *) * sbmax(sb), GFP_KERNEL);
         if (!dtohd_ptr(sb->s_root)) {
 		err = -ENOMEM;
                 goto out_dput3;
@@ -913,7 +913,7 @@
         /*
          * Allocate superblock private data
          */
-        stopd(ret_sb) = KMALLOC(sizeof(struct unionfs_sb_info), GFP_NOFS);
+        stopd(ret_sb) = KMALLOC(sizeof(struct unionfs_sb_info), GFP_KERNEL);
         if (!stopd(ret_sb)) {
                 err = -ENOMEM;
                 goto out;
@@ -927,7 +927,7 @@
         sbmax(ret_sb) = sbmax(sb);
 
         /* allocate space for underlying pointers to super block */
-        stohs_ptr(ret_sb) = KMALLOC(sizeof(super_block_t *) * sbmax(ret_sb), GFP_NOFS);
+        stohs_ptr(ret_sb) = KMALLOC(sizeof(super_block_t *) * sbmax(ret_sb), GFP_KERNEL);
         if (!stohs_ptr(ret_sb)) {
                 err = -ENOMEM;
                 goto out;
@@ -940,7 +940,7 @@
         }
 
         /* Set all reference counts to zero. */
-        stopd(ret_sb)->usi_sbcount = KMALLOC(sizeof(atomic_t) * sbmax(ret_sb), GFP_NOFS);
+        stopd(ret_sb)->usi_sbcount = KMALLOC(sizeof(atomic_t) * sbmax(ret_sb), GFP_KERNEL);
         if (!stopd(ret_sb)->usi_sbcount) {
                 err = -ENOMEM;
                 goto out;
@@ -950,7 +950,7 @@
         }
 
         /* Set the permissions to none (we'll fix them up later). */
-        stopd(ret_sb)->usi_branchperms = KMALLOC(sizeof(int) * sbmax(ret_sb), GFP_NOFS);
+        stopd(ret_sb)->usi_branchperms = KMALLOC(sizeof(int) * sbmax(ret_sb), GFP_KERNEL);
         if (!stopd(ret_sb)->usi_branchperms) {
                 err = -ENOMEM;
                 goto out;
@@ -960,7 +960,7 @@
         }
 
         /* allocate space for array of pointers for underlying mount points */
-        stohiddenmnt_ptr(ret_sb) = KMALLOC(sizeof(struct vfsmount *) * sbmax(ret_sb), GFP_NOFS);
+        stohiddenmnt_ptr(ret_sb) = KMALLOC(sizeof(struct vfsmount *) * sbmax(ret_sb), GFP_KERNEL);
         if (!stohiddenmnt_ptr(ret_sb)) {
                 err = -ENOMEM;
                 goto out;
@@ -995,13 +995,13 @@
         ret_sb->s_root->d_parent = ret_sb->s_root;
 
         /* link the upper and lower dentries */
-        dtopd(ret_sb->s_root) = KMALLOC(sizeof(struct unionfs_dentry_info), GFP_NOFS);
+        dtopd(ret_sb->s_root) = KMALLOC(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
         if (!dtopd(ret_sb->s_root)) {
                 goto out;
         }
 
         /* allocate array of dentry pointers for the root dentry */
-        dtohd_ptr(ret_sb->s_root) = KMALLOC(sizeof(dentry_t *) * sbmax(ret_sb), GFP_NOFS);
+        dtohd_ptr(ret_sb->s_root) = KMALLOC(sizeof(dentry_t *) * sbmax(ret_sb), GFP_KERNEL);
         if (!dtohd_ptr(ret_sb->s_root)) {
                 goto out;
         }
diff -Nur unionfs-1.0.8/rdstate.c unionfs-1.0.8_r1/rdstate.c
--- unionfs-1.0.8/rdstate.c	2005-01-19 16:03:24.000000000 +0100
+++ unionfs-1.0.8_r1/rdstate.c	2005-02-08 14:26:10.572227008 +0100
@@ -83,7 +83,7 @@
 	}
 	hashsize = (mallocsize - sizeof(struct unionfs_dir_state)) / sizeof(struct list_head);
 
-	ftopd(file)->rdstate = KMALLOC(mallocsize, GFP_NOFS);
+	ftopd(file)->rdstate = KMALLOC(mallocsize, GFP_KERNEL);
 	if (!ftopd(file)->rdstate) {
 		return -ENOMEM;
 	}
@@ -161,7 +161,7 @@
 	if (namelen < DNAME_INLINE_LEN_MIN) {
 	    newnode->name = newnode->iname;
 	} else {
-	    newnode->name = (char *) KMALLOC(namelen + 1, GFP_NOFS);
+	    newnode->name = (char *) KMALLOC(namelen + 1, GFP_KERNEL);
 	    if (!newnode->name) {
 		kmem_cache_free(unionfs_filldir_cachep, newnode);
 		newnode = NULL;
diff -Nur unionfs-1.0.8/subr.c unionfs-1.0.8_r1/subr.c
--- unionfs-1.0.8/subr.c	2005-01-19 16:03:24.000000000 +0100
+++ unionfs-1.0.8_r1/subr.c	2005-02-08 14:26:10.577226248 +0100
@@ -149,7 +149,7 @@
         goto out;
     }
 
-    wh_name = KMALLOC(sizeof(char) * (namelen + 5), GFP_NOFS);
+    wh_name = KMALLOC(sizeof(char) * (namelen + 5), GFP_KERNEL);
     if (!wh_name) {
         err = -ENOMEM;
         goto out;
@@ -299,7 +299,7 @@
     bend = dbend(dentry);
 
     /* create dentry's whiteout equivalent */
-    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_NOFS);
+    name = KMALLOC(sizeof(char) * (dentry->d_name.len + 5), GFP_KERNEL);
     if (!name) {
         err = -ENOMEM;
         goto out;
@@ -391,7 +391,7 @@
     fist_print_dentry("IN create_whiteout_parent", parent_dentry);
 
     /* create dentry's whiteout equivalent */
-    name = KMALLOC(sizeof(char) * (strlen(filename) + 5), GFP_NOFS);
+    name = KMALLOC(sizeof(char) * (strlen(filename) + 5), GFP_KERNEL);
     if (!name) {
         err = -ENOMEM;
         goto out;
@@ -595,7 +595,7 @@
     }
 
     hashsize = guesstimate_hash_size(dentry->d_inode);
-    buf = KMALLOC(sizeof(struct unionfs_check_whiteout_callback) + (hashsize * sizeof(struct list_head)), GFP_NOFS);
+    buf = KMALLOC(sizeof(struct unionfs_check_whiteout_callback) + (hashsize * sizeof(struct list_head)), GFP_KERNEL);
     if (!buf) {
 	err = -ENOMEM;
 	goto out;
diff -Nur unionfs-1.0.8/super.c unionfs-1.0.8_r1/super.c
--- unionfs-1.0.8/super.c	2005-01-19 16:03:24.000000000 +0100
+++ unionfs-1.0.8_r1/super.c	2005-02-08 14:26:10.579225944 +0100
@@ -33,13 +33,13 @@
     ASSERT(sizeof(struct unionfs_inode_info) < sizeof(inode->u) - sizeof(void *));
     itopd_lhs(inode) = (&(inode->u.generic_ip) + 1);
 #else
-    itopd_lhs(inode) = KMALLOC(sizeof(struct unionfs_inode_info), GFP_NOFS);
+    itopd_lhs(inode) = KMALLOC(sizeof(struct unionfs_inode_info), GFP_KERNEL);
 #endif
     if (!itopd(inode)) {
 	FISTBUG("No kernel memory when allocating inode private data!\n");
     }
     init_itopd(inode);
-    itohi_ptr(inode) = KMALLOC(sizeof(inode_t *) * sbmax(inode->i_sb), GFP_NOFS);
+    itohi_ptr(inode) = KMALLOC(sizeof(inode_t *) * sbmax(inode->i_sb), GFP_KERNEL);
     if (!itohi_ptr(inode)) {
 	FISTBUG("No kernel memory when allocating lower-pointer array!\n");
     }
@@ -171,7 +171,7 @@
     unsigned short *hidden_s_dev;
 
     print_entry_location();
-    hidden_s_dev = (unsigned short *) KMALLOC (sizeof(unsigned short) * sbmax(sb), GFP_NOFS);
+    hidden_s_dev = (unsigned short *) KMALLOC (sizeof(unsigned short) * sbmax(sb), GFP_KERNEL);
     if (!hidden_s_dev) {
         err = -ENOMEM;
         goto out;
@@ -357,7 +357,7 @@
         int bindex, bstart, bend;
         int perms;
 
-	tmp = __get_free_page(GFP_NOFS);
+	tmp = __get_free_page(GFP_KERNEL);
 	if (!tmp) {
 		ret = -ENOMEM;
 		goto out;
