diff -Nur btrfs-0.14/.hg_archival.txt kernel-f6ba18a50ad7/.hg_archival.txt
--- btrfs-0.14/.hg_archival.txt	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/.hg_archival.txt	2008-05-02 14:13:49.000000000 -0600
@@ -1,2 +1,2 @@
 repo: 972e56533d49456b288abe364ba0295fa8c0e0ad
-node: c9b946757d2354bed791012e3a924ccac9bf5d38
+node: f6ba18a50ad79a1387c86c055d9a411c82b10e80
diff -Nur btrfs-0.14/compat.h kernel-f6ba18a50ad7/compat.h
--- btrfs-0.14/compat.h	1969-12-31 17:00:00.000000000 -0700
+++ kernel-f6ba18a50ad7/compat.h	2008-05-02 14:13:49.000000000 -0600
@@ -0,0 +1,25 @@
+#ifndef _COMPAT_H_
+#define _COMPAT_H_
+
+
+/*
+ * Even if AppArmor isn't enabled, it still has different prototypes.
+ * Add more distro/version pairs here to declare which has AppArmor applied.
+ */
+#if defined(CONFIG_SUSE_KERNEL)
+# if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+# define REMOVE_SUID_PATH 1
+# endif
+#endif
+
+/*
+ * catch any other distros that have patched in apparmor.  This isn't
+ * 100% reliable because it won't catch people that hand compile their
+ * own distro kernels without apparmor compiled in.  But, it is better
+ * than nothing.
+ */
+#ifdef CONFIG_SECURITY_APPARMOR
+# define REMOVE_SUID_PATH 1
+#endif
+
+#endif /* _COMPAT_H_ */
diff -Nur btrfs-0.14/ctree.h kernel-f6ba18a50ad7/ctree.h
--- btrfs-0.14/ctree.h	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/ctree.h	2008-05-02 14:13:49.000000000 -0600
@@ -1516,9 +1516,9 @@
 /* file-item.c */
 int btrfs_insert_file_extent(struct btrfs_trans_handle *trans,
 			       struct btrfs_root *root,
-			       u64 objectid, u64 pos, u64 offset,
+			       u64 objectid, u64 pos, u64 disk_offset,
 			       u64 disk_num_bytes,
-			       u64 num_bytes);
+			     u64 num_bytes, u64 offset);
 int btrfs_lookup_file_extent(struct btrfs_trans_handle *trans,
 			     struct btrfs_root *root,
 			     struct btrfs_path *path, u64 objectid,
diff -Nur btrfs-0.14/disk-io.c kernel-f6ba18a50ad7/disk-io.c
--- btrfs-0.14/disk-io.c	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/disk-io.c	2008-05-02 14:13:49.000000000 -0600
@@ -1548,6 +1548,7 @@
 	btrfs_commit_transaction(trans, root);
 	ret = btrfs_write_and_wait_transaction(NULL, root);
 	BUG_ON(ret);
+
 	write_ctree_super(NULL, root);
 	mutex_unlock(&fs_info->fs_mutex);
 
@@ -1583,17 +1584,17 @@
 	extent_io_tree_empty_lru(&fs_info->extent_ins);
 	extent_io_tree_empty_lru(&BTRFS_I(fs_info->btree_inode)->io_tree);
 
-	flush_workqueue(end_io_workqueue);
 	flush_workqueue(async_submit_workqueue);
+	flush_workqueue(end_io_workqueue);
 
 	truncate_inode_pages(fs_info->btree_inode->i_mapping, 0);
 
-	flush_workqueue(end_io_workqueue);
-	destroy_workqueue(end_io_workqueue);
-
 	flush_workqueue(async_submit_workqueue);
 	destroy_workqueue(async_submit_workqueue);
 
+	flush_workqueue(end_io_workqueue);
+	destroy_workqueue(end_io_workqueue);
+
 	iput(fs_info->btree_inode);
 #if 0
 	while(!list_empty(&fs_info->hashers)) {
@@ -1663,8 +1664,21 @@
 
 void btrfs_btree_balance_dirty(struct btrfs_root *root, unsigned long nr)
 {
-	balance_dirty_pages_ratelimited_nr(
+	struct extent_io_tree *tree;
+	u64 num_dirty;
+	u64 start = 0;
+	unsigned long thresh = 16 * 1024 * 1024;
+	tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;
+
+	if (current_is_pdflush())
+		return;
+
+	num_dirty = count_range_bits(tree, &start, (u64)-1,
+				     thresh, EXTENT_DIRTY);
+	if (num_dirty > thresh) {
+		balance_dirty_pages_ratelimited_nr(
 				   root->fs_info->btree_inode->i_mapping, 1);
+	}
 }
 
 void btrfs_set_buffer_defrag(struct extent_buffer *buf)
diff -Nur btrfs-0.14/file-item.c kernel-f6ba18a50ad7/file-item.c
--- btrfs-0.14/file-item.c	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/file-item.c	2008-05-02 14:13:49.000000000 -0600
@@ -28,10 +28,10 @@
 			       sizeof(struct btrfs_item) * 2) / \
 			       BTRFS_CRC32_SIZE) - 1))
 int btrfs_insert_file_extent(struct btrfs_trans_handle *trans,
-			       struct btrfs_root *root,
-			       u64 objectid, u64 pos,
-			       u64 offset, u64 disk_num_bytes,
-			       u64 num_bytes)
+			     struct btrfs_root *root,
+			     u64 objectid, u64 pos,
+			     u64 disk_offset, u64 disk_num_bytes,
+			     u64 num_bytes, u64 offset)
 {
 	int ret = 0;
 	struct btrfs_file_extent_item *item;
@@ -53,9 +53,9 @@
 	leaf = path->nodes[0];
 	item = btrfs_item_ptr(leaf, path->slots[0],
 			      struct btrfs_file_extent_item);
-	btrfs_set_file_extent_disk_bytenr(leaf, item, offset);
+	btrfs_set_file_extent_disk_bytenr(leaf, item, disk_offset);
 	btrfs_set_file_extent_disk_num_bytes(leaf, item, disk_num_bytes);
-	btrfs_set_file_extent_offset(leaf, item, 0);
+	btrfs_set_file_extent_offset(leaf, item, offset);
 	btrfs_set_file_extent_num_bytes(leaf, item, num_bytes);
 	btrfs_set_file_extent_generation(leaf, item, trans->transid);
 	btrfs_set_file_extent_type(leaf, item, BTRFS_FILE_EXTENT_REG);
diff -Nur btrfs-0.14/file.c kernel-f6ba18a50ad7/file.c
--- btrfs-0.14/file.c	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/file.c	2008-05-02 14:13:49.000000000 -0600
@@ -37,6 +37,7 @@
 #include "ordered-data.h"
 #include "ioctl.h"
 #include "print-tree.h"
+#include "compat.h"
 
 
 static int btrfs_copy_from_user(loff_t pos, int num_pages, int write_bytes,
@@ -285,7 +286,7 @@
 			err = btrfs_insert_file_extent(trans, root,
 						       inode->i_ino,
 						       last_pos_in_file,
-						       0, 0, hole_size);
+						       0, 0, hole_size, 0);
 			btrfs_drop_extent_cache(inode, last_pos_in_file,
 					last_pos_in_file + hole_size -1);
 			btrfs_check_file(root, inode);
@@ -852,7 +853,11 @@
 		goto out_nolock;
 	if (count == 0)
 		goto out_nolock;
+#ifdef REMOVE_SUID_PATH
+	err = remove_suid(&file->f_path);
+#else
 	err = remove_suid(fdentry(file));
+#endif
 	if (err)
 		goto out_nolock;
 	file_update_time(file);
@@ -961,7 +966,7 @@
 		if (err < 0)
 			num_written = err;
 	} else if (num_written > 0 && (file->f_flags & O_DIRECT)) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
 		do_sync_file_range(file, start_pos,
 				      start_pos + num_written - 1,
 				      SYNC_FILE_RANGE_WRITE |
diff -Nur btrfs-0.14/inode.c kernel-f6ba18a50ad7/inode.c
--- btrfs-0.14/inode.c	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/inode.c	2008-05-02 14:13:49.000000000 -0600
@@ -19,6 +19,7 @@
 #include <linux/kernel.h>
 #include <linux/bio.h>
 #include <linux/buffer_head.h>
+#include <linux/file.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
 #include <linux/highmem.h>
@@ -141,7 +142,7 @@
 		cur_alloc_size = ins.offset;
 		ret = btrfs_insert_file_extent(trans, root, inode->i_ino,
 					       start, ins.objectid, ins.offset,
-					       ins.offset);
+					       ins.offset, 0);
 		inode->i_blocks += ins.offset >> 9;
 		btrfs_check_file(root, inode);
 		if (num_bytes < cur_alloc_size) {
@@ -1227,7 +1228,7 @@
 			err = btrfs_insert_file_extent(trans, root,
 						       inode->i_ino,
 						       hole_start, 0, 0,
-						       hole_size);
+						       hole_size, 0);
 			btrfs_drop_extent_cache(inode, hole_start,
 						(u64)-1);
 			btrfs_check_file(root, inode);
@@ -2034,12 +2035,12 @@
 
 static int btrfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
-	struct inode *inode;
+	struct inode *inode = NULL;
 	struct btrfs_trans_handle *trans;
 	struct btrfs_root *root = BTRFS_I(dir)->root;
 	int err = 0;
 	int drop_on_err = 0;
-	u64 objectid;
+	u64 objectid = 0;
 	unsigned long nr = 1;
 
 	mutex_lock(&root->fs_info->fs_mutex);
@@ -3100,6 +3101,170 @@
 	return ret;
 }
 
+void dup_item_to_inode(struct btrfs_trans_handle *trans,
+		       struct btrfs_root *root,
+		       struct btrfs_path *path,
+		       struct extent_buffer *leaf,
+		       int slot,
+		       struct btrfs_key *key,
+		       u64 destino)
+{
+	struct btrfs_path *cpath = btrfs_alloc_path();
+	int len = btrfs_item_size_nr(leaf, slot);
+	int dstoff;
+	struct btrfs_key ckey = *key;
+	int ret;
+
+	ckey.objectid = destino;
+	ret = btrfs_insert_empty_item(trans, root, cpath, &ckey, len);
+	dstoff = btrfs_item_ptr_offset(cpath->nodes[0], cpath->slots[0]);
+	copy_extent_buffer(cpath->nodes[0], leaf, dstoff,
+			   btrfs_item_ptr_offset(leaf, slot),
+			   len);
+	btrfs_release_path(root, cpath);
+}
+
+long btrfs_ioctl_clone(struct file *file, unsigned long src_fd)
+{
+	struct inode *inode = fdentry(file)->d_inode;
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+	struct file *src_file;
+	struct inode *src;
+	struct btrfs_trans_handle *trans;
+	int ret;
+	u64 pos;
+	struct btrfs_path *path;
+	struct btrfs_key key;
+	struct extent_buffer *leaf;
+	u32 nritems;
+	int nextret;
+	int slot;
+
+	src_file = fget(src_fd);
+	if (!src_file)
+		return -EBADF;
+	src = src_file->f_dentry->d_inode;
+
+	ret = -EXDEV;
+	if (src->i_sb != inode->i_sb)
+		goto out_fput;
+
+	if (inode < src) {
+		mutex_lock(&inode->i_mutex);
+		mutex_lock(&src->i_mutex);
+	} else {
+		mutex_lock(&src->i_mutex);
+		mutex_lock(&inode->i_mutex);
+	}
+
+	ret = -ENOTEMPTY;
+	if (inode->i_size)
+		goto out_unlock;
+
+	/* do any pending delalloc/csum calc on src, one way or
+	   another, and lock file content */
+	while (1) {
+		filemap_write_and_wait(src->i_mapping);
+		lock_extent(&BTRFS_I(src)->io_tree, 0, (u64)-1, GFP_NOFS);
+		if (BTRFS_I(src)->delalloc_bytes == 0)
+			break;
+		unlock_extent(&BTRFS_I(src)->io_tree, 0, (u64)-1, GFP_NOFS);
+	}
+
+	mutex_lock(&root->fs_info->fs_mutex);
+	trans = btrfs_start_transaction(root, 0);
+	path = btrfs_alloc_path();
+	pos = 0;
+	while (1) {
+		ret = btrfs_lookup_file_extent(trans, root, path, src->i_ino,
+					       pos, 0);
+		if (ret < 0)
+			goto out;
+		if (ret > 0) {
+			if (path->slots[0] == 0) {
+				ret = 0;
+				goto out;
+			}
+			path->slots[0]--;
+		}
+next_slot:
+		leaf = path->nodes[0];
+		slot = path->slots[0];
+		btrfs_item_key_to_cpu(leaf, &key, slot);
+		nritems = btrfs_header_nritems(leaf);
+
+		if (btrfs_key_type(&key) > BTRFS_CSUM_ITEM_KEY ||
+		    key.objectid != src->i_ino)
+			goto out;
+		if (btrfs_key_type(&key) == BTRFS_EXTENT_DATA_KEY) {
+			struct btrfs_file_extent_item *extent;
+			int found_type;
+			pos = key.offset;
+			extent = btrfs_item_ptr(leaf, slot,
+						struct btrfs_file_extent_item);
+			found_type = btrfs_file_extent_type(leaf, extent);
+			if (found_type == BTRFS_FILE_EXTENT_REG) {
+				u64 len = btrfs_file_extent_num_bytes(leaf,
+								      extent);
+				u64 ds = btrfs_file_extent_disk_bytenr(leaf,
+								       extent);
+				u64 dl = btrfs_file_extent_disk_num_bytes(leaf,
+								 extent);
+				u64 off = btrfs_file_extent_offset(leaf,
+								   extent);
+				btrfs_insert_file_extent(trans, root,
+							 inode->i_ino, pos,
+							 ds, dl, len, off);
+				/* ds == 0 means there's a hole */
+				if (ds != 0) {
+					btrfs_inc_extent_ref(trans, root,
+						     ds, dl,
+						     root->root_key.objectid,
+						     trans->transid,
+						     inode->i_ino, pos);
+				}
+				pos = key.offset + len;
+			} else if (found_type == BTRFS_FILE_EXTENT_INLINE) {
+				dup_item_to_inode(trans, root, path, leaf, slot,
+						  &key, inode->i_ino);
+				pos = key.offset + btrfs_item_size_nr(leaf,
+								      slot);
+			}
+		} else if (btrfs_key_type(&key) == BTRFS_CSUM_ITEM_KEY)
+			dup_item_to_inode(trans, root, path, leaf, slot, &key,
+					  inode->i_ino);
+
+		if (slot >= nritems - 1) {
+			nextret = btrfs_next_leaf(root, path);
+			if (nextret)
+				goto out;
+		} else {
+			path->slots[0]++;
+		}
+		goto next_slot;
+	}
+
+out:
+	btrfs_free_path(path);
+	ret = 0;
+
+	inode->i_blocks = src->i_blocks;
+	i_size_write(inode, src->i_size);
+	btrfs_update_inode(trans, root, inode);
+
+	unlock_extent(&BTRFS_I(src)->io_tree, 0, (u64)-1, GFP_NOFS);
+
+	btrfs_end_transaction(trans, root);
+	mutex_unlock(&root->fs_info->fs_mutex);
+
+out_unlock:
+	mutex_unlock(&src->i_mutex);
+	mutex_unlock(&inode->i_mutex);
+out_fput:
+	fput(src_file);
+	return ret;
+}
+
 long btrfs_ioctl(struct file *file, unsigned int
 		cmd, unsigned long arg)
 {
@@ -3116,6 +3281,8 @@
 		return btrfs_ioctl_add_dev(root, (void __user *)arg);
 	case BTRFS_IOC_BALANCE:
 		return btrfs_balance(root->fs_info->dev_root);
+	case BTRFS_IOC_CLONE:
+		return btrfs_ioctl_clone(file, arg);
 	}
 
 	return -ENOTTY;
diff -Nur btrfs-0.14/ioctl.h kernel-f6ba18a50ad7/ioctl.h
--- btrfs-0.14/ioctl.h	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/ioctl.h	2008-05-02 14:13:49.000000000 -0600
@@ -36,6 +36,7 @@
 				   struct btrfs_ioctl_vol_args)
 #define BTRFS_IOC_SCAN_DEV _IOW(BTRFS_IOCTL_MAGIC, 4, \
 				   struct btrfs_ioctl_vol_args)
+#define BTRFS_IOC_CLONE        _IOW(BTRFS_IOCTL_MAGIC, 9, int)
 #define BTRFS_IOC_ADD_DEV _IOW(BTRFS_IOCTL_MAGIC, 10, \
 				   struct btrfs_ioctl_vol_args)
 #define BTRFS_IOC_RM_DEV _IOW(BTRFS_IOCTL_MAGIC, 11, \
diff -Nur btrfs-0.14/ordered-data.c kernel-f6ba18a50ad7/ordered-data.c
--- btrfs-0.14/ordered-data.c	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/ordered-data.c	2008-05-02 14:13:49.000000000 -0600
@@ -18,6 +18,7 @@
 
 #include <linux/gfp.h>
 #include <linux/slab.h>
+#include <linux/blkdev.h>
 #include "ctree.h"
 #include "transaction.h"
 #include "btrfs_inode.h"
diff -Nur btrfs-0.14/transaction.c kernel-f6ba18a50ad7/transaction.c
--- btrfs-0.14/transaction.c	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/transaction.c	2008-05-02 14:13:49.000000000 -0600
@@ -814,6 +814,9 @@
 	int ret;
 
 	mutex_lock(&root->fs_info->fs_mutex);
+	if (root->fs_info->closing)
+		goto out;
+
 	mutex_lock(&root->fs_info->trans_mutex);
 	cur = root->fs_info->running_transaction;
 	if (!cur) {
@@ -838,12 +841,13 @@
 
 void btrfs_transaction_queue_work(struct btrfs_root *root, int delay)
 {
-	queue_delayed_work(trans_wq, &root->fs_info->trans_work, delay);
+	if (!root->fs_info->closing)
+		queue_delayed_work(trans_wq, &root->fs_info->trans_work, delay);
 }
 
 void btrfs_transaction_flush_work(struct btrfs_root *root)
 {
-	cancel_rearming_delayed_workqueue(trans_wq, &root->fs_info->trans_work);
+	cancel_delayed_work(&root->fs_info->trans_work);
 	flush_workqueue(trans_wq);
 }
 
diff -Nur btrfs-0.14/volumes.c kernel-f6ba18a50ad7/volumes.c
--- btrfs-0.14/volumes.c	2008-04-29 12:28:55.000000000 -0600
+++ kernel-f6ba18a50ad7/volumes.c	2008-05-02 14:13:49.000000000 -0600
@@ -547,7 +547,7 @@
 	struct extent_buffer *leaf;
 	struct btrfs_key key;
 	unsigned long ptr;
-	u64 free_devid;
+	u64 free_devid = 0;
 
 	root = root->fs_info->chunk_root;
 
