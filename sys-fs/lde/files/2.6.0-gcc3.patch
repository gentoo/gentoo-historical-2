--- src/main_lde.c.orig	2003-11-11 10:06:07.847527296 -0500
+++ src/main_lde.c	2003-11-11 10:06:40.338587904 -0500
@@ -79,7 +79,7 @@
 char *badblocks_directory = NULL;
 
 int CURR_DEVICE = 0;
-volatile struct _lde_flags lde_flags = 
+volatile struct _lde_flags my_lde_flags = 
   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } ;
 
 void (*lde_warn)(char *fmt, ...) = tty_warn;
@@ -110,18 +110,18 @@
   /* Set last character to 0 (we've allocated a space for the 0) */
   mtab[statbuf.st_size] = 0;
   if (strstr(mtab, device_name))
-    lde_flags.mounted = 1;
+    my_lde_flags.mounted = 1;
   else
-    lde_flags.mounted = 0;
+    my_lde_flags.mounted = 0;
   free(mtab);
 
-  return lde_flags.mounted;
+  return my_lde_flags.mounted;
 }
 
 /* Define a handler for Interrupt signals: Ctrl-C */
 static void handle_sigint(int a, void * b, void *c)
 {
-  lde_flags.quit_now = 1;
+  my_lde_flags.quit_now = 1;
 }
 
 int check_root(void)
@@ -293,10 +293,10 @@
 	exit(0);
 	break;
       case 'a': /* Search disk space marked in use as well as unused */
-	lde_flags.search_all = 1;
+	my_lde_flags.search_all = 1;
 	break;
       case '0': /* Linux 2.0 blanked indirect workaround */
-	lde_flags.blanked_indirects = 1;
+	my_lde_flags.blanked_indirects = 1;
 	break;
       case 'g': /* Search for an inode which contains the specified block */
 	opts->grep_mode = 1;
@@ -325,14 +325,14 @@
 	break;
       case 'r':
       case 'p': /* open FS read only */
-	lde_flags.paranoid = 1;
+	my_lde_flags.paranoid = 1;
 	break;
       case 'P': /* Superblock scanner */
 	opts->superscan = 1;
 	opts->skiptableread = 1;
 	break;
       case 'q': /* no audio -- well nop beeps */
-	lde_flags.quiet = 1;
+	my_lde_flags.quiet = 1;
 	break;
       case 's': /* Override blocksize */
 	opts->blocksize = read_num(optarg);
@@ -393,7 +393,7 @@
 	opts->search_off = read_num(optarg);
 	break;
 	  case 'F': /* Log all errors/messages to /tmp/ldeerrors */
-	lde_flags.logtofile = 1;
+	my_lde_flags.logtofile = 1;
 	break;
       case 'L': /* Set length for search string */
 	opts->search_len = read_num(optarg);
@@ -403,21 +403,21 @@
 	}
 	break;
       case 'w': /* Set FS writable */
-	lde_flags.write_ok = 1;
+	my_lde_flags.write_ok = 1;
 	break;
       case '!': /* Search for indirect blocks. */
-	lde_flags.indirect_search = 1;
+	my_lde_flags.indirect_search = 1;
 	opts->search_string = "";
 	opts->search_len = 0;
 	break;
       case '@': /* Lookup inodes on search matches. */
-	lde_flags.inode_lookup = 1;
+	my_lde_flags.inode_lookup = 1;
 	break;
       case '#': /* Check for recoverablilty on search matches. */
-	lde_flags.check_recover = 1;
+	my_lde_flags.check_recover = 1;
 	break;
       case '%': /* Always append data when recovery file exists */
-	lde_flags.always_append = 1;
+	my_lde_flags.always_append = 1;
 	break;
       case 'f': /* Specify name of recovery file */
 	opts->recover_file_name = optarg;
@@ -458,7 +458,7 @@
 
   struct _main_opts main_opts = { 0, 0, 0, AUTODETECT, 0, 0, 0UL, 0UL, NULL, NULL, NULL, 0, 0, 0, 0 };
 
-  /* Set things up to handle control-c:  just sets lde_flags.quit_now to 1 */
+  /* Set things up to handle control-c:  just sets my_lde_flags.quit_now to 1 */
   sigemptyset(&sa_mask);
   intaction.sa_handler = (void *)handle_sigint;
   intaction.sa_mask = sa_mask;
@@ -467,17 +467,17 @@
 
   parse_cmdline(argc, argv, &main_opts);
 
-  if (check_mount(device_name)&&!lde_flags.paranoid)
+  if (check_mount(device_name)&&!my_lde_flags.paranoid)
     lde_warn("Device \"%s\" is mounted, be careful",device_name);
 
 #ifndef PARANOID
-  if (!lde_flags.paranoid) {
+  if (!my_lde_flags.paranoid) {
     CURR_DEVICE = open(device_name,O_RDWR|O_BINARY);
     if (CURR_DEVICE < 0) {
       lde_warn("No write access to \"%s\",  attempting to open read-only.",
 	       device_name);
       CURR_DEVICE = open(device_name,O_RDONLY|O_BINARY);
-      lde_flags.write_ok = 0;
+      my_lde_flags.write_ok = 0;
     }
   } else
 #endif
@@ -507,7 +507,7 @@
   /* Process requests handled by tty based lde */
   if (main_opts.recover_file_name!=NULL) {
     /* Check if file exists, if so, check if append flag is set and open accordingly */
-    if ( ( (fp = open(main_opts.recover_file_name,O_RDONLY|O_BINARY)) > 0 ) && lde_flags.always_append ) {
+    if ( ( (fp = open(main_opts.recover_file_name,O_RDONLY|O_BINARY)) > 0 ) && my_lde_flags.always_append ) {
       close(fp);
       fp = open(main_opts.recover_file_name,O_WRONLY|O_APPEND|O_BINARY);
     } else {  /* It's ok to create a new file */
@@ -550,14 +550,14 @@
       }
 
       /* Looks for recoverable inodes */
-      if (lde_flags.check_recover) {
+      if (my_lde_flags.check_recover) {
 	lde_warn = no_warn;  /* Suppress output */
 	for (nr=main_opts.dump_start; nr<main_opts.dump_end; nr++) {
-	  if (lde_flags.quit_now) {
+	  if (my_lde_flags.quit_now) {
 	    fprintf(stderr,"Search aborted at inode 0x%lX\n",nr);
 	    exit(0);
 	  }
-	  if ((!FS_cmd.inode_in_use(nr))||(lde_flags.search_all)) {
+	  if ((!FS_cmd.inode_in_use(nr))||(my_lde_flags.search_all)) {
 	    GInode = FS_cmd.read_inode(nr);
 	    /* Make sure there's some data here */
 	    hasdata = 0;
@@ -584,7 +584,7 @@
 	  }
 	}
 	exit(0);
-      } /* if (lde_flags.check_recover) */
+      } /* if (my_lde_flags.check_recover) */
 
     } else {
       if ((main_opts.dump_start>sb->nzones)||(main_opts.dump_end>sb->nzones)) {
@@ -597,9 +597,9 @@
       }
 
       /* Lookup blocks inode reference and exit */
-      if (lde_flags.inode_lookup) {
+      if (my_lde_flags.inode_lookup) {
 	for (nr=main_opts.dump_start; nr<main_opts.dump_end; nr++) {
-	  if (lde_flags.quit_now) {
+	  if (my_lde_flags.quit_now) {
 	    fprintf(stderr,"Search aborted at block 0x%lX\n",nr);
 	    exit(0);
 	  }
@@ -607,7 +607,7 @@
 	  if ( (inode_nr = find_inode(nr, 0UL)) ) {
 	    printf("found in inode 0x%lX\n",inode_nr);
 	  } else {
-	    printf("not found in any %sinode\n",((lde_flags.search_all)?"":"unused ") );
+	    printf("not found in any %sinode\n",((my_lde_flags.search_all)?"":"unused ") );
 	  }
 	}
 	exit(0);
@@ -615,7 +615,7 @@
 
     }
     for (nr=main_opts.dump_start; nr<main_opts.dump_end; nr++) {
-      if (lde_flags.quit_now) {
+      if (my_lde_flags.quit_now) {
 	fprintf(stderr,"\nDump aborted at 0x%lX\n",nr);
 	exit(0);
       }
