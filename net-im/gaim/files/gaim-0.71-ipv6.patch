diff -ur gaim-0.70/AUTHORS gaim-0.70.new/AUTHORS
--- gaim-0.70/AUTHORS	2003-09-23 21:33:40.000000000 -0700
+++ gaim-0.70.new/AUTHORS	2003-10-17 09:37:57.000000000 -0700
@@ -34,6 +34,7 @@
 Etan 'deryni' Reisner
 Ethan 'Paco-Paco' Blanton
 Robert 'Robot101' McQueen
+Ryan 'red0x' Du Bois
 
 Just Because:
 ------------
Only in gaim-0.70: gaim.spec
diff -ur gaim-0.70/src/protocols/oscar/ft.c gaim-0.70.new/src/protocols/oscar/ft.c
--- gaim-0.70/src/protocols/oscar/ft.c	2003-06-19 21:16:22.000000000 -0700
+++ gaim-0.70.new/src/protocols/oscar/ft.c	2003-10-17 12:47:30.000000000 -0700
@@ -258,7 +258,14 @@
 	if ((acceptfd = accept(cur->fd, &addr, &addrlen)) == -1)
 		return 0; /* not an error */
 
-	if (addr.sa_family != AF_INET) { /* just in case IPv6 really is happening */
+	/* red0x: ipv6 is handled transparently in glibc, just support ipv6 and ipv4 will follow... */
+	/* leaving AF_INET only down here is what was breaking file transfers for me
+	   as I have ipv6 support in kernel.  Anyone with ipv6 support in kernel
+	   has most incoming ipv4 connections wrapped into ipv6 for the transparent
+	   ipv6/ipv4 interroperability stuff in glibc.  If we deny ipv6 connections
+	   then no one with that patch can send and receive files.  All I did was allow
+	   ipv6 incoming, and unwrap the ipv4 inside it automagically */
+	if (addr.sa_family != AF_INET && addr.sa_family != AF_INET6) { /* just in case IPv6 really is happening */
 		close(acceptfd);
 		aim_conn_close(cur);
 		return -1;
