--- gaim-0.59.orig/src/aim.c	2002-05-31 14:13:02.000000000 +0900
+++ gaim-0.59/src/aim.c	2002-06-27 10:51:43.000000000 +0900
@@ -644,6 +644,7 @@
 	}		
 #endif
 
+	init_utf8_converter();
 
 #ifdef USE_APPLET
 	init_applet_mgr(argc, argv);
--- gaim-0.59.orig/src/gaim.h	2002-06-25 10:29:59.000000000 +0900
+++ gaim-0.59/src/gaim.h	2002-06-27 10:53:21.000000000 +0900
@@ -432,8 +432,9 @@
 extern gchar *strdup_withhtml(const gchar *);
 extern void away_on_login(char *);
 extern void system_log(enum log_event, struct gaim_connection *, struct buddy *, int);
-extern unsigned char *utf8_to_str(unsigned char *);
-extern char *str_to_utf8(unsigned char *);
+extern void init_utf8_converter();
+extern char *utf8_to_str(const char *);
+extern char *str_to_utf8(const char *);
 extern char *add_cr(char *);
 extern void strip_linefeed(char *);
 extern time_t get_time(int, int, int, int, int, int);
--- gaim-0.59.orig/src/util.c	2002-06-25 10:29:59.000000000 +0900
+++ gaim-0.59/src/util.c	2002-06-27 12:34:50.000000000 +0900
@@ -33,6 +33,8 @@
 #include <sys/wait.h>
 #include <ctype.h>
 #include <math.h>
+#include <langinfo.h>
+#include <iconv.h>
 #include "gaim.h"
 #include "prpl.h"
 #include "gtkspell.h"
@@ -1118,90 +1120,194 @@
 	fclose(fd);
 }
 
-unsigned char *utf8_to_str(unsigned char *in)
+/* Default system encoding */
+static char system_encoding[256] = "ASCII";
+
+/* Acquire and remember default character encoding for future conversion */
+void init_utf8_converter()
+{
+	char* tmp;
+	setlocale(LC_ALL, "");
+	tmp = nl_langinfo(CODESET);
+	if ( tmp != NULL ) {
+		strcpy(system_encoding, tmp);
+        }
+}
+
+char *utf8_to_str(const char *in)
 {
 	int n = 0, i = 0;
 	int inlen;
-	unsigned char *result;
+        char *result;
+        iconv_t cd1, cd2; /* cd1: UTF-8->UCS-4, cd2: UCS-4->system_encoding */
+	size_t outleft, ucs4_outleft;
+	size_t old_inlen, old_outleft;
+	size_t tmp;
+	char *result_ptr;
+	char *ucs4_result;
+	char *ucs4_result_ptr;
 
 	if (!in)
 		return NULL;
 
-	inlen = strlen(in);
-
-	result = g_malloc(inlen + 1);
+	cd1 = iconv_open("UCS-4", "UTF-8");
+	cd2 = iconv_open(system_encoding, "UCS-4");
+	
+	if ( cd1 == (iconv_t)-1 || cd2 == (iconv_t)-1 ) {
+		if ( cd1 != (iconv_t)-1 ) {
+			iconv_close(cd1);
+		}
+		else if ( cd2 != (iconv_t)-1 ) {
+			iconv_close(cd2);
+		}
+		
+		/* failed to open converter. fall back to default conversion */
+		inlen = strlen(in);
+
+		result = g_malloc(inlen + 1);
+
+		while (n <= inlen - 1) {
+			long c = (long)in[n];
+			if (c < 0x80)
+				result[i++] = (char)c;
+			else {
+				if ((c & 0xC0) == 0xC0)
+					result[i++] =
+					(char)(((c & 0x03) << 6) | (((unsigned char)in[++n]) & 0x3F));
+				else if ((c & 0xE0) == 0xE0) {
+					if (n + 2 <= inlen) {
+						result[i] =
+						(char)(((c & 0xF) << 4) | (((unsigned char)in[++n]) & 0x3F));
+						result[i] =
+						(char)(((unsigned char)result[i]) |
+							(((unsigned char)in[++n])  & 0x3F));
+						i++;
+					} else
+						n += 2;
+				} else if ((c & 0xF0) == 0xF0)
+					n += 3;
+				else if ((c & 0xF8) == 0xF8)
+					n += 4;
+				else if ((c & 0xFC) == 0xFC)
+					n += 5;
+			}
+			n++;
 
-	while (n <= inlen - 1) {
-		long c = (long)in[n];
-		if (c < 0x80)
-			result[i++] = (char)c;
-		else {
-			if ((c & 0xC0) == 0xC0)
-				result[i++] =
-				    (char)(((c & 0x03) << 6) | (((unsigned char)in[++n]) & 0x3F));
-			else if ((c & 0xE0) == 0xE0) {
-				if (n + 2 <= inlen) {
-					result[i] =
-					    (char)(((c & 0xF) << 4) | (((unsigned char)in[++n]) & 0x3F));
-					result[i] =
-					    (char)(((unsigned char)result[i]) |
-						   (((unsigned char)in[++n]) & 0x3F));
-					i++;
-				} else
-					n += 2;
-			} else if ((c & 0xF0) == 0xF0)
-				n += 3;
-			else if ((c & 0xF8) == 0xF8)
-				n += 4;
-			else if ((c & 0xFC) == 0xFC)
-				n += 5;
 		}
-		n++;
+		result[i] = '\0';
+		
+		return result;
 	}
-	result[i] = '\0';
 
+	/* use iconv to convert UTF-8 to system encoding */
+	/* we will convert UTF-8 to UCS-4 and convert it again to system encoding
+	  one character by one because of the bug of iconv which doesn't convert
+	  all character when it encountered a character which doesn't exist
+	  in the target encoding charset. */
+
+	inlen = strlen(in);
+	if ( inlen <= 0 ) { /* no need to process an empty string. */
+		result = g_malloc(1);
+		result[0] = '\0';
+		return result;
+	}
+	outleft = inlen * 6; /* in maximum, one character will occupy 6 bytes in UTF-8 */
+	result = g_malloc(outleft + 1);
+	ucs4_outleft = inlen * 4;
+	ucs4_result = g_malloc(ucs4_outleft); /* ucs4 conversion buffer */
+	result_ptr = ucs4_result;
+	tmp = ucs4_outleft;
+	iconv(cd1, &in, &inlen, &result_ptr, &ucs4_outleft);
+	n = (tmp - ucs4_outleft) / 4; /* 'n' will indicate the number of chars */
+	debug_printf("ucs4_bytes: %d", (tmp-ucs4_outleft));
+
+	result_ptr = result;
+	ucs4_result_ptr = ucs4_result;
+	tmp = outleft; /* remember last buffer remainder */
+	for ( i = 0; i < n; i ++ ) {
+		inlen = 4;
+		iconv(cd2, &ucs4_result_ptr, &inlen, &result_ptr, &outleft);
+		if ( tmp == outleft ) {
+			/* if nothing has ben converted, add '?' symbol */
+			*(result_ptr++) = '?';
+			outleft --;
+			ucs4_result_ptr += 4;
+		}
+		
+		tmp = outleft; /* remember last buffer remainder */
+	}
+	iconv_close(cd2);
+	iconv_close(cd1);
+	
+	*result_ptr = '\0';
+	
+	g_free(ucs4_result);
+	
 	return result;
 }
 
-char *str_to_utf8(unsigned char *in)
+char *str_to_utf8(const char *in)
 {
 	int n = 0, i = 0;
 	int inlen;
 	char *result = NULL;
+	iconv_t cd;
+	size_t outbytesleft;
+	char *result_ptr;
 
 	if (!in)
 		return NULL;
 
-	inlen = strlen(in);
-
-	result = g_malloc(inlen * 2 + 1);
-
-	while (n < inlen) {
-		long c = (long)in[n];
-		if (c == 27) {
-			n += 2;
-			if (in[n] == 'x')
-				n++;
-			if (in[n] == '3')
+	cd = iconv_open("UTF-8", system_encoding);
+	if ( cd == (iconv_t)-1 ) {
+		/* failed to open converter. fall back to default conversion */
+		inlen = strlen(in);
+		result = g_malloc(inlen * 2 + 1);
+		
+		while (n < inlen) {
+			long c = (long)in[n];
+			if (c == 27) {
+				n += 2;
+				if (in[n] == 'x')
+					n++;
+				if (in[n] == '3')
+					n++;
+				n += 2;
+				continue;
+			}
+			/* why are we removing newlines and carriage returns?
+			if ((c == 0x0D) || (c == 0x0A)) {
 				n++;
-			n += 2;
-			continue;
-		}
-		/* why are we removing newlines and carriage returns?
-		if ((c == 0x0D) || (c == 0x0A)) {
+				continue;
+			}
+			*/
+			if (c < 128)
+				result[i++] = (char)c;
+			else {
+				result[i++] = (char)((c >> 6) | 192);
+				result[i++] = (char)((c & 63) | 128);
+			}
 			n++;
-			continue;
-		}
-		*/
-		if (c < 128)
-			result[i++] = (char)c;
-		else {
-			result[i++] = (char)((c >> 6) | 192);
-			result[i++] = (char)((c & 63) | 128);
 		}
-		n++;
+		result[i] = '\0';
+		
+		return result;
 	}
-	result[i] = '\0';
+
+	/* use iconv to convert UTF-8 to system encoding */
+	inlen = strlen(in);
+	if ( inlen <= 0 ) { /* No need to process an empty string. */
+		result = g_malloc(1);
+		result[0] = '\0';
+		return result;
+	}
+	outbytesleft = inlen * 6; /* in maximum, one character will occupy 6 bytes in UTF-8 */
+	result = g_malloc(outbytesleft + 1);
+	result_ptr = result;
+	/* convert message */
+	iconv(cd, &in, &inlen, &result_ptr, &outbytesleft);
+	iconv_close(cd);
+	*result_ptr = '\0';
 
 	return result;
 }
--- gaim-0.59.orig/src/protocols/msn/msn.c	2002-06-25 10:29:59.000000000 +0900
+++ gaim-0.59/src/protocols/msn/msn.c	2002-06-27 12:46:41.000000000 +0900
@@ -179,6 +179,7 @@
 {
 	static char buf[MSN_BUF_LEN];
 	int i, j = 0;
+	char* result;
 
 	bzero(buf, sizeof(buf));
 	for (i = 0; i < strlen(msg); i++) {
@@ -195,6 +196,10 @@
 	}
 	buf[j] = 0;
 
+	result = utf8_to_str(buf);
+	strcpy(buf, result);
+	g_free(result);
+
 	return buf;
 }
 
@@ -202,18 +207,23 @@
 {
 	static char buf[MSN_BUF_LEN];
 	int i, j = 0;
+	char* tmp;
+
+	tmp = str_to_utf8(msg);
 
 	bzero(buf, sizeof(buf));
-	for (i = 0; i < strlen(msg); i++) {
-		if (isalnum(msg[i]))
-			buf[j++] = msg[i];
+	for (i = 0; i < strlen(tmp); i++) {
+		if (isalnum(tmp[i]))
+			buf[j++] = tmp[i];
 		else {
-			sprintf(buf + j, "%%%02x", (unsigned char)msg[i]);
+			sprintf(buf + j, "%%%02x", (unsigned char)tmp[i]);
 			j += 3;
 		}
 	}
 	buf[j] = 0;
 
+	g_free(tmp);
+
 	return buf;
 }
 
@@ -343,6 +353,7 @@
 			g_snprintf(msg, sizeof(msg), _("User unverified"));
 			break;
 		default:
+			return msg; /* Do not popup Unknown Error Code. */
 			g_snprintf(msg, sizeof(msg), _("Unknown Error Code"));
 			break;
 	}
