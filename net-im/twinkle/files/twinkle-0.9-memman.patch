Index: src/audits/memman.cpp
===================================================================
--- src/audits/memman.cpp	(revision 223)
+++ src/audits/memman.cpp	(working copy)
@@ -114,13 +114,22 @@
 		return;
 	}
 
-	pointer_map.erase(p);
+
 	bool array_mismatch = (is_array != i->second.is_array);
-	mtx_memman.unlock();
 
 	// Check mixing of array new/delete
+	// NOTE: after the pointer has been erased from pointer_map, the
+	//       iterator i is invalid.
+	//       The mutex mtx_memman should be unlocked before logging to
+	//       avoid dead locks.
 	if (array_mismatch) {
 		num_array_mixing++;
+		string allocation_filename = i->second.filename;
+		int allocation_lineno = i->second.lineno;
+		bool allocation_is_array = i->second.is_array;
+		pointer_map.erase(p);
+		mtx_memman.unlock();
+		
 		log_file->write_header("t_memman::trc_delete",
 			LOG_MEMORY, LOG_WARNING);
 		log_file->write_raw(filename);
@@ -130,21 +139,24 @@
 		log_file->write_raw(ptr2str(p));
 		log_file->write_raw(" is deleted ");
 		if (is_array) {
-			log_file->write_raw(" as array (delete []).\n");
+			log_file->write_raw("as array (delete []).\n");
 		} else {
-			log_file->write_raw(" normally (delete).\n");
+			log_file->write_raw("normally (delete).\n");
 		}
 		log_file->write_raw("But it was allocated ");
-		if (i->second.is_array) {
-			log_file->write_raw(" as array (new []) \n");
+		if (allocation_is_array) {
+			log_file->write_raw("as array (new []) \n");
 		} else {
-			log_file->write_raw(" normally (new) \n");
+			log_file->write_raw("normally (new) \n");
 		}
-		log_file->write_raw(i->second.filename);
+		log_file->write_raw(allocation_filename);
 		log_file->write_raw(", line ");
-		log_file->write_raw(i->second.lineno);
+		log_file->write_raw(allocation_lineno);
 		log_file->write_endl();
 		log_file->write_footer();
+	} else {
+		pointer_map.erase(p);
+		mtx_memman.unlock();
 	}
 }
 
