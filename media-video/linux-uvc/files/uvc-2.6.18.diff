--- linux-uvc-0.0.1_pre51.orig/uvcvideo.c	2006-09-15 15:16:15.000000000 +0200
+++ linux-uvc-0.0.1_pre51/uvcvideo.c	2006-09-15 15:29:36.000000000 +0200
@@ -330,6 +330,7 @@
 	struct uvc_video_queue queue;
 
 	struct uvc_streaming *streaming;
+	struct list_head devlist;
 
 	struct urb *urb[UVC_URBS];
 	char *iso_buffer[UVC_URBS];
@@ -636,6 +637,8 @@
 }
 #endif
 
+static LIST_HEAD(uvc_devlist);
+
 /* ------------------------------------------------------------------------
  * Utility functions
  */
@@ -2356,13 +2359,21 @@
 
 static int uvc_v4l2_open(struct inode *inode, struct file *file)
 {
-	struct video_device *vdev;
-	struct uvc_video_device *video;
+	struct uvc_video_device *h,*video = NULL;
+	struct list_head *list;
+	int minor = iminor(inode);
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_open\n");
 	down(&dev_sem);
-	vdev = video_devdata(file);
-	video = video_get_drvdata(vdev);
+
+	list_for_each(list,&uvc_devlist) {
+		h = list_entry(list, struct uvc_video_device, devlist);
+		if (h->vdev->minor == minor) {
+			video  = h;
+		}
+	}
+
+	file->private_data=video;
 
 	if (video->dev->state & UVC_DEV_DISCONNECTED) {
 		up(&dev_sem);
@@ -2383,8 +2394,16 @@
 
 static int uvc_v4l2_release(struct inode *inode, struct file *file)
 {
-	struct video_device *vdev = video_devdata(file);
-	struct uvc_video_device *video = video_get_drvdata(vdev);
+	int minor = iminor(inode);
+	struct uvc_video_device *h,*video = NULL;
+	struct list_head *list;
+
+	list_for_each(list,&uvc_devlist) {
+		h = list_entry(list, struct uvc_video_device, devlist);
+		if (h->vdev->minor == minor) {
+			video  = h;
+		}
+	}
 
 	uvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_release\n");
 	uvc_video_enable(video, 0);
@@ -2402,9 +2421,17 @@
 static int uvc_v4l2_do_ioctl(struct inode *inode, struct file *file,
 		     unsigned int cmd, void *arg)
 {
-	struct video_device *vdev = video_devdata(file);
-	struct uvc_video_device *video = video_get_drvdata(vdev);
 	int ret;
+	int minor = iminor(inode);
+	struct uvc_video_device *h,*video = NULL;
+	struct list_head *list;
+
+	list_for_each(list,&uvc_devlist) {
+		h = list_entry(list, struct uvc_video_device, devlist);
+		if (h->vdev->minor == minor) {
+			video  = h;
+		}
+	}
 
 	if (trace & UVC_TRACE_IOCTL) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
@@ -2732,8 +2759,7 @@
 
 static int uvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	struct video_device *vdev = video_devdata(file);
-	struct uvc_video_device *video = video_get_drvdata(vdev);
+	struct uvc_video_device *video = file->private_data;
 	struct uvc_buffer *buffer = NULL;
 	struct page *page;
 	unsigned long addr, start, size;
@@ -2799,8 +2825,7 @@
 
 static unsigned int uvc_v4l2_poll(struct file *file, poll_table *wait)
 {
-	struct video_device *vdev = video_devdata(file);
-	struct uvc_video_device *video = video_get_drvdata(vdev);
+	struct uvc_video_device *video = file->private_data;
 	struct uvc_buffer *buf;
 	unsigned int mask = 0;
 
@@ -3697,7 +3722,7 @@
 	 * 	  a pointer to the usb_interface ?
 	 */
 	dev->video.vdev = vdev;
-	video_set_drvdata(vdev, &dev->video);
+	list_add_tail(&dev->video.devlist,&uvc_devlist);
 
 	if (video_register_device(vdev, VFL_TYPE_GRABBER, -1) < 0) {
 		dev->video.vdev = NULL;
