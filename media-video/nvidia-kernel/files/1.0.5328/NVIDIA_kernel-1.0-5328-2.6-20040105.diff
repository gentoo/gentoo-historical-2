diff -ruN NVIDIA_kernel-1.0-5328/Makefile NVIDIA_kernel-1.0-5328-2.6/Makefile
--- NVIDIA_kernel-1.0-5328/Makefile	2003-12-17 23:55:01.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/Makefile	1970-01-01 01:00:00.000000000 +0100
@@ -1,141 +0,0 @@
-# This Makefile is automatically generated; do not edit
-#   Generated on 'builder3.nvidia.com' on Wed Dec 17 13:54:52 PST 2003
-
-LINUX_MODULE=nv-linux.o
-DEFINES=-D__KERNEL__ -DMODULE -D_LOOSE_KERNEL_NAMES -DNTRM -D_GNU_SOURCE -D_LOOSE_KERNEL_NAMES -D__KERNEL__ -DMODULE  -DNV_MAJOR_VERSION=1 -DNV_MINOR_VERSION=0 -DNV_PATCHLEVEL=5328  -DNV_UNIX   -DNV_LINUX   -DNV_INT64_OK   -DNVCPU_X86     
-INCLUDES=-I.
-
-OBJECTS=nv.o os-agp.o os-interface.o os-registry.o 
-HEADERS=os-agp.h os-interface.h nv-linux.h nv-misc.h nv-memdbg.h nv.h  rmretval.h nvtypes.h  $(VERSION_HDR)
-
-CFLAGS=-Wall -Wimplicit -Wreturn-type -Wswitch -Wformat -Wchar-subscripts -Wparentheses -Wpointer-arith  -Wno-multichar  -Werror -O -MD $(DEFINES) $(INCLUDES) -Wno-cast-qual -Wno-error
-
-RESMAN_KERNEL_MODULE=nv-kernel.o
-
-KERNDIR=/lib/modules/$(shell uname -r)
-
-# check for newer paths. if found, use them, otherwise use old paths
-# these wouldn't work with the gnu make included with rh6.2
-# KERNINC=$(if -d $(KERNDIR)/build, $(KERNDIR)/build/include, /usr/src/linux/include)
-# INSTALLDIR=$(if -d $(KERNDIR)/kernel, $(KERNDIR)/kernel/drivers/video, $(KERNDIR)/video)
-
-# this is slightly more brain-dead, but works..
-ifeq ($(shell if test -d $(KERNDIR)/build; then echo yes; fi),yes)
-KERNINC=$(KERNDIR)/build/include
-else
-KERNINC=/usr/src/linux/include
-endif
-
-ifeq ($(shell if test -d $(KERNDIR)/kernel; then echo yes; fi),yes)
-INSTALLDIR=$(KERNDIR)/kernel/drivers/video
-else
-INSTALLDIR=$(KERNDIR)/video
-endif
-
-ifeq ($(shell echo $(NVDEBUG)),1)
-  ifeq ($(shell test -z $(RMDEBUG) && echo yes),yes)
-    RMDEBUG=1
-  endif
-endif
-
-ifeq ($(shell echo $(RMDEBUG)),1)
-CFLAGS += -DDEBUG -g -fno-common
-endif
-
-# this is just plain wrong, get rid of it
-BROKENDIR=$(KERNDIR)/kernel/video
-
-INSTALL=$(shell which install)
-
-# allow specification of alternate include file tree on command line and extra defines
-ifdef SYSINCLUDE
-INCLUDES += -I$(SYSINCLUDE)
-else
-INCLUDES += -I$(KERNINC)
-endif
-
-ifeq ($(shell sh conftest.sh remap_page_range $(INCLUDES)), 5)
-  DEFINES += -DREMAP_PAGE_RANGE_5
-endif
-
-ifeq ($(shell sh conftest.sh remap_page_range $(INCLUDES)), 4)
-  DEFINES += -DREMAP_PAGE_RANGE_4
-endif
-
-DEFINES+=$(EXTRA_DEFINES)
-
-# allow build parameters to be passed in through the environment
-ifdef BUILD_PARAMS
-    DEFINES+=-D$(BUILD_PARAMS)
-endif
-
-VERSION_HDR=nv_compiler.h
-
-all: install
-
-install: package-install
-
-package-install: nvidia.o rmmod-check
-	@if [ `id -ur` != 0 ]; then \
-		echo Please run \"make install\" as root.; \
-	else \
-		if [ -d $(BROKENDIR) ]; then \
-			rm -f $(BROKENDIR)/NVdriver; \
-			rmdir --ignore-fail-on-non-empty $(BROKENDIR); \
-		fi && \
-		mkdir -p $(INSTALLDIR) && \
-		rm -f $(INSTALLDIR)/NVdriver && \
-		$(INSTALL) -m 0664 -o root -g root nvidia.o $(INSTALLDIR)/nvidia.o$(O) && \
-		PATH="$(PATH):/bin:/sbin" depmod -a && \
-                PATH="$(PATH):/bin:/sbin" modprobe nvidia && \
-		sh makedevices.sh && \
-		echo "nvidia.o installed successfully."; \
-	fi
-
-RMMOD_ERROR=\
-	echo ""; \
-	echo "Unable to remove existing NVIDIA kernel module."; \
-	echo "Please be sure you have exited X before attempting"; \
-	echo "to install the NVIDIA kernel module."; \
-	echo ""; \
-	echo -en "\033[1;31m"; \
-	echo -e  "*** Failed rmmod sanity check. Bailing out! ***"; \
-	echo -en "\033[0m"; \
-	exit 1;
-
-rmmod-check:
-	@if PATH="$(PATH):/bin:/sbin" lsmod | grep -w nvidia > /dev/null; then \
-		if ! PATH="($PATH):/bin:/sbin" rmmod nvidia > /dev/null; then $(RMMOD_ERROR) fi \
-	fi; \
-	if PATH="$(PATH):/bin:/sbin" lsmod | grep -w NVdriver > /dev/null; then \
-		if ! PATH="$(PATH):/bin:/sbin" rmmod NVdriver > /dev/null; then $(RMMOD_ERROR) fi \
-	fi
-
-gcc-check:
-	@if ! sh conftest.sh cc_sanity_check full_output $(CC); then exit 1; fi
-
-nvidia.o: gcc-check $(LINUX_MODULE) $(RESMAN_KERNEL_MODULE) 
-	ld -r -o $@ $(LINUX_MODULE) $(RESMAN_KERNEL_MODULE)
-
-$(VERSION_HDR): 
-	echo \#define NV_COMPILER \"`$(CC) -v 2>&1 | tail -n 1`\" > $@
-
-$(LINUX_MODULE): $(OBJECTS)
-	ld -r -o $@ $(OBJECTS)
-
-%.o: %.c $(HEADERS)
-	$(CC) -c $(CFLAGS) $<
-
-# debug tool to preprocess the file and leave .i to make it easier to untangle #defines
-%.i: %.c
-	$(CC) $(CFLAGS) -E $< > $@
-
-%.s: %.c
-	$(CC) $(CFLAGS) -S $< > $@
-
-
-clean:
-	$(RM) $(OBJECTS) $(LINUX_MODULE) $(VERSION_HDR) *.d NVdriver nvidia.o
-
-
--include $(OBJECTS:%.o=%.d)
diff -ruN NVIDIA_kernel-1.0-5328/Makefile.kbuild NVIDIA_kernel-1.0-5328-2.6/Makefile.kbuild
--- NVIDIA_kernel-1.0-5328/Makefile.kbuild	1970-01-01 01:00:00.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/Makefile.kbuild	2003-12-31 12:44:13.000000000 +0100
@@ -0,0 +1,261 @@
+#
+# KBUILD Makefile for the NVIDIA Linux kernel module.
+#
+# The motivation for replacing the original Makefile is the hope that this
+# version will simplify the build and installation process. In the past,
+# many architectural and cosmetic changes to the Linux kernel have made it
+# difficult to maintain compatibility or required duplication of logic.
+#
+# Linux 2.5 introduces numerous such changes, many of which impact modules.
+# Relying on KBUILD, some aspects of the build system otherwise difficult
+# to support (for example, module versioning) are abstracted away and dealt
+# with elsewhere, making life significantly easier here.
+#
+# The new approach currently has its own share of problems, some of which
+# are architectural difficulties with KBUILD, others minor annoyances. For
+# this reason, an improved version of the NVIDIA Makefile is available to
+# those experiencing difficulties.
+#
+# Please report any problems you may be experiencing with this experimental
+# Makefile to either one (or, preferably, both) of us:
+#
+# Alistair J Strachan (alistair@devzero.co.uk) (first pass, enhancements)
+# Christian Zander (zander@mail.minion.de) (enhancements)
+#
+
+all: install
+install: package-install
+
+#
+# The NVIDIA kernel module base name and static file names. KBUILD will go
+# ahead and append ".o" or ".ko" to form the final module name.
+#
+
+MODULE_NAME := nvidia
+VERSION_HEADER := nv_compiler.h
+
+#
+# List of object files to link into NVIDIA kernel module; make sure KBUILD
+# understands that we want a module.
+#
+
+RESMAN_CORE_OBJS := nv-kernel.o
+RESMAN_GLUE_OBJS := nv.o os-agp.o os-interface.o os-registry.o
+
+$(MODULE_NAME)-objs := $(RESMAN_CORE_OBJS) $(RESMAN_GLUE_OBJS)
+
+#
+# The precompiled kernel module build process requires a separation of the
+# closed source and open source object files.
+#
+
+KERNEL_GLUE_NAME := nv-linux.o
+KERNEL_GLUE_OBJS := $(RESMAN_GLUE_OBJS) $(MODULE_NAME).mod.o
+
+#
+# A bug in KBUILD 2.4 means that leaving obj-m set in top-level context
+# will cause Rules.make to call pathdown.sh, which is wrong. So, we only
+# set this conditional of a kernel-level instance.
+#
+
+ifdef TOPDIR
+obj-m += $(MODULE_NAME).o
+endif
+
+#
+# Include local source directory in $(CC)'s include path and set disable any
+# warning types that are of little interest to us.
+#
+
+EXTRA_CFLAGS += -I$(src)
+EXTRA_CFLAGS += -Wno-cast-qual -Wno-strict-prototypes
+
+#
+# Determine location of the Linux kernel source tree. Allow users to override
+# the default (i.e. automatically determined) kernel source location with the
+# SYSSRC directive; this new directive replaces NVIDIA's SYSINCLUDE.
+#
+
+ifdef SYSSRC
+  KERNEL_SOURCES := $(SYSSRC)
+  KERNEL_HEADERS := -I$(KERNEL_SOURCES)/include
+  MODULE_ROOT    := /lib/modules/$(shell uname -r)/kernel/drivers # XXX
+else
+  KERNEL_SOURCES := /lib/modules/$(shell uname -r)/build
+  KERNEL_HEADERS := -I$(KERNEL_SOURCES)/include
+  MODULE_ROOT    := /lib/modules/$(shell uname -r)/kernel/drivers
+endif
+
+#
+# We rely on these two definitions below; if they aren't set, we set them to
+# reasonable defaults (Linux 2.4's KBUILD, and top-level passes will not set
+# these).
+#
+
+src ?= .
+obj ?= .
+
+#
+# Sets any internal variables left unset by KBUILD (e.g. this happens during
+# a top-level run).
+#
+
+TOPDIR ?= $(KERNEL_SOURCES)
+PATCHLEVEL ?= $(shell sh $(src)/conftest.sh kernel_patch_level $(TOPDIR))
+
+#
+# Linux 2.4 uses the .o module extension. Linux 2.5, however, uses the .ko
+# module extension. Handle these gracefully.
+#
+
+ifeq ($(PATCHLEVEL), 4)
+  MODULE_OBJECT := $(MODULE_NAME).o
+else
+  MODULE_OBJECT := $(MODULE_NAME).ko
+endif
+
+#
+# NVIDIA specific CFLAGS and #define's. The remap_page_range check has become
+# necessary with the introduction of the five argument version to Linux 2.4
+# distribution kernels; this conflicting change cannot be detected at compile
+# time.
+#
+
+EXTRA_CFLAGS += -D__KERNEL__ -DMODULE -D_LOOSE_KERNEL_NAMES -DNTRM -D_GNU_SOURCE -D_LOOSE_KERNEL_NAMES -D__KERNEL__ -DMODULE  -DNV_MAJOR_VERSION=1 -DNV_MINOR_VERSION=0 -DNV_PATCHLEVEL=5328  -DNV_UNIX   -DNV_LINUX   -DNV_INT64_OK   -DNVCPU_X86
+
+ifeq ($(shell echo $(NVDEBUG)),1)
+  ifeq ($(shell test -z $(RMDEBUG) && echo yes),yes)
+    RMDEBUG=1
+  endif
+endif
+
+ifeq ($(shell echo $(RMDEBUG)),1)
+  EXTRA_CFLAGS += -DDEBUG -g -fno-common
+endif
+
+ifeq ($(shell sh $(src)/conftest.sh remap_page_range $(KERNEL_HEADERS)), 5)
+  EXTRA_CFLAGS += -DREMAP_PAGE_RANGE_5
+endif
+
+ifeq ($(shell sh $(src)/conftest.sh remap_page_range $(KERNEL_HEADERS)), 4)
+  EXTRA_CFLAGS += -DREMAP_PAGE_RANGE_4
+endif
+
+#
+# NVIDIA binary object file includes .common section.
+#
+
+EXTRA_LDFLAGS := -d
+
+#
+# Miscellaneous NVIDIA kernel module build support targets. They are needed
+# to satisfy KBUILD requirements and to support NVIDIA specifics.
+#
+
+$(obj)/nv-kernel.o:
+	cp $(src)/$(RESMAN_CORE_OBJS) $(obj)/$(RESMAN_CORE_OBJS)
+
+$(obj)/$(VERSION_HEADER):
+	echo \#define NV_COMPILER \"`$(CC) -v 2>&1 | tail -n 1`\" > $@
+
+$(obj)/nv.o: $(obj)/$(VERSION_HEADER)
+
+#
+# More quirks for Linux 2.4 KBUILD, which doesn't link automatically.
+#
+
+ifeq ($(PATCHLEVEL), 4)
+$(obj)/$(MODULE_NAME).o: $($(MODULE_NAME)-objs)
+	$(LD) $(EXTRA_LDFLAGS) -r -o $@ $($(MODULE_NAME)-objs)
+endif
+
+#
+# KBUILD build parameters.
+#
+
+KBUILD_PARAMS := -C $(KERNEL_SOURCES) SUBDIRS=$(PWD)
+
+#
+# NVIDIA sanity checks.
+#
+
+suser-sanity-check:
+	@if ! sh conftest.sh suser_sanity_check; then \
+	  echo; \
+	  echo "You have insufficient privileges for this operation. Please "; \
+	  echo "run \"make install\" as root!                               "; \
+	  echo; \
+	  exit 1; \
+	fi
+
+rmmod-sanity-check:
+	@if ! sh conftest.sh rmmod_sanity_check $(MODULE_NAME); then \
+	  echo; \
+	  echo "Unable to unload the currently loaded NVIDIA kernel module! "; \
+	  echo "Please be certain that you have exited X before attempting  "; \
+	  echo "to install this version.                                    "; \
+	  echo; \
+	  exit 1; \
+	fi
+
+cc-sanity-check:
+	@if ! sh conftest.sh cc_sanity_check full_output $(CC); then \
+		exit 1; \
+	fi
+
+#
+# Build the NVIDIA kernel module using Linux KBUILD. This target is used by
+# the "package-install" target below.
+#
+
+$(MODULE_OBJECT): cc-sanity-check
+	@make $(KBUILD_PARAMS) modules; \
+	if ! [ -f $(MODULE_OBJECT) ]; then \
+	  echo "$(MODULE_OBJECT) failed to build!"; \
+	  exit 1; \
+	fi
+
+#
+# Build the NVIDIA kernel module with KBUILD. Verify that the user posesses
+# sufficient privileges. Rebuild the module dependency file.
+#
+
+module-install: suser-sanity-check $(MODULE_OBJECT)
+	@mkdir -p $(MODULE_ROOT)/video; \
+	install -m 0664 -o root -g root $(MODULE_OBJECT) $(MODULE_ROOT)/video; \
+	/sbin/depmod -ae;
+
+#
+# This target builds, then installs, then creates device nodes and inserts
+# the module, if successful.
+#
+
+package-install: module-install rmmod-sanity-check
+	@sh makedevices.sh; \
+	/sbin/modprobe $(MODULE_NAME) && \
+	echo "$(MODULE_OBJECT) installed successfully.";
+
+#
+# Build an object file suitable for further processing by the installer and
+# inclusion as a precompiled kernel interface file.
+#
+
+$(KERNEL_GLUE_NAME): $(MODULE_OBJECT)
+	@ld -r -o $(KERNEL_GLUE_NAME) $(KERNEL_GLUE_OBJS)
+
+#
+# Support hack, KBUILD isn't prepared to clean up after external modules.
+#
+
+clean:
+	@rm -f $(RESMAN_GLUE_OBJS) .*.{cmd,flags}
+	@rm -f $(MODULE_NAME).{o,ko,mod.{o,c}} built-in.o $(VERSION_HEADER) *~
+
+#
+# Linux 2.4 KBUILD requires the inclusion of Rules.make; Linux 2.5's KBUILD
+# includes dependencies automatically.
+#
+
+ifeq ($(PATCHLEVEL), 4)
+include $(KERNEL_SOURCES)/Rules.make
+endif
diff -ruN NVIDIA_kernel-1.0-5328/Makefile.nvidia NVIDIA_kernel-1.0-5328-2.6/Makefile.nvidia
--- NVIDIA_kernel-1.0-5328/Makefile.nvidia	1970-01-01 01:00:00.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/Makefile.nvidia	2003-12-18 13:24:15.000000000 +0100
@@ -0,0 +1,139 @@
+# This Makefile is automatically generated; do not edit
+#   Generated on 'builder3.nvidia.com' on Thu Jun 19 04:05:35 PDT 2003
+
+LINUX_MODULE=nv-linux.o
+DEFINES=-D__KERNEL__ -DMODULE -D_LOOSE_KERNEL_NAMES -DKBUILD_MODNAME="nvidia" -DNTRM -D_GNU_SOURCE -D_LOOSE_KERNEL_NAMES -D__KERNEL__ -DMODULE  -DNV_MAJOR_VERSION=1 -DNV_MINOR_VERSION=0 -DNV_PATCHLEVEL=5328     -DNV_UNIX   -DNV_LINUX   -DNV_INT64_OK   -DNVCPU_X86
+INCLUDES=-I.
+
+OBJECTS=nv.o os-agp.o os-interface.o os-registry.o 
+HEADERS=os-agp.h os-interface.h nv-linux.h nv-misc.h nv-memdbg.h nv.h  rmretval.h nvtypes.h  $(VERSION_HDR)
+
+CFLAGS=-Wall -Wimplicit -Wreturn-type -Wswitch -Wformat -Wchar-subscripts -Wparentheses -Wcast-qual -Wno-multichar  -O -MD $(DEFINES) $(INCLUDES) -Wno-cast-qual
+
+RESMAN_KERNEL_MODULE=nv-kernel.o
+
+KERNDIR=/lib/modules/$(shell uname -r)
+
+# check for newer paths. if found, use them, otherwise use old paths
+# these wouldn't work with the gnu make included with rh6.2
+# KERNINC=$(if -d $(KERNDIR)/build, $(KERNDIR)/build/include, /usr/src/linux/include)
+# INSTALLDIR=$(if -d $(KERNDIR)/kernel, $(KERNDIR)/kernel/drivers/video, $(KERNDIR)/video)
+
+# this is slightly more brain-dead, but works..
+ifeq ($(shell if test -d $(KERNDIR)/build; then echo yes; fi),yes)
+KERNINC=$(KERNDIR)/build/include
+else
+KERNINC=/usr/src/linux/include
+endif
+
+ifeq ($(shell if test -d $(KERNDIR)/kernel; then echo yes; fi),yes)
+INSTALLDIR=$(KERNDIR)/kernel/drivers/video
+else
+INSTALLDIR=$(KERNDIR)/video
+endif
+
+ifeq ($(shell echo $(NVDEBUG)),1)
+  ifeq ($(shell test -z $(RMDEBUG) && echo yes),yes)
+    RMDEBUG=1
+  endif
+endif
+
+ifeq ($(shell echo $(RMDEBUG)),1)
+CFLAGS += -DDEBUG -g -fno-common
+endif
+
+# this is just plain wrong, get rid of it
+BROKENDIR=$(KERNDIR)/kernel/video
+
+INSTALL=$(shell which install)
+
+# allow specification of alternate include file tree on command line and extra defines
+ifdef SYSINCLUDE
+INCLUDES += -I$(SYSINCLUDE)
+INCLUDES += -I$(SYSINCLUDE)/asm/mach-default
+else
+INCLUDES += -I$(KERNINC)
+INCLUDES += -I$(KERNINC)/asm/mach-default
+endif
+
+ifeq ($(shell sh conftest.sh remap_page_range $(INCLUDES)), 5)
+  DEFINES += -DREMAP_PAGE_RANGE_5
+endif
+
+ifeq ($(shell sh conftest.sh remap_page_range $(INCLUDES)), 4)
+  DEFINES += -DREMAP_PAGE_RANGE_4
+endif
+
+DEFINES+=$(EXTRA_DEFINES)
+
+# allow build parameters to be passed in through the environment
+ifdef BUILD_PARAMS
+    DEFINES+=-D$(BUILD_PARAMS)
+endif
+
+VERSION_HDR=nv_compiler.h
+
+all: install
+
+install: package-install
+
+suser-sanity-check:
+	@if ! sh conftest.sh suser_sanity_check; then \
+	  echo; \
+	  echo "You have insufficient privileges for this operation. Please "; \
+	  echo "run \"make install\" as root!                               "; \
+	  echo; \
+	  exit 1; \
+	fi
+
+rmmod-sanity-check:
+	@if ! sh conftest.sh rmmod_sanity_check nvidia; then \
+	  echo; \
+	  echo "Unable to unload the currently loaded NVIDIA kernel module! "; \
+	  echo "Please be certain that you have exited X before attempting  "; \
+	  echo "to install this version.                                    "; \
+	  echo; \
+	  exit 1; \
+	fi
+
+cc-sanity-check:
+	@if ! sh conftest.sh cc_sanity_check full_output $(CC); then exit 1; fi
+
+package-install: suser-sanity-check nvidia.o rmmod-sanity-check
+	if [ -d $(BROKENDIR) ]; then \
+		rm -f $(BROKENDIR)/NVdriver; \
+		rmdir --ignore-fail-on-non-empty $(BROKENDIR); \
+	fi && \
+	mkdir -p $(INSTALLDIR) && \
+	rm -f $(INSTALLDIR)/NVdriver && \
+	$(INSTALL) -m 0664 -o root -g root nvidia.o $(INSTALLDIR)/nvidia.o$(O) && \
+	/sbin/depmod -a && \
+	/sbin/modprobe nvidia && \
+	sh makedevices.sh && \
+	echo "nvidia.o installed successfully."; \
+
+nvidia.o: cc-sanity-check $(LINUX_MODULE) $(RESMAN_KERNEL_MODULE) 
+	ld -d -r -o $@ $(LINUX_MODULE) $(RESMAN_KERNEL_MODULE)
+
+$(VERSION_HDR): 
+	echo \#define NV_COMPILER \"`$(CC) -v 2>&1 | tail -n 1`\" > $@
+
+$(LINUX_MODULE): $(OBJECTS)
+	ld -r -o $@ $(OBJECTS)
+
+%.o: %.c $(HEADERS)
+	$(CC) -c $(CFLAGS) $<
+
+# debug tool to preprocess the file and leave .i to make it easier to untangle #defines
+%.i: %.c
+	$(CC) $(CFLAGS) -E $< > $@
+
+%.s: %.c
+	$(CC) $(CFLAGS) -S $< > $@
+
+
+clean:
+	$(RM) $(OBJECTS) $(LINUX_MODULE) $(VERSION_HDR) *.d NVdriver nvidia.o
+
+
+-include $(OBJECTS:%.o=%.d)
diff -ruN NVIDIA_kernel-1.0-5328/conftest.sh NVIDIA_kernel-1.0-5328-2.6/conftest.sh
--- NVIDIA_kernel-1.0-5328/conftest.sh	2003-12-17 23:55:00.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/conftest.sh	2003-12-18 13:22:54.000000000 +0100
@@ -104,5 +104,79 @@
             exit 0
         fi
     ;;
+
+    cc_sanity_check)
+        shift
+        #
+        # Verify that the same compiler is used for the kernel and kernel
+        # module.
+        #
+        if test -n "$IGNORE_CC_MISMATCH" -o -n "$KERNDIR"; then
+          #
+          # The user chose to disable the gcc sanity test or is building
+          # the module for a kernel not currently running, which renders
+          # our test meaningless.
+          #
+          exit 0
+        fi
+
+        VERSION="^Linux version.* (.*) (\(gcc.*\)).*"
+        KERNEL=$(cat /proc/version | sed "s/$VERSION/\1/")
+        MODULE=$($* -v 2>&1 | tail -n 1)
+
+        if test "$KERNEL" != "$MODULE"; then
+          #
+          # The kernel seems to have been built with a different version
+          # of the C compiler, which may be a problem.
+          #
+          exit 1
+        else
+          exit 0
+        fi
+    ;;
+
+    kernel_patch_level)
+        shift
+        #
+        # Determine the kernel's major patch level; this is only done if we
+        # aren't told by KBUILD.
+        #
+        echo $(cat "$1"/Makefile | grep "PATCHLEVEL =" | cut -d " " -f 3)
+        exit 0
+    ;;
+
+    suser_sanity_check)
+        shift
+        #
+        # Determine the caller's user id to determine if we have sufficient
+        # privileges for the requested operation.
+        #
+        if test $(id -ur) != 0; then
+          exit 1
+        else
+          exit 0
+        fi
+    ;;
+
+    rmmod_sanity_check)
+        shift
+        #
+        # Make sure that any currently loaded NVIDIA kernel module can be
+        # unloaded.
+        #
+        if /sbin/lsmod | grep -q "$1"; then
+          /sbin/rmmod "$1" >& /dev/null
+        fi
+
+        if /sbin/lsmod | grep -q "$1"; then
+          #
+          # The NVIDIA kernel module is still loaded, most likely because
+          # it is busy.
+          #
+          exit 1
+        else
+          exit 0
+        fi
+    ;;
 esac
 
diff -ruN NVIDIA_kernel-1.0-5328/makedevices.sh NVIDIA_kernel-1.0-5328-2.6/makedevices.sh
--- NVIDIA_kernel-1.0-5328/makedevices.sh	2003-12-17 23:54:59.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/makedevices.sh	2003-12-18 13:22:54.000000000 +0100
@@ -8,47 +8,49 @@
 # create a temporary file
 tmp=`(mktemp -q /tmp/nvidia.XXXXXX) 2> /dev/null` || tmp="/tmp/nvidia.$$"
 
-paths=" /etc/modutils/aliases    \
-        /etc/modules.conf        \
-        /etc/conf.modules        "
-
-modconf=""
-for path in $paths; do
-   if [ -f "$path" ]; then
-       modconf=$path
-       break
+modconfs=" /etc/modutils/aliases    \
+           /etc/modules.conf        \
+           /etc/modprobe.d/aliases  \
+           /etc/modprobe.conf       \
+           /etc/conf.modules        "
+
+#
+# Pass the -p option to cp to preserve the permissions of $modconf and
+# /etc/rc.d/rc.modules across the update. Update all relevant files
+# including those eventually regenerated to avoid the need for awkward
+# logic here.
+#
+for modconf in $modconfs; do
+   if [ -f "$modconf" ]; then
+     cp -p $modconf $tmp
+     sed '/^alias.*\(NVdriver\|nvidia\)/d'  < $modconf   > $tmp
+
+     # make sure the last character in the file is a newline
+     [ `tail -n 1 $tmp | wc -l` = 0 ] && echo "" >> $tmp
+
+     if [ -c /dev/.devfsd ]; then
+       echo "alias /dev/nvidia* nvidia" >> $tmp
+     else
+       if [ `uname -r | cut -d '.' -f 2` = 6 ]; then
+           echo "alias	char-major-195*	nvidia" >> $tmp
+       else
+           echo "alias	char-major-195	nvidia" >> $tmp
+       fi
+     fi
+     mv -f $tmp $modconf
+     test -x /sbin/update-modules && /sbin/update-modules
    fi
 done
 
-if [ ! -z $modconf ]; then
-   # Initialize the permissions on $tmp so that we don't change the
-   # permissions of $modconf when we mv it into place
-   cp -p $modconf $tmp
-   sed '/^alias.*\(NVdriver\|nvidia\)/d'  < $modconf   > $tmp
-   
-   # make sure the last character in the file is a newline
-   [ `tail -n 1 $tmp | wc -l` = 0 ] && echo "" >> $tmp
-
-   if [ -c /dev/.devfsd ]; then
-     echo "alias /dev/nvidia*   nvidia" >> $tmp
-   else
-     echo "alias char-major-195 nvidia" >> $tmp
-   fi
-   mv -f $tmp $modconf
-   test -x /sbin/update-modules && /sbin/update-modules
-else
-  if [ -f /etc/rc.d/rc.modules ]; then
-    # Initialize the permissions on $tmp so that we don't change the
-    # permissions of /etc/rc.d/rc.modules when we mv it into place
-    cp -p /etc/rc.d/rc.modules $tmp
-    sed '/.*\(NVdriver\|nvidia\).*/d' < /etc/rc.d/rc.modules > $tmp
-
-    # make sure the last character in the file is a newline
-    [ `tail -n 1 $tmp | wc -l` = 0 ] && echo "" >> $tmp 
-
-    echo "/sbin/modprobe nvidia" >> $tmp
-    mv -f $tmp /etc/rc.d/rc.modules
-  fi
+if [ -f /etc/rc.d/rc.modules ]; then
+  cp -p /etc/rc.d/rc.modules $tmp
+  sed '/.*\(NVdriver\|nvidia\).*/d' < /etc/rc.d/rc.modules > $tmp
+
+  # make sure the last character in the file is a newline
+  [ `tail -n 1 $tmp | wc -l` = 0 ] && echo "" >> $tmp
+
+  echo -e "\n/sbin/modprobe nvidia" >> $tmp
+  mv -f $tmp /etc/rc.d/rc.modules
 fi
 
 if [ ! -c /dev/.devfsd ]; then
diff -ruN NVIDIA_kernel-1.0-5328/nv-linux.h NVIDIA_kernel-1.0-5328-2.6/nv-linux.h
--- NVIDIA_kernel-1.0-5328/nv-linux.h	2003-12-17 23:55:00.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/nv-linux.h	2003-12-23 10:50:21.000000000 +0100
@@ -21,34 +21,21 @@
 #  define MODVERSIONS
 #endif
 
-#if defined (MODVERSIONS)
-#include <linux/modversions.h>
-#endif
-
 #include <linux/kernel.h>
 #include <linux/module.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 12)
-#  error This driver does not support 2.2.11 or earlier kernels!
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
-#  define KERNEL_2_2
-#  warning NVIDIA is considering dropping support for linux-2.2 
-#  warning kernels. While end users are free to maintain their 
-#  warning own patches, or stick with current drivers, our new 
-#  warning drivers will not work "out of the box." If you are 
-#  warning concerned about lack of support for 2.2 kernels, 
-#  warning please let us know at linux-bugs@nvidia.com; we would
-#  warning like to know how many users would be seriously 
-#  warning impacted by this decision.
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
+#  error This driver does not support 2.2.x kernels!
 #elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 0)
-#  error This driver does not support 2.3.x development kernels!
+#  error This driver does not support 2.3.x kernels!
 #elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #  define KERNEL_2_4
 #elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
-#  error This driver does not support 2.5.x development kernels!
-#  define KERNEL_2_5
+#  error This driver does not support 2.5.x kernels!
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 7, 0)
+#  define KERNEL_2_6
 #else
-#  error This driver does not support 2.6.x or newer kernels!
+#  error This driver does not support development kernels!
 #endif
 
 #if defined (__ia64)
@@ -61,12 +48,15 @@
 #define __SMP__
 #endif
 
+#if defined (MODVERSIONS) && !defined (KERNEL_2_6)
+#include <linux/modversions.h>
+#endif
+
 #include <linux/types.h>            /* pic_t, size_t, __u32, etc        */
 #include <linux/errno.h>            /* error codes                      */
 #include <linux/list.h>             /* circular linked list             */
 #include <linux/stddef.h>           /* NULL, offsetof                   */
 #include <linux/wait.h>             /* wait queues                      */
-#include <linux/tqueue.h>           /* struct tq_struct                 */
 
 #include <linux/slab.h>             /* kmalloc, kfree, etc              */
 #include <linux/vmalloc.h>          /* vmalloc, vfree, etc              */
@@ -74,9 +64,15 @@
 #include <linux/poll.h>             /* poll_wait                        */
 #include <linux/delay.h>            /* mdelay, udelay                   */
 
+#ifdef KERNEL_2_6
+#include <linux/sched.h>            /* suser(), capable() replacement   */
+#include <linux/moduleparam.h>      /* module_param()                   */
+#include <linux/smp_lock.h>         /* kernel_locked                    */
+#include <asm/kmap_types.h>         /* page table entry lookup          */
+#endif
+
 #include <linux/pci.h>              /* pci_find_class, etc              */
-#include <linux/wrapper.h>          /* mem_map_reserve                  */
-#include <linux/interrupt.h>        /* mark_bh, init_bh, remove_bh      */
+#include <linux/interrupt.h>        /* tasklets, interrupt helpers      */
 #include <linux/timer.h>
 
 #include <asm/system.h>             /* cli, sli, save_flags             */
@@ -85,14 +81,9 @@
 #include <asm/page.h>               /* PAGE_OFFSET                      */
 #include <asm/pgtable.h>            /* pte bit definitions              */
 
-#if !defined (KERNEL_2_2)
 #include <linux/spinlock.h>
 #include <asm/semaphore.h>
 #include <linux/highmem.h>
-#else
-#include <asm/spinlock.h>
-#include <asm/semaphore.h>
-#endif
 
 #ifdef CONFIG_PROC_FS
 #include <linux/proc_fs.h>
@@ -299,13 +290,7 @@
  * DMA use with the hardware.  This has to be done differently for
  * different platforms and kernel versions.
  */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 2, 18)
-#define NV_VMALLOC(ptr, size) \
-    { \
-        (void *) (ptr) = vmalloc(size); \
-        VM_ALLOC_RECORD(ptr, size, "vm_alloc"); \
-    }
-#elif defined(NVCPU_IA64)
+#if defined(NVCPU_IA64)
 #define NV_VMALLOC(ptr, size) \
     { \
         (void *) (ptr) = vmalloc_dma(size); \
@@ -377,78 +362,174 @@
 
 #endif /* !defined NVWATCH */
 
+#define GET_MODULE_SYMBOL(mod,sym)      (const void *) inter_module_get(sym)
+#define PUT_MODULE_SYMBOL(sym)          (inter_module_put((char *) sym))
 
-#if !defined (KERNEL_2_2)
-#  define LINUX_VMA_OFFS(vma)           (((vma)->vm_pgoff) << PAGE_SHIFT)
-#  define GET_MODULE_SYMBOL(mod,sym)	(const void *) inter_module_get(sym)
-#  define PUT_MODULE_SYMBOL(sym)        inter_module_put((char *) sym)
-#  define GET_MAP_NR(phys_page)         virt_to_page(__va(phys_page))
-#  define MEM_MAP_READ_COUNT(map_nr)    (atomic_read(&(map_nr)->count))
-#  define MEM_MAP_INC_COUNT(map_nr)     (atomic_inc(&(map_nr)->count))
-#  define MEM_MAP_DEC_COUNT(map_nr)     (atomic_dec(&(map_nr)->count))
-#  define EVENT_QUEUE(ptr)               ((struct __wait_queue_head *)(ptr))
-#  define VMA_PRIVATE(vma)              ((vma)->vm_private_data)
-#  define INIT_EVENT_QUEUE(ptr) \
-     if (ptr == NULL) { \
-        NV_KMALLOC((ptr), sizeof(struct __wait_queue_head)); \
-        if (ptr) { \
-            memset((ptr), 0, sizeof(struct __wait_queue_head)); \
-            init_waitqueue_head((struct __wait_queue_head *)(ptr)); \
-        } \
-     }
-#  define FREE_EVENT_QUEUE(ptr)         NV_KFREE((ptr), sizeof(struct __wait_queue_head)); (ptr) = NULL;
-#else
-#  define in_irq()                      (local_irq_count[smp_processor_id()])
-#  define LINUX_VMA_OFFS(vma)           ((vma)->vm_offset)
-#  define GET_MODULE_SYMBOL(mod, sym)   (void*) get_module_symbol((mod), (sym))
-#  define PUT_MODULE_SYMBOL(sym)
-#  define GET_MAP_NR(phys_page)         MAP_NR(__va(phys_page))
-#  define MEM_MAP_READ_COUNT(map_nr)    (atomic_read(&mem_map[map_nr].count))
-#  define MEM_MAP_INC_COUNT(map_nr)     (atomic_inc(&mem_map[map_nr].count))
-#  define MEM_MAP_DEC_COUNT(map_nr)     (atomic_dec(&mem_map[map_nr].count))
-#  define EVENT_QUEUE(ptr)              ((struct wait_queue **) &(ptr))
-#  define VMA_PRIVATE(vma)              ((void*)((vma)->vm_pte))
-#  define INIT_EVENT_QUEUE(ptr)         if (ptr) { ((ptr) = NULL); }
-#  define FREE_EVENT_QUEUE(ptr)
+#ifdef KERNEL_2_6
+# define NV_IS_SUSER()                  capable(CAP_SYS_ADMIN)
+# define NV_PCI_DEVICE_NAME(x)          ((x)->pretty_name)
+# define NV_CLI()                       local_irq_disable()
+# define NV_SAVE_FLAGS(x)               local_save_flags(x)
+# define NV_RESTORE_FLAGS(x)            local_irq_restore(x)
+# define NV_MAY_SLEEP()                 (!in_interrupt() && !in_atomic())
+# define NV_SMP_NUM_CPUS                num_online_cpus()
+# define NV_MODULE_PARAMETER(x)         module_param(x, int, 0)
+#else
+# define NV_IS_SUSER()                  suser()
+# define NV_PCI_DEVICE_NAME(x)          ((x)->name)
+# define NV_CLI()                       cli()
+# define NV_SAVE_FLAGS(x)               save_flags(x)
+# define NV_RESTORE_FLAGS(x)            restore_flags(x)
+# define NV_MAY_SLEEP()                 (!in_interrupt())
+# define NV_SMP_NUM_CPUS                smp_num_cpus
+# define NV_MODULE_PARAMETER(x)         MODULE_PARM(x, "i")
+#endif
+
+#define NV_DEVICE_NUMBER(x)             minor((x)->i_rdev)
+#define NV_VMA_OFFSET(x)                (((x)->vm_pgoff) << PAGE_SHIFT)
+#define NV_VMA_PRIVATE(x)               ((x)->vm_private_data)
+#define NV_IS_CONTROL_DEVICE(x)         (minor((x)->i_rdev) == 255)
+
+#ifndef minor
+/*
+ * XXX Is this correct for all possible target kernels? We need this to
+ * support older 2.4 and some 2.6 kernels.
+ */
+# define minor(x) MINOR(x)
+#endif
+
+#ifndef KERNEL_2_6
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 23)
+  typedef void irqreturn_t;
+#endif
+# define IRQ_NONE
+# define IRQ_RETVAL(x)
+# define IRQ_HANDLED
+#else
+#ifdef AGPGART
+  typedef struct agp_kern_info agp_kern_info;
+  typedef struct agp_memory agp_memory;
+#endif
+  typedef void* devfs_handle_t;
+#endif
+
+#ifdef KERNEL_2_6
+#define NV_DEVFS_REGISTER(_name, _minor)                            \
+({                                                                  \
+    devfs_handle_t __handle = NULL;                                 \
+    devfs_mk_cdev(MKDEV(NV_MAJOR_DEVICE_NUMBER, _minor),            \
+            S_IFCHR | S_IRUGO | S_IWUGO, _name);                    \
+    __handle;                                                       \
+})
+
+#define NV_DEVFS_REMOVE_DEVICE(i) devfs_remove("nvidia%d", i)
+#define NV_DEVFS_REMOVE_CONTROL() devfs_remove("nvidiactl")
+#else
+#define NV_DEVFS_REGISTER(_name, _minor)                            \
+({                                                                  \
+    devfs_handle_t __handle =                                       \
+        devfs_register(NULL, _name, DEVFS_FL_DEFAULT,               \
+                NV_MAJOR_DEVICE_NUMBER, _minor,                     \
+                S_IFCHR | S_IRUGO | S_IWUGO, &nv_fops, NULL);       \
+    __handle;                                                       \
+ })
+
+#define NV_DEVFS_REMOVE_DEVICE(i) devfs_unregister(nv_devfs_handles[i+1])
+#define NV_DEVFS_REMOVE_CONTROL() devfs_unregister(nv_devfs_handles[0])
 #endif
 
+/*
+ * Linux 2.5 introduced the five argument version of remap_page_range, all
+ * relevant releases to date use it. This version was backported to 2.4 by
+ * RedHat without means to identify the change, hence this hack.
+ */
+#ifdef KERNEL_2_6
+#define NV_REMAP_PAGE_RANGE(a, b...) remap_page_range(vma, a, ## b)
+#else
 #if defined(REMAP_PAGE_RANGE_5)
-#define NV_REMAP_PAGE_RANGE(a, b...)    remap_page_range(vma, a, ## b)
+#define NV_REMAP_PAGE_RANGE(a, b...) remap_page_range(vma, a, ## b)
 #elif defined(REMAP_PAGE_RANGE_4)
-#define NV_REMAP_PAGE_RANGE(a, b...)    remap_page_range(a, ## b)
+#define NV_REMAP_PAGE_RANGE(a, b...) remap_page_range(a, ## b)
 #else
-#error "Couldn't determine number of arguments expected by remap_page_range!"
+#warning "conftest.sh failed, assuming old Linux 2.4 remap_page_range(4)!"
+
+#define NV_REMAP_PAGE_RANGE(a, b...) remap_page_range(a, ## b)
 #endif
+#endif /* KERNEL_2_6 */
 
-#if defined(pte_offset_atomic)
-#define NV_PTE_OFFSET(addres, pg_mid_dir, pte) \
+#if defined(pmd_offset_map)
+#define NV_PMD_OFFSET(address, pgd, pmd) \
+    { \
+        pmd = pmd_offset_map(pgd, address); \
+    }
+#define NV_PMD_UNMAP(pmd) \
     { \
-        pte_t *pte__ = pte_offset_atomic(pg_mid_dir, address); \
-        pte = *pte__; \
-        pte_kunmap(pte__); \
+        pmd_unmap(pmd); \
     }
-#elif defined(pte_offset)
-#define NV_PTE_OFFSET(addres, pg_mid_dir, pte) \
-    pte = *pte_offset(pg_mid_dir, address)
 #else
-#define NV_PTE_OFFSET(addres, pg_mid_dir, pte) \
+#define NV_PMD_OFFSET(address, pgd, pmd) \
     { \
-        pte_t *pte__ = pte_offset_map(pg_mid_dir, address); \
-        pte = *pte__; \
-        pte_unmap(pte__); \
+        pmd = pmd_offset(pgd, address); \
     }
+#define NV_PMD_UNMAP(pmd)
 #endif
 
-#define NV_PAGE_ALIGN(addr)             ( ((addr) + PAGE_SIZE - 1) / PAGE_SIZE)
-#define NV_MASK_OFFSET(addr)            ( (addr) & (PAGE_SIZE - 1) )
+#define NV_PMD_PRESENT(pmd) \
+    ({ \
+        if (pmd) { \
+            if (pmd_none(*pmd)) { \
+                NV_PMD_UNMAP(pmd); pmd = NULL; \
+            } \
+        } pmd != NULL; \
+    })
 
-#ifndef MAXMEM  /* temporary define for 2.2 kernels */
-#define MAXMEM  (-PAGE_OFFSET - (64 * 1024 * 1024))
+#if defined (pte_offset_atomic)
+#define NV_PTE_OFFSET(address, pmd, pte) \
+    { \
+        pte = pte_offset_atomic(pmd, address); \
+        NV_PMD_UNMAP(pmd); \
+    }
+#define NV_PTE_UNMAP(pte) \
+    { \
+        pte_kunmap(pte); \
+    }
+#elif defined (pte_offset)
+#define NV_PTE_OFFSET(address, pmd, pte) \
+    { \
+        pte = pte_offset(pmd, address); \
+        NV_PMD_UNMAP(pmd); \
+    }
+#define NV_PTE_UNMAP(pte)
+#else
+#define NV_PTE_OFFSET(address, pmd, pte) \
+    { \
+        pte = pte_offset_map(pmd, address); \
+        NV_PMD_UNMAP(pmd); \
+    }
+#define NV_PTE_UNMAP(pte) \
+    { \
+        pte_unmap(pte); \
+    }
 #endif
 
-#ifndef NV01_ROOT
-#define NV01_ROOT 0x00000000
-#endif 
+#define NV_PTE_PRESENT(pte) \
+    ({ \
+        if (pte) { \
+            if (!pte_present(*pte)) { \
+                NV_PTE_UNMAP(pte); pte = NULL; \
+            } \
+        } pte != NULL; \
+    })
+
+#define NV_PTE_VALUE(pte) \
+    ({ \
+        unsigned long __pte_value = pte_val(*pte); \
+        NV_PTE_UNMAP(pte); \
+        __pte_value; \
+    })
+
+#define NV_PAGE_ALIGN(addr)             ( ((addr) + PAGE_SIZE - 1) / PAGE_SIZE)
+#define NV_MASK_OFFSET(addr)            ( (addr) & (PAGE_SIZE - 1) )
 
 #if defined(NVCPU_IA64)
 #define NV_GFP_HW (GFP_KERNEL | __GFP_DMA)
@@ -475,7 +556,7 @@
 static inline int NV_IRQL_IS_RAISED()
     {
         unsigned long int eflags;
-        __save_flags(eflags);
+        NV_SAVE_FLAGS(eflags);
         return !(eflags & NV_CPU_INTERRUPT_FLAGS_BIT);
     }
  
@@ -557,9 +638,10 @@
     struct pci_dev *dev;
     nv_alloc_t *alloc_queue;
 
-    // bottom half interrupt handler info; per device
-    /* keep track of any pending bottom-halves */
-    struct tq_struct *bh;
+     /* keep track of any pending bottom halfes */
+     struct tasklet_struct tasklet;
+
+     /* active bottom half counter */
     atomic_t bh_count;
 
     /* get a timer callback every second */
@@ -597,7 +679,7 @@
     U032 num_events;
     U032 put, get;
     spinlock_t fp_lock;
-    void *wqueue;               // wait_queue for polling
+    wait_queue_head_t waitqueue;
     nv_event_t *event_fifo;     // fifo for storing events
 } nv_file_private_t;
 
diff -ruN NVIDIA_kernel-1.0-5328/nv-misc.h NVIDIA_kernel-1.0-5328-2.6/nv-misc.h
--- NVIDIA_kernel-1.0-5328/nv-misc.h	2003-12-17 23:55:00.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/nv-misc.h	2003-12-31 11:45:04.000000000 +0100
@@ -53,5 +53,11 @@
 
 typedef void *PHWINFO;
 
+/*
+ * XXX: Make sure that arguments to and from the core resource
+ * manager are passed and expected on the stack. Is this a good
+ * place for this?
+ */
+#define NV_API_CALL __attribute__((regparm(0)))
 
 #endif /* _NV_MISC_H_ */
diff -ruN NVIDIA_kernel-1.0-5328/nv.c NVIDIA_kernel-1.0-5328-2.6/nv.c
--- NVIDIA_kernel-1.0-5328/nv.c	2003-12-17 23:54:59.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/nv.c	2003-12-31 14:01:09.000000000 +0100
@@ -15,6 +15,7 @@
 #include "nv_compiler.h"
 #include "os-agp.h"
 
+MODULE_LICENSE("NVIDIA");
 
 /*
  * our global state; one per device
@@ -33,32 +34,20 @@
  */
 
 nv_linux_state_t nv_ctl_device = { { 0 } };
-void *nv_ctl_wqueue = NULL;
+wait_queue_head_t nv_ctl_waitqueue;
 
 // keep track of opened clients and their process id so they
 //   can be free'd up on abnormal close
 nv_client_t       nv_clients[NV_MAX_CLIENTS];
-struct tq_struct  nv_bottom_halves[NV_MAX_CLIENTS];
 
 #ifdef CONFIG_PROC_FS
 struct proc_dir_entry *proc_nvidia;
 #endif
 
 #ifdef CONFIG_DEVFS_FS
-devfs_handle_t  nv_dev_handle[NV_MAX_DEVICES];
-devfs_handle_t  nv_ctl_handle;
+devfs_handle_t nv_devfs_handles[NV_MAX_DEVICES+1];
 #endif
 
-/*
- * pick apart our minor device number
- * low 3 bits is NV device
- * if 255, then its the control device
- */
-
-#define NV_DEVICE_NUMBER(_minor) ((_minor) & 0x0f)
-#define NV_DEVICE_IS_CONTROL_DEVICE(_minor) \
-             (((_minor) & 0xFF) == 0xFF)
-
 // #define NV_DBG_MEM 1
 #undef NV_DBG_MEM
 
@@ -121,10 +110,6 @@
  *** EXPORTS to Linux Kernel
  ***/
 
-/* linux module interface functions (called by linux kernel) */
-int           init_module(void);
-void          cleanup_module(void);
-
 /* nv_kern_ functions, interfaces used by linux kernel */
 void          nv_kern_vma_open(struct vm_area_struct *vma);
 void          nv_kern_vma_release(struct vm_area_struct *vma);
@@ -135,7 +120,8 @@
 unsigned int  nv_kern_poll(struct file *, poll_table *);
 int           nv_kern_ioctl(struct inode *, struct file *, unsigned int, unsigned long);
 void          nv_kern_bh(void *);
-void          nv_kern_isr(int, void *, struct pt_regs *);
+void          nv_kern_isr_bh(unsigned long);
+irqreturn_t   nv_kern_isr(int, void *, struct pt_regs *);
 void          nv_kern_rc_timer(unsigned long);
 #ifdef CONFIG_PM
 int           nv_kern_pm(struct pm_dev *dev, pm_request_t rqst, void *data);
@@ -158,6 +144,7 @@
 /* character driver entry points */
 
 static struct file_operations nv_fops = {
+    owner:          THIS_MODULE,
     poll:           nv_kern_poll,
     ioctl:          nv_kern_ioctl,
     mmap:           nv_kern_mmap,
@@ -329,8 +316,8 @@
     {
         nv_printf(NV_DBG_MEMINFO, "  0x%x (0x%x): count %d flags 0x%x\n", 
             page_ptr->phys_addr, page_ptr->dma_addr,
-            (GET_MAP_NR(page_ptr->phys_addr))->count,
-            (GET_MAP_NR(page_ptr->phys_addr))->flags);
+            (virt_to_page(__va(page_ptr->phys_addr)))->count,
+            (virt_to_page(__va(page_ptr->phys_addr)))->flags);
         num_pages--;
         page_ptr++;
     }
@@ -401,7 +388,7 @@
         phys_addr = virt_to_phys((void *) virt_addr);
 
         /* lock the page for dma purposes */
-        mem_map_reserve(GET_MAP_NR(phys_addr));
+        SetPageReserved(virt_to_page(__va(phys_addr)));
 
         page_ptr->phys_addr = phys_addr;
         page_ptr->virt_addr = virt_addr;
@@ -447,7 +434,7 @@
         // but if we failed pci_map_sg, make sure to free this page
         if (page_ptr->virt_addr)
         {
-            mem_map_unreserve(GET_MAP_NR(page_ptr->phys_addr));
+            ClearPageReserved(virt_to_page(__va(page_ptr->phys_addr)));
             NV_SET_PAGE_ATTRIB_CACHED(page_ptr);
 #if defined(NVCPU_X86_64)
             // only unmap the page if it really was mapped through
@@ -481,7 +468,7 @@
 
     while (pages_left)
     {
-        mem_map_unreserve(GET_MAP_NR(page_ptr->phys_addr));
+        ClearPageReserved(virt_to_page(__va(page_ptr->phys_addr)));
         page_ptr++;
         pages_left--;
     }
@@ -616,7 +603,7 @@
     return 0;
 }
 
-static struct pci_dev* nvos_find_agp_by_class(unsigned int class)
+struct pci_dev* nvos_find_agp_by_class(unsigned int class)
 {
     struct pci_dev *dev, *fn;
     u8     cap_ptr;
@@ -674,11 +661,6 @@
     nv_linux_state_t *nvl;
     nv_linux_state_t *nv_max_devices;
 
-#if defined (KERNEL_2_2)
-    struct proc_dir_entry *proc_root_driver;
-    proc_root_driver = create_proc_entry("driver", flags, &proc_root);
-#endif
-
     proc_nvidia = create_proc_entry("nvidia", flags, proc_root_driver);
     proc_nvidia_cards = create_proc_entry("cards", flags, proc_nvidia);
     proc_nvidia_agp = create_proc_entry("agp", flags, proc_nvidia);
@@ -740,9 +722,6 @@
 {
 #ifdef CONFIG_PROC_FS
     nvos_proc_remove_all(proc_nvidia);
-#if defined (KERNEL_2_2)
-    remove_proc_entry("driver", &proc_root);
-#endif
 #endif
 }
 
@@ -831,9 +810,8 @@
  *** EXPORTS to Linux Kernel
  ***/
 
-int init_module(void)
+static int __init nvidia_init_module(void)
 {
-    nv_linux_state_t *nvl;
     int rc, i;
 
     memset(nv_linux_devices, 0, sizeof(nv_linux_devices));
@@ -846,7 +824,7 @@
 
     nv_printf(NV_DBG_ERRORS, "nvidia: loading %s\n", pNVRM_ID);
 
-#ifdef CONFIG_DEVFS_FS
+#if defined(CONFIG_DEVFS_FS) && !defined(KERNEL_2_6)
     rc = devfs_register_chrdev(nv_major, "nvidia", &nv_fops);
 #else
     rc = register_chrdev(nv_major, "nvidia", &nv_fops);
@@ -858,34 +836,35 @@
     }
 
 #ifdef CONFIG_DEVFS_FS
-    memset(nv_dev_handle, 0, sizeof(devfs_handle_t) * NV_MAX_DEVICES);
     do {
+        /*
+         * XXX This code isn't pretty, but neither is dealing with the
+         * various Linux devfs implemenation(s). While Linux APIs are
+         * known to be anything but stable and oftentimes anything but
+         * well designed, the devfs interface has been more painful to
+         * deal with than most other APIs.
+         */
         char name[10];
 
-        nv_ctl_handle = devfs_register(NULL, "nvidiactl",
-                            DEVFS_FL_DEFAULT, nv_major, 255,
-                            S_IFCHR | S_IRUGO | S_IWUGO,
-                            &nv_fops, NULL);
+        nv_devfs_handles[0] = NV_DEVFS_REGISTER("nvidiactl", 255);
 
         for (i = 0; i < num_nv_devices; i++) {
             sprintf(name, "nvidia%d", i);
-            nv_dev_handle[i] = devfs_register(NULL, name,
-                                  DEVFS_FL_DEFAULT, nv_major, i,
-                                  S_IFCHR | S_IRUGO | S_IWUGO,
-                                  &nv_fops, NULL);
+            nv_devfs_handles[i+1] = NV_DEVFS_REGISTER(name, i);
         }
     } while(0);
 #endif
 
-    nv_printf(NV_DBG_INFO, "init_module: major number %d\n", nv_major);
+    nv_printf(NV_DBG_INFO, "nvidia_init_module: major number %d\n", nv_major);
 
-    // init all the bottom half structures
-    for (nvl = nv_linux_devices; nvl < nv_linux_devices + NV_MAX_DEVICES; nvl++)
-    {
-        nvl->bh = &nv_bottom_halves[nvl - nv_linux_devices];
-        nvl->bh->routine = nv_kern_bh;
-        nvl->bh->data = (void *) nvl;
-        nvl->bh->sync = 0;
+    /* instantiate tasklets */
+    for (i = 0; i < NV_MAX_DEVICES; i++) {
+        /*
+         * We keep one tasklet per card to avoid latency issues with more
+         * than one device; no two instances of a single tasklet are ever
+         * executed concurrently.
+         */
+        atomic_set(&nv_linux_devices[i].tasklet.count, 1);
     }
 
     // init the nvidia control device
@@ -893,6 +872,7 @@
         nv_state_t *nv_ctl = NV_STATE_PTR(&nv_ctl_device);
         nv_ctl->os_state = (void *) &nv_ctl_device;
         nv_lock_init_locks(nv_ctl);
+        init_waitqueue_head(&nv_ctl_waitqueue);
     }
 
 #ifdef CONFIG_PM
@@ -919,14 +899,14 @@
     /* create /proc/driver/nvidia */
     nvos_proc_create();
 
-#if defined(DEBUG) && !defined(KERNEL_2_2)
+#if defined(DEBUG)
     inter_module_register("nv_linux_devices", THIS_MODULE, nv_linux_devices);
 #endif
 
     return 0;
 
  failed:
-#ifdef CONFIG_DEVFS_FS
+#if defined(CONFIG_DEVFS_FS) && !defined(KERNEL_2_6)
     devfs_unregister_chrdev(nv_major, "nvidia");
 #else
     unregister_chrdev(nv_major, "nvidia");
@@ -934,26 +914,27 @@
     return rc;
 }
 
-void cleanup_module(void)
+static void __exit nvidia_exit_module(void)
 {
-    int rc, i;
-    nv_linux_state_t *nvl;
-    nv_linux_state_t *max_devices;
+    int rc;
+    nv_linux_state_t *nvl, *max_devices;
 
     /* remove /proc/driver/nvidia */
     nvos_proc_remove();
 
-    nv_printf(NV_DBG_INFO, "cleanup_module\n");
+    nv_printf(NV_DBG_INFO, "nvidia_exit_module\n");
 
-#if defined(DEBUG) && !defined(KERNEL_2_2)
+#if defined(DEBUG)
     inter_module_unregister("nv_linux_devices");
 #endif
 
 #ifdef CONFIG_PM
-    for (i = 0; i < num_nv_devices; i++)
-    {
-        pm_unregister(pm_nv_dev[i]);
-    }
+    do {
+        int i;
+        for (i = 0; i < num_nv_devices; i++) {
+            pm_unregister(pm_nv_dev[i]);
+        }
+    } while (0);
 #endif
 
     // Shutdown the resource manager
@@ -972,30 +953,29 @@
                 continue;
 
             nv_printf(NV_DBG_ERRORS,
-                    "still have vm que at cleanup_module(): 0x%x to 0x%x\n",
+                    "still have vm que at nvidia_exit_module(): 0x%x to 0x%x\n",
                     nvl->alloc_queue->vma->vm_start,
                     nvl->alloc_queue->vma->vm_end);
         }
     }
 
-#ifdef CONFIG_DEVFS_FS
+#if defined(CONFIG_DEVFS_FS) && !defined(KERNEL_2_6)
     rc = devfs_unregister_chrdev(nv_major, "nvidia");
 #else
     rc = unregister_chrdev(nv_major, "nvidia");
 #endif
 
     if (rc < 0) {
-        nv_printf(NV_DBG_ERRORS, "cleanup_module: unregister nv failed\n");
+        nv_printf(NV_DBG_ERRORS, "nvidia_exit_module: unregister nv failed\n");
     }
 
 #ifdef CONFIG_DEVFS_FS
     do {
         int i;
-        for (i = 0; nv_dev_handle[i] != 0; i++) {
-            devfs_unregister(nv_dev_handle[i]);
-        }
-    } while(0);
-    devfs_unregister(nv_ctl_handle);
+        NV_DEVFS_REMOVE_CONTROL();
+        for (i = 0; i < num_nv_devices; i++)
+            NV_DEVFS_REMOVE_DEVICE(i);
+    } while (0);
 #endif
 
 #if NV_ENABLE_MEM_TRACKING
@@ -1007,6 +987,8 @@
 #endif
 }
 
+module_init(nvidia_init_module);
+module_exit(nvidia_exit_module);
 
 /* this is only called when the vmas are duplicated.
  * this appears to only happen when the process is cloned to create
@@ -1020,11 +1002,11 @@
 nv_kern_vma_open(struct vm_area_struct *vma)
 {
     nv_printf(NV_DBG_MEMINFO, "vma_open for 0x%x - 0x%x, offset 0x%x\n",
-        vma->vm_start, vma->vm_end, LINUX_VMA_OFFS(vma));
+        vma->vm_start, vma->vm_end, NV_VMA_OFFSET(vma));
 
-    if (VMA_PRIVATE(vma))
+    if (NV_VMA_PRIVATE(vma))
     {
-        nv_alloc_t *at = (nv_alloc_t *) VMA_PRIVATE(vma);
+        nv_alloc_t *at = (nv_alloc_t *) NV_VMA_PRIVATE(vma);
         at->usage_count++;
 
         nv_printf(NV_DBG_MEMINFO, "  at 0x%x, usage count %d, page_table 0x%x\n",
@@ -1032,8 +1014,6 @@
 
         nvos_list_page_count(at->page_table, at->num_pages);
     }
-
-    MOD_INC_USE_COUNT;
 }
 
 
@@ -1041,11 +1021,11 @@
 nv_kern_vma_release(struct vm_area_struct *vma)
 {
     nv_printf(NV_DBG_MEMINFO, "vma_release for 0x%x - 0x%x, offset 0x%x\n",
-        vma->vm_start, vma->vm_end, LINUX_VMA_OFFS(vma));
+        vma->vm_start, vma->vm_end, NV_VMA_OFFSET(vma));
 
-    if (VMA_PRIVATE(vma))
+    if (NV_VMA_PRIVATE(vma))
     {
-        nv_alloc_t *at = (nv_alloc_t *) VMA_PRIVATE(vma);
+        nv_alloc_t *at = (nv_alloc_t *) NV_VMA_PRIVATE(vma);
 
         at->usage_count--;
 
@@ -1063,35 +1043,26 @@
             if (at->page_table)
                 nvos_unlock_pages(at);
             nvos_free_alloc(at);
-            VMA_PRIVATE(vma) = NULL;
+            NV_VMA_PRIVATE(vma) = NULL;
         }
     }
-
-    MOD_DEC_USE_COUNT;
 }
 
 
-/* at this point, this code just plain won't work with 2.2 kernels.
- * additionally, only ia64 & the 460GX need a nopage handler, and 2.2 doesn't
- * work on ia64 anyways. It's expected that at some point other agp chipsets
- * will work similar to the 460GX (AGP 3.0 spec), so pre-emptively make sure
- * this works on our standard ia32 driver.
- */
-#if !defined(KERNEL_2_2)
-
 /* AGP allocations under the 460GX are not mapped to the aperture
  * addresses by the CPU.  This nopage handler will fault on CPU
  * accesses to AGP memory and map the address to the correct page.
  */
 struct page *nv_kern_vma_nopage(struct vm_area_struct *vma, unsigned long address, int write_access)
 {
+#if defined(NVCPU_IA64) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 9))
     nv_alloc_t *at, *tmp;
     nv_linux_state_t *nvl;
     nv_state_t *nv;
     struct page *page_ptr;
     int rm_status, index;
 
-    at = VMA_PRIVATE(vma);
+    at = NV_VMA_PRIVATE(vma);
     if (at == NULL)
     {
         nv_printf(NV_DBG_ERRORS, "NVRM: nopage handler called without an at: "
@@ -1130,7 +1101,7 @@
         // far again
         nv_printf(NV_DBG_ERRORS, "NVRM: nopage handler called on a freed"
                   "address: vm_start 0x%x, at 0x%x\n", vma->vm_start, at);
-        VMA_PRIVATE(vma) = NULL;
+        NV_VMA_PRIVATE(vma) = NULL;
         return NOPAGE_SIGBUS;
     }
 
@@ -1154,15 +1125,14 @@
     at->page_table[index].virt_addr = (unsigned long) __va(page_to_pfn(page_ptr) << PAGE_SHIFT);
 
     return page_ptr;
-}
 #endif
+    return NOPAGE_SIGBUS;
+}
 
 struct vm_operations_struct nv_vm_ops = {
     nv_kern_vma_open,
     nv_kern_vma_release,  /* "close" */
-#if !defined(KERNEL_2_2)
     nv_kern_vma_nopage,
-#endif
 };
 
 static nv_file_private_t *
@@ -1177,7 +1147,7 @@
     memset(nvfp, 0, sizeof(nv_file_private_t));
 
     // initialize this file's event queue
-    INIT_EVENT_QUEUE(nvfp->wqueue);
+    init_waitqueue_head(&nvfp->waitqueue);
 
     nv_init_lock(nvfp->fp_lock);
 
@@ -1197,11 +1167,19 @@
     if (nvfp == NULL)
         return;
 
-    FREE_EVENT_QUEUE(nvfp->wqueue);
     NV_VFREE(nvfp->event_fifo, sizeof(nv_event_t) * NV_EVENT_FIFO_SIZE);
     NV_VFREE(nvfp, sizeof(nv_file_private_t));
 }
 
+void nv_kern_isr_bh(unsigned long data)
+{
+    /*
+     * XXX: This level of indirection is necessary to work around
+     * problems with Linux kernels using a non-standard calling
+     * convention, i.e. Arjan van de Ven's/RedHat's 2.6.0 kernels.
+     */
+    rm_isr_bh((VOID *) data);
+}
 
 /*
 ** nv_kern_open
@@ -1226,11 +1204,11 @@
 
     /* for control device, just jump to its open routine */
     /* after setting up the private data */
-    if (NV_DEVICE_IS_CONTROL_DEVICE(inode->i_rdev))
+    if (NV_IS_CONTROL_DEVICE(inode))
         return nv_kern_ctl_open(inode, file);
 
     /* what device are we talking about? */
-    devnum = NV_DEVICE_NUMBER(inode->i_rdev);
+    devnum = NV_DEVICE_NUMBER(inode);
     if (devnum >= NV_MAX_DEVICES)
     {
         rc = -ENODEV;
@@ -1283,12 +1261,14 @@
             goto failed;
         }
 
+        nvl->tasklet.func = nv_kern_isr_bh;
+        nvl->tasklet.data = (unsigned long) nv->pdev;
+        tasklet_enable(&nvl->tasklet);
 
         nv->flags |= NV_FLAG_OPEN;
     }
 
     nv->usage_count++;
-    MOD_INC_USE_COUNT;
 
  failed:
     nv_unlock(nvl->ldata_lock);
@@ -1319,38 +1299,32 @@
 
     /* for control device, just jump to its open routine */
     /* after setting up the private data */
-    if (NV_DEVICE_IS_CONTROL_DEVICE(inode->i_rdev))
+    if (NV_IS_CONTROL_DEVICE(inode))
         return nv_kern_ctl_close(inode, file);
 
-    nv_printf(NV_DBG_INFO, "nv_kern_close on device %d\n", NV_DEVICE_NUMBER(inode->i_rdev));
+    nv_printf(NV_DBG_INFO, "nv_kern_close on device %d\n", NV_DEVICE_NUMBER(inode));
 
     rm_free_unused_clients(nv, current->pid, (void *) file);
 
     nv_lock(nvl->ldata_lock);
     if (--nv->usage_count == 0)
     {
-        int counter = 0;
-
-        /* turn off interrupts.
-        ** be careful to make sure any pending bottom half gets run
-        **  or disabled before calling rm_shutdown_adapter() since
-        **  it will free up the pdev.  This is hard to see on single
-        **  cpu systems, but easy on dual cpu :-)
-        */
+        /*
+         * The usage count for this device has dropped to zero, it can be shut
+         * down safely; disable its interrupts.
+         */
         rm_disable_adapter(nv);
 
-        /* give it a moment to allow any bottom half to run */
-
-#define MAX_BH_TASKS 10
-        while (NV_ATOMIC_READ(nvl->bh_count) && (counter < MAX_BH_TASKS))
-        {
-            current->state = TASK_INTERRUPTIBLE;
-            schedule_timeout(HZ/50);
-            counter++;
-        }
+        /*
+         * Disable this device's tasklet to make sure that no bottom half will
+         * run with undefined device state.
+         */
+        tasklet_disable(&nvl->tasklet);
 
-        /* free the irq, which may block until any pending interrupts */
-        /* are done being processed. */
+        /*
+         * Free the IRQ, which may block until all pending interrupt processing
+         * has completed.
+         */
         free_irq(nv->interrupt_line, (void *) nv);
 
         rm_shutdown_adapter(nv);
@@ -1381,8 +1355,6 @@
         FILE_PRIVATE(file) = NULL;
     }
 
-    MOD_DEC_USE_COUNT;
-
     return 0;
 }
 
@@ -1399,10 +1371,10 @@
     nv_printf(NV_DBG_INFO, "mmap([0x%p-0x%p] off=0x%lx)\n",
         vma->vm_start,
         vma->vm_end,
-        LINUX_VMA_OFFS(vma));
+        NV_VMA_OFFSET(vma));
 
     // be a bit paranoid for now
-    if ((NV_MASK_OFFSET(LINUX_VMA_OFFS(vma))) ||
+    if ((NV_MASK_OFFSET(NV_VMA_OFFSET(vma))) ||
         (NV_MASK_OFFSET(vma->vm_start)) ||
         (NV_MASK_OFFSET(vma->vm_end)))
     {
@@ -1420,7 +1392,7 @@
 
 
     /* NV reg space */
-    if (IS_REG_OFFSET(nv, LINUX_VMA_OFFS(vma), vma->vm_end - vma->vm_start))
+    if (IS_REG_OFFSET(nv, NV_VMA_OFFSET(vma), vma->vm_end - vma->vm_start))
     {
         /* truncate to size of registers */
         if (pages > nv->regs->size / PAGE_SIZE)
@@ -1428,7 +1400,7 @@
 
         vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
         if (NV_REMAP_PAGE_RANGE(vma->vm_start,
-                             phys_to_uncached(LINUX_VMA_OFFS(vma)),
+                             phys_to_uncached(NV_VMA_OFFSET(vma)),
                              vma->vm_end - vma->vm_start,
                              vma->vm_page_prot))
             return -EAGAIN;
@@ -1438,7 +1410,7 @@
     }
 
     /* NV fb space */
-    else if (IS_FB_OFFSET(nv, LINUX_VMA_OFFS(vma), vma->vm_end - vma->vm_start))
+    else if (IS_FB_OFFSET(nv, NV_VMA_OFFSET(vma), vma->vm_end - vma->vm_start))
     {
 
         /* truncate to size of framebuffer */
@@ -1447,7 +1419,7 @@
 
         vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
         if (NV_REMAP_PAGE_RANGE(vma->vm_start,
-                             phys_to_uncached(LINUX_VMA_OFFS(vma)),
+                             phys_to_uncached(NV_VMA_OFFSET(vma)),
                              vma->vm_end - vma->vm_start,
                              vma->vm_page_prot))
             return -EAGAIN;
@@ -1457,10 +1429,10 @@
     }
 
     /* AGP allocator */
-    else if (IS_AGP_OFFSET(nv, LINUX_VMA_OFFS(vma), vma->vm_end - vma->vm_start))
+    else if (IS_AGP_OFFSET(nv, NV_VMA_OFFSET(vma), vma->vm_end - vma->vm_start))
     {
         nv_lock(nvl->at_lock);
-        at = nvl_find_alloc(nvl, LINUX_VMA_OFFS(vma), NV_ALLOC_TYPE_AGP);
+        at = nvl_find_alloc(nvl, NV_VMA_OFFSET(vma), NV_ALLOC_TYPE_AGP);
 
         if (at == NULL)
         {
@@ -1478,7 +1450,7 @@
         }
 
         at->vma = vma;
-        VMA_PRIVATE(vma) = at;
+        NV_VMA_PRIVATE(vma) = at;
         at->usage_count++;
 
         if (NV_OSAGP_ENABLED(nv))
@@ -1502,13 +1474,13 @@
     }
 
     /* Magic allocator */
-    else // if (LINUX_VMA_OFFS(vma) == NV_MMAP_ALLOCATION_OFFSET)
+    else // if (NV_VMA_OFFSET(vma) == NV_MMAP_ALLOCATION_OFFSET)
     {
         unsigned long page = 0, pos, start;
         int i = 0;
 
         nv_lock(nvl->at_lock);
-        at = nvl_find_alloc(nvl, LINUX_VMA_OFFS(vma), NV_ALLOC_TYPE_PCI);
+        at = nvl_find_alloc(nvl, NV_VMA_OFFSET(vma), NV_ALLOC_TYPE_PCI);
 
         if (at == NULL)
         {
@@ -1526,7 +1498,7 @@
         }
 
         at->vma = vma;
-        VMA_PRIVATE(vma) = at;
+        NV_VMA_PRIVATE(vma) = at;
         at->usage_count++;
 
         nv_printf(NV_DBG_INFO, "remapping %d system pages for at 0x%x\n", pages, at);
@@ -1548,9 +1520,6 @@
 
     vma->vm_file = file;
 
-    /* just increment usage count, rather than calling vma_open */
-    MOD_INC_USE_COUNT;
-
     return 0;
 }
 
@@ -1577,7 +1546,7 @@
     {
         nv_printf(NV_DBG_EVENTINFO, "calling poll_wait\n");
         // add us to the list
-        poll_wait(file, EVENT_QUEUE(nvfp->wqueue), wait);
+        poll_wait(file, &nvfp->waitqueue, wait);
     }
 
     nv_lock_irq(nvfp->fp_lock, eflags);
@@ -1645,12 +1614,13 @@
 
     switch (_IOC_NR(cmd))
     {
+#if !defined(KERNEL_2_6)
         /* debug tool; zap the module use count so we can unload driver */
         /*             even if it is confused */
         case NV_ESC_MODULE_RESET:
             atomic_set(&__this_module.uc.usecount, 1);
             break;
-
+#endif
         /* pass out info about the card */
         case NV_ESC_CARD_INFO:
         {
@@ -1777,7 +1747,7 @@
  * driver receives an interrupt
  *    if someone waiting, then hand it off.
  */
-void nv_kern_isr(
+irqreturn_t nv_kern_isr(
     int   irq,
     void *arg,
     struct pt_regs *regs
@@ -1791,9 +1761,10 @@
     if (need_to_run_bottom_half)
     {
         NV_ATOMIC_INC(nvl->bh_count);
-        queue_task(nvl->bh, &tq_immediate);
-        mark_bh(IMMEDIATE_BH);
+        tasklet_schedule(&nvl->tasklet);
     }
+
+    return IRQ_HANDLED;
 }
 
 void nv_kern_bh(
@@ -1911,11 +1882,9 @@
 
     if (nv->usage_count == 0)
     {
-        INIT_EVENT_QUEUE(nv_ctl_wqueue);
+        init_waitqueue_head(&nv_ctl_waitqueue);
     }
 
-    MOD_INC_USE_COUNT;
-
     nv->flags |= NV_FLAG_OPEN + NV_FLAG_CONTROL;
 
     /* turn off the hotkey occurred bit */
@@ -1943,10 +1912,8 @@
 
     nv_lock(nvl->ldata_lock);
     if (--nv->usage_count == 0)
-    {
-        FREE_EVENT_QUEUE(nv_ctl_wqueue);
         nv->flags = 0;
-    }
+
     nv_unlock(nvl->ldata_lock);
 
     rm_free_unused_clients(nv, current->pid, (void *) file);
@@ -1957,8 +1924,6 @@
         FILE_PRIVATE(file) = NULL;
     }
 
-    MOD_DEC_USE_COUNT;
-
     return 0;
 }
 
@@ -1982,7 +1947,7 @@
     nv = NV_STATE_PTR(nvl);
 
     if ( !(file->f_flags & O_NONBLOCK) )
-        poll_wait(file, EVENT_QUEUE(nv_ctl_wqueue), wait);
+        poll_wait(file, &nv_ctl_waitqueue, wait);
 
     nv_lock(nvl->ldata_lock);
 
@@ -2013,7 +1978,7 @@
     nv_ctl_device.nv_state.flags |= NV_FLAG_HOTKEY_OCCURRED;
     nv_unlock(nv_ctl_device.ldata_lock);
 
-    wake_up_interruptible(EVENT_QUEUE(nv_ctl_wqueue));
+    wake_up_interruptible(&nv_ctl_waitqueue);
 }
 
 int nv_kern_read_cardinfo(char *page, char **start, off_t off,
@@ -2092,7 +2057,7 @@
         len += sprintf(page+len, "Host Bridge: \t ");
 
 #if defined(CONFIG_PCI_NAMES)
-        len += sprintf(page+len, "%s\n", dev->name);
+        len += sprintf(page+len, "%s\n", NV_PCI_DEVICE_NAME(dev));
 #else
         len += sprintf(page+len, "PCI device %04x:%04x\n",
                 dev->vendor, dev->device);
@@ -2304,27 +2269,30 @@
     int kern
 )
 {
-    pgd_t *pg_dir;
-    pmd_t *pg_mid_dir;
-    pte_t pte;
+    pgd_t *pgd;
+    pmd_t *pmd;
+    pte_t *pte;
     unsigned long retval;
 
-    if (kern) pg_dir = pgd_offset_k(address);
-    else      pg_dir = pgd_offset(current->mm, address);
+    if (kern)
+        pgd = pgd_offset_k(address);
+    else
+        pgd = pgd_offset(current->mm, address);
 
-    if (pgd_none(*pg_dir))
+    if (!pgd || pgd_none(*pgd))
         goto failed;
 
-    pg_mid_dir = pmd_offset(pg_dir, address);
-    if (pmd_none(*pg_mid_dir))
+    NV_PMD_OFFSET(address, pgd, pmd);
+
+    if (!NV_PMD_PRESENT(pmd))
         goto failed;
 
-    NV_PTE_OFFSET(address, pg_mid_dir, pte);
+    NV_PTE_OFFSET(address, pmd, pte);
 
-    if (!pte_present(pte))
+    if (!NV_PTE_PRESENT(pte))
         goto failed;
 
-    retval = ((pte_val(pte) & KERN_PAGE_MASK) | NV_MASK_OFFSET(address));
+    retval = ((NV_PTE_VALUE(pte) & KERN_PAGE_MASK) | NV_MASK_OFFSET(address));
 
 #if defined(NVCPU_X86_64) && defined(_PAGE_NX)
     // mask out the non-executable page bit for the true physical address
@@ -2759,7 +2727,7 @@
 
     if (nvfp->num_events == NV_EVENT_FIFO_SIZE)
     {
-        wake_up_interruptible(EVENT_QUEUE(nvfp->wqueue));
+        wake_up_interruptible(&nvfp->waitqueue);
         nv_unlock_irq(nvfp->fp_lock, eflags);
         return;
     }
@@ -2776,7 +2744,7 @@
     if (nvfp->put >= NV_EVENT_FIFO_SIZE)
         nvfp->put = 0;
 
-    wake_up_interruptible(EVENT_QUEUE(nvfp->wqueue));
+    wake_up_interruptible(&nvfp->waitqueue);
     nv_unlock_irq(nvfp->fp_lock, eflags);
 }
 
@@ -2866,12 +2834,8 @@
     if ( (NV_AGP_DISABLED(nv)) && (config & NVOS_AGP_CONFIG_NVAGP) )
     {
         /* make sure the user does not have agpgart loaded */
-#if !defined (KERNEL_2_2)
         if (inter_module_get("drm_agp")) {
             inter_module_put("drm_agp");
-#else
-        if (GET_MODULE_SYMBOL(0, __MODULE_STRING(agp_enable))) {
-#endif
             nv_printf(NV_DBG_WARNINGS, "NVRM: not using NVAGP, AGPGART is loaded!!\n");
         } else {
 #if defined(CONFIG_X86_64) && defined(CONFIG_GART_IOMMU)
diff -ruN NVIDIA_kernel-1.0-5328/nv.h NVIDIA_kernel-1.0-5328-2.6/nv.h
--- NVIDIA_kernel-1.0-5328/nv.h	2003-12-17 23:55:00.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/nv.h	2003-12-31 11:38:22.000000000 +0100
@@ -327,31 +327,31 @@
  * ---------------------------------------------------------------------------
  */
 
-VOID*  nv_find_nv_mapping           (nv_state_t *, unsigned long); 
-VOID*  nv_find_agp_kernel_mapping   (nv_state_t *, unsigned long); 
-ULONG  nv_get_kern_phys_address     (ULONG);
-ULONG  nv_get_user_phys_address     (ULONG);
-
-VOID   nv_lock_rm                   (nv_state_t *);
-VOID   nv_unlock_rm                 (nv_state_t *);
-VOID   nv_lock_heap                 (nv_state_t *);
-VOID   nv_unlock_heap               (nv_state_t *);
-
-VOID   nv_set_hotkey_occurred_flag  (VOID);
-S032   nv_int10h_call               (nv_state_t *, U032 *, U032 *, U032 *, U032 *, VOID *);
-
-S032   nv_alloc_pages               (nv_state_t *, VOID **, U032, U032, U032, U032, U032, U032, VOID **);
-S032   nv_free_pages                (nv_state_t *, VOID **, U032, U032, VOID *);
-
-S032   nv_agp_init                  (nv_state_t *, VOID **, VOID **, VOID *, U032);
-S032   nv_agp_teardown              (nv_state_t *);
-S032   nv_agp_translate_address     (nv_state_t *, VOID *, U032, U032 *);
+VOID*  NV_API_CALL  nv_find_nv_mapping           (nv_state_t *, unsigned long); 
+VOID*  NV_API_CALL  nv_find_agp_kernel_mapping   (nv_state_t *, unsigned long); 
+ULONG  NV_API_CALL  nv_get_kern_phys_address     (ULONG);
+ULONG  NV_API_CALL  nv_get_user_phys_address     (ULONG);
+
+VOID   NV_API_CALL  nv_lock_rm                   (nv_state_t *);
+VOID   NV_API_CALL  nv_unlock_rm                 (nv_state_t *);
+VOID   NV_API_CALL  nv_lock_heap                 (nv_state_t *);
+VOID   NV_API_CALL  nv_unlock_heap               (nv_state_t *);
+
+VOID   NV_API_CALL  nv_set_hotkey_occurred_flag  (VOID);
+S032   NV_API_CALL  nv_int10h_call               (nv_state_t *, U032 *, U032 *, U032 *, U032 *, VOID *);
+
+S032   NV_API_CALL  nv_alloc_pages               (nv_state_t *, VOID **, U032, U032, U032, U032, U032, U032, VOID **);
+S032   NV_API_CALL  nv_free_pages                (nv_state_t *, VOID **, U032, U032, VOID *);
+
+S032   NV_API_CALL  nv_agp_init                  (nv_state_t *, VOID **, VOID **, VOID *, U032);
+S032   NV_API_CALL  nv_agp_teardown              (nv_state_t *);
+S032   NV_API_CALL  nv_agp_translate_address     (nv_state_t *, VOID *, U032, U032 *);
 
-S032   nv_start_rc_timer            (nv_state_t *);
-S032   nv_stop_rc_timer             (nv_state_t *);
+S032   NV_API_CALL  nv_start_rc_timer            (nv_state_t *);
+S032   NV_API_CALL  nv_stop_rc_timer             (nv_state_t *);
 
-VOID   nv_post_event                (nv_state_t *, nv_event_t *, U032, U032);
-S032   nv_get_event                 (nv_state_t *, VOID *, nv_event_t *, U032 *);
+VOID   NV_API_CALL  nv_post_event                (nv_state_t *, nv_event_t *, U032, U032);
+S032   NV_API_CALL  nv_get_event                 (nv_state_t *, VOID *, nv_event_t *, U032 *);
 
 
 /*
@@ -362,41 +362,41 @@
  * ---------------------------------------------------------------------------
  */
 
-BOOL       rm_init_rm               (VOID);
-BOOL       rm_shutdown_rm           (VOID);
-BOOL       rm_init_adapter          (nv_state_t *);
-BOOL       rm_disable_adapter       (nv_state_t *);
-BOOL       rm_shutdown_adapter      (nv_state_t *);
-BOOL       rm_ioctl                 (nv_state_t *, VOID *, U032, VOID *);
-BOOL       rm_isr                   (U032, U032 *);
-VOID       rm_isr_bh                (VOID *);
-RM_STATUS  rm_power_management      (nv_state_t *, U032, U032);
-U032       rm_get_vbios_version     (nv_state_t *, U032 *, U032 *, U032 *, U032 *, U032 *);
-VOID       rm_free_unused_clients   (nv_state_t *, U032, VOID *);
-
-VOID       rm_update_agp_config     (nv_state_t *);
-RM_STATUS  rm_init_agp              (nv_state_t *);
-RM_STATUS  rm_teardown_agp          (nv_state_t *);
-
-RM_STATUS  rm_alloc_agp_pages       (nv_state_t *, VOID **, U032, U032, VOID **, U032 *);
-RM_STATUS  rm_map_agp_pages         (nv_state_t *, VOID **, U032, VOID *);
-RM_STATUS  rm_free_agp_pages        (nv_state_t *, VOID **, VOID *);
-
-RM_STATUS  rm_alloc_agp_bitmap      (nv_state_t *, U032, U032 *);
-RM_STATUS  rm_free_agp_bitmap       (nv_state_t *, U032, U032);
-RM_STATUS  rm_set_agp_bitmap        (nv_state_t *, VOID *);
-RM_STATUS  rm_clear_agp_bitmap      (nv_state_t *, VOID **);
-
-RM_STATUS  rm_load_registry         (nv_parm_t *);
-RM_STATUS  rm_read_registry_dword   (nv_state_t *, U008 *, U008 *, U032 *);
-RM_STATUS  rm_write_registry_dword  (nv_state_t *, U008 *, U008 *, U032);
-RM_STATUS  rm_read_registry_binary  (nv_state_t *, U008 *, U008 *, U008 *, U032 *);
-RM_STATUS  rm_write_registry_binary (nv_state_t *, U008 *, U008 *, U008 *, U032);
+BOOL       NV_API_CALL  rm_init_rm               (VOID);
+BOOL       NV_API_CALL  rm_shutdown_rm           (VOID);
+BOOL       NV_API_CALL  rm_init_adapter          (nv_state_t *);
+BOOL       NV_API_CALL  rm_disable_adapter       (nv_state_t *);
+BOOL       NV_API_CALL  rm_shutdown_adapter      (nv_state_t *);
+BOOL       NV_API_CALL  rm_ioctl                 (nv_state_t *, VOID *, U032, VOID *);
+BOOL       NV_API_CALL  rm_isr                   (U032, U032 *);
+VOID       NV_API_CALL  rm_isr_bh                (VOID *);
+RM_STATUS  NV_API_CALL  rm_power_management      (nv_state_t *, U032, U032);
+U032       NV_API_CALL  rm_get_vbios_version     (nv_state_t *, U032 *, U032 *, U032 *, U032 *, U032 *);
+VOID       NV_API_CALL  rm_free_unused_clients   (nv_state_t *, U032, VOID *);
+
+VOID       NV_API_CALL  rm_update_agp_config     (nv_state_t *);
+RM_STATUS  NV_API_CALL  rm_init_agp              (nv_state_t *);
+RM_STATUS  NV_API_CALL  rm_teardown_agp          (nv_state_t *);
+
+RM_STATUS  NV_API_CALL  rm_alloc_agp_pages       (nv_state_t *, VOID **, U032, U032, VOID **, U032 *);
+RM_STATUS  NV_API_CALL  rm_map_agp_pages         (nv_state_t *, VOID **, U032, VOID *);
+RM_STATUS  NV_API_CALL  rm_free_agp_pages        (nv_state_t *, VOID **, VOID *);
+
+RM_STATUS  NV_API_CALL  rm_alloc_agp_bitmap      (nv_state_t *, U032, U032 *);
+RM_STATUS  NV_API_CALL  rm_free_agp_bitmap       (nv_state_t *, U032, U032);
+RM_STATUS  NV_API_CALL  rm_set_agp_bitmap        (nv_state_t *, VOID *);
+RM_STATUS  NV_API_CALL  rm_clear_agp_bitmap      (nv_state_t *, VOID **);
+
+RM_STATUS  NV_API_CALL  rm_load_registry         (nv_parm_t *);
+RM_STATUS  NV_API_CALL  rm_read_registry_dword   (nv_state_t *, U008 *, U008 *, U032 *);
+RM_STATUS  NV_API_CALL  rm_write_registry_dword  (nv_state_t *, U008 *, U008 *, U032);
+RM_STATUS  NV_API_CALL  rm_read_registry_binary  (nv_state_t *, U008 *, U008 *, U008 *, U032 *);
+RM_STATUS  NV_API_CALL  rm_write_registry_binary (nv_state_t *, U008 *, U008 *, U008 *, U032);
 
-RM_STATUS  rm_run_rc_callback       (nv_state_t *);
-RM_STATUS  rm_get_device_name       (U032, U032, U008*);
+RM_STATUS  NV_API_CALL  rm_run_rc_callback       (nv_state_t *);
+RM_STATUS  NV_API_CALL  rm_get_device_name       (U032, U032, U008*);
 
-NvUI64     nv_rdtsc                 (VOID);
+NvUI64     NV_API_CALL  nv_rdtsc                 (VOID);
 
 #endif /* NVWATCH */
 
diff -ruN NVIDIA_kernel-1.0-5328/os-agp.c NVIDIA_kernel-1.0-5328-2.6/os-agp.c
--- NVIDIA_kernel-1.0-5328/os-agp.c	2003-12-17 23:54:59.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/os-agp.c	2003-12-18 13:22:54.000000000 +0100
@@ -45,44 +45,9 @@
     int  ready;
 } agp_gart;
 
-typedef struct {
-    int           (*backend_acquire)(void);
-    void          (*backend_release)(void);
-    void          (*copy_info)(agp_kern_info *);
-    agp_memory *  (*allocate_memory)(size_t, unsigned int);
-    void          (*free_memory)(agp_memory *);
-    int           (*bind_memory)(agp_memory *, off_t);
-    int           (*unbind_memory)(agp_memory *);
-    void          (*enable)(unsigned int);
-} agp_operations_struct;
-
-agp_operations_struct agp_ops;
 agp_kern_info         agpinfo;
 agp_gart              gart;
-#if !defined (KERNEL_2_2)
 const drm_agp_t       *drm_agp_p;
-#endif
-
-#if defined (KERNEL_2_2)
-    #define GET_AGPGART_SYMBOL(sym, sym_string)                     \
-        sym = (void*) GET_MODULE_SYMBOL(0, sym_string);             \
-        if (sym == NULL)                                            \
-        {                                                           \
-            nv_printf(NV_DBG_ERRORS,                                \
-                "NVRM: AGPGART: unable to retrieve symbol %s\n",    \
-                sym_string);                                        \
-            return 1;                                               \
-        }
-
-    #define AGP_BACKEND_ACQUIRE_SYM   __MODULE_STRING(agp_backend_acquire)
-    #define AGP_BACKEND_RELEASE_SYM   __MODULE_STRING(agp_backend_release)
-    #define AGP_COPY_INFO_SYM         __MODULE_STRING(agp_copy_info)
-    #define AGP_ALLOCATE_MEMORY_SYM   __MODULE_STRING(agp_allocate_memory)
-    #define AGP_FREE_MEMORY_SYM       __MODULE_STRING(agp_free_memory)
-    #define AGP_BIND_MEMORY_SYM       __MODULE_STRING(agp_bind_memory)
-    #define AGP_UNBIND_MEMORY_SYM     __MODULE_STRING(agp_unbind_memory)
-    #define AGP_ENABLE_SYM            __MODULE_STRING(agp_enable)
-#endif
 
 #if defined(CONFIG_MTRR)
 #define MTRR_DEL(gart) if ((gart).mtrr > 0) mtrr_del((gart).mtrr, 0, 0);
@@ -110,48 +75,18 @@
 
     memset( (void *) &gart, 0, sizeof(agp_gart));
 
-#if !defined (KERNEL_2_2)
+    /*
+     * XXX The inter_module_* mechanism has been deprecated and replaced with
+     * a different mechanism in Linux 2.5; it will go away eventually.
+     * Also, the Linux 2.5 AGP GART driver is modularized, agpgart.o does not
+     * include backend drivers.
+     */
     if (!(drm_agp_p = inter_module_get_request("drm_agp", "agpgart")))
     {
         nv_printf(NV_DBG_ERRORS,
             "NVRM: AGPGART: unable to retrieve symbol table\n");
         return 1;
     }
-    
-    agp_ops.backend_acquire = drm_agp_p->acquire;
-    agp_ops.backend_release = drm_agp_p->release;
-    agp_ops.allocate_memory = drm_agp_p->allocate_memory;
-    agp_ops.free_memory     = drm_agp_p->free_memory;
-    agp_ops.bind_memory     = drm_agp_p->bind_memory;
-    agp_ops.unbind_memory   = drm_agp_p->unbind_memory;
-    agp_ops.enable          = drm_agp_p->enable;
-
-    // looks like some newer kernels (for example mandrake 9.0's 2.4.19-16mdk)
-    // have updated copy_info to return an integer value, and of course didn't
-    // bother bumping the agpgart revision up. The return value is pretty 
-    // harmless (backend_acquire would have already failed and caused us to
-    // bail), so cast the function pointer to avoid compiler warnings.
-    // we may need to revisit this in the future.
-    agp_ops.copy_info       = (void (*)(agp_kern_info *)) drm_agp_p->copy_info;
-
-#else
-#if defined(CONFIG_KMOD)
-    if ( request_module("agpgart") )
-    {
-        nv_printf(NV_DBG_ERRORS, "NVRM: AGPGART: not loading agpgart.o\n");
-        return 1;
-    }
-#endif
-
-    GET_AGPGART_SYMBOL(agp_ops.backend_acquire, AGP_BACKEND_ACQUIRE_SYM);
-    GET_AGPGART_SYMBOL(agp_ops.backend_release, AGP_BACKEND_RELEASE_SYM);
-    GET_AGPGART_SYMBOL(agp_ops.copy_info,       AGP_COPY_INFO_SYM);
-    GET_AGPGART_SYMBOL(agp_ops.allocate_memory, AGP_ALLOCATE_MEMORY_SYM);
-    GET_AGPGART_SYMBOL(agp_ops.free_memory,     AGP_FREE_MEMORY_SYM);
-    GET_AGPGART_SYMBOL(agp_ops.bind_memory,     AGP_BIND_MEMORY_SYM);
-    GET_AGPGART_SYMBOL(agp_ops.unbind_memory,   AGP_UNBIND_MEMORY_SYM);
-    GET_AGPGART_SYMBOL(agp_ops.enable,          AGP_ENABLE_SYM);
-#endif
 
     /* NOTE: from here down, return an error code of '-1'
      * that indicates that agpgart is loaded, but we failed to use it
@@ -159,7 +94,7 @@
      * the memory controller.
      */
 
-    if ( (*(agp_ops.backend_acquire))() )
+    if (drm_agp_p->acquire())
     {
         nv_printf(NV_DBG_ERRORS, "NVRM: AGPGART: backend in use\n");
         return -1;
@@ -177,7 +112,21 @@
         agp_fw = 1;
     agp_fw &= 0x00000001;
     
-    (*(agp_ops.copy_info))(&agpinfo);
+#if defined(KERNEL_2_4)
+    /*
+     * The original Linux 2.4 AGP GART driver interface declared copy_info to
+     * return nothing. This changed in Linux 2.5, which reports unsupported
+     * chipsets via this function. If this Linux 2.4 kernels behaves the same
+     * way, we have no way to know.
+     */
+    drm_agp_p->copy_info(&agpinfo);
+#else
+    if (drm_agp_p->copy_info(&agpinfo)) {
+        drm_agp_p->release();
+        inter_module_put("drm_agp");
+        return -1;
+    }
+#endif
 
 #ifdef CONFIG_MTRR
     if ((gart.mtrr = mtrr_add(agpinfo.aper_base,
@@ -191,7 +140,8 @@
          */
         nv_printf(NV_DBG_ERRORS, 
             "NVRM: AGPGART: unable to set MTRR write-combining\n");
-        (*(agp_ops.backend_release))();
+        drm_agp_p->release();
+        inter_module_put("drm_agp");
         return -1;
     }
 #endif
@@ -207,7 +157,8 @@
     {
         nv_printf(NV_DBG_ERRORS, "NVRM: AGPGART: unable to remap aperture\n");
         MTRR_DEL(gart);
-        (*(agp_ops.backend_release))();
+        drm_agp_p->release();
+        inter_module_put("drm_agp");
         return -1;
     }
 
@@ -218,7 +169,8 @@
         nv_printf(NV_DBG_ERRORS, "NVRM: AGPGART: unable to allocate bitmap\n");
         NV_IOUNMAP(gart.aperture, RM_PAGE_SIZE);
         MTRR_DEL(gart);
-        (*(agp_ops.backend_release))();
+        drm_agp_p->release();
+        inter_module_put("drm_agp");
         return -1;
     }
 
@@ -229,39 +181,19 @@
         os_free_mem(bitmap);
         NV_IOUNMAP(gart.aperture, RM_PAGE_SIZE);
         MTRR_DEL(gart);
-        (*(agp_ops.backend_release))();
+        drm_agp_p->release();
+        inter_module_put("drm_agp");
         return -1;
     }
 
-    nv_printf(NV_DBG_SETUP,
-        "NVRM: AGPGART: aperture: %ldM @ 0x%08lx\n",
-        (unsigned long)agpinfo.aper_size,
-        (unsigned long)agpinfo.aper_base);
-
-    nv_printf(NV_DBG_SETUP, 
-        "NVRM: AGPGART: aperture mapped from 0x%08lx to 0x%08lx\n",
-        agpinfo.aper_base,
-        (unsigned long) gart.aperture);
-
     if (!agp_sba) agpinfo.mode &= ~0x00000200;
     if (!agp_fw)  agpinfo.mode &= ~0x00000010;
 
     if (!(agp_rate & 0x00000004)) agpinfo.mode &= ~0x00000004;
     if (!(agp_rate & 0x00000002)) agpinfo.mode &= ~0x00000002;
     
-    (*(agp_ops.enable))(agpinfo.mode);
+    drm_agp_p->enable(agpinfo.mode);
     
-    if (agpinfo.mode & 0x00000200)
-        nv_printf(NV_DBG_SETUP, "NVRM: AGPGART: backend supports sba\n");
-    if (agpinfo.mode & 0x00000010)
-        nv_printf(NV_DBG_SETUP, "NVRM: AGPGART: backend supports fw\n");
-    if (agpinfo.mode & 0x00000004)
-        nv_printf(NV_DBG_SETUP, "NVRM: AGPGART: mode 4x\n");
-    else if (agpinfo.mode & 0x00000002)
-        nv_printf(NV_DBG_SETUP, "NVRM: AGPGART: mode 2x\n");
-    else if (agpinfo.mode & 0x00000001)
-        nv_printf(NV_DBG_SETUP, "NVRM: AGPGART: mode 1x\n");
-
     *ap_phys_base   = (void*) agpinfo.aper_base;
     *ap_mapped_base = (void*) gart.aperture;
     *apsize         = (agpinfo.aper_size * 0x100000) - 1;
@@ -295,11 +227,13 @@
         NV_IOUNMAP(gart.aperture, RM_PAGE_SIZE);
     }
 
-    (*(agp_ops.backend_release))();
+    drm_agp_p->release();
 
-#if !defined (KERNEL_2_2)
+    /*
+     * XXX Same as above; the inter_module_* mechanism will go away at some
+     * point, it has been deprecated in Linux 2.5.
+     */
     inter_module_put("drm_agp");
-#endif
 
     if (rm_clear_agp_bitmap(nv, &bitmap))
     {
@@ -346,7 +280,7 @@
         return RM_ERROR;
     }
 
-    ptr = (*agp_ops.allocate_memory)(PageCount, AGP_NORMAL_MEMORY);
+    ptr = drm_agp_p->allocate_memory(PageCount, AGP_NORMAL_MEMORY);
     if (ptr == NULL)
     {
         *pAddress = (void*) 0;
@@ -354,7 +288,7 @@
         return RM_ERR_NO_FREE_MEM;
     }
     
-    err = (*(agp_ops.bind_memory))(ptr, *Offset);
+    err = drm_agp_p->bind_memory(ptr, *Offset);
     if (err)
     {
         // this happens a lot when the aperture itself fills up..
@@ -371,7 +305,7 @@
     if (status != RM_OK)
     {
         nv_printf(NV_DBG_ERRORS, "NVRM: memory allocation failed\n");
-        (*(agp_ops.unbind_memory))(ptr);
+        drm_agp_p->unbind_memory(ptr);
         goto fail;
     }
 
@@ -386,7 +320,7 @@
     return RM_OK;
 
 fail:
-    (*(agp_ops.free_memory))(ptr);
+    drm_agp_p->free_memory(ptr);
     *pAddress = (void*) 0;
 
     return RM_ERROR;
@@ -426,7 +360,7 @@
     {
         nv_printf(NV_DBG_ERRORS, "NVRM: AGPGART: unable to remap %lu pages\n",
             (unsigned long)agp_data->num_pages);
-        (*(agp_ops.unbind_memory))(agp_data->ptr);
+        drm_agp_p->unbind_memory(agp_data->ptr);
         goto fail;
     }
     
@@ -445,8 +379,6 @@
 }
 #endif
 
-#if !defined(KERNEL_2_2)
-
 RM_STATUS 
 KernMapAGPNopage(
     VOID *address,
@@ -501,9 +433,6 @@
 #endif
 }
 
-#endif /* !defined(KERNEL_2_2) */
-
-
 RM_STATUS KernFreeAGPPages(
     nv_state_t *nv,
     VOID **pAddress,
@@ -529,8 +458,8 @@
     {
         size_t pages = ptr->page_count;
 
-        (*(agp_ops.unbind_memory))(ptr);
-        (*(agp_ops.free_memory))(ptr);
+        drm_agp_p->unbind_memory(ptr);
+        drm_agp_p->free_memory(ptr);
 
         nv_printf(NV_DBG_INFO, "NVRM: AGPGART: freed %ld pages\n",
             (unsigned long)pages);
diff -ruN NVIDIA_kernel-1.0-5328/os-interface.c NVIDIA_kernel-1.0-5328-2.6/os-interface.c
--- NVIDIA_kernel-1.0-5328/os-interface.c	2003-12-17 23:54:59.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/os-interface.c	2003-12-23 10:46:50.000000000 +0100
@@ -56,7 +56,7 @@
     PHWINFO pDev
 )
 {
-    return suser();
+    return NV_IS_SUSER();
 }
 
 U032 os_get_page_size(VOID)
@@ -211,6 +211,11 @@
 {
     NV_MEM_TRACKING_PAD_SIZE(size);
 
+    /*
+     * XXX This needs to be !NV_MAY_SLEEP() rather than in_interrupt(); that
+     * requires quite a bit of locking to be rearranged, however, which is why
+     * I'll leave it alone for now.
+     */
     if (in_interrupt()) {
         if (size <= KMALLOC_LIMIT) {
             /*
@@ -296,7 +301,7 @@
     *address = (void *) va;
 
     for (i = 0; i < count; i++) {
-        mem_map_reserve(GET_MAP_NR(__pa((va))));
+        SetPageReserved(virt_to_page(va));
         va += PAGE_SIZE;
     }
 
@@ -320,7 +325,7 @@
     unsigned long va = (unsigned long) address;
 
     for (i = 0; i < count; i++) {
-        mem_map_unreserve(GET_MAP_NR(__pa((va))));
+        ClearPageReserved(virt_to_page(va));
         va += PAGE_SIZE;
     }
 
@@ -426,7 +431,7 @@
     if (in_irq() && MilliSeconds > NV_MAX_ISR_MDELAY)
         return RM_ERROR;
 
-    if (in_interrupt()) 
+    if (!NV_MAY_SLEEP()) 
     {
         mdelay(MilliSeconds);
         return RM_OK;
@@ -524,8 +529,8 @@
 // The current debug display level (default to maximum debug level)
 int cur_debuglevel = 0xaaaaaaaa;
 
-MODULE_PARM(silence_nvidia_output, "1i");
 static int silence_nvidia_output = 0;
+NV_MODULE_PARAMETER(silence_nvidia_output);
 
 
 //
@@ -618,12 +623,28 @@
     return value;
 }
 
+struct pci_dev* nvos_find_agp_by_class(unsigned int);
+
 U032 os_pci_read_dword(
     VOID *handle,
     U008 offset
 ) 
 {
     U032 value;
+    if (!handle) {
+        /*
+         * XXX: This hack works around a bug in the NVIDIA AGP
+         * GART driver, which calls us with an invalid handle
+         * on newer Via chipsets. What we need here instead is
+         * a handle for the AGP graphics card.
+         */
+        handle = nvos_find_agp_by_class(PCI_CLASS_DISPLAY_VGA);
+
+        if (!handle) {
+            printk("NVRM: os_pci_read_dword(): bad handle!\n");
+            return 0;
+        }
+    }
     pci_read_config_dword( (struct pci_dev *) handle, offset, (u32 *) &value);
     return value;
 }
@@ -708,14 +729,14 @@
 
 ULONG os_cli(ULONG flags)
 {
-    save_flags(flags);
-    cli();
+    NV_SAVE_FLAGS(flags);
+    NV_CLI();
     return flags;
 }
 
 ULONG os_sti(ULONG flags)
 {
-    restore_flags(flags);
+    NV_RESTORE_FLAGS(flags);
     return flags;
 }
 
@@ -848,16 +869,6 @@
         NV_IOREMAP_NOCACHE(vaddr, start, size_bytes);
     }
 
-#if defined (KERNEL_2_2)
-    if ((vaddr == NULL)) // && (mode == NV_MEMORY_DEFAULT))
-    {
-        unsigned long map_nr = MAP_NR(__va(start));
-        if (map_nr < max_mapnr) {
-            vaddr = __va(start);
-        }
-    }
-#endif
-
     return vaddr;
 }
 
@@ -866,16 +877,7 @@
     U032 size_bytes
 )
 {
-#if defined (KERNEL_2_2)
-    if (MAP_NR(addr) < max_mapnr) {
-        // if we didn't want the memory cached, this isn't necessary
-        // but we shouldn't be in a timing critical piece of code.
-        asm volatile("wbinvd":::"memory");
-    } else 
-#endif
-    {
-        NV_IOUNMAP(addr, size_bytes);
-    }
+    NV_IOUNMAP(addr, size_bytes);
 }
 
 VOID* os_map_user_space(
@@ -979,7 +981,7 @@
 
 U032 os_get_cpu_count()
 {
-    return smp_num_cpus;
+    return NV_SMP_NUM_CPUS;
 }
 
 #if defined(DEBUG) && !defined(NVCPU_IA64)
diff -ruN NVIDIA_kernel-1.0-5328/os-interface.h NVIDIA_kernel-1.0-5328-2.6/os-interface.h
--- NVIDIA_kernel-1.0-5328/os-interface.h	2003-12-17 23:55:00.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/os-interface.h	2003-12-31 13:42:00.000000000 +0100
@@ -40,66 +40,66 @@
  * ---------------------------------------------------------------------------
  */
 
-U032        os_get_page_size            (VOID);
-ULONG       os_get_page_mask            (VOID);
-RM_STATUS   os_alloc_mem                (VOID **, U032);
-VOID        os_free_mem                 (VOID *);
-RM_STATUS   os_alloc_contig_pages       (VOID **, U032);
-VOID        os_free_contig_pages        (VOID *, U032);
-RM_STATUS   os_get_current_time         (U032 *, U032 *);
-RM_STATUS   os_delay                    (U032);
-RM_STATUS   os_delay_us                 (U032);
-U032        os_get_cpu_frequency        (VOID);
-RM_STATUS   os_get_current_process      (U032 *);
-RM_STATUS   os_kill_process             (U032, U032);
-U008*       os_string_copy              (U008 *, const U008 *);
-RM_STATUS   os_strncpy_from_user        (U008 *, const U008 *, U032);
-S032        os_string_compare           (const U008 *, const U008 *);
-U032        os_string_length            (const U008 *);
-U008*       os_mem_copy                 (U008 *, const U008 *, U032);
-RM_STATUS   os_memcpy_from_user         (VOID *, const VOID *, U032);
-RM_STATUS   os_memcpy_to_user           (void *, const VOID *, U032);
-VOID*       os_mem_set                  (VOID *, U008, U032);
-S032        os_mem_cmp                  (const U008 *, const U008 *, U032);
-VOID*       os_pci_init_handle          (U008, U008, U008, U016 *, U016 *);
-U008        os_pci_read_byte            (VOID *, U008);
-U016        os_pci_read_word            (VOID *, U008);
-U032        os_pci_read_dword           (VOID *, U008);
-VOID        os_pci_write_byte           (VOID *, U008, U008);
-VOID        os_pci_write_word           (VOID *, U008, U016);
-VOID        os_pci_write_dword          (VOID *, U008, U032);
-VOID*       os_map_kernel_space         (U032, U032, U032);
-VOID        os_unmap_kernel_space       (VOID *, U032);
-VOID*       os_map_user_space           (VOID *, VOID **, U032, U032);
-VOID        os_unmap_user_space         (VOID *, VOID *);
-VOID*       os_map_io_space             (U032, U032, VOID **, U032, U032);
-VOID        os_unmap_io_space           (VOID *, U032, VOID *, U032);
-RM_STATUS   os_flush_cpu_cache          (VOID);
-RM_STATUS   os_set_mem_range            (U032, U032, U032);
-RM_STATUS   os_unset_mem_range          (U032, U032);
-BOOL        os_pci_device_present       (U016, U016);
-U008        os_io_read_byte             (PHWINFO, U032);
-U016        os_io_read_word             (PHWINFO, U032);
-U032        os_io_read_dword            (PHWINFO, U032);
-VOID        os_io_write_byte            (PHWINFO, U032, U008);
-VOID        os_io_write_word            (PHWINFO, U032, U016);
-VOID        os_io_write_dword           (PHWINFO, U032, U032);
-ULONG       os_cli                      (ULONG);
-ULONG       os_sti                      (ULONG);
-VOID*       os_copy_in_ioctl_param      (VOID *, VOID *, U032);
-VOID*       os_copy_out_ioctl_param     (VOID *, VOID *, U032);
-VOID*       os_registry_lookup          (PHWINFO, U008 *, U008 *);
-RM_STATUS   os_swap_barrier             (U032, VOID (*)(VOID *), VOID *);
-BOOL        os_is_administrator         (PHWINFO);
-VOID        os_dbg_init                 (VOID);
-VOID        os_dbg_breakpoint           (VOID);
-VOID        os_dbg_set_level            (U032);
-U032        os_get_cpu_count            (VOID);
-RM_STATUS   os_raise_smp_barrier        (VOID);
-RM_STATUS   os_clear_smp_barrier        (VOID);
+U032        NV_API_CALL  os_get_page_size            (VOID);
+ULONG       NV_API_CALL  os_get_page_mask            (VOID);
+RM_STATUS   NV_API_CALL  os_alloc_mem                (VOID **, U032);
+VOID        NV_API_CALL  os_free_mem                 (VOID *);
+RM_STATUS   NV_API_CALL  os_alloc_contig_pages       (VOID **, U032);
+VOID        NV_API_CALL  os_free_contig_pages        (VOID *, U032);
+RM_STATUS   NV_API_CALL  os_get_current_time         (U032 *, U032 *);
+RM_STATUS   NV_API_CALL  os_delay                    (U032);
+RM_STATUS   NV_API_CALL  os_delay_us                 (U032);
+U032        NV_API_CALL  os_get_cpu_frequency        (VOID);
+RM_STATUS   NV_API_CALL  os_get_current_process      (U032 *);
+RM_STATUS   NV_API_CALL  os_kill_process             (U032, U032);
+U008*       NV_API_CALL  os_string_copy              (U008 *, const U008 *);
+RM_STATUS   NV_API_CALL  os_strncpy_from_user        (U008 *, const U008 *, U032);
+S032        NV_API_CALL  os_string_compare           (const U008 *, const U008 *);
+U032        NV_API_CALL  os_string_length            (const U008 *);
+U008*       NV_API_CALL  os_mem_copy                 (U008 *, const U008 *, U032);
+RM_STATUS   NV_API_CALL  os_memcpy_from_user         (VOID *, const VOID *, U032);
+RM_STATUS   NV_API_CALL  os_memcpy_to_user           (void *, const VOID *, U032);
+VOID*       NV_API_CALL  os_mem_set                  (VOID *, U008, U032);
+S032        NV_API_CALL  os_mem_cmp                  (const U008 *, const U008 *, U032);
+VOID*       NV_API_CALL  os_pci_init_handle          (U008, U008, U008, U016 *, U016 *);
+U008        NV_API_CALL  os_pci_read_byte            (VOID *, U008);
+U016        NV_API_CALL  os_pci_read_word            (VOID *, U008);
+U032        NV_API_CALL  os_pci_read_dword           (VOID *, U008);
+VOID        NV_API_CALL  os_pci_write_byte           (VOID *, U008, U008);
+VOID        NV_API_CALL  os_pci_write_word           (VOID *, U008, U016);
+VOID        NV_API_CALL  os_pci_write_dword          (VOID *, U008, U032);
+VOID*       NV_API_CALL  os_map_kernel_space         (U032, U032, U032);
+VOID        NV_API_CALL  os_unmap_kernel_space       (VOID *, U032);
+VOID*       NV_API_CALL  os_map_user_space           (VOID *, VOID **, U032, U032);
+VOID        NV_API_CALL  os_unmap_user_space         (VOID *, VOID *);
+VOID*       NV_API_CALL  os_map_io_space             (U032, U032, VOID **, U032, U032);
+VOID        NV_API_CALL  os_unmap_io_space           (VOID *, U032, VOID *, U032);
+RM_STATUS   NV_API_CALL  os_flush_cpu_cache          (VOID);
+RM_STATUS   NV_API_CALL  os_set_mem_range            (U032, U032, U032);
+RM_STATUS   NV_API_CALL  os_unset_mem_range          (U032, U032);
+BOOL        NV_API_CALL  os_pci_device_present       (U016, U016);
+U008        NV_API_CALL  os_io_read_byte             (PHWINFO, U032);
+U016        NV_API_CALL  os_io_read_word             (PHWINFO, U032);
+U032        NV_API_CALL  os_io_read_dword            (PHWINFO, U032);
+VOID        NV_API_CALL  os_io_write_byte            (PHWINFO, U032, U008);
+VOID        NV_API_CALL  os_io_write_word            (PHWINFO, U032, U016);
+VOID        NV_API_CALL  os_io_write_dword           (PHWINFO, U032, U032);
+ULONG       NV_API_CALL  os_cli                      (ULONG);
+ULONG       NV_API_CALL  os_sti                      (ULONG);
+VOID*       NV_API_CALL  os_copy_in_ioctl_param      (VOID *, VOID *, U032);
+VOID*       NV_API_CALL  os_copy_out_ioctl_param     (VOID *, VOID *, U032);
+VOID*       NV_API_CALL  os_registry_lookup          (PHWINFO, U008 *, U008 *);
+RM_STATUS   NV_API_CALL  os_swap_barrier             (U032, VOID (*)(VOID *), VOID *);
+BOOL        NV_API_CALL  os_is_administrator         (PHWINFO);
+VOID        NV_API_CALL  os_dbg_init                 (VOID);
+VOID        NV_API_CALL  os_dbg_breakpoint           (VOID);
+VOID        NV_API_CALL  os_dbg_set_level            (U032);
+U032        NV_API_CALL  os_get_cpu_count            (VOID);
+RM_STATUS   NV_API_CALL  os_raise_smp_barrier        (VOID);
+RM_STATUS   NV_API_CALL  os_clear_smp_barrier        (VOID);
 #if defined(DEBUG) && !defined(NVCPU_IA64)
-VOID        os_canary_arm               (VOID);
-VOID        os_canary_check             (VOID);
+VOID        NV_API_CALL  os_canary_arm               (VOID);
+VOID        NV_API_CALL  os_canary_check             (VOID);
 #define CANARY_ARM()    os_canary_arm()
 #define CANARY_CHECK()  os_canary_check()
 #else
@@ -107,8 +107,8 @@
 #define CANARY_CHECK()
 #endif  // DEBUG & !NVCPU_IA64
 
-RM_STATUS   osRaiseSmpBarrier           (VOID);
-RM_STATUS   osClearSmpBarrier           (VOID);
+RM_STATUS   NV_API_CALL  osRaiseSmpBarrier           (VOID);
+RM_STATUS   NV_API_CALL  osClearSmpBarrier           (VOID);
 
 /*
  * ---------------------------------------------------------------------------
@@ -142,8 +142,8 @@
 #define NV_DBG_ERRORS     0x4
 
 
-void out_string(const char *str);
-int nv_printf(int debuglevel, const char *printf_format, ...);
+void    NV_API_CALL  out_string(const char *str);
+int     NV_API_CALL  nv_printf(int debuglevel, const char *printf_format, ...);
 
 
 #define NV_MEMORY_TYPE_SYSTEM       0
diff -ruN NVIDIA_kernel-1.0-5328/os-registry.c NVIDIA_kernel-1.0-5328-2.6/os-registry.c
--- NVIDIA_kernel-1.0-5328/os-registry.c	2003-12-17 23:54:59.000000000 +0100
+++ NVIDIA_kernel-1.0-5328-2.6/os-registry.c	2003-12-18 13:22:54.000000000 +0100
@@ -48,24 +48,6 @@
  *   This could be changed to work on a per-device basis.
  */
 
-/*
- * The 2nd argument to MODULE_PARM is used to verify parameters passed
- * to the module at load time. It should be a string in the following 
- * format:
- *
- *   	[min[-max]]{b,h,i,l,s}
- *
- * The MIN and MAX specifiers delimit the length of the array. If MAX
- * is omitted, it defaults to MIN; if both are omitted, the default is
- * 1. The final character is a type specifier.
- *
- *  b   byte
- *  h   short
- *  i   int
- *  l   long
- *  s   string
- */
-
 /* 
  * Option: VideoMemoryTypeOverride
  * 
@@ -92,7 +74,7 @@
  */
 
 static int NVreg_VideoMemoryTypeOverride = 1;
-MODULE_PARM(NVreg_VideoMemoryTypeOverride, "i");
+NV_MODULE_PARAMETER(NVreg_VideoMemoryTypeOverride);
 
 /*
  * Option: EnableVia4x
@@ -111,7 +93,7 @@
  */
 
 static int NVreg_EnableVia4x = 0;
-MODULE_PARM(NVreg_EnableVia4x, "i");
+NV_MODULE_PARAMETER(NVreg_EnableVia4x);
 
 /*
  * Option: EnableALiAGP
@@ -134,7 +116,7 @@
  */
 
 static int NVreg_EnableALiAGP = 0;
-MODULE_PARM(NVreg_EnableALiAGP, "i");
+NV_MODULE_PARAMETER(NVreg_EnableALiAGP);
 
 /* 
  * Option: ReqAGPRate
@@ -164,7 +146,7 @@
  */
 
 static int NVreg_ReqAGPRate = 7;
-MODULE_PARM(NVreg_ReqAGPRate, "i");
+NV_MODULE_PARAMETER(NVreg_ReqAGPRate);
 
 /* 
  * Option: UpdateKernelAGP
@@ -193,7 +175,7 @@
  */
 
 static int NVreg_UpdateKernelAGP = 1;
-MODULE_PARM(NVreg_UpdateKernelAGP, "i");
+NV_MODULE_PARAMETER(NVreg_UpdateKernelAGP);
 
 /* 
  * Option: EnableAGPSBA
@@ -226,7 +208,7 @@
 static int NVreg_EnableAGPSBA = 0;
 #endif
 
-MODULE_PARM(NVreg_EnableAGPSBA, "i");
+NV_MODULE_PARAMETER(NVreg_EnableAGPSBA);
 
 /*
  * Option: EnableAGPFW
@@ -250,7 +232,7 @@
  */
 
 static int NVreg_EnableAGPFW = 0;
-MODULE_PARM(NVreg_EnableAGPFW, "i");
+NV_MODULE_PARAMETER(NVreg_EnableAGPFW);
 
 /*
  * Option: SoftEDIDs
@@ -269,7 +251,7 @@
  */
 
 static int NVreg_SoftEDIDs = 1;
-MODULE_PARM(NVreg_SoftEDIDs, "i");
+NV_MODULE_PARAMETER(NVreg_SoftEDIDs);
 
 /* 
  * Option: Mobile
@@ -293,14 +275,14 @@
  */
 
 static int NVreg_Mobile = ~0;
-MODULE_PARM(NVreg_Mobile, "i");
+NV_MODULE_PARAMETER(NVreg_Mobile);
 
 
 static int NVreg_ResmanDebugLevel = ~0;
-MODULE_PARM(NVreg_ResmanDebugLevel, "i");
+NV_MODULE_PARAMETER(NVreg_ResmanDebugLevel);
 
 static int NVreg_FlatPanelMode = 0;
-MODULE_PARM(NVreg_FlatPanelMode, "i");
+NV_MODULE_PARAMETER(NVreg_FlatPanelMode);
 
 /*
  * You can enable any of the registry options disabled by default by
