diff -ruN NVIDIA_kernel-1.0-5336/Makefile.kbuild NVIDIA_kernel-1.0-5336-2.6/Makefile.kbuild
--- NVIDIA_kernel-1.0-5336/Makefile.kbuild	2004-01-15 04:29:12.000000000 +0100
+++ NVIDIA_kernel-1.0-5336-2.6/Makefile.kbuild	2004-05-12 19:17:49.000000000 +0200
@@ -73,7 +73,7 @@
 #
 
 EXTRA_CFLAGS += -I$(src)
-EXTRA_CFLAGS += -Wall -Wimplicit -Wreturn-type -Wswitch -Wformat -Wchar-subscripts -Wparentheses -Wpointer-arith  -Wno-multichar  -Werror -O -MD $(DEFINES) $(INCLUDES) -Wno-cast-qual -Wno-error
+EXTRA_CFLAGS += -Wall -Wimplicit -Wreturn-type -Wswitch -Wformat -Wchar-subscripts -Wparentheses -Wno-pointer-arith  -Wno-multichar  -Werror -O -MD $(DEFINES) $(INCLUDES) -Wno-cast-qual -Wno-error
 
 #
 # We rely on these two definitions below; if they aren't set, we set them to
diff -ruN NVIDIA_kernel-1.0-5336/nv-linux.h NVIDIA_kernel-1.0-5336-2.6/nv-linux.h
--- NVIDIA_kernel-1.0-5336/nv-linux.h	2004-01-15 04:29:11.000000000 +0100
+++ NVIDIA_kernel-1.0-5336-2.6/nv-linux.h	2004-05-12 19:17:36.000000000 +0200
@@ -136,16 +136,19 @@
 
 #if NV_ENABLE_MEM_TRACKING
 #define NV_MEM_TRACKING_PAD_SIZE(size)   ((size) += sizeof(void *))
-#define NV_MEM_TRACKING_HIDE_SIZE(ptr, size) \
-    if ((ptr) && *(ptr)) { \
-        *(int *) *(ptr) = (size); \
-        (char *) *(ptr) += sizeof(void *); \
-    }
-#define NV_MEM_TRACKING_RETRIEVE_SIZE(ptr, size) \
-    { \
-        (char *) (ptr) -= sizeof(void *); \
-        size = *(int *) (ptr); \
-    }
+#define NV_MEM_TRACKING_HIDE_SIZE(ptr, size)            \
+    if ((ptr) && *(ptr)) {                              \
+        U008 *__ptr;                                    \
+        *(unsigned long *) *(ptr) = (size);             \
+        __ptr = *(ptr); __ptr += sizeof(void *);        \
+        *(ptr) = (void *) __ptr;                        \
+    }
+#define NV_MEM_TRACKING_RETRIEVE_SIZE(ptr, size)        \
+    {                                                   \
+        U008 *__ptr = (ptr); __ptr -= sizeof(void *);   \
+        (ptr) = (void *) __ptr;                         \
+        size = *(unsigned long *) (ptr);                \
+    } 
 #else
 #define NV_MEM_TRACKING_PAD_SIZE(size)
 #define NV_MEM_TRACKING_HIDE_SIZE(ptr, size)
@@ -293,13 +296,13 @@
 #if defined(NVCPU_IA64)
 #define NV_VMALLOC(ptr, size) \
     { \
-        (void *) (ptr) = vmalloc_dma(size); \
+        (ptr) = vmalloc_dma(size); \
         VM_ALLOC_RECORD(ptr, size, "vm_alloc"); \
     }
 #else
 #define NV_VMALLOC(ptr, size) \
     { \
-        (void *) (ptr) = vmalloc_32(size); \
+        (ptr) = vmalloc_32(size); \
         VM_ALLOC_RECORD(ptr, size, "vm_alloc"); \
     }
 #endif
@@ -312,13 +315,13 @@
 
 #define NV_IOREMAP(ptr, physaddr, size) \
     { \
-        (void *) (ptr) = ioremap(physaddr, size); \
+        (ptr) = ioremap(physaddr, size); \
         VM_ALLOC_RECORD(ptr, size, "vm_ioremap"); \
     }
 
 #define NV_IOREMAP_NOCACHE(ptr, physaddr, size) \
     { \
-        (void *) (ptr) = ioremap_nocache(physaddr, size); \
+        (ptr) = ioremap_nocache(physaddr, size); \
         VM_ALLOC_RECORD(ptr, size, "vm_ioremap_nocache"); \
     }
 
@@ -333,13 +336,13 @@
  */
 #define NV_KMALLOC(ptr, size) \
     { \
-        (void *) (ptr) = kmalloc(size, GFP_KERNEL); \
+        (ptr) = kmalloc(size, GFP_KERNEL); \
         KM_ALLOC_RECORD(ptr, size, "km_alloc"); \
     }
 
 #define NV_KMALLOC_ATOMIC(ptr, size) \
     { \
-        (void *) (ptr) = kmalloc(size, GFP_ATOMIC); \
+        (ptr) = kmalloc(size, GFP_ATOMIC); \
         KM_ALLOC_RECORD(ptr, size, "km_alloc_atomic"); \
     }  
 
@@ -352,7 +355,7 @@
 
 #define NV_GET_FREE_PAGES(ptr, order) \
     { \
-        (void *) (ptr) = __get_free_pages(NV_GFP_HW, order); \
+        (ptr) = __get_free_pages(NV_GFP_HW, order); \
     }
         
 #define NV_FREE_PAGES(ptr, order) \
@@ -689,8 +692,7 @@
 #define NV_GET_NVFP(filep)      ((nv_file_private_t *) FILE_PRIVATE(filep))
 
 /* for the card devices */
-#define NVL_FROM_FILEP(filep) \
-    ((nv_linux_state_t*) (NV_GET_NVFP(filep))->nvptr)
+#define NVL_FROM_FILEP(filep)   (NV_GET_NVFP(filep)->nvptr)
 
 #define NV_GET_NVL_FROM_NV_STATE(nv) \
     ((nv_linux_state_t *) nv->os_state)
diff -ruN NVIDIA_kernel-1.0-5336/nv.c NVIDIA_kernel-1.0-5336-2.6/nv.c
--- NVIDIA_kernel-1.0-5336/nv.c	2004-01-15 04:29:11.000000000 +0100
+++ NVIDIA_kernel-1.0-5336-2.6/nv.c	2004-05-12 19:18:29.000000000 +0200
@@ -1182,7 +1182,7 @@
 struct vm_operations_struct nv_vm_ops = {
     nv_kern_vma_open,
     nv_kern_vma_release,  /* "close" */
-    nv_kern_vma_nopage,
+/*  nv_kern_vma_nopage, */
 };
 
 static nv_file_private_t *
@@ -2006,7 +2006,7 @@
  * waiting on the wait queue
  */
 
-void nv_set_hotkey_occurred_flag(void)
+void NV_API_CALL nv_set_hotkey_occurred_flag(void)
 {
     nv_printf(NV_DBG_EVENTINFO,"setting the hotkey occurred flag!\n");
 
@@ -2190,7 +2190,7 @@
  *** EXPORTS to rest of resman
  ***/
 
-void *nv_find_nv_mapping(
+void* NV_API_CALL nv_find_nv_mapping(
     nv_state_t    *nv,
     unsigned long  address
 )
@@ -2261,8 +2261,7 @@
  * the TYPE_AGP flag to differeniate it from a PCI allocation.
  * failure is fine, we may just be checking if a given page is agp
  */
-void *
-nv_find_agp_kernel_mapping(
+void* NV_API_CALL nv_find_agp_kernel_mapping(
     nv_state_t    *nv,
     unsigned long  address
 )
@@ -2338,8 +2337,7 @@
     return (unsigned long) NULL;
 }
 
-unsigned long
-nv_get_kern_phys_address(
+unsigned long NV_API_CALL nv_get_kern_phys_address(
     unsigned long address
 )
 {
@@ -2368,8 +2366,7 @@
     return _get_phys_address(address, 1);
 }
 
-unsigned long
-nv_get_user_phys_address(
+unsigned long NV_API_CALL nv_get_user_phys_address(
     unsigned long address
 )
 {
@@ -2391,8 +2388,7 @@
 
 
 /* allocate memory for DMA push buffers */
-int
-nv_alloc_pages(
+int NV_API_CALL nv_alloc_pages(
     nv_state_t *nv,
     void **pAddress,
     unsigned int page_count,
@@ -2583,8 +2579,7 @@
         return -1; \
     }
 
-int
-nv_free_pages(
+int NV_API_CALL nv_free_pages(
     nv_state_t *nv,
     void **pAddress,
     unsigned int page_count,
@@ -2686,7 +2681,7 @@
     nvl->rm_lock_count = 0;
 }
 
-void nv_lock_rm(
+void NV_API_CALL nv_lock_rm(
     nv_state_t *nv
 )
 {
@@ -2706,7 +2701,7 @@
    nvl->rm_lock_count = 1;
 }
 
-void nv_unlock_rm(
+void NV_API_CALL nv_unlock_rm(
     nv_state_t *nv
 )
 {
@@ -2720,7 +2715,7 @@
     spin_unlock_irq(&nvl->rm_lock);
 }
 
-void nv_lock_heap(
+void NV_API_CALL nv_lock_heap(
     nv_state_t *nv
 )
 {
@@ -2730,7 +2725,7 @@
     nv_lock(nvl->heap_lock);
 }
 
-void nv_unlock_heap(
+void NV_API_CALL nv_unlock_heap(
     nv_state_t *nv
 )
 {
@@ -2743,7 +2738,7 @@
 /*
 ** post the event
 */
-void nv_post_event(
+void NV_API_CALL nv_post_event(
     nv_state_t *nv,
     nv_event_t *event,
     U032        handle,
@@ -2781,7 +2776,7 @@
     nv_unlock_irq(nvfp->fp_lock, eflags);
 }
 
-int nv_get_event(
+int NV_API_CALL nv_get_event(
     nv_state_t *nv,
     VOID *void_file,
     nv_event_t *event,
@@ -2822,8 +2817,7 @@
 }
 
 
-int
-nv_agp_init(
+int NV_API_CALL nv_agp_init(
     nv_state_t *nv,
     VOID **phys_start,
     VOID **linear_start,
@@ -2888,8 +2882,7 @@
     return status;
 }
 
-int
-nv_agp_teardown(
+int NV_API_CALL nv_agp_teardown(
     nv_state_t *nv
 )
 {
@@ -2926,8 +2919,7 @@
  * (if the linear mapping was real, this is the page that would have been
  * addressed by the virtual address. I know, confusing).
  */
-int
-nv_agp_translate_address(
+int NV_API_CALL nv_agp_translate_address(
     nv_state_t *nv,
     void       *base,
     U032        index,
@@ -2956,8 +2948,7 @@
 }
 
 
-int
-nv_int10h_call(
+int NV_API_CALL nv_int10h_call(
     nv_state_t *nv,
     U032 *eax,
     U032 *ebx,
@@ -2970,8 +2961,7 @@
 }
 
 /* set a timer to go off every second */
-int 
-nv_start_rc_timer(
+int NV_API_CALL nv_start_rc_timer(
     nv_state_t *nv
 )
 {
@@ -2991,8 +2981,7 @@
     return 0;
 }
 
-int 
-nv_stop_rc_timer(
+int NV_API_CALL nv_stop_rc_timer(
     nv_state_t *nv
 )
 {
diff -ruN NVIDIA_kernel-1.0-5336/os-interface.c NVIDIA_kernel-1.0-5336-2.6/os-interface.c
--- NVIDIA_kernel-1.0-5336/os-interface.c	2004-01-15 04:29:11.000000000 +0100
+++ NVIDIA_kernel-1.0-5336-2.6/os-interface.c	2004-05-12 19:09:35.000000000 +0200
@@ -35,7 +35,7 @@
 }
 #endif
 
-RM_STATUS os_raise_smp_barrier(VOID)
+RM_STATUS NV_API_CALL os_raise_smp_barrier(VOID)
 {
     os_block_on_smp_barrier = 1;
 #ifdef CONFIG_SMP
@@ -45,26 +45,26 @@
     return RM_OK;
 }
 
-RM_STATUS os_clear_smp_barrier(VOID)
+RM_STATUS NV_API_CALL os_clear_smp_barrier(VOID)
 {
     os_block_on_smp_barrier = 0;
     return RM_OK;
 }
 
 // return TRUE if the caller is the super-user
-BOOL os_is_administrator(
+BOOL NV_API_CALL os_is_administrator(
     PHWINFO pDev
 )
 {
     return NV_IS_SUSER();
 }
 
-U032 os_get_page_size(VOID)
+U032 NV_API_CALL os_get_page_size(VOID)
 {
     return PAGE_SIZE;
 }
 
-ULONG os_get_page_mask(VOID)
+ULONG NV_API_CALL os_get_page_mask(VOID)
 {
     return PAGE_MASK;
 }
@@ -78,7 +78,7 @@
 // just replace the code within osStringCopy with a call to the C library
 // function strcpy.
 //
-U008* os_string_copy(
+U008* NV_API_CALL os_string_copy(
     U008 *dst,
     const U008 *src
 )
@@ -86,7 +86,7 @@
     return strcpy(dst, src);
 }
 
-RM_STATUS os_strncpy_from_user(
+RM_STATUS NV_API_CALL os_strncpy_from_user(
     U008 *dst,
     const U008 *src,
     U032 n
@@ -99,7 +99,7 @@
 #endif
 }
 
-S032 os_string_compare(
+S032 NV_API_CALL os_string_compare(
     const U008 *s1,
     const U008 *s2
 )
@@ -107,14 +107,14 @@
     return strcmp(s1, s2);
 }
 
-U032 os_string_length(
+U032 NV_API_CALL os_string_length(
     const U008* str
 )
 {
     return strlen(str);
 }
 
-U008* os_mem_copy(
+U008* NV_API_CALL os_mem_copy(
     U008 *dst,
     const U008 *src,
     U032 length
@@ -123,7 +123,7 @@
     return memcpy(dst, src, length);
 }
 
-RM_STATUS os_memcpy_from_user(
+RM_STATUS NV_API_CALL os_memcpy_from_user(
     VOID *dst,
     const VOID* src,
     U032 length
@@ -132,7 +132,7 @@
     return copy_from_user(dst, src, length) ? RM_ERR_BAD_ADDRESS : RM_OK;
 }
 
-RM_STATUS os_memcpy_to_user(
+RM_STATUS NV_API_CALL os_memcpy_to_user(
     VOID *dst,
     const VOID* src,
     U032 length
@@ -141,7 +141,7 @@
     return copy_to_user(dst, src, length) ? RM_ERR_BAD_ADDRESS : RM_OK;
 }
 
-VOID* os_mem_set(
+VOID* NV_API_CALL os_mem_set(
     VOID* dst,
     U008 c,
     U032 length
@@ -150,7 +150,7 @@
     return memset(dst, (int)c, length);
 }
 
-S032 os_mem_cmp(
+S032 NV_API_CALL os_mem_cmp(
     const U008 *buf0,
     const U008* buf1,
     U032 length
@@ -159,7 +159,7 @@
     return memcmp(buf0, buf1, length);
 }
 
-VOID* os_copy_in_ioctl_param(
+VOID* NV_API_CALL os_copy_in_ioctl_param(
     VOID *dst,
     VOID *src,
     U032 length
@@ -172,7 +172,7 @@
     }
 }
 
-VOID* os_copy_out_ioctl_param(
+VOID* NV_API_CALL os_copy_out_ioctl_param(
     VOID *dst,
     VOID *src,
     U032 length
@@ -204,7 +204,7 @@
 
 #define KMALLOC_LIMIT 131072
 
-RM_STATUS os_alloc_mem(
+RM_STATUS NV_API_CALL os_alloc_mem(
     VOID **address,
     U032 size
 )
@@ -251,7 +251,7 @@
     return *address ? RM_OK : RM_ERR_NO_FREE_MEM;
 }
 
-void os_free_mem(VOID *address)
+void NV_API_CALL os_free_mem(VOID *address)
 {
     unsigned long va;
     int size;
@@ -273,7 +273,7 @@
  * we may allocate more pages than the caller really asked for.
  * we'll only lock down the number of pages the caller asked for.
  */
-RM_STATUS os_alloc_contig_pages(
+RM_STATUS NV_API_CALL os_alloc_contig_pages(
     VOID **address,
     U032 size
 )
@@ -310,7 +310,7 @@
  * the same number of pages we locked, and to calculate the order we
  * allocated, so we properly free the allocation.
  */
-VOID os_free_contig_pages(
+VOID NV_API_CALL os_free_contig_pages(
     VOID *address,
     U032 size
 )
@@ -335,7 +335,7 @@
 *
 *****************************************************************************/
 
-RM_STATUS os_get_current_time(
+RM_STATUS NV_API_CALL os_get_current_time(
     U032 *seconds,
     U032 *useconds
 )
@@ -371,7 +371,7 @@
  * this, we use mdelay() for any full millisecond to be safe.
  */
 
-RM_STATUS os_delay_us(U032 MicroSeconds)
+RM_STATUS NV_API_CALL os_delay_us(U032 MicroSeconds)
 {
     unsigned long mdelay_safe_msec;
     unsigned long usec;
@@ -411,7 +411,7 @@
  * remainder will be accounted for with mdelay().
  */
 
-RM_STATUS os_delay(U032 MilliSeconds)
+RM_STATUS NV_API_CALL os_delay(U032 MilliSeconds)
 {
     unsigned long MicroSeconds;
     unsigned long jiffies;
@@ -481,7 +481,7 @@
 }
 
 /* return CPU frequency in MHz */
-U032 os_get_cpu_frequency(VOID)
+U032 NV_API_CALL os_get_cpu_frequency(VOID)
 {
     u64 tsc[2];
     u32 tsc_d;
@@ -500,13 +500,13 @@
     return cpu_mhz;
 }
 
-RM_STATUS os_get_current_process(U032 *pPid)
+RM_STATUS NV_API_CALL os_get_current_process(U032 *pPid)
 {
     *pPid = current->pid;
     return RM_OK;
 }
 
-RM_STATUS os_kill_process(
+RM_STATUS NV_API_CALL os_kill_process(
     U032 pid,
     U032 sig
 )
@@ -531,7 +531,7 @@
 //
 // this is what actually outputs the data.
 //
-inline void out_string(const char *str)
+inline void NV_API_CALL out_string(const char *str)
 {
     printk("%d: %s", smp_processor_id(), str);
 }    
@@ -546,7 +546,7 @@
  * Returns the number of characters written.
  */
 
-int nv_printf(
+int NV_API_CALL nv_printf(
     int   debuglevel,
     const char *printf_format,
     ...
@@ -571,7 +571,7 @@
     return chars_written;
 }
 
-BOOL os_pci_device_present(
+BOOL NV_API_CALL os_pci_device_present(
     U016 vendor,
     U016 device
 )
@@ -587,7 +587,7 @@
         return ret; \
     }
 
-VOID* os_pci_init_handle(
+VOID* NV_API_CALL os_pci_init_handle(
     U008 bus,
     U008 slot,
     U008 function,
@@ -604,7 +604,7 @@
     return (VOID *) dev;
 }
 
-U008 os_pci_read_byte(
+U008 NV_API_CALL os_pci_read_byte(
     VOID *handle,
     U008 offset
 )
@@ -615,7 +615,7 @@
     return value;
 }
 
-U016 os_pci_read_word(
+U016 NV_API_CALL os_pci_read_word(
     VOID *handle,
     U008 offset
 )
@@ -626,7 +626,7 @@
     return value;
 }
 
-U032 os_pci_read_dword(
+U032 NV_API_CALL os_pci_read_dword(
     VOID *handle,
     U008 offset
 ) 
@@ -637,7 +637,7 @@
     return value;
 }
 
-VOID os_pci_write_byte(
+VOID NV_API_CALL os_pci_write_byte(
     VOID *handle,
     U008 offset,
     U008 value
@@ -647,7 +647,7 @@
     pci_write_config_byte( (struct pci_dev *) handle, offset, value);
 }
 
-VOID os_pci_write_word(
+VOID NV_API_CALL os_pci_write_word(
     VOID *handle,
     U008 offset,
     U016 value
@@ -657,7 +657,7 @@
     pci_write_config_word( (struct pci_dev *) handle, offset, value);
 }
 
-VOID os_pci_write_dword(
+VOID NV_API_CALL os_pci_write_dword(
     VOID *handle,
     U008 offset,
     U032 value
@@ -667,7 +667,7 @@
     pci_write_config_dword( (struct pci_dev *) handle, offset, value);
 }
 
-VOID os_io_write_byte(
+VOID NV_API_CALL os_io_write_byte(
     PHWINFO pdev,
     U032 address,
     U008 value
@@ -676,7 +676,7 @@
     outb(value, address);
 }
 
-VOID os_io_write_word(
+VOID NV_API_CALL os_io_write_word(
     PHWINFO pdev,
     U032 address,
     U016 value
@@ -685,7 +685,7 @@
     outw(value, address);
 }
 
-VOID os_io_write_dword(
+VOID NV_API_CALL os_io_write_dword(
     PHWINFO pdev,
     U032 address,
     U032 value
@@ -694,7 +694,7 @@
     outl(value, address);
 }
 
-U008 os_io_read_byte(
+U008 NV_API_CALL os_io_read_byte(
     PHWINFO pdev,
     U032 address
 )
@@ -702,7 +702,7 @@
     return inb(address);
 }
 
-U016 os_io_read_word(
+U016 NV_API_CALL os_io_read_word(
     PHWINFO pdev,
     U032 address
 )
@@ -710,7 +710,7 @@
     return inw(address);
 }
 
-U032 os_io_read_dword(
+U032 NV_API_CALL os_io_read_dword(
     PHWINFO pdev,
     U032 address
 )
@@ -718,14 +718,14 @@
     return inl(address);
 }
 
-ULONG os_cli(ULONG flags)
+ULONG NV_API_CALL os_cli(ULONG flags)
 {
     NV_SAVE_FLAGS(flags);
     NV_CLI();
     return flags;
 }
 
-ULONG os_sti(ULONG flags)
+ULONG NV_API_CALL os_sti(ULONG flags)
 {
     NV_RESTORE_FLAGS(flags);
     return flags;
@@ -789,7 +789,7 @@
  * achieve the same results on a PIII or higher
  */
 
-RM_STATUS os_set_mem_range(
+RM_STATUS NV_API_CALL os_set_mem_range(
     U032 start,
     U032 size,
     U032 mode
@@ -817,7 +817,7 @@
     return RM_ERROR;
 }
 
-RM_STATUS os_unset_mem_range(
+RM_STATUS NV_API_CALL os_unset_mem_range(
     U032 start,
     U032 size
 )
@@ -839,7 +839,7 @@
  * should this also check for Write-Combining??
  */
 
-VOID *os_map_kernel_space(
+VOID *NV_API_CALL os_map_kernel_space(
     U032 start,
     U032 size_bytes,
     U032 mode
@@ -864,7 +864,7 @@
     return vaddr;
 }
 
-VOID os_unmap_kernel_space(
+VOID NV_API_CALL os_unmap_kernel_space(
     VOID *addr,
     U032 size_bytes
 )
@@ -872,7 +872,7 @@
     NV_IOUNMAP(addr, size_bytes);
 }
 
-VOID* os_map_user_space(
+VOID* NV_API_CALL os_map_user_space(
     VOID *kaddr,
     VOID **priv,
     U032 size_bytes,
@@ -883,14 +883,14 @@
     return NULL;
 }
 
-VOID os_unmap_user_space(
+VOID NV_API_CALL os_unmap_user_space(
     VOID *uaddr,
     VOID *priv
 )
 {
 }
 
-VOID* os_map_io_space(
+VOID* NV_API_CALL os_map_io_space(
     U032 start,
     U032 size_bytes,
     VOID **priv,
@@ -920,7 +920,7 @@
     return (void *)(NV_UINTPTR_T) vma->vm_start;
 }
 
-VOID os_unmap_io_space(
+VOID NV_API_CALL os_unmap_io_space(
     VOID *addr,
     U032 size_bytes,
     VOID *priv,
@@ -930,14 +930,14 @@
 }
 
 // flush the cpu's cache, uni-processor version
-RM_STATUS os_flush_cpu_cache()
+RM_STATUS NV_API_CALL os_flush_cpu_cache()
 {
     CACHE_FLUSH();
     return RM_OK;
 }
 
 // override initial debug level from registry
-VOID os_dbg_init(void)
+VOID NV_API_CALL os_dbg_init(void)
 {
     U032 new_debuglevel;
     if (RM_OK == rm_read_registry_dword(0,
@@ -950,7 +950,7 @@
     }
 }
 
-VOID os_dbg_set_level(U032 new_debuglevel)
+VOID NV_API_CALL os_dbg_set_level(U032 new_debuglevel)
 {
     nv_printf(NV_DBG_SETUP, "Changing debuglevel from 0x%x to 0x%x\n", cur_debuglevel, new_debuglevel);
     cur_debuglevel = new_debuglevel;
@@ -962,7 +962,7 @@
  * a lock or which threw the breakpoint. I should probably scan the list of
  * nv_state_t's and drop any held locks before throwing this breakpoint.
  */
-VOID os_dbg_breakpoint(void)
+VOID NV_API_CALL os_dbg_breakpoint(void)
 {
 #ifdef DEBUG
     out_string("Break\n");
@@ -979,7 +979,7 @@
 }
 
 
-U032 os_get_cpu_count()
+U032 NV_API_CALL os_get_cpu_count()
 {
     return NV_NUM_CPUS();
 }
@@ -1008,7 +1008,7 @@
 #define NV_CANARY_CAGE  ((unsigned long *)(current + 1))
 
 void
-os_canary_arm()
+NV_API_CALL os_canary_arm()
 {
     int i;
 
@@ -1017,7 +1017,7 @@
 }
 
 void
-os_canary_check()
+NV_API_CALL os_canary_check()
 {
     int i;
 
