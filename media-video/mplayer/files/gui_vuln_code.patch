diff -Naur MPlayer-1.0pre4/Gui/Makefile MPlayer-1.0pre5/Gui/Makefile
--- MPlayer-1.0pre4/Gui/Makefile	2003-04-05 00:39:51.000000000 +0900
+++ MPlayer-1.0pre5/Gui/Makefile	2004-06-28 04:17:24.000000000 +0900
@@ -27,11 +27,12 @@
 $(LIB):	.depend	$(OBJS)
 	rm -f $(LIB)
 	$(AR) rc $(LIB) $(OBJS) $(MPLAYEROBJS)
+	$(RANLIB) $(LIB)
 
 all:	$(LIB)
 
 clean:
-	rm -rf $(OBJS) *.o *~ *.bak main $(PRG) $(LIB) .depend
+	rm -rf $(OBJS) *.o *~ *.bak main $(LIB) .depend
 
 #dep:	depend
 #
diff -Naur MPlayer-1.0pre4/Gui/interface.c MPlayer-1.0pre5/Gui/interface.c
--- MPlayer-1.0pre4/Gui/interface.c	2004-03-26 06:49:47.000000000 +0900
+++ MPlayer-1.0pre5/Gui/interface.c	2004-06-26 22:26:10.000000000 +0900
@@ -54,8 +56,12 @@
  if ( *dest )
   {
    tmp=malloc( strlen( *dest ) + strlen( src ) + 1 );
-   strcpy( tmp,*dest ); strcat( tmp,src ); free( *dest ); 
-  }
+   
+   if ( tmp ) /* TODO: advanced error handling */
+    {
+     strcpy( tmp,*dest ); strcat( tmp,src ); free( *dest ); 
+    }
+   }
   else
    { tmp=malloc( strlen( src ) + 1 ); strcpy( tmp,src ); }
  *dest=tmp;
diff -Naur MPlayer-1.0pre4/Gui/mplayer/common.c MPlayer-1.0pre5/Gui/mplayer/common.c
--- MPlayer-1.0pre4/Gui/mplayer/common.c	2003-03-20 21:42:09.000000000 +0900
+++ MPlayer-1.0pre5/Gui/mplayer/common.c	2004-06-26 22:54:20.000000000 +0900
@@ -30,37 +30,41 @@
 #include "play.h"
 #include "widgets.h"
 
 extern unsigned int GetTimerMS( void );
 
-inline void TranslateFilename( int c,char * tmp )
+inline void TranslateFilename( int c,char * tmp,size_t tmplen )
 {
  int i;
+ char * p;
+ 
  switch ( guiIntfStruct.StreamType )
   {
    case STREAMTYPE_STREAM:
-        strcpy( tmp,guiIntfStruct.Filename );
+        strlcpy(tmp, guiIntfStruct.Filename, tmplen);
         break;
    case STREAMTYPE_FILE:
           if ( ( guiIntfStruct.Filename )&&( guiIntfStruct.Filename[0] ) )
            {
-	    if ( strrchr( guiIntfStruct.Filename,'/' ) ) strcpy( tmp,strrchr( guiIntfStruct.Filename,'/' ) + 1 );
-	     else strcpy( tmp,guiIntfStruct.Filename );
+            if ( p = strrchr(guiIntfStruct.Filename, '/') )
+              strlcpy(tmp, p + 1, tmplen);
+            else
+              strlcpy(tmp, guiIntfStruct.Filename, tmplen);
             if ( tmp[strlen( tmp ) - 4] == '.' ) tmp[strlen( tmp ) - 4]=0;
             if ( tmp[strlen( tmp ) - 5] == '.' ) tmp[strlen( tmp ) - 5]=0;
-           } else strcpy( tmp,MSGTR_NoFileLoaded );
+           } else strlcpy( tmp,MSGTR_NoFileLoaded,tmplen );
           break;
 #ifdef USE_DVDREAD
    case STREAMTYPE_DVD:
-          if ( guiIntfStruct.DVD.current_chapter ) sprintf( tmp,MSGTR_Chapter,guiIntfStruct.DVD.current_chapter );
-            else strcat( tmp,MSGTR_NoChapter );
+          if ( guiIntfStruct.DVD.current_chapter ) snprintf(tmp,tmplen,MSGTR_Chapter,guiIntfStruct.DVD.current_chapter );
+            else strlcat( tmp,MSGTR_NoChapter,tmplen );
           break;
 #endif
 #ifdef HAVE_VCD
    case STREAMTYPE_VCD:
-        sprintf( tmp,MSGTR_VCDTrack,guiIntfStruct.Track );
+        snprintf( tmp,tmplen,MSGTR_VCDTrack,guiIntfStruct.Track );
 	break;
 #endif
-   default: strcpy( tmp,MSGTR_NoMediaOpened );
+   default: strlcpy( tmp,MSGTR_NoMediaOpened,tmplen );
   }
  if ( c )
   {
@@ -74,75 +80,94 @@
   }
 }
 
+/* Unsafe!  Pass only null-terminated strings as (char *)str. */
 char * Translate( char * str )
 {
  static char   trbuf[512];
         char   tmp[512];
         int    i,c;
         int    t;
+        int    strsize = 0;
  memset( trbuf,0,512 );
  memset( tmp,0,128 );
- for ( c=0,i=0;i < (int)strlen( str );i++ )
+ strsize = strlen(str);
+ for ( c=0,i=0;i < strsize;i++ )
   {
    if ( str[i] != '$' ) { trbuf[c++]=str[i]; trbuf[c]=0; }
     else
     {
      switch ( str[++i] )
       {
-       case 't': sprintf( tmp,"%02d",guiIntfStruct.Track ); strcat( trbuf,tmp ); break;
-       case 'o': TranslateFilename( 0,tmp ); strcat( trbuf,tmp ); break;
-       case 'f': TranslateFilename( 1,tmp ); strcat( trbuf,tmp ); break;
-       case 'F': TranslateFilename( 2,tmp ); strcat( trbuf,tmp ); break;
+       case 't': snprintf( tmp,sizeof( tmp ),"%02d",guiIntfStruct.Track );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'o': TranslateFilename( 0,tmp,sizeof( tmp ) );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'f': TranslateFilename( 1,tmp,sizeof( tmp ) );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'F': TranslateFilename( 2,tmp,sizeof( tmp ) );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
        case '6': t=guiIntfStruct.LengthInSec; goto calclengthhhmmss;
        case '1': t=guiIntfStruct.TimeSec;
 calclengthhhmmss:
-            sprintf( tmp,"%02d:%02d:%02d",t/3600,t/60%60,t%60 ); strcat( trbuf,tmp );
+            snprintf( tmp,sizeof( tmp ),"%02d:%02d:%02d",t/3600,t/60%60,t%60 );
+            strlcat( trbuf,tmp,sizeof( trbuf ) );
             break;
        case '7': t=guiIntfStruct.LengthInSec; goto calclengthmmmmss;
        case '2': t=guiIntfStruct.TimeSec;
 calclengthmmmmss:
-            sprintf( tmp,"%04d:%02d",t/60,t%60 ); strcat( trbuf,tmp );
+            snprintf( tmp,sizeof( tmp ),"%04d:%02d",t/60,t%60 );
+            strlcat( trbuf,tmp,sizeof( trbuf ) );
             break;
-       case '3': sprintf( tmp,"%02d",guiIntfStruct.TimeSec / 3600 ); strcat( trbuf,tmp ); break;
-       case '4': sprintf( tmp,"%02d",( ( guiIntfStruct.TimeSec / 60 ) % 60 ) ); strcat( trbuf,tmp ); break;
-       case '5': sprintf( tmp,"%02d",guiIntfStruct.TimeSec % 60 ); strcat( trbuf,tmp ); break;
-       case '8': sprintf( tmp,"%01d:%02d:%02d",guiIntfStruct.TimeSec / 3600,( guiIntfStruct.TimeSec / 60 ) % 60,guiIntfStruct.TimeSec % 60 ); strcat( trbuf,tmp ); break;
-       case 'v': sprintf( tmp,"%3.2f%%",guiIntfStruct.Volume ); strcat( trbuf,tmp ); break;
-       case 'V': sprintf( tmp,"%3.1f",guiIntfStruct.Volume ); strcat( trbuf,tmp ); break;
-       case 'b': sprintf( tmp,"%3.2f%%",guiIntfStruct.Balance ); strcat( trbuf,tmp ); break;
-       case 'B': sprintf( tmp,"%3.1f",guiIntfStruct.Balance ); strcat( trbuf,tmp ); break;
-       case 'd': sprintf( tmp,"%d",guiIntfStruct.FrameDrop ); strcat( trbuf,tmp ); break;
-       case 'x': sprintf( tmp,"%d",guiIntfStruct.MovieWidth ); strcat( trbuf,tmp ); break;
-       case 'y': sprintf( tmp,"%d",guiIntfStruct.MovieHeight ); strcat( trbuf,tmp ); break;
-       case 'C': sprintf( tmp,"%s", guiIntfStruct.sh_video? ((sh_video_t *)guiIntfStruct.sh_video)->codec->name : "");
-                 strcat( trbuf,tmp ); break;
-       case 's': if ( guiIntfStruct.Playing == 0 ) strcat( trbuf,"s" ); break;
-       case 'l': if ( guiIntfStruct.Playing == 1 ) strcat( trbuf,"p" ); break;
-       case 'e': if ( guiIntfStruct.Playing == 2 ) strcat( trbuf,"e" ); break;
+       case '3': snprintf( tmp,sizeof( tmp ),"%02d",guiIntfStruct.TimeSec / 3600 );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case '4': snprintf( tmp,sizeof( tmp ),"%02d",( ( guiIntfStruct.TimeSec / 60 ) % 60 ) );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case '5': snprintf( tmp,sizeof( tmp ),"%02d",guiIntfStruct.TimeSec % 60 );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case '8': snprintf( tmp,sizeof( tmp ),"%01d:%02d:%02d",guiIntfStruct.TimeSec / 3600,( guiIntfStruct.TimeSec / 60 ) % 60,guiIntfStruct.TimeSec % 60 ); strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'v': snprintf( tmp,sizeof( tmp ),"%3.2f%%",guiIntfStruct.Volume );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'V': snprintf( tmp,sizeof( tmp ),"%3.1f",guiIntfStruct.Volume );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'b': snprintf( tmp,sizeof( tmp ),"%3.2f%%",guiIntfStruct.Balance );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'B': snprintf( tmp,sizeof( tmp ),"%3.1f",guiIntfStruct.Balance );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'd': snprintf( tmp,sizeof( tmp ),"%d",guiIntfStruct.FrameDrop );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'x': snprintf( tmp,sizeof( tmp ),"%d",guiIntfStruct.MovieWidth );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'y': snprintf( tmp,sizeof( tmp ),"%d",guiIntfStruct.MovieHeight );
+		 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 'C': snprintf( tmp,sizeof( tmp ),"%s", guiIntfStruct.sh_video? ((sh_video_t *)guiIntfStruct.sh_video)->codec->name : "");
+                 strlcat( trbuf,tmp,sizeof( trbuf ) ); break;
+       case 's': if ( guiIntfStruct.Playing == 0 ) strlcat( trbuf,"s",sizeof( trbuf ) ); break;
+       case 'l': if ( guiIntfStruct.Playing == 1 ) strlcat( trbuf,"p",sizeof( trbuf ) ); break;
+       case 'e': if ( guiIntfStruct.Playing == 2 ) strlcat( trbuf,"e",sizeof( trbuf ) ); break;
        case 'a':
-            if ( muted ) { strcat( trbuf,"n" ); break; }
+            if ( muted ) { strlcat( trbuf,"n",sizeof( trbuf ) ); break; }
             switch ( guiIntfStruct.AudioType )
              {
-              case 0: strcat( trbuf,"n" ); break;
-              case 1: strcat( trbuf,"m" ); break;
-              case 2: strcat( trbuf,"t" ); break;
+              case 0: strlcat( trbuf,"n",sizeof( trbuf ) ); break;
+              case 1: strlcat( trbuf,"m",sizeof( trbuf ) ); break;
+              case 2: strlcat( trbuf,"t",sizeof( trbuf ) ); break;
              }
             break;
        case 'T':
            switch ( guiIntfStruct.StreamType )
             {
-             case STREAMTYPE_FILE:   strcat( trbuf,"f" ); break;
+             case STREAMTYPE_FILE:   strlcat( trbuf,"f",sizeof( trbuf ) ); break;
 #ifdef HAVE_VCD
-             case STREAMTYPE_VCD:    strcat( trbuf,"v" ); break;
+             case STREAMTYPE_VCD:    strlcat( trbuf,"v",sizeof( trbuf ) ); break;
 #endif
-             case STREAMTYPE_STREAM: strcat( trbuf,"u" ); break;
+             case STREAMTYPE_STREAM: strlcat( trbuf,"u",sizeof( trbuf ) ); break;
 #ifdef USE_DVDREAD
-             case STREAMTYPE_DVD:    strcat( trbuf,"d" ); break;
+             case STREAMTYPE_DVD:    strlcat( trbuf,"d",sizeof( trbuf ) ); break;
 #endif
-             default:                strcat( trbuf," " ); break;
+             default:                strlcat( trbuf," ",sizeof( trbuf ) ); break;
             }
            break;
-       case '$': strcat( trbuf,"$" ); break;
+       case '$': strlcat( trbuf,"$",sizeof( trbuf ) ); break;
        default: continue;
       }
      c=strlen( trbuf );
diff -Naur MPlayer-1.0pre4/Gui/mplayer/gtk/about.c MPlayer-1.0pre5/Gui/mplayer/gtk/about.c
--- MPlayer-1.0pre4/Gui/mplayer/gtk/about.c	2003-03-17 09:48:26.000000000 +0900
+++ MPlayer-1.0pre5/Gui/mplayer/gtk/about.c	2004-06-15 19:52:36.000000000 +0900
@@ -105,7 +105,6 @@
 	"     * Bertrand Baudet\n" 
 	"     * Derek J Witt\n"
 	"     * Artur Zaprzala\n" 
-	"     * lanzz@lanzz.org\n"
 	"     * Adam Tla/lka\n"
 	"     * Folke Ashberg\n"
 	"     * Kamil-"
diff -Naur MPlayer-1.0pre4/Gui/skin/skin.c MPlayer-1.0pre5/Gui/skin/skin.c
--- MPlayer-1.0pre4/Gui/skin/skin.c	2003-06-04 02:36:25.000000000 +0900
+++ MPlayer-1.0pre5/Gui/skin/skin.c	2004-06-26 01:49:52.000000000 +0900
@@ -116,7 +116,7 @@
 {
  CHECKDEFLIST( "window" );
 
- strcpy( window_name,strlower( in ) );
+ strlcpy( window_name,strlower( in ),sizeof( window_name ) );
  if ( !strncmp( in,"main",4 ) ) { currSection=&skinAppMPlayer->main; currSubItem=&skinAppMPlayer->NumberOfItems; currSubItems=skinAppMPlayer->Items; }
   else if ( !strncmp( in,"sub",3 ) ) currSection=&skinAppMPlayer->sub;
    else if ( !strncmp( in,"playbar",7 ) ) { currSection=&skinAppMPlayer->bar; currSubItem=&skinAppMPlayer->NumberOfBarItems; currSubItems=skinAppMPlayer->barItems; }
@@ -147,7 +147,7 @@
    defList->main.x=x;
    defList->main.y=y;
    defList->main.type=itBase;
-   strcpy( tmp,path ); strcat( tmp,fname );
+   strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, fname, sizeof( tmp )); 
    if ( skinBPRead( tmp,&defList->main.Bitmap ) ) return 1;
    defList->main.width=defList->main.Bitmap.Width;
    defList->main.height=defList->main.Bitmap.Height;
@@ -162,7 +162,7 @@
  if ( !strcmp( window_name,"sub" ) )
   {
    defList->sub.type=itBase;
-   strcpy( tmp,path ); strcat( tmp,fname );
+   strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, fname, sizeof( tmp )); 
    if ( skinBPRead( tmp,&defList->sub.Bitmap ) ) return 1;
    defList->sub.x=x;
    defList->sub.y=y;
@@ -179,7 +179,7 @@
   {
    defList->menuIsPresent=1;
    defList->menuBase.type=itBase;
-   strcpy( tmp,path ); strcat( tmp,fname );
+   strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, fname, sizeof( tmp )); 
    if ( skinBPRead( tmp,&defList->menuBase.Bitmap ) ) return 1;
    defList->menuBase.width=defList->menuBase.Bitmap.Width;
    defList->menuBase.height=defList->menuBase.Bitmap.Height;
@@ -197,7 +197,7 @@
    defList->bar.x=x;
    defList->bar.y=y;
    defList->bar.type=itBase;
-   strcpy( tmp,path ); strcat( tmp,fname );
+   strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, fname, sizeof( tmp )); 
    if ( skinBPRead( tmp,&defList->bar.Bitmap ) ) return 1;
    defList->bar.width=defList->bar.Bitmap.Width;
    defList->bar.height=defList->bar.Bitmap.Height;
@@ -268,7 +268,7 @@
  currSubItems[ *currSubItem ].Bitmap.Image=NULL;
  if ( strcmp( fname,"NULL" ) )
   {
-   strcpy( tmp,path ); strcat( tmp,fname );
+   strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, fname, sizeof( tmp )); 
    if ( skinBPRead( tmp,&currSubItems[ *currSubItem ].Bitmap ) ) return 1;
   }
 
@@ -289,7 +289,7 @@
 
  cutItem( in,fname,',',0 );
  defList->menuSelected.type=itBase;
- strcpy( tmp,path ); strcat( tmp,fname );
+ strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, fname, sizeof( tmp )); 
  mp_dbg( MSGT_GPLAYER,MSGL_DBG2,"\n[skin] selected: %s\n",fname );
  if ( skinBPRead( tmp,&defList->menuSelected.Bitmap ) ) return 1;
  defList->menuSelected.width=defList->menuSelected.Bitmap.Width;
@@ -381,14 +381,14 @@
  item->Bitmap.Image=NULL;
  if ( strcmp( phfname,"NULL" ) )
   {
-   strcpy( tmp,path ); strcat( tmp,phfname );
+   strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, phfname, sizeof( tmp )); 
    if ( skinBPRead( tmp,&item->Bitmap ) ) return 1;
   }
 
  item->Mask.Image=NULL;
  if ( strcmp( pfname,"NULL" ) )
   {
-   strcpy( tmp,path ); strcat( tmp,pfname );
+   strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, pfname, sizeof( tmp )); 
    if ( skinBPRead( tmp,&item->Mask ) ) return 1;
   }
  return 0;
@@ -445,7 +445,7 @@
  item->Bitmap.Image=NULL;
  if ( strcmp( phfname,"NULL" ) )
   {
-   strcpy( tmp,path ); strcat( tmp,phfname );
+   strlcpy(tmp, path, sizeof( tmp )); strlcat(tmp, phfname, sizeof( tmp )); 
    if ( skinBPRead( tmp,&item->Bitmap ) ) return 1;
   }
  return 0;
@@ -655,7 +655,12 @@
 FILE * skinFile;
  XFlush( wsDisplay );
 
 void setname( char * item1, char * item2 )
-{ strcpy( fn,item1 ); strcat( fn,"/" ); strcat( fn,item2 ); strcpy( path,fn ); strcat( path,"/" ); strcat( fn,"/skin" ); }
+{
+  strlcpy(fn, item1, sizeof( fn ));
+  strlcat(fn, "/", sizeof( fn )); strlcat(fn, item2, sizeof( fn ));
+  strlcpy(path, fn, sizeof( path )); strlcat(path, "/", sizeof( path ));
+  strlcat(fn, "/skin", sizeof( fn ));
+}
 
 int skinRead( char * dname )
 {
diff -Naur MPlayer-1.0pre4/Gui/wm/wm.c MPlayer-1.0pre5/Gui/wm/wm.c
--- MPlayer-1.0pre4/Gui/wm/ws.c	2004-06-25 11:19:47.095450056 +0900
+++ MPlayer-1.0pre5/Gui/wm/ws.c	2004-06-25 11:23:47.593888736 +0900
@@ -763,6 +763,7 @@
 #ifdef ENABLE_DPMS
    wsScreenSaverOn( wsDisplay );
 #endif
+   vo_x11_ewmh_fullscreen( 0 ); // removes fullscreen state to be added if wm supports EWMH
   }
   else
    {
@@ -774,6 +775,7 @@
 #ifdef ENABLE_DPMS
     wsScreenSaverOff( wsDisplay );
 #endif
+    vo_x11_ewmh_fullscreen( 1 ); // sends fullscreen state to be added if wm supports EWMH
    }
 
  vo_x11_decoration( wsDisplay,win->WindowID,decoration );
diff -Naur MPlayer-1.0pre4/libvo/x11_common.c MPlayer-1.0pre5/Gui/libvo/x11_common.c
--- MPlayer-1.0pre4/libvo/x11_common.c	2004-06-25 11:24:39.212041584 +0900
+++ MPlayer-1.0pre5/libvo/x11_common.c	2004-06-25 11:31:05.225358640 +0900
@@ -117,6 +117,43 @@
 
 static int vo_x11_get_fs_type(int supported);
 
+/*
+ * Sends the EWMH fullscreen state event.
+ *
+ * action: could be on of 0 -- remove state
+ *                        1 -- add state
+ *                        2 -- toggle
+ */
+void vo_x11_ewmh_fullscreen( int action )
+{
+  if ( vo_fs_type & vo_wm_FULLSCREEN )
+  {
+    XEvent xev;
+
+    /* init X event structure for _NET_WM_FULLSCREEN client msg */
+    xev.xclient.type = ClientMessage;
+    xev.xclient.serial = 0;
+    xev.xclient.send_event = True;
+    xev.xclient.message_type = XInternAtom( mDisplay,
+                                            "_NET_WM_STATE", False );
+    xev.xclient.window = vo_window;
+    xev.xclient.format = 32;
+    xev.xclient.data.l[0] = action;
+    xev.xclient.data.l[1] = XInternAtom( mDisplay,
+                                         "_NET_WM_STATE_FULLSCREEN", False );
+    xev.xclient.data.l[2] = 0;
+    xev.xclient.data.l[3] = 0;
+    xev.xclient.data.l[4] = 0;
+
+    /* finally send that damn thing */
+    if ( !XSendEvent( mDisplay, DefaultRootWindow( mDisplay ), False,
+                     SubstructureRedirectMask | SubstructureNotifyMask, &xev ) )
+    {
+      mp_msg( MSGT_VO,MSGL_ERR, "\nX11: Couldn't send EWMH fullscreen Event!\n" );
+    }
+  }
+}
+	
 void vo_hidecursor ( Display *disp , Window win )
 {
 	Cursor no_ptr;
@@ -1062,11 +1099,15 @@
 
  if ( vo_fs ){
    // fs->win
+   vo_x11_ewmh_fullscreen( 0 ); // removes fullscreen state if wm supports EWMH
+   
    if(vo_dwidth != vo_screenwidth && vo_dheight != vo_screenheight) return;
    vo_fs=VO_FALSE;
    x=vo_old_x; y=vo_old_y; w=vo_old_width; h=vo_old_height;
  } else {
    // win->fs
+   vo_x11_ewmh_fullscreen( 1 ); // sends fullscreen state to be added if wm supports EWMH
+
    if(vo_old_width && 
      (vo_dwidth==vo_screenwidth && vo_dwidth!=vo_old_width) &&
      (vo_dheight==vo_screenheight && vo_dheight!=vo_old_height) ) return;
