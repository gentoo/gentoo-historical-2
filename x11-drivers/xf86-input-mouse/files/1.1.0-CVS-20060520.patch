? 1.1.0-CVS-20060520.patch
Index: ChangeLog
===================================================================
RCS file: /cvs/xorg/driver/xf86-input-mouse/ChangeLog,v
retrieving revision 1.16
retrieving revision 1.18
diff -u -B -r1.16 -r1.18
--- ChangeLog	7 Apr 2006 17:59:54 -0000	1.16
+++ ChangeLog	21 Apr 2006 11:15:23 -0000	1.18
@@ -1,3 +1,18 @@
+2006-04-21  Matthias Hopf  <mhopf@suse.de>
+
+	* man/mouse.man:
+	Fixed default for YAxisMapping.
+	Changed default for ZAxisMapping. Added short explanation.
+	* src/mouse.c: (MouseCommonOptions), (MouseReadInput):
+	Autodetect (one way only) single wheel only for EXPS2.
+	Use singlebit protocol for multiwheel EXPS2 mice.
+
+2006-04-20  Matthias Hopf  <mhopf@suse.de>
+
+	* src/mouse.c: (MousePostEvent):
+	Overhaul of wheel processing. Does work correctly with multibit
+	zaxis events now.
+
 2006-04-06  Adam Jackson  <ajax@freedesktop.org>
 
 	* configure.ac:
Index: man/mouse.man
===================================================================
RCS file: /cvs/xorg/driver/xf86-input-mouse/man/mouse.man,v
retrieving revision 1.11
retrieving revision 1.12
diff -u -B -r1.11 -r1.12
--- man/mouse.man	2 Feb 2006 11:53:50 -0000	1.11
+++ man/mouse.man	21 Apr 2006 11:15:23 -0000	1.12
@@ -138,7 +138,7 @@
 .I N1
 is mapped to the negative Y axis motion and button number
 .I N2
-is mapped to the positive Y axis motion.  Default: "4 5".
+is mapped to the positive Y axis motion.  Default: no mapping.
 .TP 7
 .BI "Option \*qZAxisMapping\*q \*qX\*q"
 .TP 7
@@ -161,7 +161,9 @@
 .I N3
 and
 .IR N4 .
-Default: "4 5 6 7".
+Note that the protocols for mice with one and two wheels can be different
+and the driver may not be able to autodetect it.
+Default: "4 5".
 .TP 7
 .BI "Option \*qButtonMapping\*q \*q" "N1 N2 [...]" \*q
 Specifies how physical mouse buttons are mapped to logical buttons.
Index: src/mouse.c
===================================================================
RCS file: /cvs/xorg/driver/xf86-input-mouse/src/mouse.c,v
retrieving revision 1.27
retrieving revision 1.29
diff -u -B -r1.27 -r1.29
--- src/mouse.c	7 Apr 2006 17:59:54 -0000	1.27
+++ src/mouse.c	21 Apr 2006 11:15:23 -0000	1.29
@@ -543,18 +543,18 @@
 	xfree(s);
     }
 
-    s = xf86SetStrOption(pInfo->options, "ZAxisMapping", "4 5 6 7");
+    s = xf86SetStrOption(pInfo->options, "ZAxisMapping", "4 5");
     if (s) {
 	int b1 = 0, b2 = 0, b3 = 0, b4 = 0;
 	char *msg = NULL;
 
+	pMse->negativeZ = pMse->positiveZ = MSE_NOAXISMAP;
+	pMse->negativeW = pMse->positiveW = MSE_NOAXISMAP;
 	if (!xf86NameCmp(s, "x")) {
 	    pMse->negativeZ = pMse->positiveZ = MSE_MAPTOX;
-	    pMse->negativeW = pMse->positiveW = MSE_MAPTOX;
 	    msg = xstrdup("X axis");
 	} else if (!xf86NameCmp(s, "y")) {
 	    pMse->negativeZ = pMse->positiveZ = MSE_MAPTOY;
-	    pMse->negativeW = pMse->positiveW = MSE_MAPTOY;
 	    msg = xstrdup("Y axis");
 	} else if (sscanf(s, "%d %d %d %d", &b1, &b2, &b3, &b4) >= 2 &&
 		 b1 > 0 && b1 <= MSE_MAXBUTTONS &&
@@ -562,8 +562,8 @@
 	    msg = xstrdup("buttons XX and YY");
 	    if (msg)
 		sprintf(msg, "buttons %d and %d", b1, b2);
-	    pMse->negativeZ = pMse->negativeW = 1 << (b1-1);
-	    pMse->positiveZ = pMse->positiveW = 1 << (b2-1);
+	    pMse->negativeZ = 1 << (b1-1);
+	    pMse->positiveZ = 1 << (b2-1);
 	    if (b3 > 0 && b3 <= MSE_MAXBUTTONS &&
 		b4 > 0 && b4 <= MSE_MAXBUTTONS) {
 		if (msg)
@@ -578,9 +578,6 @@
 	    if (b2 > pMse->buttons) pMse->buttons = b2;
 	    if (b3 > pMse->buttons) pMse->buttons = b3;
 	    if (b4 > pMse->buttons) pMse->buttons = b4;
-	} else {
-	    pMse->negativeZ = pMse->positiveZ = MSE_NOZMAP;
-	    pMse->negativeW = pMse->positiveW = MSE_NOZMAP;
 	}
 	if (msg) {
 	    xf86Msg(X_CONFIG, "%s: ZAxisMapping: %s\n", pInfo->name, msg);
@@ -1506,7 +1503,21 @@
 		      (pBuf[3] & 0x20) >> 1;        /* button 5 */
 	    dx = (pBuf[0] & 0x10) ?    pBuf[1]-256  :  pBuf[1];
 	    dy = (pBuf[0] & 0x20) ?  -(pBuf[2]-256) : -pBuf[2];
-	    dz = (pBuf[3] & 0x08) ? (pBuf[3] & 0x0f) - 16 : (pBuf[3] & 0x0f);
+	    if (pMse->negativeW != MSE_NOAXISMAP) {
+		switch (pBuf[3] & 0x0f) {
+		case 0x00:          break;
+		case 0x01: dz =  1; break;
+		case 0x02: dw =  1; break;
+		case 0x0e: dw = -1; break;
+		case 0x0f: dz = -1; break;
+		default:
+		    xf86Msg(X_INFO,
+			    "Mouse autoprobe: Disabling secondary wheel\n");
+		    pMse->negativeW = pMse->positiveW = MSE_NOAXISMAP;
+		}
+	    }
+	    if (pMse->negativeW == MSE_NOAXISMAP)
+	        dz = (pBuf[3]&0x08) ? (pBuf[3]&0x0f) - 16 : (pBuf[3]&0x0f);
 	    break;
 
 	case PROT_MMPS2:	/* MouseMan+ PS/2 */
@@ -2332,7 +2343,7 @@
 	       int dx, int dy, int dz, int dw)
 {
     MouseDevPtr pMse;
-    int zbutton = 0;
+    int zbutton = 0, wbutton = 0, zbuttoncount = 0, wbuttoncount = 0;
     int i, b, buttons = 0;
 
     pMse = pInfo->private;
@@ -2353,6 +2364,7 @@
     /* XXX Could this go in the conversion_proc? */
     switch (pMse->negativeZ) {
     case MSE_NOZMAP:	/* do nothing */
+	dz = 0;
 	break;
     case MSE_MAPTOX:
 	if (dz != 0) {
@@ -2367,20 +2379,46 @@
 	}
 	break;
     default:	/* buttons */
-	buttons &= ~(pMse->negativeZ | pMse->positiveZ
-		   | pMse->negativeW | pMse->positiveW);
-	if (dw < 0 || dz < -1)
-	    zbutton = pMse->negativeW;
-	else if (dz < 0)
+	buttons &= ~(pMse->negativeZ | pMse->positiveZ);
+	if (dz < 0) {
 	    zbutton = pMse->negativeZ;
-	else if (dw > 0 || dz > 1)
-	    zbutton = pMse->positiveW;
-	else if (dz > 0)
+	    zbuttoncount = -dz;
+	} else if (dz > 0) {
 	    zbutton = pMse->positiveZ;
-	buttons |= zbutton;
+	    zbuttoncount = dz;
+	}
 	dz = 0;
 	break;
     }
+    switch (pMse->negativeW) {
+    case MSE_NOZMAP:	/* do nothing */
+	dw = 0;
+	break;
+    case MSE_MAPTOX:
+	if (dw != 0) {
+	    dx = dw;
+	    dw = 0;
+	}
+	break;
+    case MSE_MAPTOY:
+	if (dw != 0) {
+	    dy = dw;
+	    dw = 0;
+	}
+	break;
+    default:	/* buttons */
+	buttons &= ~(pMse->negativeW | pMse->positiveW);
+	if (dw < 0) {
+	    wbutton = pMse->negativeW;
+	    wbuttoncount = -dw;
+	} else if (dw > 0) {
+	    wbutton = pMse->positiveW;
+	    wbuttoncount = dw;
+	}
+	dw = 0;
+	break;
+    }
+
 
     /* Apply angle offset */
     if (pMse->angleOffset != 0) {
@@ -2397,16 +2435,19 @@
 	dx = dy;
 	dy = tmp;
     }
-    MouseDoPostEvent(pInfo, buttons, dx, dy);
 
-    /*
-     * If dz has been mapped to a button `down' event, we need to cook up
-     * a corresponding button `up' event.
-     */
-    if (zbutton) {
-	buttons &= ~zbutton;
-	MouseDoPostEvent(pInfo, buttons, 0, 0);
-    }
+    /* If mouse wheel movement has to be mapped on a button, we need to
+     * loop for button press and release events. */
+    do {
+        MouseDoPostEvent(pInfo, buttons | zbutton | wbutton, dx, dy);
+	dx = dy = 0;
+	if (zbutton || wbutton)
+	    MouseDoPostEvent(pInfo, buttons, 0, 0);
+	if (--zbuttoncount <= 0)
+	    zbutton = 0;
+	if (--wbuttoncount <= 0)
+	    wbutton = 0;
+    } while (zbutton || wbutton);
 
     pMse->lastButtons = truebuttons;
 }
