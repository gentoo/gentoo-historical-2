From the fix for https://bugs.freedesktop.org/show_bug.cgi?id=12844 - "Display is washed out, too bright. No adjustment will correct for over bright display"
Affecting mostly radeon IGP chips, such as the Radeon XPRESS
Fixed by setting the TV DAC up correctly, etc

diff --git a/src/radeon_output.c b/src/radeon_output.c
index 599a89c..54c27cd 100644
--- a/src/radeon_output.c
+++ b/src/radeon_output.c
@@ -1039,11 +1039,12 @@ static void RADEONInitDACRegisters(xf86OutputPtr output, RADEONSavePtr save,
     save->dac_macro_cntl = info->SavedReg.dac_macro_cntl;
 }
 
-/* XXX: fix me */
 static void
-RADEONInitTvDacCntl(ScrnInfoPtr pScrn, RADEONSavePtr save)
+RADEONInitTvDacCntl(xf86OutputPtr output, RADEONSavePtr save)
 {
+    ScrnInfoPtr pScrn = output->scrn;
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
+    RADEONOutputPrivatePtr radeon_output = output->driver_private;
 
     if (info->ChipFamily == CHIP_FAMILY_R420 ||
 	info->ChipFamily == CHIP_FAMILY_RV410) {
@@ -1064,10 +1065,11 @@ RADEONInitTvDacCntl(ScrnInfoPtr pScrn, RADEONSavePtr save)
 			       RADEON_TV_DAC_GDACPD |
 			       RADEON_TV_DAC_GDACPD);
     }
-    /* FIXME: doesn't make sense, this just replaces the previous value... */
+
     save->tv_dac_cntl |= (RADEON_TV_DAC_NBLANK |
-			 RADEON_TV_DAC_NHOLD |
-			  RADEON_TV_DAC_STD_PS2);
+			  RADEON_TV_DAC_NHOLD |
+			  RADEON_TV_DAC_STD_PS2 |
+			  radeon_output->tv_dac_adj);
 
 }
 
@@ -1078,7 +1080,7 @@ static void RADEONInitDAC2Registers(xf86OutputPtr output, RADEONSavePtr save,
     RADEONInfoPtr  info       = RADEONPTR(pScrn);
 
     /*0x0028023;*/
-    RADEONInitTvDacCntl(pScrn, save);
+    RADEONInitTvDacCntl(output, save);
 
     if (IS_R300_VARIANT)
 	save->gpiopad_a = info->SavedReg.gpiopad_a | 1;
@@ -1671,9 +1673,13 @@ radeon_detect(xf86OutputPtr output)
 	   * so we can get something on the screen
 	   */
 	  if (((radeon_output->type == OUTPUT_VGA || radeon_output->type == OUTPUT_DVI) &&
-	       radeon_output->DACType == DAC_TVDAC) ||
-	      (info->IsIGP && radeon_output->type == OUTPUT_DVI))
+	       radeon_output->DACType == DAC_TVDAC)) {
+	      radeon_output->MonType = MT_CRT;
 	      return XF86OutputStatusUnknown;
+	  } else if  (info->IsIGP && radeon_output->type == OUTPUT_DVI) {
+	      radeon_output->MonType = MT_DFP; /* MT_LCD ??? */
+	      return XF86OutputStatusUnknown;
+	  }
       }
 
       if (connected)
@@ -2623,6 +2629,7 @@ void RADEONInitConnector(xf86OutputPtr output)
     if (radeon_output->type == OUTPUT_STV ||
 	radeon_output->type == OUTPUT_CTV) {
 	RADEONGetTVInfo(output);
+	RADEONGetTVDacAdjInfo(output);
     }
 
     if (radeon_output->DACType == DAC_TVDAC) {
diff --git a/src/radeon_tv.c b/src/radeon_tv.c
index 3a26a0a..2a8873c 100644
--- a/src/radeon_tv.c
+++ b/src/radeon_tv.c
@@ -434,7 +434,7 @@ void RADEONInitTVRegisters(xf86OutputPtr output, RADEONSavePtr save,
 
     save->tv_vscaler_cntl2 = ((save->tv_vscaler_cntl2 & 0x00fffff0)
 			      | (0x10 << 24)
-			      | RADEON_DITHER_MODE 
+			      | RADEON_DITHER_MODE
 			      | RADEON_Y_OUTPUT_DITHER_EN
 			      | RADEON_UV_OUTPUT_DITHER_EN
 			      | RADEON_UV_TO_BUF_DITHER_EN);
@@ -444,10 +444,12 @@ void RADEONInitTVRegisters(xf86OutputPtr output, RADEONSavePtr save,
     tmp = (tmp << RADEON_UV_OUTPUT_POST_SCALE_SHIFT) | 0x000b0000;
     save->tv_timing_cntl = tmp;
 
-    save->tv_dac_cntl = RADEON_TV_DAC_NBLANK | RADEON_TV_DAC_NHOLD | (8 << 16) | (6 << 20);
+    save->tv_dac_cntl = (RADEON_TV_DAC_NBLANK |
+			 RADEON_TV_DAC_NHOLD |
+			 radeon_output->tv_dac_adj /*(8 << 16) | (6 << 20)*/);
 
     if (radeon_output->tvStd == TV_STD_NTSC ||
-        radeon_output->tvStd == TV_STD_NTSC_J)
+	radeon_output->tvStd == TV_STD_NTSC_J)
 	save->tv_dac_cntl |= RADEON_TV_DAC_STD_NTSC;
     else
 	save->tv_dac_cntl |= RADEON_TV_DAC_STD_PAL;
