This patch includes Christian Heim's <christian.th.heim@gmx.de> patch from
http://bugs.gentoo.org/show_bug.cgi?id=80318

diff -Naur eix-0.2.0_alpha.orig/configure.in eix-0.2.0_alpha/configure.in
--- eix-0.2.0_alpha.orig/configure.in	2005-02-02 16:40:55.045430120 +0100
+++ eix-0.2.0_alpha/configure.in	2005-02-02 16:41:12.715743824 +0100
@@ -1,4 +1,4 @@
-AC_INIT(eix, 0.1.4)
+AC_INIT(eix, 0.2.0_alpha)
 
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE()
diff -Naur eix-0.2.0_alpha.orig/src/portagedb.cc eix-0.2.0_alpha/src/portagedb.cc
--- eix-0.2.0_alpha.orig/src/portagedb.cc	2005-02-02 16:40:55.037431336 +0100
+++ eix-0.2.0_alpha/src/portagedb.cc	2005-02-02 16:51:23.240929888 +0100
@@ -119,11 +119,11 @@
 {
 	// get portdir
 	VarsReader vr("/etc/make.conf");
-	portdir = vr["portdir"];
+	portdir = vr["PORTDIR"];
 	if( portdir.size() == 0 )
 		portdir = "/usr/portage/";
 	else
-		/* dont neet to do this because "/usr/" is the same as "/usr//"
+		/* dont need to do this because "/usr/" is the same as "/usr//"
 		 * else if( portdir[portdir.size() - 1] != '/' ) */
 		portdir.append("/");
 
@@ -240,12 +240,15 @@
 	}
 }
 
+#if 0
 // filter function for scandir64 called in portagedb::readcats
 int portagedb::readcats_selector (const struct dirent64* dent)
 {
 	if( dent->d_name[0]!='.' && strchr(dent->d_name, '-')!=0 ) return 1;
 	return 0;
 }
+#endif
+
 // filter function for scandir64 called in portagedb::readcachedpkgs
 int portagedb::readcpkgs_selector (const struct dirent64* dent)
 {
@@ -419,97 +422,111 @@
 	free(dir_entry);
 }
 
-// overlays
+
+/** Read overlay into portagedb::packages.
+ * FIXME: This thing needs to be cleaned. (It's disgusting, the big while's should be somehow put
+ * into functions .. this is soo baaaah!) */
 void portagedb::readoverlay(string directory) throw(exBasic)
 {
-	DIR *dir_base, *dir_category;
-	struct dirent64** dir_package_entries;
-	vector<string> listdir_base, listdir_category;
-	string path_base, path_category, path_package;
-	string category, package_dirname;
-	string ebuild_filename;
-
-	// read overlay base directory
-	path_base = directory;
-	if ( (dir_base = opendir(path_base.c_str())) == NULL)
-		throw exBasic("Can't open " + directory );
+	/* Pointers to overlay, category and package DIRectory */
+	DIR *dir_overlay, *dir_category, *dir_package;
+
+	char *current_ebuild_name = NULL; /* Pointer to ebuildname .. DON'T FREE THIS, it's static */
 
-	dir_entry_list(dir_base, listdir_base, true);
-	//	cout << "Number of categories in overlay: " << listdir_base.size() << endl;
-	// 	for(size_t i=0; i<listdir_base.size(); i++)
-	// 	{
-	// 		cout << "  " << listdir_base[i] << endl;
-	// 	}
+	struct dirent* category_entry; /* current category dirent */
+	struct dirent* package_entry;  /* current package dirent */
+	string current_category_path,  /* Path to category */
+		   current_package_path,   /* Path to package */
+		   current_package,        /* Name of current package */
+		   current_category;       /* Name of current category */
 
-	// read category directories
-	for(size_t i=0; i<listdir_base.size();i++)
+	/* open base-directory of overlay */
+	if( (dir_overlay = opendir(directory.c_str())) == NULL)
+		throw exBasic("Can't open " + directory );
+
+	/* cycle through categories in overlay */
+	while( (category_entry = readdir(dir_overlay)) != NULL )
 	{
-		path_category = path_base + listdir_base[i];
-		category = listdir_base[i];
+		if(category_entry->d_name[0] == '.')
+			continue;
 
-		if ( (dir_category = opendir(path_category.c_str())) == NULL )
-		{
+		current_category = category_entry->d_name;
+
+		if( !(current_category.find('-')))
 			continue;
-		}
 
-		listdir_category.clear();
-		dir_entry_list(dir_category, listdir_category, false);
-		closedir( dir_category ); // was a 6 MB leak !
+		current_category_path = directory + current_category;
 
-		// read package directories
-		for(unsigned int j=0;j<listdir_category.size();j++)
+		/* Open dir_category */
+		if( (dir_category = opendir( current_category_path.c_str() ))  == NULL )
+			continue;
+
+		/* Cycle through package-directories in this category */
+		while( (package_entry = readdir(dir_category)) != NULL )
 		{
-			path_package = path_category + "/" + listdir_category[j];
-			package_dirname = listdir_category[j];
+			if(package_entry->d_name[0] == '.') /* We don't want dot-files */
+				continue;
 
-			package p;
-			int versioncounter=0;
+			current_package = package_entry->d_name;
+			current_package_path = current_category_path + "/" + current_package + "/";
 
-			//cout << " - Overlay package: " << package_dirname << endl;
-			int numdirs = scandir64( path_package.c_str(), &dir_package_entries, &dirlist_select_all, alphasort64 );
-			for( int k=0; k<numdirs; k++ )
-			{
-				char* fntemp = dir_package_entries[k]->d_name;
-				if( strstr( fntemp, ".ebuild" ) != 0 )
-				{
-					// --> read the ebuild
-					ebuild_filename = path_package + "/" + fntemp;
-					VarsReader ebuild( ebuild_filename.c_str() );
+			/* Open dir_package */
+			if( (dir_package = opendir( current_package_path.c_str() ))  == NULL )
+				continue;
 
-					// now we don't need fntemp anymore, so we can cut off the .ebuild
-					fntemp[strlen(fntemp)-7]=0;
+			bool have_onetime_info = false;
+			package p;
 
-					// only copy ebuild infos once
-					if( ++versioncounter == 1 )
-					{
-						// 						cout << "overlay ebuild: " << package_dirname << endl;
-						p.name		 = package_dirname;
-						p.rootcat  = category.substr(0,category.find("-"));
-						p.subcat   = category.substr(category.find("-")+1);
-						p.homepage = ebuild["HOMEPAGE"];
-						p.licenses = ebuild["LICENSE"];
-						p.desc		 = ebuild["DESCRIPTION"];
-					}
+			/* Cycle through files in package-directory */
+			while( (package_entry = readdir(dir_package)) != NULL ) /* {{{ */
+			{
+				/* Check if this is a ebuild 
+				 * TODO: Perhaps we should try something else .. check use rindex for '.' 
+				 * and look if the position is ok for a ebuild .. if not break.
+				 * Then check if the return from rindex points to ".ebuild\n". */
+				if( strstr(package_entry->d_name, ".ebuild") == 0 )
+					continue;
+
+				current_ebuild_name = package_entry->d_name;
+
+				/* read the ebuild */
+				VarsReader ebuild( (current_package_path + current_ebuild_name).c_str() );
+
+				/* now we don't need the filename anymore, so we can cut off the .ebuild
+				 *  Could we use package_entry->d_reclen insteed of strlen? man 3 readdir whines
+				 *  about being not portable if we use this d_reclen .. because it's not in posix or
+				 *  so.  Do we care? */
+				current_ebuild_name[strlen(current_ebuild_name) - 7] = '\0';
 
-					// add any version of the ebuild
-					char* ver = globals_local.ExplodePkgFileName( fntemp, globals_local.xplodeVersion );
-					versionEx ve(ver);
-					ve.stability = p.getStability( arch.c_str(), (char *)ebuild["KEYWORDS"].c_str() );
-					p.addVersion( ve );
-					free( ver );
+				/* only copy ebuild infos once */
+				if( !(have_onetime_info) )
+				{
+					p.name     = current_package;
+					p.rootcat  = current_category.substr(0,current_category.find("-"));
+					p.subcat   = current_category.substr(current_category.find("-")+1);
+					p.homepage = ebuild["HOMEPAGE"];
+					p.licenses = ebuild["LICENSE"];
+					p.desc     = ebuild["DESCRIPTION"];
 
+					have_onetime_info = true;
 				}
-				free( dir_package_entries[k] );
-			}
-			if(numdirs) free(dir_package_entries);
 
-			// debug
-			/* cout << p.rootcat << "-" << p.subcat << "/" << p.name << "\n\tversions: ";
-			   for(list<versionEx>::iterator i=p.versions.begin(); i!=p.versions.end(); i++) cout << (*i).full << " ";
-			   cout << endl;*/
+				// add any version of the ebuild
+				char* ver = globals_local.ExplodePkgFileName( current_ebuild_name, globals_local.xplodeVersion );
+				versionEx ve(ver);
+				ve.stability = p.getStability( arch.c_str(), (char *)ebuild["KEYWORDS"].c_str() );
+				p.addVersion( ve );
+				free( ver );
+			} /* }}} */
+
+#if 0
+			cout << p.rootcat << "-" << p.subcat << "/" << p.name << "\n\tversions: ";
+			for(list<versionEx>::iterator i=p.versions.begin(); i!=p.versions.end(); i++) cout << (*i).full << " ";
+			cout << endl;
+#endif
 
-			// merge package with portagedb::packages
-			if( versioncounter > 0 )
+			/* merge package with portagedb::packages */
+			if(have_onetime_info)
 			{
 				bool packageexists=false;
 				vector<pcat>::iterator it = find( categories.begin(), categories.end(), p.rootcat );
@@ -534,16 +551,12 @@
 					packages.push_back(p);
 					(*it).package_indices.push_back(packages.size()-1);
 				}
-
 			}
-
-			// read the next package
+			closedir(dir_package);
 		}
-
-		// read the next category
+		closedir(dir_category);
 	}
-
-	closedir(dir_base);
+	closedir(dir_overlay);
 }
 
 // Full db update
@@ -604,7 +617,7 @@
  * @param db_query DBQuery with search-pattern et cetera. */
 void portagedb::DBSelectEntry( FILE *is, DBQuery &db_query) throw(exBasic)
 {
-	bool name_no_match;
+	bool name_no_match = false;
 	unsigned short numVersions = 0;
 	long next_pkg;
 	package *p = &(db_query.matching_packages[db_query.matches]);
diff -Naur eix-0.2.0_alpha.orig/src/version.cc eix-0.2.0_alpha/src/version.cc
--- eix-0.2.0_alpha.orig/src/version.cc	2005-02-02 16:40:55.038431184 +0100
+++ eix-0.2.0_alpha/src/version.cc	2005-02-02 16:51:50.049854312 +0100
@@ -61,7 +61,7 @@
 	else
 	{
 		primary = full;
-		cerr << "Error in versions.cc: regexec(\"" << full << "\") failed. can't determine primary version." << endl;
+		cerr << "Error in version.cc: regexec(\"" << full << "\") failed. can't determine primary version." << endl;
 	}
 
 	// try to split primary version
@@ -86,7 +86,7 @@
 		gr+=2;
 		gentoorelease=strtol(gr,NULL,10);
 		if( gentoorelease == 0 ) {
-			cerr << "Error in versions.cc: invalid gentoo release number in \"" << full << "\"" << endl;
+			cerr << "Error in version.cc: invalid gentoo release number in \"" << full << "\"" << endl;
 		}
 	}
 
