# Copyright 1999-2006 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2
# $Id: oodict.eselect-20060601,v 1.1 2006/06/02 13:28:52 kevquinn Exp $

DESCRIPTION="Manages configuration of dictionaries for OpenOffice.Org."
MAINTAINER="kevquinn@gentoo.org"
SVN_DATE='$Date: 2006/06/02 13:28:52 $'
VERSION=$(svn_date_to_version "${SVN_DATE}" )

# Supports myspell(hunspell) dictionaries; designed to be extensible to
# manage other types of dictionaries should they become applicable
# to OpenOffice.org.

OOO_DICTBASE="/usr/lib/openoffice/share/dict/ooo"
OOO_DICTLIST="dictionary.lst"

MYSPELL_BASE="/usr/share/myspell"

# set array "fields" to the elements of $1, separated by $2.
# This saves having to muck about with IFS all over the place.
oodict_set_fields() {
	local old_IFS
	old_IFS="${IFS}"
	IFS=$2
	fields=($1)
	IFS="${old_IFS}"
}

# dictionary names are <class>-<lang>
oodict_get_lang() {
	local fields
	oodict_set_fields "${P}" "-"
	echo ${fields[1]}
}

# return suffixes for dictionary type; spelling dictionary,
# hyphenation dictionary and thesaurus.
oodict_get_myspell_suffixes() {
	case $1 in
		DICT) echo ".aff .dic" ;;
		HYPH) echo ".dic" ;;
		THES) echo ".dat .idx" ;;
	esac
}

# display a heading (indented 4 spaces) and a wrapped list of
# language codes (indented 6 spaces)
oodict_display_langs() {
	local count lang
	printf "    $1:\n"
	shift
	if [[ $1 == "" ]]; then
		printf "      (none)\n"
	else
		count=0
		for lang in $*; do
			[[ ${count} == 0 ]] && printf "     "
			printf " %s" ${lang}
			((count = count+1))
			[[ ${count} == 22 ]] && printf "\n" && count=0
		done
		[[ ${count} == 0 ]] || printf "\n"
	fi
}

# Format of dictionary.lst files (from OOo standard
# dictionary.lst file):
#
# List of All Dictionaries to be Loaded by OpenOffice
# ---------------------------------------------------
# Each Entry in the list have the following space delimited fields
#
# Field 0: Entry Type "DICT" - spellchecking dictionary
#                     "HYPH" - hyphenation dictionary
#                     "THES" - thesaurus files
#
# Field 1: Language code from Locale "en" or "de" or "pt" ...
#
# Field 2: Country Code from Locale "US" or "GB" or "PT"
#
# Field 3: Root name of file(s) "en_US" or "hyph_de" or "th_en_US"
#          (do not add extensions to the name)

# Format of MYSPELL_[SPELLING|HYPHENATION|THESAURUS]_DICTIONARIES:
#
# Field 0: Language code
# Field 1: Country code
# Field 2: Root name of dictionary files
# Field 3: Description
# Field 4: Archive filename
#
# This format is from the available.lst, hyphavail.lst and
# thesavail.lst files on the openoffice.org repository.




### show action

## {{{ show stuff
describe_show() {
	echo "Show which dictionaries are configured for use with OpenOffice.org."
}

do_show() {
	local lang sources suffix suffixes
	[[ -f ${OOO_DICTBASE}/${OOO_DICTLIST} ]] || return
	lang=""
	myspell_sources=""
	unknown_sources=""
	listn=1
	write_list_start "OpenOffice.org configured dictionaries"
	while read entry; do
		fields=(${entry})
		[[ ${fields[0]:0:1} == "#" ]] && continue
		lang=${fields[1]}
		for suffix in $(oodict_get_myspell_suffixes ${fields[0]}); do
			if [[ -h ${OOO_DICTBASE}/${fields[3]}${suffix} ]]; then
				src=$(canonicalise ${OOO_DICTBASE}/${fields[3]}${suffix})
				if [[ ${src/${MYSPELL_BASE}} != ${src} ]]; then
					has ${lang} ${myspell_sources} ||
						myspell_sources="${myspell_sources} ${lang}"
				else
					write_warning_msg "Unrecognised link to ${src} ignored\n"
				fi
			else
				write_warning_msg "${OOO_DICTBASE}/${fields[3]}${suffix} is not a softlink, ignored\n"
			fi
		done
	done <<-EOF
		$(sort --key=2 ${OOO_DICTBASE}/${OOO_DICTLIST})
	EOF
	write_numbered_list_entry 1 "myspell"
	oodict_display_langs "Configured language codes" ${myspell_sources}
}
## }}}


### list action

## {{{ list stuff
describe_list() {
	echo "List the dictionaries that can be configured for use with OpenOffice."
}

do_list() {
	local known_langs
	write_list_start "Installed dictionary sources:"
	write_numbered_list_entry 1 "myspell"
	known_langs=""
	for dict in ${MYSPELL_BASE}/${OOO_DICTLIST}.*; do
		known_langs="${known_langs} ${dict/${MYSPELL_BASE}\/${OOO_DICTLIST}.}"
	done
	oodict_display_langs "Installed language codes" ${known_langs}
}
## }}}


### unset action

## {{{ unset stuff
describe_unset() {
	echo "Unconfigure a dictionary from use with OpenOffice.org."
}

describe_unset_parameters() {
	echo "<dictionary>"
}

describe_unset_options() {
	echo "dictionary: <class>-<lang> e.g. myspell-en"
}

do_unset() {
	# Check OOo dictionary area exists
	[[ -d ${OOO_DICTBASE} ]] || return
	local dict dlang dtype suffix filen dictlst entry fields
	dict=$1
	dlang=${dict/*-}
	dtype=${dict/-*}
	dictlst="${OOO_DICTLIST}.${dlang}"
	case ${dtype} in
	myspell)
		# Remove softlinks and entries in dictionary.lst - uses
		# dictionary.<lang>.lst from /usr/share/myspell
		if [[ -f ${MYSPELL_BASE}/${dictlst} ]]; then
			while read entry; do
				fields=(${entry})
				[[ ${fields[0]:0:1} == "#" ]] && continue
				[[ ${fields[3]} == "" ]] && continue
				# Remove entry from dictionary.lst
				sed -i -e "/^${fields[0]} ${fields[1]} ${fields[2]} ${fields[3]}$/ { d }" \
					${OOO_DICTBASE}/${OOO_DICTLIST} ||
						die "Could not edit ${OOO_DICTBASE}/${OOO_DICTLIST}"
				# See if any other entries in dictionary.lst match the current
				# dictionary type and filename
				grep "^${fields[0]} .* ${fields[3]}$" ${OOO_DICTBASE}/${OOO_DICTLIST} \
					2>&1 > /dev/null && continue
				# If no other entries match, remove relevant symlinks
				for suffix in $(oodict_get_myspell_suffixes ${fields[0]}); do
					filen="${fields[3]}${suffix}"
					[[ -f ${OOO_DICTBASE}/${filen} ]] &&
					if [[ -h ${OOO_DICTBASE}/${filen} ]]; then
						rm -f ${OOO_DICTBASE}/${filen} ||
							die "Failed t remove ${OOO_DICTBASE}/${filen}"
					else
						write_warning_msg "File ${OOO_DICTBASE}/${filen} is not a softlink so left untouched"
					fi
				done
			done < ${MYSPELL_BASE}/${dictlst}
		else
			write_warning_msg "Source ${dict} is not installed; nothing changed"
		fi
		;;
	*)
		die "Unknown dictionary type ${dtype}"
		;;
	esac
}
## }}}

### set action

## {{{ set stuff
describe_set() {
	echo "Configure a dictionary for use with OpenOffice.org."
}

describe_set_parameters() {
	echo "<dictionary>"
}

describe_set_options() {
	echo "dictionary: <class>-<lang> e.g. myspell-en"
}

do_set() {
	local dict dlang dtype filen dictlst entry fields suffix
	dict=$1
	dlang=${dict/*-}
	dtype=${dict/-*}
	dictlst="${OOO_DICTLIST}.${dlang}"
	case ${dtype} in
	myspell)
		# Clear out any existing entry
		do_unset ${dict}
		# Ensure OOo dictionary area exists
		[[ -d ${OOO_DICTBASE} ]] || mkdir -p ${OOO_DICTBASE}
		# Set new entries & links
		[[ -f ${MYSPELL_BASE}/${dictlst} ]] ||
			die "Dictionary $1 not found in ${MYSPELL_BASE}"
		[[ -f ${OOO_DICTBASE}/${OOO_DICTLIST} ]] ||
			touch ${OOO_DICTBASE}/${OOO_DICTLIST} ||
				die "Unable to create ${OOO_DICTBASE}/${OOO_DICTLIST}"
		while read entry; do
			fields=(${entry})
			[[ ${fields[0]:0:1} == "#" ]] && continue
			grep "^${fields[0]} ${fields[1]} ${fields[2]} " \
				${OOO_DICTBASE}/${OOO_DICTLIST} > /dev/null 2>&1 ||
					echo "${entry}" >> ${OOO_DICTBASE}/${OOO_DICTLIST}
			for suffix in $(oodict_get_myspell_suffixes ${fields[0]}); do
				filen="${fields[3]}${suffix}"
				if [[ -h ${OOO_DICTBASE}/${filen} ]]; then
					rm -f ${OOO_DICTBASE}/${filen} ||
						die "Failed to remove ${OOO_DICTBASE}/${filen}"
				fi
				if [[ ! -f ${OOO_DICTBASE}/${filen} ]]; then
					ln -s ${MYSPELL_BASE}/${filen} ${OOO_DICTBASE}/${filen} ||
						die "Failed to create symlink from ${MYSPELL_BASE}/${filen} to ${OOO_DICTBASE}/${filen}"
				else
					write_warning_msg "File ${OOO_DICTBASE}/${filen} is not a softlink so left untouched"
				fi
			done
		done < ${MYSPELL_BASE}/${dictlst}
		;;
	*)
		die "Unknown dictionary type $1"
		;;
	esac
}
## }}}


### update action

## {{{ update stuff
describe_update() {
	echo "(Re)build OpenOffice.org dictionary configuration."
}

describe_update_parameters() {
	echo "[<class>]"
}

describe_update_options() {
	echo "class: type of dictionary (e.g. myspell) - omit to update everything"
}

do_update() {
	local dlang dtype dictlst dtypes
	dtypes=$1
	[[ -z ${dtypes} ]] && dtypes="myspell"
	for dtype in ${dtypes}; do
		case ${dtype} in
		myspell)
			for dictlst in ${MYSPELL_BASE}/${OOO_DICTLIST}.*; do
				dlang=${dictlst/*.lst.}
				do_set ${dtype}-${dlang}
			done
			;;
		*)
			die "Unknown dictionary type $1"
			;;
		esac
	done
}
## }}}

# vim: ts=4 sw=4 noet fdm=marker
