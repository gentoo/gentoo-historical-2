#! /usr/bin/python
#
# Copyright 2002 Gentoo Technologies, Inc
# Distributed under the terms of the GNU General Public License v2.0
# Author Karl Trygve Kalleberg <karltk@gentoo.org>
#
# About:
# lintool checks if a set of ebuilds conforms to the ebuild style guide.
# This is not (yet) an exhaustive test, so your ebuild might be broken even 
# if lintool thinks it's okay.
#
# Usage: lintool /usr/portage/*/*/*.ebuild
# Options: 
#  --no-summary     : Do not show total summary
#  --show-separate  : Show short summary of tests for each ebuild checked
#  --show-details   : Show full details of tests for each ebuild checked
#
# TODO
#
# - Make HTMLFormatter
#
#

import sys
import re
import getopt

class TextFormatter:
  def section(self, s):
    print "\n" + "-"*79
    print " " + s + "\n"
  def bullet(self, s):
    print "* " + s
  def sub(self, s):
    print "- " + s
  def subwarn(self, s):
    print "- (W) " + s
  def suberr(self, s):
    print "- (E) " + s
  def subsub(self, s):
    print " |" + s
  def subsubwarn(self, s):
    print " (W) |" + s
  def subsuberr(self, s):
    print " (E) |" + s
  def div(self, left, right):
    l = len(left)
    r = len(right)
    print left + " " * (79-l-r) + right

class Test:
  def __init__(self, formatter):
    self.formatter = formatter
    self.errors = []
    self.warnings = []
  def reset(self):
    self.errors = []
    self.warnings = []
  def hasWarnings(self):
    return len(self.warnings)
  def hasErrors(self):
    return len(self.errors)
  def getDesc(self):
    return self.desc
  def getStatus(self):
    if self.hasErrors():
      return "failed"
    else:
      return "passed"

class TestSpaces(Test):
  def __init__(self, formatter):
    Test.__init__(self, formatter)
    self.desc = "Testing for illegal space characters, weird backslash formatting"
    self.re_spaces = re.compile("^([ ][ ]*)([a-zA-Z\.].*)")
    self.re_backslash = re.compile("([^#]*\S)((\s\s+|\t))\\\\")
    self.spaces = []
    self.backslashes = []
    
  def checkLine(self, s):
    k = self.re_spaces.match(s)
    if k:
      spcs = k.groups()[0]
      rest = k.groups()[1]
      self.spaces.append(spcs.replace(" ", "%") + rest)
    else:
      k = self.re_backslash.match(s)
      if k:
        head = k.group(1)
        spcs = k.group(2)
        tail = "\\"
        self.backslashes.append(head + len(spcs) * "%" + tail)

  def hasErrors(self):
    return 0
  def hasWarning(self):
    return len(self.spaces) + len(self.backslashes)
  
  def report(self):
    if len(self.spaces):
      self.formatter.subwarn("Has illegal space characters (marked by %):")
      for i in self.spaces:
        self.formatter.subsub(i)
    if len(self.backslashes):
      self.formatter.subwarn("Has illegal white space (marked by %), only one space character allowed:")
      for i in self.backslashes:
        self.formatter.subsub(i)

class TestHeaders(Test):

  def __init__(self, formatter):
    Test.__init__(self,formatter)
    self.desc = "Testing for malformed headers"
    self.re = [ (1, # append result of regex match
                 re.compile("^(# Copyright 1999-(2000|2001).*)"),
                 "Suspect copyright year"), 
                (1,
                 re.compile("^(# /home.*)"),
                 "Suspect path in header"),
                (0, # don't append result of regex match
                 re.compile("^(# Author.*)"),
                 "Use of Author field in the header is deprecated. Put name in ChangeLog"),
                (0,
                 re.compile("^(# Maintainer.*)"),
                 "Use of Maintainer field in the header is deprecated. Put name in ChangeLog"),
                (1,
                 re.compile("^(# /space.*)"),
                 "Suspect path in header")]

  def checkLine(self, s):
    for i in self.re:
      k = i[1].match(s)
      if k and i[0]:
        self.warnings.append(i[2] + ": " + k.groups()[0] )
      elif k and not i[0]:
        self.warnings.append(i[2])
        
  def report(self):
    if len(self.warnings):
      self.formatter.subwarn("Has illegal or suspect headers:")
      for i in self.warnings:
        self.formatter.subsub(i)

class TestTry(Test):

  def __init__(self,formatter):
    Test.__init__(self,formatter)
    self.desc = "Testing for occurence of deprecated try"
    self.re = [ re.compile("^([ \t][ \t]*try.*)"),
                re.compile("(.*=.* try .*)") ]

  def checkLine(self, s):
    for i in self.re:
      k = i.match(s)
      if k:
        self.errors.append(k.groups()[0])

  def report(self):
    if len(self.errors):
      self.formatter.suberr("Uses try, which is deprecated")
      for i in self.errors:
        self.formatter.subsub(i)

class TestA(Test):

  def __init__(self, formatter):
    Test.__init__(self,formatter)
    self.desc = "Testing for superfluous A=${P}.tar.gz"
    self.re = re.compile("(A=\$\{P\}.tar.gz)")

  def checkLine(self, s):
    k = self.re.match(s)
    if k:
      self.errors.append(k.groups()[0])

  def report(self):
    if len(self.errors):
      self.formatter.suberr("Contains superfluous " + self.lines[0])
        
class TestDepend(Test):

  def __init__(self, formatter):
    Test.__init__(self,formatter)
    self.desc = "Testing for empty DEPEND"
    self.re = re.compile("DEPEND=\"\"")

  def checkLine(self, s):
    k = self.re.match(s)
    if k:
      self.warnings.append("")

  def report(self):
    if len(self.warnings):
      self.formatter.subwarn("DEPEND is suspiciously empty")

class TestHomepage(Test):

  def __init__(self, formatter):
    Test.__init__(self,formatter)
    self.desc = "Testing for empty HOMEPAGE"
    self.re = re.compile("HOMEPAGE=\"\"")

  def checkLine(self, s):
    k = self.re.match(s)
    if k:
      self.warnings.append("")

  def report(self):
    if len(self.warnings):
      self.formatter.subwarn("Is HOMEPAGE really supposed to be empty ?")

class TestDescription(Test):

  def __init__(self, formatter):
    Test.__init__(self,formatter)
    self.desc = "Testing for empty DESCRIPTION"
    self.re = re.compile("DESCRIPTION=\"\"")

  def checkLine(self, s):
    k = self.re.match(s)
    if k:
      self.errors.append("")

  def report(self):
    if len(self.errors):
      self.formatter.suberr("DESCRIPTION must not be empty")

class TestEnvVarPresence(Test):

  def __init__(self, formatter):
    Test.__init__(self,formatter)
    self.desc = "Testing for presence of env vars"
    self.re = []
    self.found = []
    self.required = [ "SRC_URI=",
                      "DESCRIPTION=",
                      "HOMEPAGE=",
                      "DEPEND=",
                      "RDEPEND=",
                      "LICENSE="
                      ]
    self.desired = [ "SLOT=",
                     "S="]

    for i in self.required:
      self.re.append(re.compile("^(" + i + ")"))
    for i in self.desired:
      self.re.append(re.compile("^(" + i + ")"))
      
  def checkLine(self, s):
    for i in self.re:
      k = i.match(s)
      if k:
        self.found.append(k.group(1))

  def report(self):
    for i in self.required:
      if i not in self.found:
        self.formatter.suberr("Missing " + i)
    for i in self.desired:
      if i not in self.found:
        self.formatter.subwarn("Missing " + i)

  def hasWarnings(self):
    for i in self.desired:
      if i not in self.found:
        return 1

  def hasErrors(self):
    for i in self.required:
      if i not in self.found:
        return 1

class TestUseFlags(Test):
  def __init__(self, formatter):
    Test.__init__(self,formatter)
    self.desc = "Testing for sane USE flag usage"
    self.re = re.compile("[^#]*use ([a-z0-9]+).*")
    self.useflags = self.loadUseFlags()

  def loadUseFlags(self):
    ins = open("/usr/portage/profiles/use.desc")
    rex = re.compile("^([a-z0-9]+)[ \t]+-.*");
    useflags = []
    for i in ins.readlines():
      k = rex.match(i)
      if k:
        useflags.append(k.group(1))
    return useflags
    
  def checkLine(self, s):
    k = self.re.match(s)
    if k:
      flag = k.group(1)
      if flag not in self.useflags:
        l = k.start(1)
        # We want to try and figure pretty exactly if we've hit a real instnce
        # of the use command or just some random mumbling inside a string
        numApostrophes = 0
        numBackticks = 0
        numTicks = 0
        for i in xrange(l,0,-1):
          if s[i] == '\"' and (i == 0 or (i > 0 and s[i-1] != '\\')):
            numApostrophes += 1
          if s[i] == '\'' and (i == 0 or (i > 0 and s[i-1] != '\\')):
            numTicks += 1
          if s[i] == '`' and (i == 0 or (i > 0 and s[i-1] != '\\')):
            numBackticks += 1

        if numApostrophes % 2 == 0:
          foundError = 1
        elif numBackticks % 2 and numTicks % 2 == 0:
          foundError = 1
        else:
          foundError = 0

        if foundError:
          self.errors.append("Unknown USE flag '" + flag + "'")

  def report(self):
    for i in self.errors:
      self.formatter.suberr(i)
       
def extractFilename(path):
  return path

def runTests(tests,results,ins):
  for j in tests:
    j.reset()

  for i in ins.readlines():
    for j in tests:
      j.checkLine(i)

  hasWarning = 0
  hasError = 0
  for j in xrange(len(tests)):
    if tests[j].hasErrors():
      results[j][0] += 1
      hasError = 1
    if tests[j].hasWarnings():
      results[j][1] += 1
      hasWarning = 1
  return (hasError, hasWarning)
        
def showStatus(options,tests,formatter,file):
  if options['showDetails'] or options['showSeparate']:
    formatter.section("Status for " + file)
    for j in tests:
      if options['showSeparate'] or options['showDetails']:
        l = len(j.getDesc())
        formatter.bullet(j.getDesc() + " " * (70 - l) + ": " + j.getStatus())
        if options['showDetails']:
          j.report()
  elif options['showShort']:
    allOK = 1
    for j in tests:
      if j.hasErrors():
        allOK = 0
        break
    if allOK:
      formatter.div(file, ": OK")
    else:
      formatter.div(file, ": Not OK")
    # else fall through the bottom    
    
def usage(opts):
  print sys.argv[0], "[options] ebuild [ebuild ebuild ... ]"
  print

  print "Where [options] include:"
  for (short,long_,desc) in opts:
    short_ = ''
    for s in short:
      short_ = short_ + '-' + s + ','
    long_ = '--' + long_
    opt = short_ + long_
    opt = opt.rjust(18)
    print opt + '  ' + desc
  print

def parse_opts(argv):
  options = { 'showSeparate': 0,
              'showTotal': 1,
              'showDetails': 0,
              'showShort': 1,
              'listTests': 0,
	      'desiredTests': 0
            }

  opts = (('', 'show-separate',
           'Show short summary of tests for each ebuild checked'),

          ('', 'no-summary',
           'Do not show total summary'),

          ('', 'show-details',
           'Show full details of tests for each ebuild checked'),

          ('', 'tests=',
           'Specify which tests to run'),

          ('', 'list-tests',
           'List available tests'),

          ('', 'ebuilds=<file>',
           'Read ebuilds from <file>'),
          
          ('?h', 'help',
           'Show this help'),
         )

  short_options = ''
  long_options = []
  for (short,long_,desc) in opts:
    short_options = short_options + short
    if '=' in long_:
      long_ = long_.split('=', 1)[0] + '='
    long_options.append(long_)

  try:
    (option_list,args) = getopt.getopt(sys.argv[1:], short_options, long_options)
  except getopt.GetoptError, details:
    print 'Error parsing command line:',str(details)
    sys.exit(1)

  for (option,value) in option_list:
    if option in [ '--show-details' ]:
      options['showShort'] = 0
      options['showDetails'] = 1
    elif option in [ '--show-separate' ]:
      options['showShort'] = 0
      options['showSeparate'] = 1
    elif option in [ '--no-summary']:
      options['showTotal'] = 0
    elif option in [ '--ebuilds' ]:
      lines = open(value, 'r').readlines()
      lines = [o.strip() for o in lines]
      args = lines + args
    elif option in [ '--tests' ]:
      options['desiredTests'] = value.split(",")
    elif option in [ '--list-tests' ]:
      options['listTests'] = 1
    elif option in [ '-h', '-?', '--help' ]:
      usage(opts)
      sys.exit(0)
    else:
      # shouldn't ever happen. better to be safe
      print "Unknown option - '%s'!" % (option)
      sys.exit(1)

  return (options,args)

def main():
    (options,args) = parse_opts(sys.argv[1:])

    
    formatter = TextFormatter()
    available_tests = [ TestSpaces(formatter),
                        TestHeaders(formatter),
                        TestTry(formatter),
                        TestA(formatter),
                        TestDepend(formatter),
                        TestHomepage(formatter),
                        TestDescription(formatter),
                        TestEnvVarPresence(formatter),
                        TestUseFlags(formatter) ]
    
    if options['listTests']:
      maxlen = 0
      for i in available_tests:
        maxlen = max(len(i.__class__.__name__), maxlen)
      for i in available_tests:
        n = i.__class__.__name__
        print n + " " * (maxlen - len(n)) + " - " + i.getDesc()

    if len(args) == 0:
      sys.exit(1)
      
    tests = []
    notTests = []
    if options['desiredTests']:
      for i in options['desiredTests']:
        for j in available_tests:
          if len(i) and i[0] == "-":
            notTests.append(i[1:])
          if j.__class__.__name__ == i:
            tests.append(j)
    else:
      tests = available_tests

    if len(notTests):
      for i in available_tests:
        if i.__class__.__name__ not in notTests:
          tests.append(i)
      
    results = [[0, 0] for x in range(len(tests))]
    
    numFiles = 0
    totalErrors = 0
    totalWarnings = 0
    
    for i in args:
      fn = extractFilename(i)
      ins = open(i, "r")
      numFiles += 1
      (hasError, hasWarning) = runTests(tests,results,ins)
      totalErrors += hasError
      totalWarnings += hasWarning
      showStatus(options,tests,formatter,fn)
    
    if options['showTotal']:
      print "\n" + "-"*79
      s = " Summary for all " + str(numFiles) + " ebuild(s) checked"
      print s + " " * (65 - len(s)) + "# errors/warns"
      print "-"*79
      for i in xrange(len(tests)):
        l = len(tests[i].getDesc())
        print tests[i].getDesc() + " " * (66 - l) + ": " + \
              str(results[i][0]) + " / " + str(results[i][1])
      print
      print "Total number of ebuilds with errors                               : " + str(totalErrors) + \
            " (" + str(totalErrors*100/numFiles) + "%)"
      print "Total number of ebuilds with warnings                             : " + str(totalWarnings) + \
            " (" + str(totalWarnings*100/numFiles) + "%)"
        
if __name__ == "__main__":
  main()

