diff -ruw testdisk-6.8.org/src/dir.h testdisk-6.8/src/dir.h
--- testdisk-6.8.org/src/dir.h	2007-05-11 11:16:17.000000000 +0200
+++ testdisk-6.8/src/dir.h	2007-12-02 22:41:59.000000000 +0100
@@ -51,7 +51,7 @@
 };
 
 struct file_info {
-  struct list_head list;
+  struct td_list_head list;
   char name[4096];
   struct stat stat;
 };
diff -ruw testdisk-6.8.org/src/filegen.h testdisk-6.8/src/filegen.h
--- testdisk-6.8.org/src/filegen.h	2007-06-03 23:52:41.000000000 +0200
+++ testdisk-6.8/src/filegen.h	2007-12-02 22:41:59.000000000 +0100
@@ -88,7 +88,7 @@
 
 struct alloc_data_struct
 {
-  struct list_head list;
+  struct td_list_head list;
   uint64_t start;
   uint64_t end;
   file_stat_t *file_stat;
diff -ruw testdisk-6.8.org/src/intrface.c testdisk-6.8/src/intrface.c
--- testdisk-6.8.org/src/intrface.c	2007-07-18 19:10:10.000000000 +0200
+++ testdisk-6.8/src/intrface.c	2007-12-02 22:41:59.000000000 +0100
@@ -1080,15 +1080,15 @@
 
 static list_part_t *interface_load(disk_t *disk_car,list_part_t *list_part, const int debug)
 {
-  struct list_head *backup_walker=NULL;
+  struct td_list_head *backup_walker=NULL;
   backup_disk_t *backup_list=partition_load(disk_car,debug);
   {
     log_info("interface_load\n");
-    list_for_each(backup_walker,&backup_list->list)
+    td_list_for_each(backup_walker,&backup_list->list)
     {
       list_part_t *element;
       backup_disk_t *backup;
-      backup=list_entry(backup_walker, backup_disk_t, list);
+      backup=td_list_entry(backup_walker, backup_disk_t, list);
       log_info("%s %s",backup->description,ctime(&backup->my_time));
       for(element=backup->list_part;element!=NULL;element=element->next)
 	log_partition(disk_car,element->part);
@@ -1100,7 +1100,7 @@
     int backup_current_num=0;
     int rewrite=1;
     unsigned int menu=3;   /* default : quit */
-    struct list_head *backup_current=backup_list->list.next;
+    struct td_list_head *backup_current=backup_list->list.next;
     struct MenuItem menuLoadBackup[]=
     {
       { 'P', "Previous",""},
@@ -1134,7 +1134,7 @@
 	for(i=0,backup_walker=backup_list->list.next;(backup_walker!=&backup_list->list) && (i<offset);backup_walker=backup_walker->next,i++);
 	for(i=offset;(backup_walker!=&backup_list->list) &&((i-offset)<INTER_STRUCTURE);i++,backup_walker=backup_walker->next)
 	{
-	  backup=list_entry(backup_walker, backup_disk_t, list);
+	  backup=td_list_entry(backup_walker, backup_disk_t, list);
 	  wmove(stdscr,8+i-offset,0);
 	  wclrtoeol(stdscr);	/* before addstr for BSD compatibility */
 	  if(backup_walker==backup_current)
@@ -1222,7 +1222,7 @@
     {
       list_part_t *partition;
       backup_disk_t *backup;
-      backup=list_entry(backup_current, backup_disk_t, list);
+      backup=td_list_entry(backup_current, backup_disk_t, list);
       for(partition=backup->list_part;partition!=NULL;partition=partition->next)
       {
 	/* Check partition and load partition name */
@@ -1232,11 +1232,11 @@
     }
   }
   { /* Cleanup */
-    struct list_head *backup_walker_next = NULL;
-    list_for_each_safe(backup_walker,backup_walker_next,&backup_list->list)
+    struct td_list_head *backup_walker_next = NULL;
+    td_list_for_each_safe(backup_walker,backup_walker_next,&backup_list->list)
     {
       backup_disk_t *backup;
-      backup=list_entry(backup_walker, backup_disk_t, list);
+      backup=td_list_entry(backup_walker, backup_disk_t, list);
       delete_list_part(backup->list_part);
       free(backup);
     }
diff -ruw testdisk-6.8.org/src/intrf.c testdisk-6.8/src/intrf.c
--- testdisk-6.8.org/src/intrf.c	2007-07-19 23:44:00.000000000 +0200
+++ testdisk-6.8/src/intrf.c	2007-12-02 22:41:59.000000000 +0100
@@ -1548,11 +1548,11 @@
   do
   {
     DIR* dir;
-    struct list_head *dir_current;
+    struct td_list_head *dir_current;
     int offset=0;
     int pos_num=0;
     static struct file_info dir_list = {
-      .list = LIST_HEAD_INIT(dir_list.list),
+      .list = TD_LIST_HEAD_INIT(dir_list.list),
       .name = {0}
     };
     wmove(window,7,0);
@@ -1576,7 +1576,7 @@
 	new_drive->name[2]=PATH_SEP;
 	new_drive->name[3]='\0';
 	new_drive->stat.st_mode=LINUX_S_IFDIR|LINUX_S_IRWXUGO;
-	list_add_tail(&new_drive->list,&dir_list.list);
+	td_list_add_tail(&new_drive->list,&dir_list.list);
       }
       dir=NULL;
     }
@@ -1633,7 +1633,7 @@
 	      }
 #endif
 	      strncpy(dir_info->name,dir_entrie->d_name,sizeof(dir_info->name));
-	      list_add_tail(&dir_info->list,&dir_list.list);
+	      td_list_add_tail(&dir_info->list,&dir_list.list);
 	      dir_info=(struct file_info*)MALLOC(sizeof(*dir_info));
 	    }
 	  }
@@ -1665,14 +1665,14 @@
 	wdoprintf(window,"To select another directory, use the arrow keys.");
 #endif
 	{
-	  struct list_head *dir_walker = NULL;
+	  struct td_list_head *dir_walker = NULL;
 	  int i=0;
-	  list_for_each(dir_walker,&dir_list.list)
+	  td_list_for_each(dir_walker,&dir_list.list)
 	  {
 	    if(offset<=i)
 	    {
 	      struct file_info *dir_info;
-	      dir_info=list_entry(dir_walker, struct file_info, list);
+	      dir_info=td_list_entry(dir_walker, struct file_info, list);
 	      wmove(window,8+i-offset,0);
 	      wclrtoeol(window);	/* before addstr for BSD compatibility */
 	      if(dir_walker==dir_current)
@@ -1792,7 +1792,7 @@
 	      if(dir_current!=&dir_list.list)
 	      {
 		struct file_info *dir_info;
-		dir_info=list_entry(dir_current, struct file_info, list);
+		dir_info=td_list_entry(dir_current, struct file_info, list);
 		if(strcmp(dir_info->name,".")==0)
 		{
 		}
@@ -1819,13 +1819,13 @@
 	} while(quit==0);
       } while(quit==1);
       {
-	struct list_head *dir_walker = NULL;
-	struct list_head *dir_walker_next = NULL;
-	list_for_each_safe(dir_walker,dir_walker_next,&dir_list.list)
+	struct td_list_head *dir_walker = NULL;
+	struct td_list_head *dir_walker_next = NULL;
+	td_list_for_each_safe(dir_walker,dir_walker_next,&dir_list.list)
 	{
 	  struct file_info *dir_info;
-	  dir_info=list_entry(dir_walker, struct file_info, list);
-	  list_del(dir_walker);
+	  dir_info=td_list_entry(dir_walker, struct file_info, list);
+	  td_list_del(dir_walker);
 	  free(dir_info);
 	}
       }
diff -ruw testdisk-6.8.org/src/list.c testdisk-6.8/src/list.c
--- testdisk-6.8.org/src/list.c	2007-07-06 18:48:25.000000000 +0200
+++ testdisk-6.8/src/list.c	2007-12-02 22:41:59.000000000 +0100
@@ -87,14 +87,14 @@
       if(file_size>=size)
       {
 	element->end-=(file_size-size);
-	list_delete(element->next);
-//	element->next=NULL;	already done by list_delete
+	td_list_delete(element->next);
+//	element->next=NULL;	already done by td_list_delete
       }
     }
   }
 }
 
-void list_delete(alloc_list_t *list)
+void td_list_delete(alloc_list_t *list)
 {
   alloc_list_t *next;
   if(list!=NULL && list->prev!=NULL)
diff -ruw testdisk-6.8.org/src/list.h testdisk-6.8/src/list.h
--- testdisk-6.8.org/src/list.h	2007-06-05 23:01:06.000000000 +0200
+++ testdisk-6.8/src/list.h	2007-12-02 22:41:59.000000000 +0100
@@ -34,7 +34,7 @@
 
 void list_append_block(alloc_list_t *list, const uint64_t offset, const uint64_t blocksize, const int data);
 void list_truncate(alloc_list_t *list, uint64_t size);
-void list_delete(alloc_list_t *list);
+void td_list_delete(alloc_list_t *list);
 
 
 /*
@@ -56,16 +56,16 @@
  * using the generic single-entry routines.
  */
 
-struct list_head {
-	struct list_head *next, *prev;
+struct td_list_head {
+	struct td_list_head *next, *prev;
 };
 
-#define LIST_HEAD_INIT(name) { &(name), &(name) }
+#define TD_LIST_HEAD_INIT(name) { &(name), &(name) }
 
-#define LIST_HEAD(name) \
-	struct list_head name = LIST_HEAD_INIT(name)
+#define TD_LIST_HEAD(name) \
+	struct td_list_head name = TD_LIST_HEAD_INIT(name)
 
-#define INIT_LIST_HEAD(ptr) do { \
+#define INIT_TD_LIST_HEAD(ptr) do { \
 	(ptr)->next = (ptr); (ptr)->prev = (ptr); \
 } while (0)
 
@@ -75,9 +75,9 @@
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  */
-static inline void __list_add(struct list_head *new,
-			      struct list_head *prev,
-			      struct list_head *next)
+static inline void __td_list_add(struct td_list_head *new,
+			      struct td_list_head *prev,
+			      struct td_list_head *next)
 {
 	next->prev = new;
 	new->next = next;
@@ -86,29 +86,29 @@
 }
 
 /**
- * list_add - add a new entry
+ * td_list_add - add a new entry
  * @new: new entry to be added
  * @head: list head to add it after
  *
  * Insert a new entry after the specified head.
  * This is good for implementing stacks.
  */
-static inline void list_add(struct list_head *new, struct list_head *head)
+static inline void td_list_add(struct td_list_head *new, struct td_list_head *head)
 {
-	__list_add(new, head, head->next);
+	__td_list_add(new, head, head->next);
 }
 
 /**
- * list_add_tail - add a new entry
+ * td_list_add_tail - add a new entry
  * @new: new entry to be added
  * @head: list head to add it before
  *
  * Insert a new entry before the specified head.
  * This is useful for implementing queues.
  */
-static inline void list_add_tail(struct list_head *new, struct list_head *head)
+static inline void td_list_add_tail(struct td_list_head *new, struct td_list_head *head)
 {
-	__list_add(new, head->prev, head);
+	__td_list_add(new, head->prev, head);
 }
 
 /*
@@ -118,91 +118,91 @@
  * This is only for internal list manipulation where we know
  * the prev/next entries already!
  */
-static inline void __list_del(struct list_head * prev, struct list_head * next)
+static inline void __td_list_del(struct td_list_head * prev, struct td_list_head * next)
 {
 	next->prev = prev;
 	prev->next = next;
 }
 
 /**
- * list_del - deletes entry from list.
+ * td_list_del - deletes entry from list.
  * @entry: the element to delete from the list.
- * Note: list_empty on entry does not return true after this, the entry is
+ * Note: td_list_empty on entry does not return true after this, the entry is
  * in an undefined state.
  */
-static inline void list_del(struct list_head *entry)
+static inline void td_list_del(struct td_list_head *entry)
 {
-	__list_del(entry->prev, entry->next);
+	__td_list_del(entry->prev, entry->next);
 	entry->next = LIST_POISON1;
 	entry->prev = LIST_POISON2;
 }
 
 /**
- * list_del_init - deletes entry from list and reinitialize it.
+ * td_list_del_init - deletes entry from list and reinitialize it.
  * @entry: the element to delete from the list.
  */
-static inline void list_del_init(struct list_head *entry)
+static inline void td_list_del_init(struct td_list_head *entry)
 {
-	__list_del(entry->prev, entry->next);
-	INIT_LIST_HEAD(entry);
+	__td_list_del(entry->prev, entry->next);
+	INIT_TD_LIST_HEAD(entry);
 }
 
 /**
- * list_move - delete from one list and add as another's head
+ * td_list_move - delete from one list and add as another's head
  * @list: the entry to move
  * @head: the head that will precede our entry
  */
-static inline void list_move(struct list_head *list, struct list_head *head)
+static inline void td_list_move(struct td_list_head *list, struct td_list_head *head)
 {
-        __list_del(list->prev, list->next);
-        list_add(list, head);
+        __td_list_del(list->prev, list->next);
+        td_list_add(list, head);
 }
 
 /**
- * list_move_tail - delete from one list and add as another's tail
+ * td_list_move_tail - delete from one list and add as another's tail
  * @list: the entry to move
  * @head: the head that will follow our entry
  */
-static inline void list_move_tail(struct list_head *list,
-				  struct list_head *head)
+static inline void td_list_move_tail(struct td_list_head *list,
+				  struct td_list_head *head)
 {
-        __list_del(list->prev, list->next);
-        list_add_tail(list, head);
+        __td_list_del(list->prev, list->next);
+        td_list_add_tail(list, head);
 }
 
 /**
- * list_empty - tests whether a list is empty
+ * td_list_empty - tests whether a list is empty
  * @head: the list to test.
  */
-static inline int list_empty(const struct list_head *head)
+static inline int td_list_empty(const struct td_list_head *head)
 {
 	return head->next == head;
 }
 
 /**
- * list_empty_careful - tests whether a list is
+ * td_list_empty_careful - tests whether a list is
  * empty _and_ checks that no other CPU might be
  * in the process of still modifying either member
  *
- * NOTE: using list_empty_careful() without synchronization
+ * NOTE: using td_list_empty_careful() without synchronization
  * can only be safe if the only activity that can happen
- * to the list entry is list_del_init(). Eg. it cannot be used
- * if another CPU could re-list_add() it.
+ * to the list entry is td_list_del_init(). Eg. it cannot be used
+ * if another CPU could re-td_list_add() it.
  *
  * @head: the list to test.
  */
-static inline int list_empty_careful(const struct list_head *head)
+static inline int td_list_empty_careful(const struct td_list_head *head)
 {
-	struct list_head *next = head->next;
+	struct td_list_head *next = head->next;
 	return (next == head) && (next == head->prev);
 }
 
-static inline void __list_splice(struct list_head *list,
-				 struct list_head *head)
+static inline void __td_list_splice(struct td_list_head *list,
+				 struct td_list_head *head)
 {
-	struct list_head *first = list->next;
-	struct list_head *last = list->prev;
-	struct list_head *at = head->next;
+	struct td_list_head *first = list->next;
+	struct td_list_head *last = list->prev;
+	struct td_list_head *at = head->next;
 
 	first->prev = head;
 	head->next = first;
@@ -212,125 +212,125 @@
 }
 
 /**
- * list_splice - join two lists
+ * td_list_splice - join two lists
  * @list: the new list to add.
  * @head: the place to add it in the first list.
  */
-static inline void list_splice(struct list_head *list, struct list_head *head)
+static inline void td_list_splice(struct td_list_head *list, struct td_list_head *head)
 {
-	if (!list_empty(list))
-		__list_splice(list, head);
+	if (!td_list_empty(list))
+		__td_list_splice(list, head);
 }
 
 /**
- * list_splice_init - join two lists and reinitialise the emptied list.
+ * td_list_splice_init - join two lists and reinitialise the emptied list.
  * @list: the new list to add.
  * @head: the place to add it in the first list.
  *
  * The list at @list is reinitialised
  */
-static inline void list_splice_init(struct list_head *list,
-				    struct list_head *head)
+static inline void td_list_splice_init(struct td_list_head *list,
+				    struct td_list_head *head)
 {
-	if (!list_empty(list)) {
-		__list_splice(list, head);
-		INIT_LIST_HEAD(list);
+	if (!td_list_empty(list)) {
+		__td_list_splice(list, head);
+		INIT_TD_LIST_HEAD(list);
 	}
 }
 
 /**
- * list_entry - get the struct for this entry
- * @ptr:	the &struct list_head pointer.
+ * td_list_entry - get the struct for this entry
+ * @ptr:	the &struct td_list_head pointer.
  * @type:	the type of the struct this is embedded in.
  * @member:	the name of the list_struct within the struct.
  */
-#define list_entry(ptr, type, member) \
+#define td_list_entry(ptr, type, member) \
 	((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
 
 /**
- * __list_for_each	-	iterate over a list
- * @pos:	the &struct list_head to use as a loop counter.
+ * __td_list_for_each	-	iterate over a list
+ * @pos:	the &struct td_list_head to use as a loop counter.
  * @head:	the head for your list.
  *
  */
-#define list_for_each(pos, head) \
+#define td_list_for_each(pos, head) \
 	for (pos = (head)->next; pos != (head); pos = pos->next)
 
 /**
- * list_for_each_prev	-	iterate over a list backwards
- * @pos:	the &struct list_head to use as a loop counter.
+ * td_list_for_each_prev	-	iterate over a list backwards
+ * @pos:	the &struct td_list_head to use as a loop counter.
  * @head:	the head for your list.
  */
-#define list_for_each_prev(pos, head) \
+#define td_list_for_each_prev(pos, head) \
 	for (pos = (head)->prev; pos != (head); \
         	pos = pos->prev)
 
 /**
- * list_for_each_safe	-	iterate over a list safe against removal of list entry
- * @pos:	the &struct list_head to use as a loop counter.
- * @n:		another &struct list_head to use as temporary storage
+ * td_list_for_each_safe	-	iterate over a list safe against removal of list entry
+ * @pos:	the &struct td_list_head to use as a loop counter.
+ * @n:		another &struct td_list_head to use as temporary storage
  * @head:	the head for your list.
  */
-#define list_for_each_safe(pos, n, head) \
+#define td_list_for_each_safe(pos, n, head) \
 	for (pos = (head)->next, n = pos->next; pos != (head); \
 		pos = n, n = pos->next)
 
 /**
- * list_for_each_entry	-	iterate over list of given type
+ * td_list_for_each_entry	-	iterate over list of given type
  * @pos:	the type * to use as a loop counter.
  * @head:	the head for your list.
  * @member:	the name of the list_struct within the struct.
  */
-#define list_for_each_entry(pos, head, member)				\
-	for (pos = list_entry((head)->next, typeof(*pos), member);	\
+#define td_list_for_each_entry(pos, head, member)				\
+	for (pos = td_list_entry((head)->next, typeof(*pos), member);	\
 	     &pos->member != (head); 	\
-	     pos = list_entry(pos->member.next, typeof(*pos), member))
+	     pos = td_list_entry(pos->member.next, typeof(*pos), member))
 
 /**
- * list_for_each_entry_reverse - iterate backwards over list of given type.
+ * td_list_for_each_entry_reverse - iterate backwards over list of given type.
  * @pos:	the type * to use as a loop counter.
  * @head:	the head for your list.
  * @member:	the name of the list_struct within the struct.
  */
-#define list_for_each_entry_reverse(pos, head, member)			\
-	for (pos = list_entry((head)->prev, typeof(*pos), member);	\
+#define td_list_for_each_entry_reverse(pos, head, member)			\
+	for (pos = td_list_entry((head)->prev, typeof(*pos), member);	\
 	     &pos->member != (head); 	\
-	     pos = list_entry(pos->member.prev, typeof(*pos), member))
+	     pos = td_list_entry(pos->member.prev, typeof(*pos), member))
 
 /**
- * list_prepare_entry - prepare a pos entry for use as a start point in
- *			list_for_each_entry_continue
+ * td_list_prepare_entry - prepare a pos entry for use as a start point in
+ *			td_list_for_each_entry_continue
  * @pos:	the type * to use as a start point
  * @head:	the head of the list
  * @member:	the name of the list_struct within the struct.
  */
-#define list_prepare_entry(pos, head, member) \
-	((pos) ? : list_entry(head, typeof(*pos), member))
+#define td_list_prepare_entry(pos, head, member) \
+	((pos) ? : td_list_entry(head, typeof(*pos), member))
 
 /**
- * list_for_each_entry_continue -	iterate over list of given type
+ * td_list_for_each_entry_continue -	iterate over list of given type
  *			continuing after existing point
  * @pos:	the type * to use as a loop counter.
  * @head:	the head for your list.
  * @member:	the name of the list_struct within the struct.
  */
-#define list_for_each_entry_continue(pos, head, member) 		\
-	for (pos = list_entry(pos->member.next, typeof(*pos), member);	\
+#define td_list_for_each_entry_continue(pos, head, member) 		\
+	for (pos = td_list_entry(pos->member.next, typeof(*pos), member);	\
 	     &pos->member != (head);	\
-	     pos = list_entry(pos->member.next, typeof(*pos), member))
+	     pos = td_list_entry(pos->member.next, typeof(*pos), member))
 
 /**
- * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * td_list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
  * @pos:	the type * to use as a loop counter.
  * @n:		another type * to use as temporary storage
  * @head:	the head for your list.
  * @member:	the name of the list_struct within the struct.
  */
-#define list_for_each_entry_safe(pos, n, head, member)			\
-	for (pos = list_entry((head)->next, typeof(*pos), member),	\
-		n = list_entry(pos->member.next, typeof(*pos), member);	\
+#define td_list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = td_list_entry((head)->next, typeof(*pos), member),	\
+		n = td_list_entry(pos->member.next, typeof(*pos), member);	\
 	     &pos->member != (head); 					\
-	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
+	     pos = n, n = td_list_entry(n->member.next, typeof(*n), member))
 
 
 #endif
diff -ruw testdisk-6.8.org/src/ntfs.c testdisk-6.8/src/ntfs.c
--- testdisk-6.8.org/src/ntfs.c	2007-07-19 23:44:05.000000000 +0200
+++ testdisk-6.8/src/ntfs.c	2007-12-02 22:41:59.000000000 +0100
@@ -233,7 +233,7 @@
     {
       unsigned int attr_value_length=NTFS_GETU16(attr_record+0x10);
       unsigned int attr_value_offset=NTFS_GETU16(attr_record+0x14);
-      const char *attr_list_entry=attr_record+attr_value_offset;
+      const char *attr_td_list_entry=attr_record+attr_value_offset;
       if(attr_value_offset%8!=0)
       {
 #ifdef NTFS_DEBUG
@@ -241,15 +241,15 @@
 #endif
 	return 2;
       }
-      if(attr_list_entry+26>=end)
+      if(attr_td_list_entry+26>=end)
       {
 #ifdef NTFS_DEBUG
-	log_debug("ntfs_get_attr attr_list_entry+26=%p, end=%p\n",attr_list_entry+26,end);
+	log_debug("ntfs_get_attr attr_td_list_entry+26=%p, end=%p\n",attr_td_list_entry+26,end);
 #endif
 	return 2;
       }
       /* We found the attribute type. Is the name correct, too? */
-      if((attr_value_offset+attr_value_length>attr_len) || (attr_list_entry+attr_len >= end))
+      if((attr_value_offset+attr_value_length>attr_len) || (attr_td_list_entry+attr_len >= end))
       {
 #ifdef NTFS_DEBUG
 	// log_debug("ntfs_get_attr \n");
@@ -262,7 +262,7 @@
 	{
 	  case 0x30:	/* AT_FILE_NAME */
 	    {
-	      const char *file_name_attr=attr_list_entry;
+	      const char *file_name_attr=attr_td_list_entry;
 	      unsigned int file_name_length;
 	      const char *name_it;
 	      if(file_name_attr+0x42>=end)
@@ -303,13 +303,13 @@
 	      volume_name_length/=2;	/* Unicode */
 	      if(volume_name_length>sizeof(partition->name)-1)
 		volume_name_length=sizeof(partition->name)-1;
-	      for(name_it=attr_list_entry;(volume_name_length>0) && (*name_it!='\0') && (name_it[1]=='\0'); name_it+=2,volume_name_length--)
+	      for(name_it=attr_td_list_entry;(volume_name_length>0) && (*name_it!='\0') && (name_it[1]=='\0'); name_it+=2,volume_name_length--)
 		*dest++=*name_it;
 	      *dest++='\0'; /* 27 january 2003: Correct a bug found by Andreas du Plessis-Denz */
 	    }
 	    return 1;
 	  case 0x90:	/* AT_INDEX_ROOT */
-	    return NTFS_GETU32(attr_list_entry+8);	/* index_block_size */
+	    return NTFS_GETU32(attr_td_list_entry+8);	/* index_block_size */
 	}
       }
     }
diff -ruw testdisk-6.8.org/src/ntfs_dir.c testdisk-6.8/src/ntfs_dir.c
--- testdisk-6.8.org/src/ntfs_dir.c	2007-07-10 13:46:07.000000000 +0200
+++ testdisk-6.8/src/ntfs_dir.c	2007-12-02 22:41:59.000000000 +0100
@@ -93,7 +93,7 @@
 extern u64 ntfs_inode_lookup_by_name(ntfs_inode *dir_ni,
                 const ntfschar *uname, const int uname_len);
 static time_t ntfs2utc (s64 ntfstime);
-static int ntfs_list_entry(  struct ntfs_dir_struct *ls, const ntfschar *name, 
+static int ntfs_td_list_entry(  struct ntfs_dir_struct *ls, const ntfschar *name, 
 		const int name_len, const int name_type, const s64 pos,
 		const MFT_REF mref, const unsigned dt_type);
 static file_data_t *ntfs_dir(disk_t *disk_car, const partition_t *partition, dir_data_t *dir_data, const unsigned long int cluster);
@@ -138,10 +138,10 @@
 }
 
 /**
- * ntfs_list_entry
+ * ntfs_td_list_entry
  * FIXME: Should we print errors as we go along? (AIA)
  */
-static int ntfs_list_entry(  struct ntfs_dir_struct *ls, const ntfschar *name, 
+static int ntfs_td_list_entry(  struct ntfs_dir_struct *ls, const ntfschar *name, 
 		const int name_len, const int name_type, const s64 pos,
 		const MFT_REF mref, const unsigned dt_type)
 {
@@ -150,7 +150,7 @@
   filename = calloc (1, MAX_PATH);
   if (!filename)
   {
-    log_critical("ntfs_list_entry calloc failed\n");
+    log_critical("ntfs_td_list_entry calloc failed\n");
     return -1;
   }
 
@@ -292,7 +292,7 @@
    */
   pos = 0;
   if (inode->mrec->flags & MFT_RECORD_IS_DIRECTORY) {
-    if(ntfs_readdir(inode, &pos, ls, (ntfs_filldir_t)ntfs_list_entry)<0)
+    if(ntfs_readdir(inode, &pos, ls, (ntfs_filldir_t)ntfs_td_list_entry)<0)
     {
       log_error("ntfs_readdir failed\n");
     }
diff -ruw testdisk-6.8.org/src/photorec.c testdisk-6.8/src/photorec.c
--- testdisk-6.8.org/src/photorec.c	2007-07-20 20:44:13.000000000 +0200
+++ testdisk-6.8/src/photorec.c	2007-12-02 22:41:59.000000000 +0100
@@ -223,14 +223,14 @@
 
 static void list_free_add(const file_recovery_t *file_recovery, alloc_data_t *list_search_space)
 {
-  struct list_head *search_walker = NULL;
+  struct td_list_head *search_walker = NULL;
 #ifdef DEBUG_FREE
   log_trace("list_free_add %lu\n",(long unsigned)(file_recovery->location.start/512));
 #endif
-  list_for_each(search_walker, &list_search_space->list)
+  td_list_for_each(search_walker, &list_search_space->list)
   {
     alloc_data_t *current_search_space;
-    current_search_space=list_entry(search_walker, alloc_data_t, list);
+    current_search_space=td_list_entry(search_walker, alloc_data_t, list);
     if(current_search_space->start < file_recovery->location.start && file_recovery->location.start < current_search_space->end)
     {
       alloc_data_t *new_free_space;
@@ -239,7 +239,7 @@
       new_free_space->end=current_search_space->end;
       new_free_space->file_stat=NULL;
       current_search_space->end=file_recovery->location.start-1;
-      list_add(&new_free_space->list, search_walker);
+      td_list_add(&new_free_space->list, search_walker);
     }
     if(current_search_space->start==file_recovery->location.start)
     {
@@ -252,22 +252,22 @@
 static alloc_data_t *update_search_space(const file_recovery_t *file_recovery, alloc_data_t *list_search_space, alloc_data_t **new_current_search_space, uint64_t *offset, const unsigned int blocksize)
 {
   const alloc_list_t *element;
-  struct list_head *search_walker = NULL;
+  struct td_list_head *search_walker = NULL;
 #ifdef DEBUG_UPDATE_SEARCH_SPACE
   log_trace("update_search_space\n");
-  list_for_each(search_walker, &list_search_space->list)
+  td_list_for_each(search_walker, &list_search_space->list)
   {
     alloc_data_t *cur_free_space;
-    cur_free_space=list_entry(search_walker, alloc_data_t, list);
+    cur_free_space=td_list_entry(search_walker, alloc_data_t, list);
     log_trace(" %llu-%llu",(long long unsigned)(cur_free_space->start/512),
 	(long long unsigned)(cur_free_space->end/512));
   }
   log_trace("\n");
 #endif
-  list_for_each(search_walker, &list_search_space->list)
+  td_list_for_each(search_walker, &list_search_space->list)
   {
     alloc_data_t *current_search_space;
-    current_search_space=list_entry(search_walker, alloc_data_t, list);
+    current_search_space=td_list_entry(search_walker, alloc_data_t, list);
     if(current_search_space->start <= file_recovery->location.start &&
 	file_recovery->location.start <= current_search_space->end)
     {
@@ -291,7 +291,7 @@
 
 static alloc_data_t *update_search_space_aux(alloc_data_t *list_search_space, uint64_t start, uint64_t end, alloc_data_t **new_current_search_space, uint64_t *offset)
 {
-  struct list_head *search_walker = NULL;
+  struct td_list_head *search_walker = NULL;
 #ifdef DEBUG_UPDATE_SEARCH_SPACE
     log_trace("update_search_space_aux offset=%llu remove [%llu-%llu]\n",
 	(long long unsigned)((*offset)/512),
@@ -300,10 +300,10 @@
 #endif
   if(start >= end)
     return list_search_space;
-  list_for_each(search_walker, &list_search_space->list)
+  td_list_for_each(search_walker, &list_search_space->list)
   {
     alloc_data_t *current_search_space;
-    current_search_space=list_entry(search_walker, alloc_data_t, list);
+    current_search_space=td_list_entry(search_walker, alloc_data_t, list);
 #ifdef DEBUG_UPDATE_SEARCH_SPACE
     log_trace("update_search_space_aux offset=%llu remove [%llu-%llu] in [%llu-%llu]\n",
 	(long long unsigned)((*offset)/512),
@@ -328,14 +328,14 @@
       /* current_search_space->start==start current_search_space->end<=end */
       start=current_search_space->end+1;
       if(list_search_space==current_search_space)
-	list_search_space=list_entry(current_search_space->list.next, alloc_data_t, list);
+	list_search_space=td_list_entry(current_search_space->list.next, alloc_data_t, list);
       if(offset!=NULL && new_current_search_space!=NULL &&
 	  current_search_space->start<=*offset && *offset<=current_search_space->end)
       {
-	*new_current_search_space=list_entry(current_search_space->list.next, alloc_data_t, list);
+	*new_current_search_space=td_list_entry(current_search_space->list.next, alloc_data_t, list);
 	*offset=(*new_current_search_space)->start;
       }
-      list_del(search_walker);
+      td_list_del(search_walker);
       free(current_search_space);
       return update_search_space_aux(list_search_space, start,end, new_current_search_space, offset);
     }
@@ -349,7 +349,7 @@
 	if(offset!=NULL && new_current_search_space!=NULL &&
 	  start<=*offset && *offset<=current_search_space->end)
 	{
-	  *new_current_search_space=list_entry(current_search_space->list.next, alloc_data_t, list);
+	  *new_current_search_space=td_list_entry(current_search_space->list.next, alloc_data_t, list);
 	  *offset=(*new_current_search_space)->start;
 	}
 	current_search_space->end=start-1;
@@ -358,14 +358,14 @@
       /* start<=current_search_space->start current_search_space->end==end */
       end=current_search_space->start-1;
       if(list_search_space==current_search_space)
-	list_search_space=list_entry(current_search_space->list.next, alloc_data_t, list);
+	list_search_space=td_list_entry(current_search_space->list.next, alloc_data_t, list);
       if(offset!=NULL && new_current_search_space!=NULL &&
 	  current_search_space->start<=*offset && *offset<=current_search_space->end)
       {
-	*new_current_search_space=list_entry(current_search_space->list.next, alloc_data_t, list);
+	*new_current_search_space=td_list_entry(current_search_space->list.next, alloc_data_t, list);
 	*offset=(*new_current_search_space)->start;
       }
-      list_del(search_walker);
+      td_list_del(search_walker);
       free(current_search_space);
       return update_search_space_aux(list_search_space, start,end, new_current_search_space, offset);
     }
@@ -388,7 +388,7 @@
       new_free_space->end=current_search_space->end;
       new_free_space->file_stat=NULL;
       current_search_space->end=start-1;
-      list_add(&new_free_space->list,search_walker);
+      td_list_add(&new_free_space->list,search_walker);
       if(offset!=NULL && new_current_search_space!=NULL &&
 	  new_free_space->start<=*offset && *offset<=new_free_space->end)
       {
@@ -418,13 +418,13 @@
 
 void free_list_search_space(alloc_data_t *list_search_space)
 {
-  struct list_head *search_walker = NULL;
-  struct list_head *search_walker_next = NULL;
-  list_for_each_safe(search_walker,search_walker_next,&list_search_space->list)
+  struct td_list_head *search_walker = NULL;
+  struct td_list_head *search_walker_next = NULL;
+  td_list_for_each_safe(search_walker,search_walker_next,&list_search_space->list)
   {
     alloc_data_t *current_search_space;
-    current_search_space=list_entry(search_walker, alloc_data_t, list);
-    list_del(search_walker);
+    current_search_space=td_list_entry(search_walker, alloc_data_t, list);
+    td_list_del(search_walker);
     free(current_search_space);
   }
 }
@@ -514,7 +514,7 @@
 static void get_prev_header(alloc_data_t *list_search_space, alloc_data_t **current_search_space, uint64_t *offset)
 {
   if((*current_search_space) != list_search_space)
-    *current_search_space=list_entry((*current_search_space)->list.prev, alloc_data_t, list);
+    *current_search_space=td_list_entry((*current_search_space)->list.prev, alloc_data_t, list);
   *offset=(*current_search_space)->start;
 }
 #endif
@@ -525,7 +525,7 @@
   alloc_data_t *file_space=*current_search_space;
   for(nbr=0;nbr<5;nbr++)
   {
-    file_space=list_entry(file_space->list.prev, alloc_data_t, list);
+    file_space=td_list_entry(file_space->list.prev, alloc_data_t, list);
     if(file_space==list_search_space)
       return -1;
     if(file_space->file_stat!=NULL)
@@ -540,8 +540,8 @@
 
 void forget(alloc_data_t *list_search_space, alloc_data_t *current_search_space)
 {
-  struct list_head *search_walker = NULL;
-  struct list_head *prev= NULL;
+  struct td_list_head *search_walker = NULL;
+  struct td_list_head *prev= NULL;
   int nbr=0;
   if(current_search_space==list_search_space)
     return ;
@@ -553,8 +553,8 @@
     if(nbr>10000)
     {
       alloc_data_t *tmp;
-      tmp=list_entry(search_walker, alloc_data_t, list);
-      list_del(&tmp->list);
+      tmp=td_list_entry(search_walker, alloc_data_t, list);
+      td_list_del(&tmp->list);
       free(tmp);
     }
     else
@@ -564,14 +564,14 @@
 
 void list_cluster_free(list_cluster_t *list_cluster)
 {
-  struct list_head *dir_walker = NULL;
-  struct list_head *dir_walker_next = NULL;
-  list_for_each_safe(dir_walker,dir_walker_next,&list_cluster->list)
+  struct td_list_head *dir_walker = NULL;
+  struct td_list_head *dir_walker_next = NULL;
+  td_list_for_each_safe(dir_walker,dir_walker_next,&list_cluster->list)
   {
     list_cluster_t *info;
-    info=list_entry(dir_walker, list_cluster_t, list);
+    info=td_list_entry(dir_walker, list_cluster_t, list);
     delete_list_file(info->dir_list);
-    list_del(dir_walker);
+    td_list_del(dir_walker);
     free(info);
   }
 }
@@ -589,16 +589,16 @@
 
 void update_stats(file_stat_t *file_stats, alloc_data_t *list_search_space)
 {
-  struct list_head *search_walker = NULL;
+  struct td_list_head *search_walker = NULL;
   int i;
   /* Reset */
   for(i=0;file_stats[i].file_hint!=NULL;i++)
     file_stats[i].not_recovered=0;
   /* Update */
-  list_for_each(search_walker, &list_search_space->list)
+  td_list_for_each(search_walker, &list_search_space->list)
   {
     alloc_data_t *current_search_space;
-    current_search_space=list_entry(search_walker, alloc_data_t, list);
+    current_search_space=td_list_entry(search_walker, alloc_data_t, list);
     if(current_search_space->file_stat!=NULL)
     {
       current_search_space->file_stat->not_recovered++;
@@ -705,13 +705,13 @@
   unsigned int nbr_max=0;
   for(cluster_size=default_blocksize;cluster_size<=128*512;cluster_size*=2)
   {
-    struct list_head *dir_walker = NULL;
+    struct td_list_head *dir_walker = NULL;
     cluster_offset_t cluster_offset[1000];
     unsigned int nbr_sol=0;
-    list_for_each(dir_walker,&list_cluster->list)
+    td_list_for_each(dir_walker,&list_cluster->list)
     {
       list_cluster_t *info;
-      info=list_entry(dir_walker, list_cluster_t, list);
+      info=td_list_entry(dir_walker, list_cluster_t, list);
       if(info->cluster>=2 && (info->cluster-2)*cluster_size<info->offset)
       {
 	unsigned int sol_cur;
@@ -753,15 +753,15 @@
   int blocksize_ok=0;
   unsigned int blocksize;
   *offset=0;
-  if(list_empty(&list_file->list))
+  if(td_list_empty(&list_file->list))
     return default_blocksize;
   for(blocksize=128*512;blocksize>=default_blocksize && blocksize_ok==0;blocksize=blocksize>>1)
   {
-    struct list_head *search_walker = NULL;
+    struct td_list_head *search_walker = NULL;
     blocksize_ok=1;
     {
       alloc_data_t *tmp;
-      tmp=list_entry(list_file->list.next, alloc_data_t, list);
+      tmp=td_list_entry(list_file->list.next, alloc_data_t, list);
       *offset=tmp->start%blocksize;
     }
     for(search_walker=list_file->list.next;
@@ -769,7 +769,7 @@
       search_walker=search_walker->next)
     {
       alloc_data_t *current_file;
-      current_file=list_entry(search_walker, alloc_data_t, list);
+      current_file=td_list_entry(search_walker, alloc_data_t, list);
       if(current_file->start%blocksize!=*offset)
 	blocksize_ok=0;
     }
@@ -780,18 +780,18 @@
 
 alloc_data_t * update_blocksize(unsigned int blocksize, alloc_data_t *list_search_space, const uint64_t offset)
 {
-  struct list_head *search_walker = NULL;
-  struct list_head *search_walker_next = NULL;
-  list_for_each_safe(search_walker,search_walker_next,&list_search_space->list)
+  struct td_list_head *search_walker = NULL;
+  struct td_list_head *search_walker_next = NULL;
+  td_list_for_each_safe(search_walker,search_walker_next,&list_search_space->list)
   {
     alloc_data_t *current_search_space;
-    current_search_space=list_entry(search_walker, alloc_data_t, list);
+    current_search_space=td_list_entry(search_walker, alloc_data_t, list);
     current_search_space->start=(current_search_space->start-offset%blocksize+blocksize-1)/blocksize*blocksize+offset%blocksize;
     if(current_search_space->start>current_search_space->end)
     {
-      list_del(search_walker);
+      td_list_del(search_walker);
       if(list_search_space==current_search_space)
-	list_search_space=list_entry(search_walker_next, alloc_data_t, list);
+	list_search_space=td_list_entry(search_walker_next, alloc_data_t, list);
       free(current_search_space);
     }
   }
@@ -1240,14 +1240,14 @@
       list_free_add(file_recovery, list_search_space);
       if((*current_search_space)!=list_search_space &&
 	  !((*current_search_space)->start <= *offset && *offset <= (*current_search_space)->end))
-	*current_search_space=list_entry((*current_search_space)->list.next, alloc_data_t, list);
+	*current_search_space=td_list_entry((*current_search_space)->list.next, alloc_data_t, list);
     }
     else if(status!=STATUS_EXT2_ON_SAVE_EVERYTHING && status!=STATUS_EXT2_OFF_SAVE_EVERYTHING && status!=STATUS_FIND_OFFSET)
     {
       list_search_space=update_search_space(file_recovery,list_search_space,current_search_space,offset,blocksize);
       file_recovered=1;
     }
-    list_delete(file_recovery->location.next);
+    td_list_delete(file_recovery->location.next);
     file_recovery->location.next=NULL;
   }
   if(file_recovery->file_size==0 && file_recovery->offset_error!=0)
diff -ruw testdisk-6.8.org/src/photorec.h testdisk-6.8/src/photorec.h
--- testdisk-6.8.org/src/photorec.h	2007-07-17 19:24:04.000000000 +0200
+++ testdisk-6.8/src/photorec.h	2007-12-02 22:41:59.000000000 +0100
@@ -9,7 +9,7 @@
 typedef struct list_cluster_struct list_cluster_t;
 struct list_cluster_struct
 {
-  struct list_head list;
+  struct td_list_head list;
   uint64_t offset;
   uint32_t cluster;
   file_data_t *dir_list;
diff -ruw testdisk-6.8.org/src/phrecn.c testdisk-6.8/src/phrecn.c
--- testdisk-6.8.org/src/phrecn.c	2007-07-19 23:39:26.000000000 +0200
+++ testdisk-6.8/src/phrecn.c	2007-12-02 22:41:59.000000000 +0100
@@ -365,8 +365,8 @@
 
 static int photorec_bf(disk_t *disk_car, partition_t *partition, const int debug, const int paranoid, const char *recup_dir, const int interface, file_stat_t *file_stats, unsigned int *file_nbr, unsigned int *blocksize, alloc_data_t *list_search_space, const time_t real_start_time, unsigned int *dir_num, const photorec_status_t status, const unsigned int pass, const unsigned int expert, const unsigned int lowmem)
 {
-  struct list_head *search_walker = NULL;
-  struct list_head *n= NULL;
+  struct td_list_head *search_walker = NULL;
+  struct td_list_head *n= NULL;
   unsigned char *buffer_start;
   unsigned int read_size;
   unsigned int buffer_size;
@@ -385,7 +385,7 @@
     uint64_t offset;
     int need_to_check_file;
     file_recovery_t file_recovery;
-    current_search_space=list_entry(search_walker, alloc_data_t, list);
+    current_search_space=td_list_entry(search_walker, alloc_data_t, list);
     offset=current_search_space->start;
     buffer_olddata=buffer_start;
     buffer=buffer_olddata+(*blocksize);
@@ -394,12 +394,12 @@
     disk_car->read(disk_car,READ_SIZE, buffer, offset);
 #ifdef DEBUG_BF
     {
-      struct list_head *tmp= NULL;
+      struct td_list_head *tmp= NULL;
       log_debug("Explore ");
-      list_for_each(tmp, &list_search_space->list)
+      td_list_for_each(tmp, &list_search_space->list)
       {
 	alloc_data_t *cur_free_space;
-	cur_free_space=list_entry(tmp, alloc_data_t, list);
+	cur_free_space=td_list_entry(tmp, alloc_data_t, list);
 	log_debug(" %lu-%lu",(long unsigned)(cur_free_space->start/disk_car->sector_size),
 	    (long unsigned)(cur_free_space->end/disk_car->sector_size));
 	if(cur_free_space==current_search_space)
@@ -538,7 +538,7 @@
     {
       if(file_finish(&file_recovery,recup_dir,paranoid,file_nbr, *blocksize, list_search_space, &current_search_space, &offset, dir_num,status,disk_car->sector_size,disk_car)<0)
       { /* BF */
-	current_search_space=list_entry(search_walker, alloc_data_t, list);
+	current_search_space=td_list_entry(search_walker, alloc_data_t, list);
 	ind_stop=photorec_bf_aux(disk_car, partition, paranoid, recup_dir, interface, file_stats, file_nbr, &file_recovery, *blocksize, list_search_space, current_search_space, real_start_time, dir_num, status, pass2);
 	pass2++;
       }
@@ -619,11 +619,11 @@
 	  extrablock_offset=element->end/blocksize*blocksize;
       }
       /* Get the corresponding search_place */
-      extractblock_search_space=list_entry(list_search_space->list.next, alloc_data_t, list);
+      extractblock_search_space=td_list_entry(list_search_space->list.next, alloc_data_t, list);
       while(extractblock_search_space != list_search_space &&
 	  !(extractblock_search_space->start <= extrablock_offset &&
 	    extrablock_offset <= extractblock_search_space->end))
-	extractblock_search_space=list_entry(extractblock_search_space->list.next, alloc_data_t, list);
+	extractblock_search_space=td_list_entry(extractblock_search_space->list.next, alloc_data_t, list);
       /* Update extractblock_search_space & extrablock_offset */
       get_next_sector(list_search_space, &extractblock_search_space, &extrablock_offset, blocksize);
       /* */
@@ -730,10 +730,10 @@
   alloc_data_t *current_search_space;
   file_recovery_t file_recovery;
   static alloc_data_t list_file={
-    .list = LIST_HEAD_INIT(list_file.list)
+    .list = TD_LIST_HEAD_INIT(list_file.list)
   };
   static list_cluster_t list_cluster= {
-    .list = LIST_HEAD_INIT(list_cluster.list)
+    .list = TD_LIST_HEAD_INIT(list_cluster.list)
   };
 #define READ_SIZE 256*512
   read_size=((*blocksize)>8192?(*blocksize):8192);
@@ -747,18 +747,18 @@
   memset(buffer_olddata,0,(*blocksize));
   if(debug>1)
   {
-    struct list_head *search_walker = NULL;
+    struct td_list_head *search_walker = NULL;
     log_debug("Explore ");
-    list_for_each(search_walker, &list_search_space->list)
+    td_list_for_each(search_walker, &list_search_space->list)
     {
       alloc_data_t *cur_free_space;
-      cur_free_space=list_entry(search_walker, alloc_data_t, list);
+      cur_free_space=td_list_entry(search_walker, alloc_data_t, list);
       log_debug(" %lu-%lu",(long unsigned)(cur_free_space->start/disk_car->sector_size),
 	  (long unsigned)(cur_free_space->end/disk_car->sector_size));
     }
     log_debug("\n");
   }
-  current_search_space=list_entry(list_search_space->list.next, alloc_data_t, list);
+  current_search_space=td_list_entry(list_search_space->list.next, alloc_data_t, list);
   if(current_search_space!=list_search_space)
     offset=current_search_space->start;
   disk_car->read(disk_car,READ_SIZE, buffer, offset);
@@ -832,7 +832,7 @@
 	      new_file_alloc=(alloc_data_t*)MALLOC(sizeof(*new_file_alloc));
 	      new_file_alloc->start=file_recovery.location.start;
 	      new_file_alloc->end=0;
-	      list_add_tail(&new_file_alloc->list,&list_file.list);
+	      td_list_add_tail(&new_file_alloc->list,&list_file.list);
 	      (*file_nbr)++;
 	    }
 	    if(file_recovery.file_stat->file_hint==&file_hint_dir)
@@ -1080,7 +1080,7 @@
   aff_buffer(BUFFER_RESET,"Q");
   log_info("\nAnalyse\n");
   log_partition(disk_car,partition);
-  if(blocksize==0 || list_empty(&list_search_space->list))
+  if(blocksize==0 || td_list_empty(&list_search_space->list))
   {
     blocksize=disk_car->sector_size;
     blocksize_is_known=0;
@@ -1088,10 +1088,10 @@
   else
     blocksize_is_known=1;
 
-  if(list_empty(&list_search_space->list))
+  if(td_list_empty(&list_search_space->list))
   {
     alloc_data_t *tmp=init_search_space(partition,disk_car);
-    list_add_tail(&tmp->list, &list_search_space->list);
+    td_list_add_tail(&tmp->list, &list_search_space->list);
     if(mode_ext2==0 && carve_free_space_only>0)
     {
       blocksize=remove_used_space(disk_car, partition, list_search_space);
@@ -1103,11 +1103,11 @@
   }
   else
   { /* Correct the values */
-    struct list_head *search_walker = NULL;
-    list_for_each(search_walker, &list_search_space->list)
+    struct td_list_head *search_walker = NULL;
+    td_list_for_each(search_walker, &list_search_space->list)
     {
       alloc_data_t *current_search_space;
-      current_search_space=list_entry(search_walker, alloc_data_t, list);
+      current_search_space=td_list_entry(search_walker, alloc_data_t, list);
       current_search_space->start=current_search_space->start*disk_car->sector_size;
       current_search_space->end=current_search_space->end*disk_car->sector_size+disk_car->sector_size-1;
     }
@@ -1266,15 +1266,15 @@
     }
   }
   {
-    struct list_head *search_walker = NULL;
-    struct list_head *search_walker_next = NULL;
+    struct td_list_head *search_walker = NULL;
+    struct td_list_head *search_walker_next = NULL;
     unsigned long int nbr_headers=0;
     uint64_t sectors_with_unknown_data=0;
     /* Free memory */
-    list_for_each_safe(search_walker,search_walker_next,&list_search_space->list)
+    td_list_for_each_safe(search_walker,search_walker_next,&list_search_space->list)
     {
       alloc_data_t *current_search_space;
-      current_search_space=list_entry(search_walker, alloc_data_t, list);
+      current_search_space=td_list_entry(search_walker, alloc_data_t, list);
       if(current_search_space->file_stat!=NULL)
       {
 	nbr_headers++;
@@ -1290,7 +1290,7 @@
 	      current_search_space->file_stat->file_hint->extension:""):
 	     "(null)"));
       }
-      list_del(search_walker);
+      td_list_del(search_walker);
       free(current_search_space);
     }
     log_info("%llu sectors contains unknown data, %lu invalid files found %s.\n",
@@ -1533,12 +1533,12 @@
   };
   char *current_cmd=cmd_run;
   alloc_data_t list_search_space={
-    .list = LIST_HEAD_INIT(list_search_space.list)
+    .list = TD_LIST_HEAD_INIT(list_search_space.list)
   };
   if(cmd_device==NULL)
   {
     session_load(&cmd_device, &current_cmd,&list_search_space);
-    if(cmd_device!=NULL && current_cmd!=NULL && !list_empty(&list_search_space.list) && ask_confirmation("Continue previous session ? (Y/N)")!=0)
+    if(cmd_device!=NULL && current_cmd!=NULL && !td_list_empty(&list_search_space.list) && ask_confirmation("Continue previous session ? (Y/N)")!=0)
     {
       /* yes */
     }
@@ -2041,7 +2041,7 @@
       (unsigned long long)((*current_search_space)->end)/512);
 #endif
   if((*current_search_space) != list_search_space)
-    *current_search_space=list_entry((*current_search_space)->list.next, alloc_data_t, list);
+    *current_search_space=td_list_entry((*current_search_space)->list.next, alloc_data_t, list);
   *offset=(*current_search_space)->start;
 }
 
diff -ruw testdisk-6.8.org/src/savehdr.c testdisk-6.8/src/savehdr.c
--- testdisk-6.8.org/src/savehdr.c	2007-07-06 16:35:45.000000000 +0200
+++ testdisk-6.8/src/savehdr.c	2007-12-02 22:41:59.000000000 +0100
@@ -137,7 +137,7 @@
 	log_debug("new disk: %s\n",pos);
       }
       if(new_backup!=NULL)
-	list_add_tail(&new_backup->list,&list_backup->list);
+	td_list_add_tail(&new_backup->list,&list_backup->list);
       new_backup=(backup_disk_t*)MALLOC(sizeof(*new_backup));
       new_backup->description[0]='\0';
       new_backup->list_part=NULL;
@@ -196,7 +196,7 @@
     }
   }
   if(new_backup!=NULL)
-    list_add_tail(&new_backup->list,&list_backup->list);
+    td_list_add_tail(&new_backup->list,&list_backup->list);
   fclose(f_backup);
   free(buffer);
   return list_backup;
diff -ruw testdisk-6.8.org/src/savehdr.h testdisk-6.8/src/savehdr.h
--- testdisk-6.8.org/src/savehdr.h	2007-05-11 11:16:40.000000000 +0200
+++ testdisk-6.8/src/savehdr.h	2007-12-02 22:41:59.000000000 +0100
@@ -23,7 +23,7 @@
 typedef struct backup_disk backup_disk_t;
 struct backup_disk
 {
-  struct list_head list;
+  struct td_list_head list;
   time_t my_time;
   char description[128];
   list_part_t *list_part;
diff -ruw testdisk-6.8.org/src/sessionp.c testdisk-6.8/src/sessionp.c
--- testdisk-6.8.org/src/sessionp.c	2007-07-06 16:32:42.000000000 +0200
+++ testdisk-6.8/src/sessionp.c	2007-12-02 22:41:59.000000000 +0100
@@ -142,7 +142,7 @@
 	  new_free_space->start=start;
 	  new_free_space->end=end;
 	  new_free_space->file_stat=NULL;
-	  list_add_tail(&new_free_space->list, &list_free_space->list);
+	  td_list_add_tail(&new_free_space->list, &list_free_space->list);
 #ifdef DEBUG
 	  log_trace(">%lu-%lu<\n",start,end);
 #endif
@@ -161,7 +161,7 @@
 
 int session_save(alloc_data_t *list_free_space, disk_t *disk_car, const partition_t *partition, const file_enable_t *files_enable, const unsigned int blocksize, const int debug)
 {
-  struct list_head *free_walker = NULL;
+  struct td_list_head *free_walker = NULL;
   FILE *f_session;
   unsigned int i;
   if(debug>1)
@@ -183,10 +183,10 @@
     }
   }
   fprintf(f_session,"search,inter\n");
-  list_for_each(free_walker, &list_free_space->list)
+  td_list_for_each(free_walker, &list_free_space->list)
   {
     alloc_data_t *current_free_space;
-    current_free_space=list_entry(free_walker, alloc_data_t, list);
+    current_free_space=td_list_entry(free_walker, alloc_data_t, list);
     fprintf(f_session,"%lu-%lu\n",(long unsigned)(current_free_space->start/disk_car->sector_size),
 	(long unsigned)(current_free_space->end/disk_car->sector_size));
   }
