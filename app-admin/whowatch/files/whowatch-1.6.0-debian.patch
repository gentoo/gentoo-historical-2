Taken from the Debian patch at http://ftp.de.debian.org/debian/pool/main/w/whowatch/whowatch_1.6.0a-2.diff.gz


diff -Nru whowatch-1.6.0.orig/src/block.c whowatch-1.6.0/src/block.c
--- whowatch-1.6.0.orig/src/block.c	2001-06-13 00:56:23.000000000 +0200
+++ whowatch-1.6.0/src/block.c	2006-06-15 01:54:05.000000000 +0200
@@ -3,6 +3,7 @@
  * is used. Pre-allocated memory is managed by a bit map.
  */
 
+#include <time.h>
 #include "whowatch.h"
 
 #define USED 		1
@@ -42,10 +43,11 @@
 {
 	struct _block_tbl_t *tmp;
 	tmp = calloc(1, sizeof *tmp);
-	if(!tmp) prg_exit(__FUNCTION__ ": Cannot allocate memory.\n");
+	if(!tmp) prg_exit("new_block(): Cannot allocate memory. [1]\n");
 	tmp->_block_t = calloc(1, size * TBL_SIZE);
-dolog(__FUNCTION__ ":new block(%d) - alloc size = %d\n", nr_blocks, size * TBL_SIZE);
-	if(!tmp->_block_t) prg_exit(__FUNCTION__ ": Cannot allocate memory.\n");
+	dolog("%s: new block(%d) - alloc size = %d\n",
+		__FUNCTION__, nr_blocks, size * TBL_SIZE);
+	if(!tmp->_block_t) prg_exit("new_block(): Cannot allocate memory. [2]\n");
 	list_add(&tmp->head, h);
 	return tmp;
 }
@@ -68,15 +70,17 @@
 		}
 nr++;
 	}
-	dolog(__FUNCTION__": no empty space, getting new one.\n");
+	dolog("%s: no empty space, getting new one.\n", __FUNCTION__);
 	tmp = new_block(size, h);
 	i = 0;
 FOUND:
-	dolog(__FUNCTION__": empty in %d block at %d pos\n", nr, i);
+	dolog("%s: empty in %d block at %d pos\n", __FUNCTION__, nr, i);
 	tmp->map |= 1<<i;
 	return tmp->_block_t + (size * i);
 }
 
+#if 0
+/* dead code */
 /*
  * Free all unused blocks of memory (map == 0)
  */
@@ -85,12 +89,12 @@
 	struct _block_tbl_t *tmp;
 	struct list_head *t, *p;
 	t = head->next;
-dolog(__FUNCTION__": entering\n");
+	dolog("%s: entering\n", __FUNCTION__);
 	while(t != head) {
 		tmp = list_entry(t, struct _block_tbl_t, head);
 		p = t->next;
 		if(!tmp->map) {
-			dolog(__FUNCTION__": empty block found %p\n", tmp);
+			dolog("%s: empty block found %p\n", __FUNCTION__, tmp);
 			free(tmp->_block_t);
 			list_del(&tmp->head);
 			free(tmp);
@@ -98,6 +102,7 @@
 		t = p;
 	}
 }
+#endif
 
 /*
  * Find entry pointed by p and mark it unused.
@@ -113,13 +118,13 @@
 			goto FOUND;
 		i++;
 	}
-	dolog(__FUNCTION__ ":entry not found - error\n");
+	dolog("%s: entry not found - error\n", __FUNCTION__);
 	return -1;
 FOUND:
-	dolog(__FUNCTION__": %p pointer found in %d\n", p, i);
+	dolog("%s: %p pointer found in %d\n", __FUNCTION__, p, i);
 	tmp->map &= ~(1<<(p - tmp->_block_t)/size);
-	dolog(__FUNCTION__": setting map pos %d to zero, map = %x\n",
-		(p - tmp->_block_t)/size, tmp->map);
+	dolog("%s: setting map pos %d to zero, map = %x\n",
+		__FUNCTION__, (p - tmp->_block_t)/size, tmp->map);
 	return 0;
 }		 	
 
diff -Nru whowatch-1.6.0.orig/src/dialects/linux/proc_plugin.c whowatch-1.6.0/src/dialects/linux/proc_plugin.c
--- whowatch-1.6.0.orig/src/dialects/linux/proc_plugin.c	2001-05-21 04:05:53.000000000 +0200
+++ whowatch-1.6.0/src/dialects/linux/proc_plugin.c	2006-06-15 01:54:05.000000000 +0200
@@ -6,6 +6,7 @@
  * gives better performance)
  */
 #include <err.h>
+#include <time.h>
 #include "pluglib.h"
 #include "whowatch.h"
 
@@ -40,7 +41,9 @@
 	println(v);
 }
 
-static int used;
+#if 0
+static int used;	/* unused */
+#endif
 struct netconn_t {
 	struct list_head n_list;
 	struct list_head n_hash;
@@ -97,7 +100,7 @@
 
 static inline void add_to_hash(struct netconn_t *c, int inode)
 {
-//dolog(__FUNCTION__ ": inode %d, %s\n",inode, ip_addr(c));
+	// dolog("%s: inode %d, %s\n", __FUNCTION__,inode, ip_addr(c));
 	list_add(&c->n_hash, tcp_hashtable + hash(inode));
 }		
 
@@ -106,15 +109,15 @@
 	struct list_head *h, *tmp;
 	struct netconn_t *t;
 	tmp  = head + hash(inode);
-//dolog(__FUNCTION__": looking for %d (hash %d)\n", inode, hash(inode));
+	// dolog("%s: looking for %d (hash %d)\n", __FUNCTION__, inode, hash(inode));
 	list_for_each(h, tmp) {
 		t = list_entry(h, struct netconn_t, n_hash);
 		if(inode == t->inode) {
-//dolog(__FUNCTION__ ": found [%d]\n", t->inode);		
+	// dolog("%s: found [%d]\n", __FUNCTION__, t->inode);		
 			return t;
 }			
 	}
-//dolog(__FUNCTION__ ": [%d] not found\n", inode);	
+	// dolog("%s: [%d] not found\n", __FUNCTION__, inode);	
 	return 0;
 }
 
@@ -128,7 +131,7 @@
 	t->inode = inode;
 	add_to_hash(t, inode);
 	list_add(&t->n_list, &tcp_l);
-dolog(__FUNCTION__": new conn [%d]\n", inode);	
+	dolog("%s: new conn [%d]\n", __FUNCTION__, inode);	
 	return t;
 }
 
@@ -140,25 +143,23 @@
 	i = sscanf(s, "%x:%x %x:%x %x", &t.s_addr, &t.s_port, 
 			&t.d_addr, &t.d_port, &t.state);
 	if(i != 5) return 0;
-//dolog(__FUNCTION__": entering\n");	
+	// dolog("%s: entering\n", __FUNCTION__);	
 	tmp = tcp_find(inode, tcp_hashtable);
 	if(!tmp) {
-//dolog(__FUNCTION__ ": %d %d %d not found\n", inode, t.s_port, t.d_port);
+	// dolog("%s: %d %d %d not found\n", __FUNCTION__, inode, t.s_port, t.d_port);
 
 		tmp =  new_netconn(inode, &t);		
 		return tmp;
 	}	
 //	t.used = tmp->used = 0;
 	if(!memcmp((char*)&t + offset,(char*)tmp + offset, sizeof(t) - offset)) {
-dolog(__FUNCTION__ ": %d %d %d %s found, not changed\n", 
-inode, t.s_port, t.d_port, tcp_state[t.state-1]);	
+		dolog("%s: %d %d %d %s found, not changed\n",
+			__FUNCTION__, inode, t.s_port, t.d_port, tcp_state[t.state-1]);	
 		return tmp; 
 	}
-dolog(__FUNCTION__ ":  %d %d->%d %d->%d found,changed\n", 
-  inode, t.s_port, t.d_port, tmp->s_port, tmp->d_port);	
-
-
-memcpy((char*)&t + offset, (char*)tmp + offset, sizeof(t) - offset);
+	dolog("%s: %d %d->%d %d->%d found,changed\n",
+		__FUNCTION__, inode, t.s_port, t.d_port, tmp->s_port, tmp->d_port);	
+	memcpy((char*)&t + offset, (char*)tmp + offset, sizeof(t) - offset);
 /*
 	tmp->s_addr = t.s_addr;	
 	tmp->s_addr = t.s_addr;	
@@ -184,7 +185,7 @@
 		hash_init(tcp_hashtable); 
 		flag = 1;
 	}	
-//dolog(__FUNCTION__ ": reading tcp connections\n");
+	// dolog("%s: reading tcp connections\n", __FUNCTION__);
 	if(!(f = fopen("/proc/net/tcp", "r"))) return;
 	/* skip titles */
 	fgets(buf, sizeof buf, f);
@@ -198,7 +199,7 @@
 		validate(inode, tmp);
 	}
 	fclose(f);
-//dolog(__FUNCTION__ ": done.\n");	
+	// dolog("%s: done.\n", __FUNCTION__);	
 	return;
 }
 
@@ -225,13 +226,13 @@
 	struct netconn_t *t;
 	unsigned int inode = 0;	
 	if(sscanf(s, "%d", &inode) != 1) return 1;
-//dolog(__FUNCTION__ ": looking for [%d]\n", inode);	
+	// dolog("%s: looking for [%d]\n", __FUNCTION__, inode);	
 	t = tcp_find(inode, tcp_hashtable);
 	if(!t) {
-//dolog(__FUNCTION__ ": %d not found\n", inode);	
+	// dolog("%s: %d not found\n", __FUNCTION__, inode);	
 		return 0;
 	}
-//dolog(__FUNCTION__ ": %d found, printing\n", inode);		
+	// dolog("%s: %d found, printing\n", __FUNCTION__, inode);		
 	print_net_conn(t);
 	return 1;
 }
@@ -241,7 +242,7 @@
 {
 	struct list_head *h;
 	struct netconn_t *t;
-//dolog(__FUNCTION__": looking for %d (hash %d)\n", inode, hash(inode));
+	// dolog("%s: looking for %d (hash %d)\n", __FUNCTION__, inode, hash(inode));
 	list_for_each(h, &tcp_l) {
 		t = list_entry(h, struct netconn_t, n_list);
 		if(t->valid	
@@ -268,8 +269,8 @@
 		return;
 	}
 	if(!count || ticks - count >= 2) {
-//write(1, "\a", 1);	
-//dolog(__FUNCTION__ " reading tcp conn %d %d\n", ticks, ticks%2);	
+	// write(1, "\a", 1);	
+	// dolog("%s reading tcp conn %d %d\n", __FUNCTION__, ticks, ticks%2);	
 	read_tcp_conn();
 	count = ticks;
 
@@ -416,7 +417,7 @@
 		return;
 	}
 	sec = boot_time + i/HZ;
-	s = ctime(&sec);
+	s = ctime((time_t *)&sec);
 	print("%s", s);
 }
 
diff -Nru whowatch-1.6.0.orig/src/dialects/linux/procinfo.c whowatch-1.6.0/src/dialects/linux/procinfo.c
--- whowatch-1.6.0.orig/src/dialects/linux/procinfo.c	2001-05-20 20:22:54.000000000 +0200
+++ whowatch-1.6.0/src/dialects/linux/procinfo.c	2006-06-15 01:54:05.000000000 +0200
@@ -5,6 +5,7 @@
  * gives better performance)
  */
 #include <err.h>
+#include <time.h>
 #include "whowatch.h"
 #include "proctree.h"
 #include "config.h"
diff -Nru whowatch-1.6.0.orig/src/help.c whowatch-1.6.0/src/help.c
--- whowatch-1.6.0.orig/src/help.c	2001-05-16 01:21:59.000000000 +0200
+++ whowatch-1.6.0/src/help.c	2006-06-15 01:54:05.000000000 +0200
@@ -51,7 +51,7 @@
 
 static void show_help(void *unused)
 {
-dolog(__FUNCTION__":printing help\n");
+	dolog("%s: printing help\n", __FUNCTION__);
 	general();
 	if(current == &users_list) userwin_help();
 	if(current == &proc_win) procwin_help();	
diff -Nru whowatch-1.6.0.orig/src/info_box.c whowatch-1.6.0/src/info_box.c
--- whowatch-1.6.0.orig/src/info_box.c	2001-05-10 01:22:59.000000000 +0200
+++ whowatch-1.6.0/src/info_box.c	2006-06-15 01:54:05.000000000 +0200
@@ -66,7 +66,7 @@
 	if(_box.wd) return;
 	set_size();
 	_box.wd = newpad(_box.rows, _box.cols);
-	if(!_box.wd) prg_exit(__FUNCTION__": cannot allocate memory.");
+	if(!_box.wd) prg_exit("box_create(): cannot allocate memory.");
 	wbkgd(_box.wd, COLOR_PAIR(9));
 	werase(_box.wd);
 	box(_box.wd, ACS_VLINE, ACS_HLINE);
diff -Nru whowatch-1.6.0.orig/src/input_box.c whowatch-1.6.0/src/input_box.c
--- whowatch-1.6.0.orig/src/input_box.c	2001-05-13 17:09:27.000000000 +0200
+++ whowatch-1.6.0/src/input_box.c	2006-06-15 01:54:05.000000000 +0200
@@ -127,7 +127,7 @@
 
 void clb(char *s)
 {
-	dolog(__FUNCTION__": in: %s\n", s);
+	dolog("%s: in: %s\n", __FUNCTION__, s);
 }
 
 /* 
diff -Nru whowatch-1.6.0.orig/src/menu.c whowatch-1.6.0/src/menu.c
--- whowatch-1.6.0.orig/src/menu.c	2001-05-16 01:23:08.000000000 +0200
+++ whowatch-1.6.0/src/menu.c	2006-06-15 01:54:05.000000000 +0200
@@ -74,7 +74,7 @@
 	static int pos = TITLE_START;
 	
 	t = calloc(1, sizeof *t);
-	if(!t) prg_exit(__FUNCTION__": cannot allocate memory.");
+	if(!t) prg_exit("add_submenu(): cannot allocate memory.");
 	t->title = s;
 	INIT_LIST_HEAD(&t->items);
 	list_add(&t->l_menu, &menu.submenus);
@@ -101,11 +101,11 @@
 	static unsigned short longest;
 	int len = strlen(i->name);// + strlen(i->descr) + 1;
 	if(!(t = find_submenu(title))) {
-//dolog(__FUNCTION__ ": cannot find title %s\n", title);
+	// dolog("%s: cannot find title %s\n", __FUNCTION__, title);
 		return;
 	}
 	if(len > longest) longest = len;
-//dolog(__FUNCTION__": %d %d %d\n", longest, strlen(i->descr), t->cols);	
+	// dolog("%s: %d %d %d\n", __FUNCTION__, longest, strlen(i->descr), t->cols);	
 	if(longest + strlen(i->descr) + 3 > t->cols) 
 		t->cols = 3 + longest + strlen(i->descr);
 	if(!t->rows) t->rows = 3; /* make space for a border line */
@@ -193,7 +193,7 @@
 {
 	set_size();
 	menu.wd = newpad(1, menu.cols);
-	if(!menu.wd) prg_exit(__FUNCTION__ ": Cannot allocate memory.");
+	if(!menu.wd) prg_exit("menu_create(): Cannot allocate memory.");
 	wbkgd(menu.wd, COLOR_PAIR(9));
 //	overwrite(info_win.wd, menu.wd);
 	werase(menu.wd);
@@ -276,7 +276,7 @@
 		return 1;
 	}
 	if(!menu.wd) return 0;
-dolog(__FUNCTION__"submenu_wd %p\n", submenu_wd);	
+	dolog("%s: submenu_wd %p\n", __FUNCTION__, submenu_wd);	
 	switch(key) {
 	case KBD_ESC:
 		menu_destroy();
@@ -291,7 +291,7 @@
 		if(!submenu_show()) return 1; 
 		if(change_item(cur_item->l_submenu.prev))
 			highlight_item(cur_submenu, 1);
-		dolog(__FUNCTION__": cur item %s\n", cur_item->name);
+		dolog("%s: cur item %s\n", __FUNCTION__, cur_item->name);
 		break;	
 	case KBD_UP:
 		if(!submenu_show()) return 1; 
@@ -308,10 +308,10 @@
 		menu_destroy();
 		break;
 	default: 
-dolog(__FUNCTION__": [%d] skipped\n", key);
+		dolog("%s: [%d] skipped\n", __FUNCTION__, key);
 		return KEY_HANDLED;
 	}
-dolog(__FUNCTION__":[%d] accepted\n", key);
+	dolog("%s: [%d] accepted\n", __FUNCTION__, key);
 	return KEY_HANDLED;
 }
 
diff -Nru whowatch-1.6.0.orig/src/menu_hooks.c whowatch-1.6.0/src/menu_hooks.c
--- whowatch-1.6.0.orig/src/menu_hooks.c	2001-05-16 01:29:14.000000000 +0200
+++ whowatch-1.6.0/src/menu_hooks.c	2006-06-15 01:54:05.000000000 +0200
@@ -9,7 +9,7 @@
 
 void  m_exit(void)
 {
-dolog(__FUNCTION__":entering\n");
+	dolog("%s: entering\n", __FUNCTION__);
 	prg_exit("");
 }	
 void m_details(void)
diff -Nru whowatch-1.6.0.orig/src/menu_hooks.h whowatch-1.6.0/src/menu_hooks.h
--- whowatch-1.6.0.orig/src/menu_hooks.h	2001-05-16 01:23:16.000000000 +0200
+++ whowatch-1.6.0/src/menu_hooks.h	2006-06-15 01:54:05.000000000 +0200
@@ -15,4 +15,4 @@
 void m_hup(void);
 void m_term(void);
 void m_sysinfo(void);
-void m_siglist(void);
\ No newline at end of file
+void m_siglist(void);
diff -Nru whowatch-1.6.0.orig/src/process.c whowatch-1.6.0/src/process.c
--- whowatch-1.6.0.orig/src/process.c	2001-05-16 03:02:44.000000000 +0200
+++ whowatch-1.6.0/src/process.c	2006-06-15 01:54:14.000000000 +0200
@@ -75,7 +75,7 @@
 		memset(z, 0, sizeof *z);
 		check_line(l);
 		z->line = l++;
-		(struct process *) p->priv = z;
+		p->priv = z;
 		z->proc = p;
 		if (*current){
 			z->next = *current;
@@ -275,7 +275,7 @@
 
 	if(!(key&KBD_CTRL)) return KEY_SKIPPED;
 	key &= KBD_MASK;
-dolog(__FUNCTION__": %x %x\n", key, 'H');	
+	dolog("%s: %x %x\n", __FUNCTION__, key, 'H');	
 
 	switch(key) {
 	case 'K': signal = 9; break;
diff -Nru whowatch-1.6.0.orig/src/screen.c whowatch-1.6.0/src/screen.c
--- whowatch-1.6.0.orig/src/screen.c	2001-05-16 01:07:55.000000000 +0200
+++ whowatch-1.6.0/src/screen.c	2006-06-15 01:54:18.000000000 +0200
@@ -41,7 +41,7 @@
 void win_init(void)
 {
 	curs_buf = realloc(curs_buf, screen_cols * sizeof(chtype));
-	if(!curs_buf) errx(1, __FUNCTION__ ": Cannot allocate memory.");
+	if(!curs_buf) errx(1, "%s: Cannot allocate memory.", __FUNCTION__);
 	bzero(curs_buf, sizeof(chtype) * screen_cols);
 	users_list.rows = screen_rows - RESERVED_LINES - 1;
 	users_list.cols = screen_cols - 2; 	
diff -Nru whowatch-1.6.0.orig/src/search.c whowatch-1.6.0/src/search.c
--- whowatch-1.6.0.orig/src/search.c	2001-05-10 02:13:34.000000000 +0200
+++ whowatch-1.6.0/src/search.c	2006-06-15 01:54:18.000000000 +0200
@@ -39,7 +39,7 @@
 	/* move the cursor to appropriate line */
 	to_line(p, current);
 	pad_draw();
-dolog(__FUNCTION__": %d\n", p);
+	dolog("%s: %d\n", __FUNCTION__, p);
 }
 
 
diff -Nru whowatch-1.6.0.orig/src/subwin.c whowatch-1.6.0/src/subwin.c
--- whowatch-1.6.0.orig/src/subwin.c	2001-05-16 01:10:11.000000000 +0200
+++ whowatch-1.6.0/src/subwin.c	2006-06-15 01:54:18.000000000 +0200
@@ -67,7 +67,8 @@
 			sub_current->offset--;
 		break;
 	case 'y':
-dolog(__FUNCTION__": sending %d signal to %d\n" ,signals[sub_current->arrow].sig, cur_pid);
+		dolog("%s: sending %d signal to %d\n",
+			__FUNCTION__, signals[sub_current->arrow].sig, cur_pid);
 		do_signal(signals[sub_current->arrow].sig, cur_pid);
 		return KEY_HANDLED;
 	default: return KEY_SKIPPED;
@@ -116,7 +117,7 @@
 	int size = sizeof signals/sizeof (struct signal_t);
 	char buf[16];
 	int i, pid = *(int *) p;
-dolog(__FUNCTION__": pid %d\n", pid);
+	dolog("%s: pid %d\n", __FUNCTION__, pid);
 	if(pid <= 0) {
 		title("No valid pid selected");
 		return;
@@ -155,11 +156,11 @@
 {
 assert(sub_current);
 	main_pad->wd = newpad(SUBWIN_ROWS, SUBWIN_COLS);
-	if(!main_pad->wd) prg_exit(__FUNCTION__ ": cannot create details window.");
+	if(!main_pad->wd) prg_exit("pad_create(): cannot create details window. [1]");
 	set_size(main_pad);
 	w->offset = w->lines = w->xoffset = 0;
 	border_wd = newpad(BORDER_ROWS+1, BORDER_COLS+1);
-	if(!border_wd) prg_exit(__FUNCTION__ ": cannot create details window.");
+	if(!border_wd) prg_exit("pad_create(): cannot create details window. [2]");
 	wbkgd(border_wd, COLOR_PAIR(8));
 	werase(border_wd);
 	box(border_wd, ACS_VLINE, ACS_HLINE);
@@ -198,10 +199,10 @@
  */
 static void *on_cursor(void)
 {
-	static void *p = 0;
+	static void *p = NULL;
 	static int pid;
 	if(current == &users_list)
-		(char *)p = cursor_user()->name;
+		p = cursor_user()->name;
 	else {
 		pid = cursor_pid();
 		p = &pid;
@@ -218,7 +219,7 @@
 {
 	void *p;
 assert(sub_current);
-dolog(__FUNCTION__":entering\n");	
+	dolog("%s: entering\n", __FUNCTION__);	
 	if(!main_pad->wd) return;
 	werase(main_pad->wd);
 	sub_current->lines = 0; 
@@ -226,7 +227,7 @@
 	if(sub_current == &sub_info) {
 		draw_plugin(0);
 //		pad_refresh();
-dolog(__FUNCTION__"; info only..skipping draw\n");
+		dolog("%s; info only..skipping draw\n", __FUNCTION__);
 		return;
 	}
 	p = on_cursor();
@@ -242,7 +243,7 @@
 		draw_plugin(p);
 	}		
 	else {
-dolog(__FUNCTION__"; only builtin draw\n");
+		dolog("%s; only builtin draw\n", __FUNCTION__);
 		sub_current->builtin_draw(p);
 	}	
 	/* number of data lines probably has changed - adjust offset */
@@ -316,7 +317,7 @@
 		snprintf(dlerr, sizeof dlerr, "%s", dlerror());
 		return dlerr;
 	}
-dolog(__FUNCTION__" dlopen returned %x\n", h);
+	dolog("%s: dlopen returned %x\n", __FUNCTION__, h);
 	/* 
 	 * Check if the same plugin has been loaded. 
 	 * Plugin's name could be the same but code could be different.
@@ -325,10 +326,12 @@
 	 */
 	for(i = 0; i < sizeof sb/sizeof(struct subwin *); i++) {
 		if(sb[i]->handle == h) {
-dolog(__FUNCTION__": subwin %d has handle %x\n", i, sb[i]->handle); 		
+			dolog("%s: subwin %d has handle %x\n",
+				__FUNCTION__, i, sb[i]->handle); 		
 			dlclose(h);
 			dlclose(sb[i]->handle);
-dolog(__FUNCTION__": plugin already loaded in subwin %d, count %d\n", i, i);
+			dolog("%s: plugin already loaded in subwin %d, count %d\n",
+				__FUNCTION__, i, i);
 			sb[i]->handle = h = 0;
 			goto AGAIN;
 		break;
@@ -352,14 +355,15 @@
 	if(target->handle) {
 		int i;
 		i = dlclose(target->handle);
-dolog(__FUNCTION__": closing prev library: %d %s\n", i, dlerror());
-}
-dolog(__FUNCTION__": plugin loaded\n");	
+		dolog("%s: closing prev library: %d %s\n",
+			__FUNCTION__, i, dlerror());
+	}
+	dolog("%s: plugin loaded\n", __FUNCTION__);
 	target->handle = h;
 	target->flags = target->plugin_init(on_cursor());
 	return 0;
 ERROR:
-dolog(__FUNCTION__": plugin not loaded\n");
+	dolog("%s: plugin not loaded\n", __FUNCTION__);
 	snprintf(dlerr, sizeof dlerr, "%s", err);
 	dlclose(h);
 	return dlerr;
@@ -398,7 +402,7 @@
 	sub_main.plugin_clear = dummy;
 	sub_main.plugin_cleanup = dummy;
 	main_pad = calloc(1, sizeof(struct pad_t));
-	if(!main_pad) prg_exit(__FUNCTION__": cannot allocate memory.");
+	if(!main_pad) prg_exit("subwin_init(): cannot allocate memory.");
 	sub_main.arrow = -1;
 	memcpy(&sub_proc, &sub_main, sizeof(sub_main));
 	memcpy(&sub_user, &sub_main, sizeof(sub_main));
@@ -412,7 +416,7 @@
 	sub_current = &sub_user;
 	/* set builtin plugins */
 	builtin_set();
-dolog(__FUNCTION__": %d %d\n", sub_main.arrow, sub_proc.arrow);
+	dolog("%s: %d %d\n", __FUNCTION__, sub_main.arrow, sub_proc.arrow);
 	
 }
 
@@ -442,11 +446,11 @@
 		}	
 	default: return KEY_SKIPPED;
 	}
-dolog(__FUNCTION__": key processed\n");	
-dolog(__FUNCTION__": cur %d, %d %d\n", sub_current->arrow, sub_main.arrow, sub_proc.arrow);
+	dolog("%s: key processed\n", __FUNCTION__);	
+	dolog("%s: cur %d, %d %d\n", __FUNCTION__, sub_current->arrow, sub_main.arrow, sub_proc.arrow);
 
 	sub_change(sub_current);
-dolog(__FUNCTION__": cur %d, %d %d\n", sub_current->arrow, sub_main.arrow, sub_proc.arrow);
+	dolog("%s: cur %d, %d %d\n", __FUNCTION__, sub_current->arrow, sub_main.arrow, sub_proc.arrow);
 
 	return KEY_HANDLED;
 }
@@ -455,10 +459,10 @@
 {
 	if(!main_pad->wd) return;
 	if(sub_current->flags & PERIODIC) {
-dolog(__FUNCTION__": doing plugin (and perhaps builtin) draw\n");
+	dolog("%s: doing plugin (and perhaps builtin) draw\n", __FUNCTION__);
 		pad_draw();
 	}
-dolog(__FUNCTION__": doing refresh\n");
+	dolog("%s: doing refresh\n", __FUNCTION__);
 	pad_refresh();
 }
 
diff -Nru whowatch-1.6.0.orig/src/user.c whowatch-1.6.0/src/user.c
--- whowatch-1.6.0.orig/src/user.c	2001-05-10 02:15:20.000000000 +0200
+++ whowatch-1.6.0/src/user.c	2006-06-15 01:54:18.000000000 +0200
@@ -57,7 +57,7 @@
 	int i;
 	struct prot_t *t;
 	users_list.d_lines += p;
-dolog(__FUNCTION__": dlines %d\n", users_list.d_lines);	
+	dolog("%s : dlines %d\n", __FUNCTION__, users_list.d_lines);	
 	for(i = 0; i < sizeof prot_tab/sizeof(struct prot_t); i++){
 		t = &prot_tab[i];
 		if(strncmp(t->s, name, strlen(t->s))) continue;
@@ -217,7 +217,7 @@
 	while((i = read(wtmp_fd, &entry, sizeof entry)) > 0){ 
 		if (i < sizeof entry){
 			curses_end();
-			errx(1, __FUNCTION__ ": error reading " WTMP_FILE );
+			errx(1, "%s: error reading %s", __FUNCTION__, WTMP_FILE );
 		}
 		/* user just logged in */
 #ifdef HAVE_USER_PROCESS
@@ -328,11 +328,11 @@
 void users_init(void)
 {
         if((wtmp_fd = open(WTMP_FILE ,O_RDONLY)) == -1)
-                errx(1, __FUNCTION__ ": cannot open " WTMP_FILE ": %s",
-                        strerror(errno));
+                errx(1, "%s: cannot open %s, %s",
+			__FUNCTION__, WTMP_FILE, strerror(errno));
         if(lseek(wtmp_fd, 0, SEEK_END) == -1)
-                errx(1, __FUNCTION__  ": cannot seek in " WTMP_FILE ": %s",
-			strerror(errno));
+                errx(1, "%s: cannot seek in %s, %s",
+			__FUNCTION__, WTMP_FILE, strerror(errno));
 	users_list.giveme_line = users_list_giveline;
 	users_list.keys = ulist_key;
 	users_list.periodic = periodic;
diff -Nru whowatch-1.6.0.orig/src/user_plugin.c whowatch-1.6.0/src/user_plugin.c
--- whowatch-1.6.0.orig/src/user_plugin.c	2001-05-10 01:27:39.000000000 +0200
+++ whowatch-1.6.0/src/user_plugin.c	2006-06-15 01:54:18.000000000 +0200
@@ -25,5 +25,3 @@
 	title("SHELL: "); println("%s", pw->pw_shell);
 	title("GECOS: "); println("%s", pw->pw_gecos);
 }
-
-	
\ No newline at end of file
diff -Nru whowatch-1.6.0.orig/src/whowatch.c whowatch-1.6.0/src/whowatch.c
--- whowatch-1.6.0.orig/src/whowatch.c	2001-05-16 01:00:37.000000000 +0200
+++ whowatch-1.6.0/src/whowatch.c	2006-06-15 01:54:18.000000000 +0200
@@ -152,7 +152,7 @@
 	default: return;
 	}
 SKIP:
-dolog(__FUNCTION__": doing refresh\n");
+	dolog("%s: doing refresh\n", __FUNCTION__);
 	wnoutrefresh(main_win);
 	wnoutrefresh(info_win.wd);
 	pad_refresh();
@@ -170,7 +170,7 @@
 		*x = win.ws_col;
 		return;
 	}
-	prg_exit(__FUNCTION__ ": ioctl error: cannot read screen size.");
+	prg_exit("get_row_cols(): ioctl error: cannot read screen size.");
 }								
 
 static void winch_handler()
diff -Nru whowatch-1.6.0a.orig/configure.in whowatch-1.6.0a/configure.in
--- whowatch-1.6.0a.orig/configure.in	2001-05-13 17:25:40.000000000 +0200
+++ whowatch-1.6.0a/configure.in	2006-06-23 19:33:20.000000000 +0200
@@ -6,7 +6,6 @@
 AC_SUBST(VERSION)
 AC_SUBST(PACKAGE)
 AC_CONFIG_HEADER(src/config.h)
-AC_CONFIG_HEADER(src/config.h)
 
 dnl Checks for programs.
 AC_PROG_CC
@@ -84,6 +83,7 @@
 AC_MSG_CHECKING([whether select() modifies the time value])
 AC_TRY_RUN([#include <sys/types.h>
 #include <sys/time.h>
+#include <stdlib.h>
 #include <unistd.h>
 
 int main()
@@ -91,8 +91,8 @@
 int retval;
 fd_set rfds;
 struct timeval tv = {1, 0};
-FD_ZERO(&rfds); FD_SET(0,&rfds);
-select(1,&rfds,0,0,&tv);
+FD_ZERO(&rfds); FD_SET(1,&rfds);
+select(1,&rfds,NULL,NULL,&tv);
 if(tv.tv_sec == 0) exit(0);
 else exit(1);
 }
