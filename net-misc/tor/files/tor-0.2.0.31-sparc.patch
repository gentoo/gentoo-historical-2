--- src/or/buffers.c-	2008-11-13 22:41:16.000000000 +0000
+++ src/or/buffers.c	2008-11-13 22:46:46.000000000 +0000
@@ -957,7 +957,8 @@
     return 0;
   peek_from_buf(hdr, sizeof(hdr), buf);
 
-  command = *(uint8_t*)(hdr+2);
+  /* command = *(uint8_t*)(hdr+2); */
+  command = get_uint8(hdr+2);
   if (!(CELL_COMMAND_IS_VAR_LENGTH(command)))
     return 0;
 
@@ -966,7 +967,8 @@
     return 1;
   result = var_cell_new(length);
   result->command = command;
-  result->circ_id = ntohs(*(uint16_t*)hdr);
+  /* result->circ_id = ntohs(*(uint16_t*)hdr); */
+  result->circ_id = ntohs(get_uint16(hdr));
 
   buf_remove_from_front(buf, VAR_CELL_HEADER_SIZE);
   peek_from_buf(result->payload, length, buf);
--- src/or/connection_or.c-	2008-06-13 05:12:28.000000000 +0000
+++ src/or/connection_or.c	2008-11-13 22:48:56.000000000 +0000
@@ -157,8 +157,12 @@
 void
 var_cell_pack_header(const var_cell_t *cell, char *hdr_out)
 {
+	/*
   *(uint16_t*)(hdr_out) = htons(cell->circ_id);
   *(uint8_t*)(hdr_out+2) = cell->command;
+  */
+  set_uint16(hdr_out, htons(cell->circ_id));
+  set_uint8(hdr_out+2, cell->command);
   set_uint16(hdr_out+3, htons(cell->payload_len));
 }
 
--- src/common/compat.h-	2008-11-14 00:17:28.000000000 +0000
+++ src/common/compat.h	2008-11-14 00:18:31.000000000 +0000
@@ -454,8 +454,10 @@
 /* ===== OS compatibility */
 const char *get_uname(void);
 
+uint8_t get_uint8(const char *cp) ATTR_PURE ATTR_NONNULL((1));
 uint16_t get_uint16(const char *cp) ATTR_PURE ATTR_NONNULL((1));
 uint32_t get_uint32(const char *cp) ATTR_PURE ATTR_NONNULL((1));
+void set_uint8(char *cp, uint8_t v) ATTR_NONNULL((1));
 void set_uint16(char *cp, uint16_t v) ATTR_NONNULL((1));
 void set_uint32(char *cp, uint32_t v) ATTR_NONNULL((1));
 
--- src/common/compat.c-	2008-11-14 00:23:11.000000000 +0000
+++ src/common/compat.c	2008-11-14 00:21:34.000000000 +0000
@@ -407,6 +407,18 @@
 #endif
 
 /**
+ * Read a 8-bit value beginning at <b>cp</b>.  Equivalent to
+ * *(uint8_t*)(cp), but will not cause segfaults on platforms that forbid
+ * unaligned memory access.  (fmccor@gentoo.org)
+ */
+uint8_t
+get_uint8(const char *cp)
+{
+  uint8_t v;
+  memcpy(&v,cp,1);
+  return v;
+}
+/**
  * Read a 16-bit value beginning at <b>cp</b>.  Equivalent to
  * *(uint16_t*)(cp), but will not cause segfaults on platforms that forbid
  * unaligned memory access.
@@ -431,6 +443,15 @@
   return v;
 }
 /**
+ * Set a 8-bit value beginning at <b>cp</b> to <b>v</b>. Equivalent to
+ * *(uint8_t)(cp) = v, but will not cause segfaults on platforms that forbid
+ * unaligned memory access. (fmccor@gentoo.org) */
+void
+set_uint8(char *cp, uint8_t v)
+{
+  memcpy(cp,&v,1);
+}
+/**
  * Set a 16-bit value beginning at <b>cp</b> to <b>v</b>. Equivalent to
  * *(uint16_t)(cp) = v, but will not cause segfaults on platforms that forbid
  * unaligned memory access. */
