--- ospf_lsa.c.orig	Mon Sep 16 23:09:47 2002
+++ ospf_lsa.c	Tue Sep 17 10:03:10 2002
@@ -2535,6 +2535,7 @@
 	if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))
 	  zlog_info("LSA[%s]: is MaxAge", dump_lsa_key (lsa));
 
+#ifdef BUGGY_OPAQUE_LSA_HANDLING
         switch (lsa->data->type)
           {
           case OSPF_AS_EXTERNAL_LSA:
@@ -2547,6 +2548,31 @@
 	    ospf_spf_calculate_schedule ();
             break;
           }
+#else /* BUGGY_OPAQUE_LSA_HANDLING */
+        switch (lsa->data->type)
+          {
+#ifdef HAVE_OPAQUE_LSA
+          case OSPF_OPAQUE_LINK_LSA:
+          case OSPF_OPAQUE_AREA_LSA:
+          case OSPF_OPAQUE_AS_LSA:
+            /*
+             * As a general rule, whenever network topology has changed
+             * (due to an LSA removal in this case), routing recalculation
+             * should be triggered. However, this is not true for opaque
+             * LSAs. Even if an opaque LSA instance is going to be removed
+             * from the routing domain, it does not mean a change in network
+             * topology, and thus, routing recalculation is not needed here.
+             */
+            break;
+#endif /* HAVE_OPAQUE_LSA */
+          case OSPF_AS_EXTERNAL_LSA:
+	    ospf_ase_incremental_update (lsa, ospf_top);
+            break;
+          default:
+	    ospf_spf_calculate_schedule ();
+            break;
+          }
+#endif /* BUGGY_OPAQUE_LSA_HANDLING */
 
 	ospf_lsa_maxage (lsa);
       }
