diff -ur /var/zab/src/vpnc-0.3.2/config.c vpnc-0.3.2/config.c
--- /var/zab/src/vpnc-0.3.2/config.c	2004-11-21 16:11:48.000000000 -0800
+++ vpnc-0.3.2/config.c	2005-01-04 09:58:35.000000000 -0800
@@ -352,7 +352,7 @@
 	const char *p, *q;
 
 	for (p = text, q = strchr(p, '\n'); q; p = q+1, q = strchr(p, '\n'))
-		printf("%s%.*s\n", pre, q-p, p);
+		printf("%s%.*s\n", pre, (int)(q-p), p);
 
 	if (*p != '\0')
 		printf("%s%s\n", pre, p);
@@ -423,8 +423,9 @@
 void do_config(int argc, char **argv)
 {
 	char *s;
-	int i, c, known, s_len;
+	int i, c, known;
 	int print_config = 0;
+	size_t s_len;
 
 	for (i = 1; i < argc; i++) {
 		if (argv[i][0] != '-') {
diff -ur /var/zab/src/vpnc-0.3.2/isakmp-pkt.c vpnc-0.3.2/isakmp-pkt.c
--- /var/zab/src/vpnc-0.3.2/isakmp-pkt.c	2004-11-21 14:15:41.000000000 -0800
+++ vpnc-0.3.2/isakmp-pkt.c	2005-01-04 09:56:31.000000000 -0800
@@ -293,14 +293,14 @@
 
 struct isakmp_payload *new_isakmp_payload(uint8_t type)
 {
-	struct isakmp_payload *result = xallocc(sizeof(struct isakmp_packet));
+	struct isakmp_payload *result = xallocc(sizeof(struct isakmp_payload));
 	result->type = type;
 	return result;
 }
 
 struct isakmp_payload *new_isakmp_data_payload(uint8_t type, const void *data, size_t data_length)
 {
-	struct isakmp_payload *result = xallocc(sizeof(struct isakmp_packet));
+	struct isakmp_payload *result = xallocc(sizeof(struct isakmp_payload));
 
 	if (type != ISAKMP_PAYLOAD_KE && type != ISAKMP_PAYLOAD_HASH
 		&& type != ISAKMP_PAYLOAD_SIG && type != ISAKMP_PAYLOAD_NONCE
@@ -697,7 +697,7 @@
 	size_t isakmp_data_len;
 
 	if (data_len < ISAKMP_PAYLOAD_O) {
-		DEBUG(2, printf("packet to short: len = %d < min = %d\n", data_len, ISAKMP_PAYLOAD_O));
+		DEBUG(2, printf("packet to short: len = %lld < min = %d\n", (long long)data_len, ISAKMP_PAYLOAD_O));
 		reason = ISAKMP_N_UNEQUAL_PAYLOAD_LENGTHS;
 		goto error;
 	}
@@ -730,8 +730,8 @@
 	isakmp_data_len = fetch4();
 	hex_dump("len", &isakmp_data_len, UINT32);
 	if (o_data_len != isakmp_data_len) {
-		DEBUG(2, printf("isakmp length does not match packet length: isakmp = %d != datalen = %d\n",
-			isakmp_data_len, o_data_len));
+		DEBUG(2, printf("isakmp length does not match packet length: isakmp = %lld != datalen = %lld\n",
+			(long long)isakmp_data_len, (long long)o_data_len));
 		reason = ISAKMP_N_UNEQUAL_PAYLOAD_LENGTHS;
 		goto error;
 	}
diff -ur /var/zab/src/vpnc-0.3.2/isakmp-pkt.h vpnc-0.3.2/isakmp-pkt.h
--- /var/zab/src/vpnc-0.3.2/isakmp-pkt.h	2004-11-21 14:15:05.000000000 -0800
+++ vpnc-0.3.2/isakmp-pkt.h	2005-01-04 10:03:26.000000000 -0800
@@ -41,7 +41,7 @@
 			uint8_t *data;
 		} lots;
 	} u;
-};
+} __attribute__((packed));
 
 struct isakmp_payload {
 	struct isakmp_payload *next;
@@ -102,7 +102,7 @@
 			struct isakmp_attribute *attributes;
 		} modecfg;
 	} u;
-};
+} __attribute__((packed));
 
 struct isakmp_packet {
 	uint8_t i_cookie[ISAKMP_COOKIE_LENGTH];
@@ -112,7 +112,7 @@
 	uint8_t flags;
 	uint32_t message_id;
 	struct isakmp_payload *payload;
-};
+} __attribute__((packed));
 
 extern void *xallocc(size_t x);
 extern struct isakmp_packet *new_isakmp_packet(void);
diff -ur /var/zab/src/vpnc-0.3.2/sysdep-bsd.c vpnc-0.3.2/sysdep-bsd.c
--- /var/zab/src/vpnc-0.3.2/sysdep-bsd.c	2004-07-04 06:57:30.000000000 -0700
+++ vpnc-0.3.2/sysdep-bsd.c	2005-01-04 10:09:21.000000000 -0800
@@ -74,7 +74,7 @@
 		uint32_t timeout;
 	} header;
 	u_char data[MAX_MRU];
-};
+} __attribute__((packed));
 
 /* Read/write frames from TUN device */
 int tun_write(int fd, char *buf, int len)
diff -ur /var/zab/src/vpnc-0.3.2/tunip.c vpnc-0.3.2/tunip.c
--- /var/zab/src/vpnc-0.3.2/tunip.c	2004-11-17 12:23:43.000000000 -0800
+++ vpnc-0.3.2/tunip.c	2005-01-04 10:56:06.000000000 -0800
@@ -87,8 +87,8 @@
 	unsigned char use_fallback; /* use initial address as fallback? */
 	unsigned char use_dest; /* is dest address known yet? */
 
-	unsigned long spi; /* security parameters index */
-	unsigned long seq_id; /* for replay protection (not implemented) */
+	uint32_t spi; /* security parameters index */
+	uint32_t seq_id; /* for replay protection (not implemented) */
 
 	/* Encryption key */
 	const unsigned char *enc_secret;
@@ -118,12 +118,12 @@
 
 /* A real ESP header (RFC 2406) */
 typedef struct esp_encap_header {
-	unsigned long spi; /* security parameters index */
-	unsigned long seq_id; /* sequence id (unimplemented) */
+	uint32_t spi; /* security parameters index */
+	uint32_t seq_id; /* sequence id (unimplemented) */
 	/* variable-length payload data + padding */
 	/* unsigned char next_header */
 	/* optional auth data */
-} esp_encap_header_t;
+} esp_encap_header_t __attribute__((packed));
 
 struct encap_method {
 	int fd; /* file descriptor for relevant socket */
@@ -136,7 +136,7 @@
 	unsigned int bufsize, bufpayload, var_header_size;
 	int buflen;
 	struct sockaddr_in from;
-	int fromlen;
+	socklen_t fromlen;
 
 	int (*recv) (struct encap_method * encap,
 		unsigned char *buf, unsigned int bufsize, struct sockaddr_in * from);
@@ -151,7 +151,7 @@
 	struct peer_desc *peer, unsigned char *buf, unsigned int bufsize);
 void encap_udp_send_peer(struct encap_method *encap,
 	struct peer_desc *peer, unsigned char *buf, unsigned int bufsize);
-struct peer_desc *peer_find(unsigned long spi, struct encap_method *encap);
+struct peer_desc *peer_find(uint32_t spi, struct encap_method *encap);
 int encap_esp_recv_peer(struct encap_method *encap, struct peer_desc *peer);
 
 /* Yuck! Global variables... */
@@ -220,7 +220,7 @@
 int encap_rawip_recv(struct encap_method *encap,
 	unsigned char *buf, unsigned int bufsize, struct sockaddr_in *from)
 {
-	int r;
+	ssize_t r;
 	struct ip *p = (struct ip *)buf;
 
 	encap->fromlen = sizeof(encap->from);
@@ -231,7 +231,10 @@
 		return -1;
 	}
 	if (r < (p->ip_hl << 2) + encap->fixed_header_size) {
-		syslog(LOG_ALERT, "packet too short from %s", inet_ntoa(encap->from.sin_addr));
+#if 0
+		syslog(LOG_ALERT, "packet too short from %s",
+			inet_ntoa(encap->from.sin_addr));
+#endif
 		return -1;
 	}
 #if 0
@@ -268,7 +271,7 @@
 	unsigned char *buf, unsigned int bufsize,
 	struct sockaddr_in *from)
 {
-	int r;
+	ssize_t r;
 
 	encap->fromlen = sizeof(encap->from);
 
@@ -279,8 +282,10 @@
 		return -1;
 	}
 	if (r < encap->fixed_header_size) {
+#if 0
 		syslog(LOG_ALERT, "packet too short from %s",
 			inet_ntoa(encap->from.sin_addr));
+#endif
 		return -1;
 	}
 
@@ -447,11 +452,11 @@
 /*
  * Find the peer record associated with a given local SPI.
  */
-struct peer_desc *peer_find(unsigned long spi, struct encap_method *encap)
+struct peer_desc *peer_find(uint32_t spi, struct encap_method *encap)
 {
 	if (vpnpeer.local_sa->spi == spi && vpnpeer.local_sa->em == encap)
 		return &vpnpeer;
-	syslog(LOG_ALERT, "unknown spi %ld", spi);
+	syslog(LOG_ALERT, "unknown spi %u", spi);
 	return NULL;
 }
 
@@ -623,7 +628,7 @@
 		return;
 	}
 	if (sent != encap->buflen)
-		syslog(LOG_ALERT, "truncated out (%d out of %d)", sent, encap->buflen);
+		syslog(LOG_ALERT, "truncated out (%llu out of %d)", (unsigned long long)sent, encap->buflen);
 }
 
 /*
@@ -659,8 +664,8 @@
 		return;
 	}
 	if (sent != encap->buflen)
-		syslog(LOG_ALERT, "truncated out (%Zd out of %Zd)",
-			sent, encap->buflen);
+		syslog(LOG_ALERT, "truncated out (%lld out of %d)",
+			(long long)sent, encap->buflen);
 }
 
 int encap_esp_recv_peer(struct encap_method *encap, struct peer_desc *peer)
@@ -838,7 +843,7 @@
 				char addr1[16];
 				strcpy(addr1, inet_ntoa(peer->remote_sa->dest.sin_addr));
 				syslog(LOG_NOTICE,
-					"spi %ld: remote address changed from %s to %s",
+					"spi %u: remote address changed from %s to %s",
 					peer->remote_sa->spi, addr1, inet_ntoa(from.sin_addr));
 				peer->remote_sa->dest.sin_addr.s_addr = from.sin_addr.s_addr;
 				peer->remote_sa->use_dest = 1;
diff -ur /var/zab/src/vpnc-0.3.2/vpnc.c vpnc-0.3.2/vpnc.c
--- /var/zab/src/vpnc-0.3.2/vpnc.c	2004-11-21 16:12:02.000000000 -0800
+++ vpnc-0.3.2/vpnc.c	2005-01-04 09:55:37.000000000 -0800
@@ -468,8 +468,8 @@
 	*r_p = NULL;
 
 	if (r_length < ISAKMP_PAYLOAD_O || ((r_length - ISAKMP_PAYLOAD_O) % s->ivlen != 0)) {
-		DEBUG(2, printf("payload to short or not padded: len=%d, min=%d (ivlen=%d)\n",
-			r_length, ISAKMP_PAYLOAD_O, s->ivlen));
+		DEBUG(2, printf("payload to short or not padded: len=%lld, min=%d (ivlen=%lld)\n",
+			(long long)r_length, ISAKMP_PAYLOAD_O, (long long)s->ivlen));
 		return ISAKMP_N_UNEQUAL_PAYLOAD_LENGTHS;
 	}
 
