#!/usr/bin/env python2
#
# -*- mode: python; -*-
#
# --| Version Information |------------------------------------------
# 
#  etcat v0.1.4 (27 Apr 2003)
#
#  $Header: /var/cvsroot/gentoo-x86/net-misc/cfengine/files/module:cfportage,v 1.1 2003/12/17 15:07:02 tigger Exp $
#
# --| About |--------------------------------------------------------
#
#  This is a module for cfengine which can be used to test the for installed
#  software on a gentoo linux box.
#
#  Several major functions, the layout of this file  and the general code
#  structure were borrowed from the etcat tool by Alastair Tse.
#
# --| License |------------------------------------------------------
#
#  Distributed under the terms of the GNU General Public License v2
#  Copyright (c) 2003 Rob Holland.
#
# --| Usage |--------------------------------------------------------
#
#  module:cfportage [options] || <test_type> <class> <category/package[-ver]>
#
#  -i/installed) defines <class> if the package is installed
#  -n/newer) defines <class> if a later version of the package is installed
#  -N/newerorequal) defines <class> if a later or equal version of the package is installed
#  -o/older) defines <class> if an earlier version of the package is installed
#  -O/olderorequal) defines <class> if an earlier or equal version of the package is installed

import os,sys,string
import getopt
import portage

__author__ = "Rob Holland"
__email__ = "tigger@gentoo.org"
__version__ = "0.2.0"
__productname__ = "module:cfportage"
__description__ = "Packages module for cfengine"

# "option": ("shortcommand","desc")
options = {
	"newer":("n","Defines class if there is a newer version of the package installed"),
	"newerorequal":("N","Defines class if there is a later version of the package installed"),
	"installed":("i","Defines class if there is an exactly matching version of the package installed"),
	"older":("o","Defines class if there is an earlier version of the package installed"),
	"olderorequal":("O","Defines class if there is an earlier or equal version of the package installed"),
}

# .-------------------------------------------------------.
# | Smart Package Version Comparison                      |
# +-------------------------------------------------------+
# | Does more advanced package sorting hueristics         |
# `-------------------------------------------------------'

LETTERS=map(lambda x: chr(x), range(ord('a'),ord('z')))
# find roughly which is the newer version
def vercmp(a, b):
    a_ver = []
    a_min = ""
    a_pre = ""
    a_rev = 0
    b_ver = []
    b_min = ""
    b_pre = ""
    b_rev = 0

    # split into digestable components
    # eg. 1.2.3b_pre4-r5
    # 1. get the 1.2.3 bit
    a_parts = a.split("-")[0].split("_")
    a_ver = a_parts[0].split(".")
    b_parts = b.split("-")[0].split("_")
    b_ver = b_parts[0].split(".")    
    
    # 2. get a,b,c.. or whatever letter at the end
    if a_ver[-1][-1] in LETTERS:
        a_min = a_ver[-1][-1]
        a_ver[-1] = a_ver[-1][:-1]
    if b_ver[-1][-1] in LETTERS:
        b_min = b_ver[-1][-1]
        b_ver[-1] = b_ver[-1][:-1]        
    
    # 2. get the _pre4 bit and -r5 
    if len(a_parts) > 1:
        a_pre = a_parts[1]
    if len(a.split("-")) > 1:
        a_rev = int(a.split("-")[1][1:])
    if len(b_parts) > 1:
        b_pre = b_parts[1]
    if len(b.split("-")) > 1:
        b_rev = int(b.split("-")[1][1:])        

    # 3. do the comparison
    for x in range(len(a_ver)):
        # 3a. convert to numbers
        try:
            a_num = int(a_ver[x])
        except (ValueError, IndexError):
            a_num = 0
        try:
            b_num = int(b_ver[x])
        except (ValueError, IndexError):
            b_num = 0
        # 3b. the comparison
        if a_num == b_num:
            continue
        elif a_num > b_num:
            return 1
        elif a_num < b_num:
            return -1

    # 3c. compare minor ver
    if a_min and not b_min:
        return -1
    elif not a_min and b_min:
        return 1
    elif a_min and b_min and a_min > b_min:
        return 1
    elif a_min and b_min and a_min < b_min:
        return -1

    # 3d. compare pre ver
    if a_pre and not b_pre:
        return -1
    elif not a_pre and b_pre:
        return 1
    elif a_pre and b_pre and a_pre > b_pre:
        return 1
    elif a_pre and b_pre and a_pre < b_pre:
        return -1
    
    # 3e. compare rev
    if a_rev > b_rev:
        return 1
    elif a_rev < b_rev:
        return -1
    else:
        return 0

    
def pkgcmp(a,b):
    # strips out package name and returns the result of vercmp
    awords = a.split("-")
    bwords = b.split("-")
    apkg = [awords[0]]
    bpkg = [bwords[0]]
    DIGITS = ['0','1','2','3','4','5','6','7','8','9']
    
    for w in awords[1:]:
	if w[0] in DIGITS:
	    break
	else:
	    apkg.append(w)
    aver = awords[len(apkg):]
    apkg_str = string.join(apkg, "-")
    aver_str = string.join(aver, "-")
    
    for w in bwords[1:]:
	if w[0] in DIGITS:
	    break
	else:
	    bpkg.append(w)
    bver = bwords[len(bpkg):]
    bpkg_str = string.join(bpkg, "-")
    bver_str = string.join(bver, "-")    
    
    if apkg_str > bpkg_str:
	return 1
    elif bpkg_str > apkg_str:
	return -1
    else:
	return vercmp(aver_str, bver_str)
    
# .-------------------------------------------------------.
# | Package Name Guesser                                  |
# +-------------------------------------------------------+
# | A smart (eg. dodgy) version of portage.catpkgsplit()  |
# | that determines the category, package, version and    |
# | revision given a string. If it doesn't know, it'll    |
# | leave the field blank.                                |
# |                                                       |
# | Returns a list like :                                 |
# |  [ "net-www", "mozilla", "1.1", "r1"]                 |
# `-------------------------------------------------------'    

def smart_pkgsplit(query):
    cat = ''
    pkg = ''
    ver = ''
    rev = ''
    
    if len(query.split('/')) == 2:
	cat = query.split('/')[0]
	query = query.split('/')[1]
    
    components = query.split('-')
    name_components = []
    ver_components = []
	
    # seperate pkg-ver-rev
    for c in components:
	if ver_components:
	    ver_components.append(c)
	elif ord(c[0]) > 47 and ord(c[0]) < 58:
	    ver_components.append(c)
	else:
	    name_components.append(c)
    pkg = '-'.join(name_components)
	
    # check if there is a revision number
    if len(ver_components) > 0 and ver_components[-1][0] == 'r':
	rev = ver_components[-1]
	ver_components = ver_components[:-1]
	
    # check for version number
    if len(ver_components) > 0:
	ver = '-'.join(ver_components)
    
    return [cat, pkg, ver, rev]

# .-------------------------------------------------------.
# | Versions Function                                     |
# +-------------------------------------------------------+
# | Prints out the available version, masked status and   |
# | installed status.                                     |
# `-------------------------------------------------------'	

def test_version(type, define_class, query):
	tup = smart_pkgsplit(query)
	if tup[0] and tup[1]:
		package = tup[0] + "/" + tup[1]
	else:
		print "Couldn't split package name properly. Aborting"
		sys.exit(1)

	if (type != 'installed') and (not tup[2]):
		print "You must specify a version number when using the greater or lesser tests"
		sys.exit(1)
	
	curver = portage.db["/"]["vartree"].dep_bestmatch(package)

	# tests if its installed
	if (type == 'installed') and not tup[2] and curver: print "+" + define_class
	# test if a specific version is installed
	elif (type == 'installed') and curver and (pkgcmp(query, curver) == 0): print "+" + define_class
	# test if a newer version is installed
	elif (type == 'newer') and (pkgcmp(query, curver) == -1): print "+" + define_class
	# test if an older version is installed
	elif (type == 'older') and (pkgcmp(query, curver) == 1): print "+" + define_class
	# test if an equal or newer version is installed
	elif (type == 'newerorequal') and ((pkgcmp(query, curver) == -1) or (pkgcmp(query, curver) == 0)): print "+" + define_class
	# test if an equal or older version is installed
	elif (type == 'olderorequal') and ((pkgcmp(query, curver) == 1) or (pkgcmp(query, curver) == 0)): print "+" + define_class

	sys.exit(0)

def ver():
    print __productname__ + " (" + __version__ + ") - " + __description__ + " - By: " + __author__ + " <" + __email__ + ">"

def help():
    
    ver()
    print
    print "Usage: " + __productname__ + " [ options ] [ test ] class package"
    print
    print "Options/Tests:"
    print
    for name,tup in options.items():
        print " " + name + " (-" + tup[0] + " short option) - " + tup[1]
    print
	
# .-------------------------------------------------------.
# | Main Function                                         |
# `-------------------------------------------------------'
def main():
    
    test = ''
    package = ''
    
    if len(sys.argv) < 3:
	help()
	sys.exit(1)
	
    # delegates the commandline stuff to functions
    pointer = 2
    # short/long opts mapping
    shortopts = map(lambda x: "-" + x[0], options.values())
    short2long = {}
    for k,v in options.items():
	short2long[v[0]] = k
    longopts = options.keys()
    # loop thru arguments
    for arg in sys.argv[1:]:
	if arg[0] == "-" and len(arg) == 2 and arg in shortopts:
	    test = short2long[arg[1]]
	    if (len(sys.argv) - pointer) == 2:
	    	define_class = sys.argv[pointer]
	    	query = sys.argv[pointer+1]
	    else:
		help()
		sys.exit(1)
	    break
	elif arg in longopts:
	    test = arg
	    if (len(sys.argv) - pointer) == 2:
	    	define_class = sys.argv[pointer]
	    	query = sys.argv[pointer+1]
	    else:
		help()
		sys.exit(1)
	    break
	else:
	    pointer += 1
	    
    # abort if we don't have an action or query string
    if not test or not define_class or not query:
    	print "You must specify a class, a test type and a package"
	sys.exit(1)
    else:
    	test_version(test, define_class, query)
    
if __name__ == "__main__":
    try:
	main()
    except KeyboardInterrupt:
	print "Operation Aborted!"
