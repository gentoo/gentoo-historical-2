diff -Naurp -x .svn zaptel-0.9.1/zaptel.c zaptel-0.9.1-devfs26/zaptel.c
--- zaptel-0.9.1/zaptel.c	2004-04-09 19:55:31.000000000 +0200
+++ zaptel-0.9.1-devfs26/zaptel.c	2004-05-04 23:17:44.243915848 +0200
@@ -137,12 +137,14 @@ static struct proc_dir_entry *proc_entri
 
 /* Here are a couple important little additions for devfs */
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 static devfs_handle_t zaptel_devfs_dir;
 static devfs_handle_t channel;
 static devfs_handle_t pseudo;
 static devfs_handle_t ctl;
 static devfs_handle_t timer;
 #endif
+#endif
 /* There is a table like this in the PPP driver, too */
 
 static int deftaps = 64;
@@ -1062,6 +1064,7 @@ static void zt_set_law(struct zt_chan *c
 }
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 static devfs_handle_t register_devfs_channel(struct zt_chan *chan, devfs_handle_t dir)
 {
 	char path[100];
@@ -1104,6 +1107,28 @@ static devfs_handle_t register_devfs_cha
 
 	return chan_dev;
 }
+#else
+static dev_t register_devfs_channel(struct zt_chan *chan, dev_t dir)
+{
+	char path[100];
+	char link[100];
+	dev_t chan_dev;
+	umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
+
+	/* create /dev/zap/span%d/%d channel device node */
+	if ((chan_dev = devfs_mk_cdev(MKDEV(ZT_MAJOR, chan->channo), mode, "zap/span%d/%d", dir, chan->chanpos)) < 0) {
+                printk("zaptel: Something really bad happened.  Unable to register devfs entry\n");
+                return 0;
+	}
+
+	/* link /dev/zap/span%d/%d -> /dev/zap/%d ?!? */
+	sprintf(path, "zap/span%d/%d", dir, chan->chanpos);
+	sprintf(link, "zap/%d", chan->chanpos);
+	devfs_mk_symlink(link, path);
+
+	return chan_dev;
+}
+#endif
 #endif /* CONFIG_DEVFS_FS */
 
 static int zt_chan_reg(struct zt_chan *chan)
@@ -4111,6 +4136,7 @@ int zt_register(struct zt_span *span, in
 #endif
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	{
 		char span_name[50];
 		sprintf(span_name, "span%d", span->spanno);
@@ -4120,6 +4146,15 @@ int zt_register(struct zt_span *span, in
 			chan->fhandle = register_devfs_channel(chan, chan->span->dhandle); /* Register our stuff with devfs */
 		}
 	}
+#else
+	{
+		devfs_mk_dir("zap/span%d", span->spanno);
+		for (x = 0; x < span->channels; x++) {
+			struct zt_chan *chan = &span->chans[x];
+			register_devfs_channel(chan, span->spanno); /* Register our stuff with devfs */
+		}
+	}
+#endif
 #endif /* CONFIG_DEVFS_FS */
 
 	if (debug)
@@ -4159,11 +4194,22 @@ int zt_unregister(struct zt_span *span)
         remove_proc_entry(tempfile, NULL);
 #endif /* CONFIG_PROC_FS */
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	for (x = 0; x < span->channels; x++) {
 		devfs_unregister(span->chans[x].fhandle);
 		devfs_unregister(span->chans[x].fhandle_symlink);
 	}
 	devfs_unregister(span->dhandle);
+#else
+	for (x = 0; x < span->channels; x++) {
+		/* remove symlink first */
+		devfs_remove("zap/span%d/%d", span->spanno, span->chans[x].chanpos);
+		/* remove channel device */
+		devfs_remove("zap/%d", span->chans[x].chanpos);
+	}
+	/* remove span dir */
+	devfs_remove("zap/span%d", span->spanno);
+#endif
 #endif /* CONFIG_DEVFS_FS */
 	spans[span->spanno] = NULL;
 	span->spanno = 0;
@@ -6016,6 +6062,7 @@ static int __init zt_init(void) {
 	proc_entries[0] = proc_mkdir("zaptel", NULL);
 #endif
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	{
 	umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
 	devfs_register_chrdev(ZT_MAJOR, "zaptel", &zt_fops);
@@ -6027,6 +6074,22 @@ static int __init zt_init(void) {
 	ctl = devfs_register(zaptel_devfs_dir, "ctl", DEVFS_FL_DEFAULT, ZT_MAJOR, 0, mode, &zt_fops, NULL);
 	}
 #else
+	{
+		umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
+		if ((res = register_chrdev(ZT_MAJOR, "zaptel", &zt_fops)) < 0) {
+                	printk(KERN_ERR "Unable to register for device on %d, error: %d\n", ZT_MAJOR, res);
+                	return res;
+		}
+
+		devfs_mk_dir("zap");
+
+		devfs_mk_cdev(MKDEV(ZT_MAJOR, 253), mode, "zap/timer");
+		devfs_mk_cdev(MKDEV(ZT_MAJOR, 254), mode, "zap/channel");
+		devfs_mk_cdev(MKDEV(ZT_MAJOR, 255), mode, "zap/pseudo");
+		devfs_mk_cdev(MKDEV(ZT_MAJOR, 0),   mode, "zap/ctl");
+	}
+#endif
+#else
 	if ((res = register_chrdev(ZT_MAJOR, "zaptel", &zt_fops))) {
 		printk(KERN_ERR "Unable to register tor device on %d\n", ZT_MAJOR);
 		return res;
@@ -6057,6 +6120,7 @@ static void __exit zt_cleanup(void) {
 		if (tone_zones[x])
 			kfree(tone_zones[x]);
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	devfs_unregister(timer);
 	devfs_unregister(channel);
 	devfs_unregister(pseudo);
@@ -6065,6 +6129,16 @@ static void __exit zt_cleanup(void) {
 	devfs_unregister_chrdev(ZT_MAJOR, "zaptel");
 #else
 	unregister_chrdev(ZT_MAJOR, "zaptel");
+
+	devfs_remove("zap/timer");
+	devfs_remove("zap/ctl");
+	devfs_remove("zap/pseudo");
+	devfs_remove("zap/channel");
+
+	devfs_remove("zap");
+#endif
+#else
+	unregister_chrdev(ZT_MAJOR, "zaptel");
 #endif
 #ifdef CONFIG_ZAPTEL_WATCHDOG
 	watchdog_cleanup();
diff -Naurp -x .svn zaptel-0.9.1/zaptel.h zaptel-0.9.1-devfs26/zaptel.h
--- zaptel-0.9.1/zaptel.h	2004-03-26 08:44:19.000000000 +0100
+++ zaptel-0.9.1-devfs26/zaptel.h	2004-05-04 23:16:07.000000000 +0200
@@ -46,14 +46,13 @@
 
 #include "ecdis.h"
 #include "fasthdlc.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define LINUX26
 #endif
+#endif /* __KERNEL__ */
 #ifdef CONFIG_DEVFS_FS
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 #include <linux/devfs_fs_kernel.h>
-#else
-#undef CONFIG_DEVFS_FS
-#warning "Zaptel doesn't support DEVFS in post 2.4 kernels.  Disabling DEVFS in zaptel"
-#endif
 #endif /* CONFIG_DEVFS_FS */
 #include <linux/ioctl.h>
 
@@ -61,6 +60,8 @@
 #define ELAST 500
 #endif
 
+
+
 /* Per-span configuration values */
 #define	ZT_CONFIG_TXLEVEL	7	/* bits 0-2 are tx level */
 
@@ -1089,8 +1090,10 @@ struct zt_chan {
 #endif
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	devfs_handle_t fhandle;  /* File handle in devfs for the channel */
 	devfs_handle_t fhandle_symlink;
+#endif
 #endif /* CONFIG_DEVFS_FS */
 };
 
@@ -1219,7 +1222,9 @@ struct zt_span {
 	int lastalarms;		/* Previous alarms */
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	devfs_handle_t dhandle;  /* Directory name */
+#endif
 #endif	
 	/* If the watchdog detects no received data, it will call the
 	   watchdog routine */
@@ -1404,10 +1409,6 @@ static inline short zt_txtone_nextsample
 
 #endif /* CONFIG_CALC_XLAW */
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
-#define LINUX26
-#endif
-
 #endif /* __KERNEL__ */
 
 #endif /* _LINUX_ZAPTEL_H */
