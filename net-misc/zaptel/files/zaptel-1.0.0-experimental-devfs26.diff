--- zaptel-1.0.0/zaptel.c.orig	2004-09-11 17:48:45.000000000 +0200
+++ zaptel-1.0.0/zaptel.c	2004-09-24 00:41:48.856014048 +0200
@@ -143,12 +143,14 @@
 
 /* Here are a couple important little additions for devfs */
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 static devfs_handle_t zaptel_devfs_dir;
 static devfs_handle_t channel;
 static devfs_handle_t pseudo;
 static devfs_handle_t ctl;
 static devfs_handle_t timer;
 #endif
+#endif
 
 /* udev necessary data structures.  Yeah! */
 #ifdef CONFIG_ZAP_UDEV
@@ -1087,6 +1089,7 @@
 }
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 static devfs_handle_t register_devfs_channel(struct zt_chan *chan, devfs_handle_t dir)
 {
 	char path[100];
@@ -1129,6 +1132,28 @@
 
 	return chan_dev;
 }
+#else
+static dev_t register_devfs_channel(struct zt_chan *chan, dev_t dir)
+{
+	char path[100];
+	char link[100];
+	dev_t chan_dev;
+	umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
+
+	/* create /dev/zap/span%d/%d channel device node */
+	if ((chan_dev = devfs_mk_cdev(MKDEV(ZT_MAJOR, chan->channo), mode, "zap/span%d/%d", dir, chan->chanpos)) < 0) {
+                printk("zaptel: Something really bad happened.  Unable to register devfs entry\n");
+                return 0;
+	}
+
+	/* link /dev/zap/span%d/%d -> /dev/zap/%d ?!? */
+	sprintf(path, "zap/span%d/%d", dir, chan->chanpos);
+	sprintf(link, "zap/%d", chan->chanpos);
+	devfs_mk_symlink(link, path);
+
+	return chan_dev;
+}
+#endif
 #endif /* CONFIG_DEVFS_FS */
 
 static int zt_chan_reg(struct zt_chan *chan)
@@ -4285,6 +4310,7 @@
 #endif
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	{
 		char span_name[50];
 		sprintf(span_name, "span%d", span->spanno);
@@ -4294,6 +4320,15 @@
 			chan->fhandle = register_devfs_channel(chan, chan->span->dhandle); /* Register our stuff with devfs */
 		}
 	}
+#else
+	{
+		devfs_mk_dir("zap/span%d", span->spanno);
+		for (x = 0; x < span->channels; x++) {
+			struct zt_chan *chan = &span->chans[x];
+			register_devfs_channel(chan, span->spanno); /* Register our stuff with devfs */
+		}
+	}
+#endif
 #endif /* CONFIG_DEVFS_FS */
 
 #ifdef CONFIG_ZAP_UDEV
@@ -4341,11 +4376,22 @@
         remove_proc_entry(tempfile, NULL);
 #endif /* CONFIG_PROC_FS */
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	for (x = 0; x < span->channels; x++) {
 		devfs_unregister(span->chans[x].fhandle);
 		devfs_unregister(span->chans[x].fhandle_symlink);
 	}
 	devfs_unregister(span->dhandle);
+#else
+	for (x = 0; x < span->channels; x++) {
+		/* remove symlink first */
+		devfs_remove("zap/span%d/%d", span->spanno, span->chans[x].chanpos);
+		/* remove channel device */
+		devfs_remove("zap/%d", span->chans[x].chanpos);
+	}
+	/* remove span dir */
+	devfs_remove("zap/span%d", span->spanno);
+#endif
 #endif /* CONFIG_DEVFS_FS */
 
 #ifdef CONFIG_ZAP_UDEV
@@ -6282,6 +6328,7 @@
 #endif /* CONFIG_ZAP_UDEV */
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	{
 	umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
 	devfs_register_chrdev(ZT_MAJOR, "zaptel", &zt_fops);
@@ -6293,6 +6340,22 @@
 	ctl = devfs_register(zaptel_devfs_dir, "ctl", DEVFS_FL_DEFAULT, ZT_MAJOR, 0, mode, &zt_fops, NULL);
 	}
 #else
+	{
+		umode_t mode = S_IFCHR|S_IRUGO|S_IWUGO;
+		if ((res = register_chrdev(ZT_MAJOR, "zaptel", &zt_fops)) < 0) {
+                	printk(KERN_ERR "Unable to register for device on %d, error: %d\n", ZT_MAJOR, res);
+                	return res;
+		}
+
+		devfs_mk_dir("zap");
+
+		devfs_mk_cdev(MKDEV(ZT_MAJOR, 253), mode, "zap/timer");
+		devfs_mk_cdev(MKDEV(ZT_MAJOR, 254), mode, "zap/channel");
+		devfs_mk_cdev(MKDEV(ZT_MAJOR, 255), mode, "zap/pseudo");
+		devfs_mk_cdev(MKDEV(ZT_MAJOR, 0),   mode, "zap/ctl");
+	}
+#endif
+#else
 	if ((res = register_chrdev(ZT_MAJOR, "zaptel", &zt_fops))) {
 		printk(KERN_ERR "Unable to register tor device on %d\n", ZT_MAJOR);
 		return res;
@@ -6323,6 +6386,7 @@
 		if (tone_zones[x])
 			kfree(tone_zones[x]);
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	devfs_unregister(timer);
 	devfs_unregister(channel);
 	devfs_unregister(pseudo);
@@ -6338,6 +6402,16 @@
 	class_simple_destroy(zap_class);
 #endif /* CONFIG_ZAP_UDEV */
 	unregister_chrdev(ZT_MAJOR, "zaptel");
+
+	devfs_remove("zap/timer");
+	devfs_remove("zap/ctl");
+	devfs_remove("zap/pseudo");
+	devfs_remove("zap/channel");
+
+	devfs_remove("zap");
+#endif
+#else
+	unregister_chrdev(ZT_MAJOR, "zaptel");
 #endif
 #ifdef CONFIG_ZAPTEL_WATCHDOG
 	watchdog_cleanup();
--- zaptel-1.0.0/zaptel.h.orig	2004-09-11 17:48:45.000000000 +0200
+++ zaptel-1.0.0/zaptel.h	2004-09-24 00:40:26.169584296 +0200
@@ -52,12 +52,7 @@
 #include "fasthdlc.h"
 #endif
 #ifdef CONFIG_DEVFS_FS
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 #include <linux/devfs_fs_kernel.h>
-#else
-#undef CONFIG_DEVFS_FS
-//#warning "Zaptel doesn't support DEVFS in post 2.4 kernels.  Disabling DEVFS in zaptel"
-#endif
 #endif /* CONFIG_DEVFS_FS */
 #include <linux/ioctl.h>
 
@@ -65,6 +60,8 @@
 #define ELAST 500
 #endif
 
+
+
 /* Per-span configuration values */
 #define	ZT_CONFIG_TXLEVEL	7	/* bits 0-2 are tx level */
 
@@ -1122,8 +1119,10 @@
 #endif
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	devfs_handle_t fhandle;  /* File handle in devfs for the channel */
 	devfs_handle_t fhandle_symlink;
+#endif
 #endif /* CONFIG_DEVFS_FS */
 };
 
@@ -1253,7 +1252,9 @@
 	int lastalarms;		/* Previous alarms */
 
 #ifdef CONFIG_DEVFS_FS
+#ifndef LINUX26
 	devfs_handle_t dhandle;  /* Directory name */
+#endif
 #endif	
 	/* If the watchdog detects no received data, it will call the
 	   watchdog routine */
