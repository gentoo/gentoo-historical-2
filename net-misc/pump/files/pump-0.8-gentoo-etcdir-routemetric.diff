--- pump.h.orig	2005-06-30 12:58:52.357148624 +0100
+++ pump.h	2005-06-30 12:59:21.426160635 +0100
@@ -88,13 +88,13 @@
 char * pumpDhcpRun(char * device, int flags, int lease,
 		     char * reqHostname, struct pumpNetIntf * intf,
 		     struct pumpOverrideInfo * override);
-char * pumpSetupInterface(struct pumpNetIntf * intf);
+char * pumpSetupInterface(struct pumpNetIntf * intf, int metric);
 /* setup an interface for sending a broadcast -- uses all 0's address */
 char * pumpPrepareInterface(struct pumpNetIntf * intf, int s);
 char * pumpDisableInterface(char * device);
 int pumpDhcpRenew(struct pumpNetIntf * intf);
 int pumpDhcpRelease(struct pumpNetIntf * intf);
-int pumpSetupDefaultGateway(struct in_addr * gw);
+int pumpSetupDefaultGateway(struct pumpNetIntf * intf, int metric);
 time_t pumpUptime(void);
 
 #define RESULT_OKAY		0
--- pump.c.orig	2005-06-30 12:59:09.391801577 +0100
+++ pump.c	2005-06-30 12:59:19.553415093 +0100
@@ -69,6 +69,8 @@
 	    int flags;
 	    int reqLease;			/* in hours */
 	    char reqHostname[200];
+	    char resolv[1024];
+	    int routeMetric;
 	} start;
 	int result;				/* 0 for success */
 	struct {
@@ -92,13 +94,14 @@
 
 static int openControlSocket(char * configFile, struct pumpOverrideInfo * override);
 
-char * readSearchPath(void) {
+char * readSearchPath(char *file) {
     int fd;
     struct stat sb;
     char * buf;
     char * start;
 
-    fd = open("/etc/resolv.conf", O_RDONLY);
+    if (! file) return NULL;
+    fd = open(file, O_RDONLY);
     if (fd < 0) return NULL;
 
     fstat(fd, &sb);
@@ -132,8 +135,8 @@
     return NULL;
 }
 
-static void createResolvConf(struct pumpNetIntf * intf, char * domain,
-			     int isSearchPath) {
+static void createResolvConf(char * file, struct pumpNetIntf * intf,
+			char * domain, int isSearchPath) {
     FILE * f;
     int i;
     char * chptr;
@@ -142,7 +145,7 @@
     res_close();
 
     if (!domain) {
-	domain = readSearchPath();
+	domain = readSearchPath(file);
  	if (domain) {
 	    chptr = alloca(strlen(domain) + 1);
 	    strcpy(chptr, domain);
@@ -152,19 +155,21 @@
 	}
     }
 
-    f = fopen("/etc/resolv.conf", "w");
+    f = fopen(file, "w");
     if (!f) {
-	syslog(LOG_ERR, "cannot create /etc/resolv.conf: %s\n",
+	syslog(LOG_ERR, "cannot create %s: %s\n", file,
 	       strerror(errno));
 	return;
     }
 
+    fprintf(f, "# Generated by pump for interface %s\n", intf->device);
+
     if (domain && isSearchPath) {
 	fprintf(f, "search %s\n", domain);
     } else if (domain && !strchr(domain, '.')) {
-	fprintf(f, "search %s\n", domain);
+	fprintf(f, "domain %s\n", domain);
     } else if (domain) {
-	fprintf(f, "search");
+	fprintf(f, "domain");
 	chptr = domain;
 	do {
 	    /* If there is a single . in the search path, write it out
@@ -240,7 +245,7 @@
     return;
 }
 
-void setupDns(struct pumpNetIntf * intf, struct pumpOverrideInfo * override) {
+void setupDns(char *file, struct pumpNetIntf * intf, struct pumpOverrideInfo * override) {
     char * hn, * dn = NULL;
     struct hostent * he;
 
@@ -249,7 +254,7 @@
     }
 
     if (override->searchPath) {
-	createResolvConf(intf, override->searchPath, 1);
+	createResolvConf(file, intf, override->searchPath, 1);
 	return;
     }
 
@@ -258,7 +263,7 @@
 	    if (intf->set & PUMP_NETINFO_HAS_HOSTNAME) {
 		hn = intf->hostname;
 	    } else {
-		createResolvConf(intf, NULL, 0);
+		createResolvConf(file, intf, NULL, 0);
 
 		he = gethostbyaddr((char *) &intf->ip, sizeof(intf->ip),
 				   AF_INET);
@@ -278,7 +283,7 @@
 	    dn = intf->domain;
 	}
 
-	createResolvConf(intf, dn, 0);
+	createResolvConf(file, intf, dn, 0);
     }
 }
 
@@ -480,16 +485,18 @@
 			        intf + numInterfaces, o)) {
 		    cmd.u.result = 1;
 		} else {
-		    pumpSetupInterface(intf + numInterfaces);
+		    pumpSetupInterface(intf + numInterfaces,
+			    cmd.u.start.routeMetric);
 		    i = numInterfaces;
 
 		    syslog(LOG_INFO, "configured interface %s", intf[i].device);
 
 		    if ((intf[i].set & PUMP_NETINFO_HAS_GATEWAY) &&
 			 !(o->flags & OVERRIDE_FLAG_NOGATEWAY))
-			pumpSetupDefaultGateway(&intf[i].gateway);
+			 pumpSetupDefaultGateway(intf + i,
+				 cmd.u.start.routeMetric);
 
-		    setupDns(intf + i, o);
+		    setupDns(cmd.u.start.resolv, intf + i, o);
 		    setupDomain(intf + i, o);
 
 		    callScript(o->script, PUMP_SCRIPT_NEWLEASE, 
@@ -761,12 +768,16 @@
     int nogateway = 0;
     struct command cmd, response;
     char * configFile = "/etc/pump.conf";
+    char * etcDir = "/etc";
+    int routeMetric = 0;
     struct pumpOverrideInfo * overrides;
     int cont;
     struct poptOption options[] = {
 	    { "config-file", 'c', POPT_ARG_STRING, &configFile, 0,
 			N_("Configuration file to use instead of "
 			   "/etc/pump.conf") },
+	    { "etc-dir", 'e', POPT_ARG_STRING, &etcDir, 0,
+			N_("Directory to store resolv.conf (normally /etc)") },
             { "hostname", 'h', POPT_ARG_STRING, &hostname, 0, 
 			N_("Hostname to request"), N_("hostname") },
             { "interface", 'i', POPT_ARG_STRING, &device, 0, 
@@ -782,6 +793,8 @@
 			N_("Release interface"), NULL },
 	    { "renew", 'R', POPT_ARG_NONE, &renew, 0,
 			N_("Force immediate lease renewal"), NULL },
+	    { "route-metric", 'm', POPT_ARG_INT, &routeMetric, 0,
+			N_("Metric applied to routes (normally 0)") },
 	    { "status", 's', POPT_ARG_NONE, &status, 0,
 			N_("Display interface status"), NULL },
 	    { "no-dns", 'd', POPT_ARG_NONE, &nodns, 0,
@@ -855,6 +868,8 @@
 	cmd.u.start.flags = flags;
 	cmd.u.start.reqLease = lease * 60 * 60;
 	strcpy(cmd.u.start.reqHostname, hostname);
+	sprintf(cmd.u.start.resolv, "%s/resolv.conf", etcDir);
+	cmd.u.start.routeMetric = routeMetric;
     }
 
     write(cont, &cmd, sizeof(cmd));
--- dhcp.c.orig	2005-06-30 12:58:47.802781163 +0100
+++ dhcp.c	2005-06-30 12:59:24.662721637 +0100
@@ -227,7 +227,7 @@
     return NULL;
 }
 
-char * pumpSetupInterface(struct pumpNetIntf * intf) {
+char * pumpSetupInterface(struct pumpNetIntf * intf, int metric) {
     char * rc;
     struct sockaddr_in * addrp;
     struct ifreq req;
@@ -239,7 +239,6 @@
     s = socket(AF_INET, SOCK_DGRAM, 0);
 	
     memset(&req,0,sizeof(req));
-    memset(&route,0,sizeof(route));
     /* we have to have basic information to get this far */
     addrp = (struct sockaddr_in *) &req.ifr_addr;
     addrp->sin_family = AF_INET;
@@ -267,29 +266,47 @@
     if (ioctl(s, SIOCSIFFLAGS, &req))
 	return perrorstr("SIOCSIFFLAGS");
 
-    if (!strcmp(intf->device, "lo") || oldKernel()) {
-	/* add a route for this network */
-	route.rt_dev = intf->device;
-	route.rt_flags = RTF_UP;
+    /* If the we're on a modern kernel and the metric we want is not zero
+     * then we don't need todo anything else */
+    if (! oldKernel() && metric == 0) {
+	return NULL;
+    }
+    
+    /* Prepare the route */
+    memset(&route,0,sizeof(route));
+    route.rt_dev = intf->device;
+    route.rt_flags = RTF_UP;
+
+    addrp->sin_family = AF_INET;
+    addrp->sin_port = 0;
+    addrp->sin_addr = intf->network;
+    memcpy(&route.rt_dst, addrp, sizeof(*addrp));
+    addrp->sin_addr = intf->netmask;
+    memcpy(&route.rt_genmask, addrp, sizeof(*addrp));
+
+    /* Modern kernels automatically add a default route with a metric of zero
+     * we need to delete this route and add our own */
+    if (! oldKernel()) {
 	route.rt_metric = 0;
 
-	addrp->sin_family = AF_INET;
-	addrp->sin_port = 0;
-	addrp->sin_addr = intf->network;
-	memcpy(&route.rt_dst, addrp, sizeof(*addrp));
-	addrp->sin_addr = intf->netmask;
-	memcpy(&route.rt_genmask, addrp, sizeof(*addrp));
-
-	if (ioctl(s, SIOCADDRT, &route)) {
-	    /* the route cannot already exist, as we've taken the device down */
-	    return perrorstr("SIOCADDRT 1");
+	if (ioctl(s, SIOCDELRT, &route)) {
+	    syslog(LOG_ERR, "pump: failed to delete kernel supplied default route: %m");
+	    return perrorstr("SIOCADDRT 2");
 	}
     }
 
+    /* Now add our route */
+    if (metric > 0) metric++;
+    route.rt_metric = metric;
+    if (ioctl(s, SIOCADDRT, &route)) {
+	syslog(LOG_ERR, "pump: failed to add default route: %m");
+	return perrorstr("SIOCADDRT 1");
+    }
+    
     return NULL;
 }
 
-int pumpSetupDefaultGateway(struct in_addr * gw) {
+int pumpSetupDefaultGateway(struct pumpNetIntf * intf, int metric) {
     struct sockaddr_in addr;
     struct rtentry route;
     int s;
@@ -303,12 +320,12 @@
     addr.sin_addr.s_addr = INADDR_ANY;
     memcpy(&route.rt_dst, &addr, sizeof(addr));
     memcpy(&route.rt_genmask, &addr, sizeof(addr));
-    addr.sin_addr = *gw;
+    addr.sin_addr = intf->gateway;
     memcpy(&route.rt_gateway, &addr, sizeof(addr));
     
     route.rt_flags = RTF_UP | RTF_GATEWAY;
-    route.rt_metric = 0;
-    route.rt_dev = NULL;
+    route.rt_metric = metric + 1;
+    route.rt_dev = intf->device;
 
     if (ioctl(s, SIOCADDRT, &route)) {
 	syslog(LOG_ERR, "failed to set default route: %s", strerror(errno));
