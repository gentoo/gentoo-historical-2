--- config.c	2002-06-18 18:03:59.000000000 +0100
+++ config.c	2005-07-13 10:23:35.000000000 +0100
@@ -200,6 +200,12 @@
 		return 1;
 	    }
 	    override->flags |= OVERRIDE_FLAG_NONISDOMAIN;
+	} else if (!strcmp(start, "nontp")) {
+	    if (*rest) {
+		parseError(*lineNum, "unexpected argument to nonisdomain directive");
+		return 1;
+	    }
+	    override->flags |= OVERRIDE_FLAG_NONTP;
 	} else if (!strcmp(start, "script")) {
 	    if (overrideList != override) {
 		parseError(*lineNum, "script directive may not occur "
--- dhcp.c	2004-09-21 16:19:06.000000000 +0100
+++ dhcp.c	2005-07-13 10:14:12.000000000 +0100
@@ -203,13 +203,62 @@
     return err;
 }
 
-
 char * pumpDisableInterface(char * device) {
+    struct sockaddr_in * addrp;
     struct ifreq req;
     int s;
+    struct rtentry route;
+    
+    /* Instead of downing the interface, we erase the addresses
+     * This is important as other daemons such as ifplugd and/or
+     * wpa_supplicant may be using it */
 
     s = socket(AF_INET, SOCK_DGRAM, 0);
-	
+
+    memset(&req,0,sizeof(req));
+    addrp = (struct sockaddr_in *) &req.ifr_addr;
+    addrp->sin_family = AF_INET;
+    strcpy(req.ifr_name, device);
+   
+    while(! ioctl(s, SIOCGIFADDR, &req)) {
+	addrp->sin_addr.s_addr = 0;
+	if (ioctl(s, SIOCSIFADDR, &req)) {
+	    close(s);
+	    return perrorstr("SIOCSIFADDR");
+	}
+    }
+  
+    /* Delete the broadcast route that we may have added earlier */
+    memset(&route, 0, sizeof(route));
+    memcpy(&route.rt_gateway, addrp, sizeof(*addrp));
+
+    addrp->sin_family = AF_INET;
+    addrp->sin_port = 0;
+    addrp->sin_addr.s_addr = INADDR_ANY;
+    memcpy(&route.rt_dst, addrp, sizeof(*addrp));
+    memcpy(&route.rt_genmask, addrp, sizeof(*addrp));
+
+    route.rt_dev = device;
+    route.rt_flags = RTF_UP;
+    route.rt_metric = 0;
+
+    if (ioctl(s, SIOCDELRT, &route)) {
+        if (errno != EEXIST) {
+            close(s);
+            return perrorstr("SIOCADDRT 3");
+        }
+    }
+    
+    close(s);
+    return NULL;
+}
+
+char * pumpDownInterface(char * device) {
+    struct ifreq req;
+    int s;
+
+    s = socket(AF_INET, SOCK_DGRAM, 0);
+
     memset(&req,0,sizeof(req));
 
     strcpy(req.ifr_name, device);
@@ -229,17 +278,18 @@
     return NULL;
 }
 
-char * pumpSetupInterface(struct pumpNetIntf * intf) {
+char * pumpSetupInterface(struct pumpNetIntf * intf, int metric) {
     char * rc;
     struct sockaddr_in * addrp;
     struct ifreq req;
     struct rtentry route;
     int s;
 
+    if ((rc = pumpDisableInterface(intf->device))) return rc;
+    
     s = socket(AF_INET, SOCK_DGRAM, 0);
 	
     memset(&req,0,sizeof(req));
-    memset(&route,0,sizeof(route));
     /* we have to have basic information to get this far */
     addrp = (struct sockaddr_in *) &req.ifr_addr;
     addrp->sin_family = AF_INET;
@@ -267,29 +317,45 @@
     if (ioctl(s, SIOCSIFFLAGS, &req))
 	return perrorstr("SIOCSIFFLAGS");
 
-    if (!strcmp(intf->device, "lo") || oldKernel()) {
-	/* add a route for this network */
-	route.rt_dev = intf->device;
-	route.rt_flags = RTF_UP;
+    /* If the we're on a modern kernel and the metric we want is not zero
+     * then we don't need todo anything else */
+    if (! oldKernel() && metric == 0) {
+	return NULL;
+    }
+    
+    /* Prepare the route */
+    memset(&route,0,sizeof(route));
+    route.rt_dev = intf->device;
+    route.rt_flags = RTF_UP;
+
+    addrp->sin_family = AF_INET;
+    addrp->sin_port = 0;
+    addrp->sin_addr = intf->network;
+    memcpy(&route.rt_dst, addrp, sizeof(*addrp));
+    addrp->sin_addr = intf->netmask;
+    memcpy(&route.rt_genmask, addrp, sizeof(*addrp));
+
+    /* Modern kernels automatically add a default route with a metric of zero
+     * we need to delete this route and add our own */
+    if (! oldKernel()) {
 	route.rt_metric = 0;
 
-	addrp->sin_family = AF_INET;
-	addrp->sin_port = 0;
-	addrp->sin_addr = intf->network;
-	memcpy(&route.rt_dst, addrp, sizeof(*addrp));
-	addrp->sin_addr = intf->netmask;
-	memcpy(&route.rt_genmask, addrp, sizeof(*addrp));
-
-	if (ioctl(s, SIOCADDRT, &route)) {
-	    /* the route cannot already exist, as we've taken the device down */
-	    return perrorstr("SIOCADDRT 1");
+	if (ioctl(s, SIOCDELRT, &route)) {
+	    return perrorstr("SIOCADDRT");
 	}
     }
 
+    /* Now add our route */
+    if (metric > 0) metric++;
+    route.rt_metric = metric;
+    if (ioctl(s, SIOCADDRT, &route)) {
+	return perrorstr("SIOCADDRT 1");
+    }
+    
     return NULL;
 }
 
-int pumpSetupDefaultGateway(struct in_addr * gw) {
+int pumpSetupDefaultGateway(struct pumpNetIntf * intf, int metric) {
     struct sockaddr_in addr;
     struct rtentry route;
     int s;
@@ -303,12 +369,12 @@
     addr.sin_addr.s_addr = INADDR_ANY;
     memcpy(&route.rt_dst, &addr, sizeof(addr));
     memcpy(&route.rt_genmask, &addr, sizeof(addr));
-    addr.sin_addr = *gw;
+    addr.sin_addr = intf->gateway;
     memcpy(&route.rt_gateway, &addr, sizeof(addr));
     
     route.rt_flags = RTF_UP | RTF_GATEWAY;
-    route.rt_metric = 0;
-    route.rt_dev = NULL;
+    route.rt_metric = metric + 1;
+    route.rt_dev = intf->device;
 
     if (ioctl(s, SIOCADDRT, &route)) {
 	syslog(LOG_ERR, "failed to set default route: %s", strerror(errno));
@@ -1423,7 +1489,7 @@
 char * pumpDhcpRun(char * device, int flags, int reqLease,
                   char * reqHostname, struct pumpNetIntf * intf,
                   struct pumpOverrideInfo * override) {
-    pumpDhcpClassRun(device, flags, reqLease, reqHostname, NULL, intf,
+    return pumpDhcpClassRun(device, flags, reqLease, reqHostname, NULL, intf,
                      override);
 }
 
--- pump.8	2001-02-01 22:58:16.000000000 +0000
+++ pump.8	2005-07-13 10:24:33.000000000 +0100
@@ -43,14 +43,17 @@
 		/etc/pump.conf
 -h	--hostname=hostname	Hostname to request
 -i	--interface=iface	Interface to configure (normally eth0)
+-u	--keep-up	Keep the interface up when releasing it
 -k	--kill	Kill daemon (and disable all interfaces)
 -l	--lease=hours	Lease time to request (in hours)
 	--lookup-hostname	Always look up hostname and domain in DNS
 -r	--release	Release interface
 -R	--renew	Force immediate lease renewal
+	--script=script		Script to run when on DHCP actions
 -s	--status	Display interface status
 -d	--no-dns	Don't update resolv.conf
   	--no-gateway	Don't configurate a default route for this interface
+	--no-ntp	Don't update ntp.conf
 	--win-client-id	Specify a Windows-like client identifier
 -?	--help	Show this help message
 	--usage	Display brief usage message
@@ -111,13 +114,6 @@
 directive may only be used globally. 
 
 .TP
-\fBnonisdomain\fR
-Don't set a new NIS domain. Normally \fBpump\fR sets the system's NIS domain
-if an NIS domain is specified by the dhcp server and the current NIS domain 
-is empty or \fBlocaldomain\fR.
-This directive may only be used within a \fBdevice\fR directive.
-
-.TP
 \fBnodns\fR
 Don't create a new /etc/resolv.conf when this interface is configured. This
 directive may only be used within a \fBdevice\fR directive.
@@ -128,6 +124,18 @@
 can be usefull on machines with multiple ethernet cards.
 
 .TP
+\fBnonisdomain\fR
+Don't set a new NIS domain. Normally \fBpump\fR sets the system's NIS domain
+if an NIS domain is specified by the dhcp server and the current NIS domain 
+is empty or \fBlocaldomain\fR.
+This directive may only be used within a \fBdevice\fR directive.
+
+.TP
+\fBnontp\fR
+Don't create a new /etc/ntp.conf when this interface is configured. This
+directive may only be used within a \fBdevice\fR directive.
+
+.TP
 \fBretries\fR \fIcount\fR
 Retry each phase of the DHCP process \fIcount\fR times.
 
--- pump.c	2002-06-18 18:03:59.000000000 +0100
+++ pump.c	2005-07-13 10:12:28.000000000 +0100
@@ -69,10 +69,16 @@
 	    int flags;
 	    int reqLease;			/* in seconds */
 	    char reqHostname[200];
+	    struct {
+		char resolv[MAX_PATH];
+		char ntp[MAX_PATH];
+	    } files;
+	    int routeMetric;
 	} start;
 	int result;				/* 0 for success */
 	struct {
 	    char device[20];
+	    int keepUp;
 	} stop;
 	struct {
 	    char device[20];
@@ -92,13 +98,14 @@
 
 static int openControlSocket(char * configFile, struct pumpOverrideInfo * override);
 
-char * readSearchPath(void) {
+char * readSearchPath(char *file) {
     int fd;
     struct stat sb;
     char * buf;
     char * start;
 
-    fd = open("/etc/resolv.conf", O_RDONLY);
+    if (! file) return NULL;
+    fd = open(file, O_RDONLY);
     if (fd < 0) return NULL;
 
     fstat(fd, &sb);
@@ -132,8 +139,42 @@
     return NULL;
 }
 
-static void createResolvConf(struct pumpNetIntf * intf, char * domain,
-			     int isSearchPath) {
+void createNtpConf(char *file, struct pumpNetIntf * intf) {
+    FILE * f;
+    int i;
+
+    f = fopen(file, "w");
+    if (!f) {
+	syslog(LOG_ERR, "cannot create %s: %s\n", file,
+	       strerror(errno));
+	return;
+    }
+
+    fprintf(f, "# Generated by pump for interface %s\n", intf->device);
+    fprintf(f, "restrict default noquery notrust nomodify\n"
+		"restrict 127.0.0.1\n"
+		"driftfile /var/lib/ntp/ntp.drift\n");
+
+    for (i = 0; i < intf->numNtp; i++) {
+	fprintf(f, "restrict %s nomodify notrap noquery\n"
+		"server %s\n", inet_ntoa(intf->ntpServers[i]),
+		inet_ntoa(intf->ntpServers[i]));
+    }
+ 
+    fclose(f);
+}
+
+void setupNtp(char *file, struct pumpNetIntf * intf, struct pumpOverrideInfo * override) {
+
+    if (override->flags & OVERRIDE_FLAG_NONTP)
+        return;
+
+    if (intf->set & PUMP_NETINFO_HAS_NTPSRVS)
+        createNtpConf(file, intf);
+}
+
+static void createResolvConf(char * file, struct pumpNetIntf * intf,
+			char * domain, int isSearchPath) {
     FILE * f;
     int i;
     char * chptr;
@@ -142,7 +183,7 @@
     res_close();
 
     if (!domain) {
-	domain = readSearchPath();
+	domain = readSearchPath(file);
  	if (domain) {
 	    chptr = alloca(strlen(domain) + 1);
 	    strcpy(chptr, domain);
@@ -152,19 +193,21 @@
 	}
     }
 
-    f = fopen("/etc/resolv.conf", "w");
+    f = fopen(file, "w");
     if (!f) {
-	syslog(LOG_ERR, "cannot create /etc/resolv.conf: %s\n",
+	syslog(LOG_ERR, "cannot create %s: %s\n", file,
 	       strerror(errno));
 	return;
     }
 
+    fprintf(f, "# Generated by pump for interface %s\n", intf->device);
+
     if (domain && isSearchPath) {
 	fprintf(f, "search %s\n", domain);
     } else if (domain && !strchr(domain, '.')) {
-	fprintf(f, "search %s\n", domain);
+	fprintf(f, "domain %s\n", domain);
     } else if (domain) {
-	fprintf(f, "search");
+	fprintf(f, "domain");
 	chptr = domain;
 	do {
 	    /* If there is a single . in the search path, write it out
@@ -240,7 +283,7 @@
     return;
 }
 
-void setupDns(struct pumpNetIntf * intf, struct pumpOverrideInfo * override) {
+void setupDns(char *file, struct pumpNetIntf * intf, struct pumpOverrideInfo * override) {
     char * hn, * dn = NULL;
     struct hostent * he;
 
@@ -249,7 +292,7 @@
     }
 
     if (override->searchPath) {
-	createResolvConf(intf, override->searchPath, 1);
+	createResolvConf(file, intf, override->searchPath, 1);
 	return;
     }
 
@@ -258,7 +301,7 @@
 	    if (intf->set & PUMP_NETINFO_HAS_HOSTNAME) {
 		hn = intf->hostname;
 	    } else {
-		createResolvConf(intf, NULL, 0);
+		createResolvConf(file, intf, NULL, 0);
 
 		he = gethostbyaddr((char *) &intf->ip, sizeof(intf->ip),
 				   AF_INET);
@@ -278,7 +321,7 @@
 	    dn = intf->domain;
 	}
 
-	createResolvConf(intf, dn, 0);
+	createResolvConf(file, intf, dn, 0);
     }
 }
 
@@ -360,7 +403,7 @@
 static void runDaemon(int sock, char * configFile, struct pumpOverrideInfo * overrides) {
     int conn;
     struct sockaddr_un addr;
-    int addrLength = sizeof(struct sockaddr_un);
+    socklen_t addrLength = sizeof(struct sockaddr_un);
     struct command cmd;
     struct pumpNetIntf intf[20];
     int numInterfaces = 0;
@@ -529,17 +572,20 @@
 			        intf + numInterfaces, o)) {
 		    cmd.u.result = 1;
 		} else {
-		    pumpSetupInterface(intf + numInterfaces);
+		    pumpSetupInterface(intf + numInterfaces,
+			    cmd.u.start.routeMetric);
 		    i = numInterfaces;
 
 		    syslog(LOG_INFO, "configured interface %s", intf[i].device);
 
 		    if ((intf[i].set & PUMP_NETINFO_HAS_GATEWAY) &&
 			 !(o->flags & OVERRIDE_FLAG_NOGATEWAY))
-			pumpSetupDefaultGateway(&intf[i].gateway);
+			 pumpSetupDefaultGateway(intf + i,
+				 cmd.u.start.routeMetric);
 
-		    setupDns(intf + i, o);
+		    setupDns(cmd.u.start.files.resolv, intf + i, o);
 		    setupDomain(intf + i, o);
+		    setupNtp(cmd.u.start.files.ntp, intf + i, o);
 
 		    callScript(o->script, PUMP_SCRIPT_NEWLEASE, 
 			       intf + numInterfaces);
@@ -570,6 +616,7 @@
 		    cmd.u.result = RESULT_UNKNOWNIFACE;
 		else {
 		    cmd.u.result = pumpDhcpRelease(intf + i);
+		    if (! cmd.u.stop.keepUp) pumpDownInterface(intf[i].device);
 		    callScript(o->script, PUMP_SCRIPT_DOWN, intf + i);
 		    if (numInterfaces == 1) {
 			cmd.type = CMD_RESULT;
@@ -808,20 +855,27 @@
     int killDaemon = 0;
     int winId = 0;
     int release = 0, renew = 0, status = 0, lookupHostname = 0, nodns = 0;
-    int nogateway = 0, nobootp = 0;
+    int nogateway = 0, nobootp = 0, nontp=1;
     struct command cmd, response;
     char * configFile = "/etc/pump.conf";
+    char * etcDir = "/etc";
+    int routeMetric = 0, keepUp = 0;
+    char * script = "";
     struct pumpOverrideInfo * overrides;
     int cont;
     struct poptOption options[] = {
 	    { "config-file", 'c', POPT_ARG_STRING, &configFile, 0,
 			N_("Configuration file to use instead of "
 			   "/etc/pump.conf") },
+	    { "etc-dir", 'e', POPT_ARG_STRING, &etcDir, 0,
+			N_("Directory to store resolv.conf (normally /etc)") },
             { "hostname", 'h', POPT_ARG_STRING, &hostname, 0, 
 			N_("Hostname to request"), N_("hostname") },
             { "interface", 'i', POPT_ARG_STRING, &device, 0, 
 			N_("Interface to configure (normally eth0)"), 
 			N_("iface") },
+	    { "keep-up", 'u', POPT_ARG_NONE, &keepUp, 0,
+			N_("Keep the interface up when releasing it") },
 	    { "kill", 'k', POPT_ARG_NONE, &killDaemon, 0,
 			N_("Kill daemon (and disable all interfaces)"), NULL },
 	    { "lease", 'l', POPT_ARG_INT, &lease_hrs, 0,
@@ -834,14 +888,20 @@
 			N_("Release interface"), NULL },
 	    { "renew", 'R', POPT_ARG_NONE, &renew, 0,
 			N_("Force immediate lease renewal"), NULL },
+	    { "route-metric", 'm', POPT_ARG_INT, &routeMetric, 0,
+			N_("Metric applied to routes (normally 0)") },
+	    { "script", '\0', POPT_ARG_STRING, &script, 0,
+			N_("Script to run when on DHCP actions") },
 	    { "status", 's', POPT_ARG_NONE, &status, 0,
 			N_("Display interface status"), NULL },
+	    { "no-bootp", '\0', POPT_ARG_NONE, &nobootp, 0,
+	                N_("Ignore non-DHCP BOOTP responses"), NULL },
 	    { "no-dns", 'd', POPT_ARG_NONE, &nodns, 0,
 			N_("Don't update resolv.conf"), NULL },
 	    { "no-gateway", '\0', POPT_ARG_NONE, &nogateway, 0,
 			N_("Don't set a gateway for this interface"), NULL },
-	    { "no-bootp", '\0', POPT_ARG_NONE, &nobootp, 0,
-	                N_("Ignore non-DHCP BOOTP responses"), NULL },
+	    { "no-ntp", '\0', POPT_ARG_NONE, &nontp, 0,
+			N_("Don't update ntp.conf"), NULL },
 	    { "win-client-ident", '\0', POPT_ARG_NONE, &winId, 0,
 			N_("Set the client identifier to match Window's") },
 	    /*{ "test", 't', POPT_ARG_NONE, &test, 0,
@@ -889,6 +949,10 @@
 	overrides->flags |= OVERRIDE_FLAG_NOBOOTP;
     if (nogateway)
 	overrides->flags |= OVERRIDE_FLAG_NOGATEWAY;
+    if (nontp)
+	overrides->flags |= OVERRIDE_FLAG_NONTP;
+    if (strlen(script))
+	overrides->script = script;	
 
     cont = openControlSocket(configFile, overrides);
     if (cont < 0) 
@@ -905,6 +969,7 @@
     } else if (release) {
 	cmd.type = CMD_STOPIFACE;
 	strcpy(cmd.u.stop.device, device);
+	cmd.u.stop.keepUp = keepUp;
     } else {
 	cmd.type = CMD_STARTIFACE;
 	strcpy(cmd.u.start.device, device);
@@ -914,6 +979,9 @@
 	else
 		cmd.u.start.reqLease = lease;
 	strcpy(cmd.u.start.reqHostname, hostname);
+	snprintf(cmd.u.start.files.resolv, MAX_PATH, "%s/resolv.conf", etcDir);
+	snprintf(cmd.u.start.files.ntp, MAX_PATH, "%s/ntp.conf", etcDir);
+	cmd.u.start.routeMetric = routeMetric;
     }
 
     write(cont, &cmd, sizeof(cmd));
--- pump.h	2003-10-24 20:37:53.000000000 +0100
+++ pump.h	2005-07-13 09:55:41.000000000 +0100
@@ -13,6 +13,8 @@
 #define MAX_XFS_SERVERS		3
 #define MAX_XDM_SERVERS		3
 
+#define MAX_PATH		256
+
 #define PUMP_INTFINFO_HAS_IP		(1 << 0)
 #define PUMP_INTFINFO_HAS_NETMASK	(1 << 1)
 #define PUMP_INTFINFO_HAS_BROADCAST	(1 << 2)
@@ -83,6 +85,7 @@
 #define OVERRIDE_FLAG_NONISDOMAIN	(1 << 1)
 #define OVERRIDE_FLAG_NOGATEWAY		(1 << 2)
 #define OVERRIDE_FLAG_NOBOOTP           (1 << 3)
+#define OVERRIDE_FLAG_NONTP		(1 << 4)
 
 struct pumpOverrideInfo {
     struct pumpNetIntf intf;
@@ -100,13 +103,14 @@
 char * pumpDhcpRun(char * device, int flags, int lease,
 		     char * reqHostname, struct pumpNetIntf * intf,
 		     struct pumpOverrideInfo * override);
-char * pumpSetupInterface(struct pumpNetIntf * intf);
+char * pumpSetupInterface(struct pumpNetIntf * intf, int metric);
 /* setup an interface for sending a broadcast -- uses all 0's address */
 char * pumpPrepareInterface(struct pumpNetIntf * intf, int s);
 char * pumpDisableInterface(char * device);
+char * pumpDownInterface(char * device);
 int pumpDhcpRenew(struct pumpNetIntf * intf);
 int pumpDhcpRelease(struct pumpNetIntf * intf);
-int pumpSetupDefaultGateway(struct in_addr * gw);
+int pumpSetupDefaultGateway(struct pumpNetIntf * intf, int metric);
 time_t pumpUptime(void);
 
 #define RESULT_OKAY		0
