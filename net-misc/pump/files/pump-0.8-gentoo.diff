--- pump.h.orig	2003-10-24 20:37:53.000000000 +0100
+++ pump.h	2005-07-01 10:30:28.526406380 +0100
@@ -100,13 +100,14 @@
 char * pumpDhcpRun(char * device, int flags, int lease,
 		     char * reqHostname, struct pumpNetIntf * intf,
 		     struct pumpOverrideInfo * override);
-char * pumpSetupInterface(struct pumpNetIntf * intf);
+char * pumpSetupInterface(struct pumpNetIntf * intf, int metric);
 /* setup an interface for sending a broadcast -- uses all 0's address */
 char * pumpPrepareInterface(struct pumpNetIntf * intf, int s);
 char * pumpDisableInterface(char * device);
+char * pumpDownInterface(char * device);
 int pumpDhcpRenew(struct pumpNetIntf * intf);
 int pumpDhcpRelease(struct pumpNetIntf * intf);
-int pumpSetupDefaultGateway(struct in_addr * gw);
+int pumpSetupDefaultGateway(struct pumpNetIntf * intf, int metric);
 time_t pumpUptime(void);
 
 #define RESULT_OKAY		0
--- pump.c.orig	2002-06-18 18:03:59.000000000 +0100
+++ pump.c	2005-07-01 10:30:26.579634633 +0100
@@ -69,10 +69,13 @@
 	    int flags;
 	    int reqLease;			/* in seconds */
 	    char reqHostname[200];
+	    char resolv[1024];
+	    int routeMetric;
 	} start;
 	int result;				/* 0 for success */
 	struct {
 	    char device[20];
+	    int keepUp;
 	} stop;
 	struct {
 	    char device[20];
@@ -92,13 +95,14 @@
 
 static int openControlSocket(char * configFile, struct pumpOverrideInfo * override);
 
-char * readSearchPath(void) {
+char * readSearchPath(char *file) {
     int fd;
     struct stat sb;
     char * buf;
     char * start;
 
-    fd = open("/etc/resolv.conf", O_RDONLY);
+    if (! file) return NULL;
+    fd = open(file, O_RDONLY);
     if (fd < 0) return NULL;
 
     fstat(fd, &sb);
@@ -132,8 +136,8 @@
     return NULL;
 }
 
-static void createResolvConf(struct pumpNetIntf * intf, char * domain,
-			     int isSearchPath) {
+static void createResolvConf(char * file, struct pumpNetIntf * intf,
+			char * domain, int isSearchPath) {
     FILE * f;
     int i;
     char * chptr;
@@ -142,7 +146,7 @@
     res_close();
 
     if (!domain) {
-	domain = readSearchPath();
+	domain = readSearchPath(file);
  	if (domain) {
 	    chptr = alloca(strlen(domain) + 1);
 	    strcpy(chptr, domain);
@@ -152,19 +156,21 @@
 	}
     }
 
-    f = fopen("/etc/resolv.conf", "w");
+    f = fopen(file, "w");
     if (!f) {
-	syslog(LOG_ERR, "cannot create /etc/resolv.conf: %s\n",
+	syslog(LOG_ERR, "cannot create %s: %s\n", file,
 	       strerror(errno));
 	return;
     }
 
+    fprintf(f, "# Generated by pump for interface %s\n", intf->device);
+
     if (domain && isSearchPath) {
 	fprintf(f, "search %s\n", domain);
     } else if (domain && !strchr(domain, '.')) {
-	fprintf(f, "search %s\n", domain);
+	fprintf(f, "domain %s\n", domain);
     } else if (domain) {
-	fprintf(f, "search");
+	fprintf(f, "domain");
 	chptr = domain;
 	do {
 	    /* If there is a single . in the search path, write it out
@@ -240,7 +246,7 @@
     return;
 }
 
-void setupDns(struct pumpNetIntf * intf, struct pumpOverrideInfo * override) {
+void setupDns(char *file, struct pumpNetIntf * intf, struct pumpOverrideInfo * override) {
     char * hn, * dn = NULL;
     struct hostent * he;
 
@@ -249,7 +255,7 @@
     }
 
     if (override->searchPath) {
-	createResolvConf(intf, override->searchPath, 1);
+	createResolvConf(file, intf, override->searchPath, 1);
 	return;
     }
 
@@ -258,7 +264,7 @@
 	    if (intf->set & PUMP_NETINFO_HAS_HOSTNAME) {
 		hn = intf->hostname;
 	    } else {
-		createResolvConf(intf, NULL, 0);
+		createResolvConf(file, intf, NULL, 0);
 
 		he = gethostbyaddr((char *) &intf->ip, sizeof(intf->ip),
 				   AF_INET);
@@ -278,7 +284,7 @@
 	    dn = intf->domain;
 	}
 
-	createResolvConf(intf, dn, 0);
+	createResolvConf(file, intf, dn, 0);
     }
 }
 
@@ -529,16 +535,18 @@
 			        intf + numInterfaces, o)) {
 		    cmd.u.result = 1;
 		} else {
-		    pumpSetupInterface(intf + numInterfaces);
+		    pumpSetupInterface(intf + numInterfaces,
+			    cmd.u.start.routeMetric);
 		    i = numInterfaces;
 
 		    syslog(LOG_INFO, "configured interface %s", intf[i].device);
 
 		    if ((intf[i].set & PUMP_NETINFO_HAS_GATEWAY) &&
 			 !(o->flags & OVERRIDE_FLAG_NOGATEWAY))
-			pumpSetupDefaultGateway(&intf[i].gateway);
+			 pumpSetupDefaultGateway(intf + i,
+				 cmd.u.start.routeMetric);
 
-		    setupDns(intf + i, o);
+		    setupDns(cmd.u.start.resolv, intf + i, o);
 		    setupDomain(intf + i, o);
 
 		    callScript(o->script, PUMP_SCRIPT_NEWLEASE, 
@@ -570,6 +578,8 @@
 		    cmd.u.result = RESULT_UNKNOWNIFACE;
 		else {
 		    cmd.u.result = pumpDhcpRelease(intf + i);
+		    syslog(LOG_INFO, "keekUp %i", cmd.u.stop.keepUp);
+		    if (! cmd.u.stop.keepUp) pumpDownInterface(intf[i].device);
 		    callScript(o->script, PUMP_SCRIPT_DOWN, intf + i);
 		    if (numInterfaces == 1) {
 			cmd.type = CMD_RESULT;
@@ -811,17 +821,24 @@
     int nogateway = 0, nobootp = 0;
     struct command cmd, response;
     char * configFile = "/etc/pump.conf";
+    char * etcDir = "/etc";
+    int routeMetric = 0, keepUp = 0;
+    char * script = "";
     struct pumpOverrideInfo * overrides;
     int cont;
     struct poptOption options[] = {
 	    { "config-file", 'c', POPT_ARG_STRING, &configFile, 0,
 			N_("Configuration file to use instead of "
 			   "/etc/pump.conf") },
+	    { "etc-dir", 'e', POPT_ARG_STRING, &etcDir, 0,
+			N_("Directory to store resolv.conf (normally /etc)") },
             { "hostname", 'h', POPT_ARG_STRING, &hostname, 0, 
 			N_("Hostname to request"), N_("hostname") },
             { "interface", 'i', POPT_ARG_STRING, &device, 0, 
 			N_("Interface to configure (normally eth0)"), 
 			N_("iface") },
+	    { "keep-up", 'u', POPT_ARG_NONE, &keepUp, 0,
+			N_("Keep the interface up when releasing it") },
 	    { "kill", 'k', POPT_ARG_NONE, &killDaemon, 0,
 			N_("Kill daemon (and disable all interfaces)"), NULL },
 	    { "lease", 'l', POPT_ARG_INT, &lease_hrs, 0,
@@ -834,6 +851,10 @@
 			N_("Release interface"), NULL },
 	    { "renew", 'R', POPT_ARG_NONE, &renew, 0,
 			N_("Force immediate lease renewal"), NULL },
+	    { "route-metric", 'm', POPT_ARG_INT, &routeMetric, 0,
+			N_("Metric applied to routes (normally 0)") },
+	    { "script", '\0', POPT_ARG_STRING, &script, 0,
+			N_("Script to run when on DHCP actions") },
 	    { "status", 's', POPT_ARG_NONE, &status, 0,
 			N_("Display interface status"), NULL },
 	    { "no-dns", 'd', POPT_ARG_NONE, &nodns, 0,
@@ -889,6 +910,8 @@
 	overrides->flags |= OVERRIDE_FLAG_NOBOOTP;
     if (nogateway)
 	overrides->flags |= OVERRIDE_FLAG_NOGATEWAY;
+    if (strlen(script))
+	overrides->script = script;	
 
     cont = openControlSocket(configFile, overrides);
     if (cont < 0) 
@@ -905,6 +928,7 @@
     } else if (release) {
 	cmd.type = CMD_STOPIFACE;
 	strcpy(cmd.u.stop.device, device);
+	cmd.u.stop.keepUp = keepUp;
     } else {
 	cmd.type = CMD_STARTIFACE;
 	strcpy(cmd.u.start.device, device);
@@ -914,6 +938,8 @@
 	else
 		cmd.u.start.reqLease = lease;
 	strcpy(cmd.u.start.reqHostname, hostname);
+	sprintf(cmd.u.start.resolv, "%s/resolv.conf", etcDir);
+	cmd.u.start.routeMetric = routeMetric;
     }
 
     write(cont, &cmd, sizeof(cmd));
--- dhcp.c.orig	2004-09-21 16:19:06.000000000 +0100
+++ dhcp.c	2005-07-01 10:32:30.240170027 +0100
@@ -203,43 +203,68 @@
     return err;
 }
 
-
 char * pumpDisableInterface(char * device) {
+    struct sockaddr_in * addrp;
     struct ifreq req;
     int s;
 
+    /* Instead of downing the interface, we erase the address
+     * This is important as other daemons such as ifplugd and/or
+     * wpa_supplicant may be using it */
+    
     s = socket(AF_INET, SOCK_DGRAM, 0);
 	
     memset(&req,0,sizeof(req));
+    addrp = (struct sockaddr_in *) &req.ifr_addr;
+    addrp->sin_family = AF_INET;
+    strcpy(req.ifr_name, device);
+   
+    addrp->sin_addr.s_addr = 0;
+    if (ioctl(s, SIOCSIFADDR, &req)) {
+	close(s);
+	return perrorstr("SIOCSIFADDR");
+    }
+
+    close(s);
+    return NULL;
+}
+
+char * pumpDownInterface(char * device) {
+    struct ifreq req;
+    int s;
+
+    s = socket(AF_INET, SOCK_DGRAM, 0);
+
+    memset(&req,0,sizeof(req));
 
     strcpy(req.ifr_name, device);
     if (ioctl(s, SIOCGIFFLAGS, &req)) {
-	close(s);
-	return perrorstr("SIOCGIFFLAGS");
+        close(s);
+        return perrorstr("SIOCGIFFLAGS");
     }
 
     req.ifr_flags &= ~(IFF_UP | IFF_RUNNING);
     if (ioctl(s, SIOCSIFFLAGS, &req)) {
-	close(s);
-	return perrorstr("SIOCSIFFLAGS");
+        close(s);
+        return perrorstr("SIOCSIFFLAGS");
     }
 
     close(s);
-
     return NULL;
 }
 
-char * pumpSetupInterface(struct pumpNetIntf * intf) {
+char * pumpSetupInterface(struct pumpNetIntf * intf, int metric) {
     char * rc;
     struct sockaddr_in * addrp;
     struct ifreq req;
     struct rtentry route;
     int s;
 
+    if ((rc = pumpDisableInterface(intf->device))) return rc;
+    
     s = socket(AF_INET, SOCK_DGRAM, 0);
 	
     memset(&req,0,sizeof(req));
-    memset(&route,0,sizeof(route));
     /* we have to have basic information to get this far */
     addrp = (struct sockaddr_in *) &req.ifr_addr;
     addrp->sin_family = AF_INET;
@@ -267,29 +292,45 @@
     if (ioctl(s, SIOCSIFFLAGS, &req))
 	return perrorstr("SIOCSIFFLAGS");
 
-    if (!strcmp(intf->device, "lo") || oldKernel()) {
-	/* add a route for this network */
-	route.rt_dev = intf->device;
-	route.rt_flags = RTF_UP;
+    /* If the we're on a modern kernel and the metric we want is not zero
+     * then we don't need todo anything else */
+    if (! oldKernel() && metric == 0) {
+	return NULL;
+    }
+    
+    /* Prepare the route */
+    memset(&route,0,sizeof(route));
+    route.rt_dev = intf->device;
+    route.rt_flags = RTF_UP;
+
+    addrp->sin_family = AF_INET;
+    addrp->sin_port = 0;
+    addrp->sin_addr = intf->network;
+    memcpy(&route.rt_dst, addrp, sizeof(*addrp));
+    addrp->sin_addr = intf->netmask;
+    memcpy(&route.rt_genmask, addrp, sizeof(*addrp));
+
+    /* Modern kernels automatically add a default route with a metric of zero
+     * we need to delete this route and add our own */
+    if (! oldKernel()) {
 	route.rt_metric = 0;
 
-	addrp->sin_family = AF_INET;
-	addrp->sin_port = 0;
-	addrp->sin_addr = intf->network;
-	memcpy(&route.rt_dst, addrp, sizeof(*addrp));
-	addrp->sin_addr = intf->netmask;
-	memcpy(&route.rt_genmask, addrp, sizeof(*addrp));
-
-	if (ioctl(s, SIOCADDRT, &route)) {
-	    /* the route cannot already exist, as we've taken the device down */
-	    return perrorstr("SIOCADDRT 1");
+	if (ioctl(s, SIOCDELRT, &route)) {
+	    return perrorstr("SIOCADDRT");
 	}
     }
 
+    /* Now add our route */
+    if (metric > 0) metric++;
+    route.rt_metric = metric;
+    if (ioctl(s, SIOCADDRT, &route)) {
+	return perrorstr("SIOCADDRT 1");
+    }
+    
     return NULL;
 }
 
-int pumpSetupDefaultGateway(struct in_addr * gw) {
+int pumpSetupDefaultGateway(struct pumpNetIntf * intf, int metric) {
     struct sockaddr_in addr;
     struct rtentry route;
     int s;
@@ -303,12 +344,12 @@
     addr.sin_addr.s_addr = INADDR_ANY;
     memcpy(&route.rt_dst, &addr, sizeof(addr));
     memcpy(&route.rt_genmask, &addr, sizeof(addr));
-    addr.sin_addr = *gw;
+    addr.sin_addr = intf->gateway;
     memcpy(&route.rt_gateway, &addr, sizeof(addr));
     
     route.rt_flags = RTF_UP | RTF_GATEWAY;
-    route.rt_metric = 0;
-    route.rt_dev = NULL;
+    route.rt_metric = metric + 1;
+    route.rt_dev = intf->device;
 
     if (ioctl(s, SIOCADDRT, &route)) {
 	syslog(LOG_ERR, "failed to set default route: %s", strerror(errno));
