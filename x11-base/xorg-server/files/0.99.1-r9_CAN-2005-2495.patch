diff -urN afb/afbpixmap.c afb/afbpixmap.c
--- afb/afbpixmap.c	2005-08-26 15:35:33.000000000 -0400
+++ afb/afbpixmap.c	2005-08-26 14:09:24.000000000 -0400
@@ -77,10 +77,14 @@
 	int				depth;
 {
 	PixmapPtr pPixmap;
-	int datasize;
-	int paddedWidth;
+	size_t datasize;
+	size_t paddedWidth;
 
 	paddedWidth = BitmapBytePad(width);
+
+	if (paddedWidth > 32767 || height > 32767)
+		return NullPixmap;
+
 	datasize = height * paddedWidth * depth;
 	pPixmap = AllocatePixmap(pScreen, datasize);
 	if (!pPixmap)
diff -urN cfb/cfbpixmap.c cfb/cfbpixmap.c
--- cfb/cfbpixmap.c	2005-08-26 15:35:33.000000000 -0400
+++ cfb/cfbpixmap.c	2005-08-26 14:10:14.000000000 -0400
@@ -68,10 +68,14 @@
     int		depth;
 {
     PixmapPtr pPixmap;
-    int datasize;
-    int paddedWidth;
+    size_t datasize;
+    size_t paddedWidth;
 
     paddedWidth = PixmapBytePad(width, depth);
+
+	if (paddedWidth > 32767 || height > 32767)
+		return NullPixmap;
+
     datasize = height * paddedWidth;
     pPixmap = AllocatePixmap(pScreen, datasize);
     if (!pPixmap)
diff -urN dix/dispatch.c dix/dispatch.c
--- dix/dispatch.c	2004-12-12 20:23:05.000000000 -0500
+++ dix/dispatch.c	2005-08-26 14:13:37.000000000 -0400
@@ -1506,6 +1506,23 @@
 	client->errorValue = 0;
         return BadValue;
     }
+	if (stuff->width > 32767 || stuff->height > 32767)
+	{
+		/* It is allowed to try and allocate a pixmap which is larger than
+		 * 32767 in either dimension.  However, all of the framebuffer code
+		 * is buggy and does not reliably draw to such big pixmaps, basically
+		 * because the Region data structure operates with signed shorts for
+		 * the rectangles in it.
+		 *
+		 * Furthermore, several places in the X server compute the size in
+		 * bytes of the pixmap and try to store it in an integer.  This
+		 * integer can overflow and cause the allocated size to be much
+		 * smaller.
+		 *
+		 * So, such big pixmaps are rejected here with a BadAlloc
+		 */
+		return BadAlloc;
+	}
     if (stuff->depth != 1)
     {
         pDepth = pDraw->pScreen->allowedDepths;
diff -urN fb/fbpixmap.c fb/fbpixmap.c
--- fb/fbpixmap.c	2004-08-08 23:40:50.000000000 -0400
+++ fb/fbpixmap.c	2005-08-26 14:14:49.000000000 -0400
@@ -32,12 +32,16 @@
 fbCreatePixmapBpp (ScreenPtr pScreen, int width, int height, int depth, int bpp)
 {
     PixmapPtr	pPixmap;
-    int		datasize;
-    int		paddedWidth;
+    size_t	datasize;
+    size_t	paddedWidth;
     int		adjust;
     int		base;
 
     paddedWidth = ((width * bpp + FB_MASK) >> FB_SHIFT) * sizeof (FbBits);
+
+	if (paddedWidth > 32767 || height > 32767)
+		return NullPixmap;
+
     datasize = height * paddedWidth;
 #ifdef PIXPRIV
     base = pScreen->totalPixmapSize;
diff -urN hw/xfree86/xaa/xaaInit.c hw/xfree86/xaa/xaaInit.c
--- hw/xfree86/xaa/xaaInit.c	2004-07-30 16:30:56.000000000 -0400
+++ hw/xfree86/xaa/xaaInit.c	2005-08-26 14:16:30.000000000 -0400
@@ -499,6 +499,9 @@
     PixmapPtr pPix = NULL;
     int size = w * h;
     
+	if (w > 32767 || h > 32767)
+		return NullPixmap;
+
     if (!infoRec->offscreenDepthsInitialized)
 	XAAInitializeOffscreenDepths (pScreen);
 
diff -urN hw/xfree86/xf4bpp/ppcPixmap.c hw/xfree86/xf4bpp/ppcPixmap.c
--- hw/xfree86/xf4bpp/ppcPixmap.c	2004-04-23 15:54:17.000000000 -0400
+++ hw/xfree86/xf4bpp/ppcPixmap.c	2005-08-26 14:17:29.000000000 -0400
@@ -85,14 +85,18 @@
     int		depth ;
 {
     register PixmapPtr pPixmap  = (PixmapPtr)NULL;
-    int size ;
+    size_t size ;
     
     TRACE(("xf4bppCreatePixmap(pScreen=0x%x, width=%d, height=%d, depth=%d)\n", pScreen, width, height, depth)) ;
 
     if ( depth > 8 )
-	return (PixmapPtr) NULL ;
+		return (PixmapPtr) NULL ;
+
+	if (width > 32767 || height > 32767)
+		return (PixmapPtr) NULL ;
 
     size = PixmapBytePad(width, depth);
+
     pPixmap = AllocatePixmap (pScreen, (height * size));
     
     if ( !pPixmap )
diff -urN mfb/mfbpixmap.c mfb/mfbpixmap.c
--- mfb/mfbpixmap.c	2003-11-14 11:48:57.000000000 -0500
+++ mfb/mfbpixmap.c	2005-08-26 15:34:32.000000000 -0400
@@ -72,11 +72,15 @@
     int		depth;
 {
     PixmapPtr pPixmap;
-    int datasize;
-    int paddedWidth;
+    size_t datasize;
+    size_t paddedWidth;
 
     if (depth != 1)
 	return NullPixmap;
+
+	if (width > 32767 || height > 32767)
+		return NullPixmap;
+
     paddedWidth = BitmapBytePad(width);
     datasize = height * paddedWidth;
     pPixmap = AllocatePixmap(pScreen, datasize);
