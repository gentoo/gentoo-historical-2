--- glibc-2.3.1/sysdeps/i386/dl-machine.h	2002-09-18 02:28:40.000000000 +0100
+++ libc/sysdeps/i386/dl-machine.h	2002-11-15 22:51:19.000000000 +0000
@@ -201,7 +201,7 @@
 	.previous\n\
 ");
 # else
-# define ELF_MACHINE_RUNTIME_TRAMPOLINE asm ("\n\
+#  define ELF_MACHINE_RUNTIME_TRAMPOLINE asm ("\n\
 	.text\n\
 	.globl _dl_runtime_resolve\n\
 	.globl _dl_runtime_profile\n\
@@ -299,7 +299,7 @@
    define the value.
    ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
    of the main executable's symbols, as for a COPY reloc.  */
-#ifdef USE_TLS
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || USE___THREAD)
 # define elf_machine_type_class(type) \
   ((((type) == R_386_JMP_SLOT || (type) == R_386_TLS_DTPMOD32		      \
      || (type) == R_386_TLS_DTPOFF32 || (type) == R_386_TLS_TPOFF32	      \
@@ -389,7 +389,7 @@
     return;
 # endif
   else
-#endif
+#endif	/* !RTLD_BOOTSTRAP and have no -z combreloc */
     {
       const Elf32_Sym *const refsym = sym;
 #if defined USE_TLS && !defined RTLD_BOOTSTRAP
@@ -402,7 +402,7 @@
       if (sym != NULL)
 # endif
 	value += sym->st_value;
-#endif
+#endif	/* use TLS and !RTLD_BOOTSTRAP */
 
       switch (r_type)
 	{
@@ -411,7 +411,7 @@
 	  *reloc_addr = value;
 	  break;
 
-#ifdef USE_TLS
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || USE___THREAD)
 	case R_386_TLS_DTPMOD32:
 # ifdef RTLD_BOOTSTRAP
 	  /* During startup the dynamic linker is always the module
@@ -444,7 +444,10 @@
 	     thread pointer.  To get the variable position in the TLS
 	     block we subtract the offset from that of the TLS block.  */
 	  if (sym != NULL)
-	    *reloc_addr += sym_map->l_tls_offset - sym->st_value;
+	    {
+	      *reloc_addr += sym_map->l_tls_offset - sym->st_value;
+	      CHECK_STATIC_TLS (map, sym_map);
+	    }
 # endif
 	  break;
 	case R_386_TLS_TPOFF:
@@ -456,7 +459,10 @@
 	     It is a negative value which will be added to the
 	     thread pointer.  */
 	  if (sym != NULL)
-	    *reloc_addr += sym->st_value - sym_map->l_tls_offset;
+	    {
+	      *reloc_addr += sym->st_value - sym_map->l_tls_offset;
+	      CHECK_STATIC_TLS (map, sym_map);
+	    }
 # endif
 	  break;
 #endif	/* use TLS */
@@ -491,7 +497,7 @@
 	default:
 	  _dl_reloc_bad_type (map, r_type, 0);
 	  break;
-#endif
+#endif	/* !RTLD_BOOTSTRAP */
 	}
     }
 }
@@ -508,6 +514,9 @@
     *reloc_addr = map->l_addr + reloc->r_addend;
   else if (r_type != R_386_NONE)
     {
+# ifndef RESOLVE_CONFLICT_FIND_MAP
+      const Elf32_Sym *const refsym = sym;
+# endif
 # ifdef USE_TLS
       struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
       Elf32_Addr value = sym == NULL ? 0 : sym_map->l_addr + sym->st_value;
@@ -515,7 +524,7 @@
       Elf32_Addr value = RESOLVE (&sym, version, ELF32_R_TYPE (reloc->r_info));
       if (sym != NULL)
 	value += sym->st_value;
-#endif
+# endif
 
       switch (ELF32_R_TYPE (reloc->r_info))
 	{
@@ -528,7 +537,7 @@
 	  *reloc_addr = (value + reloc->r_addend - (Elf32_Addr) reloc_addr);
 	  break;
 
-#ifdef USE_TLS
+# ifdef USE_TLS
 	case R_386_TLS_DTPMOD32:
 	  /* Get the information from the link map returned by the
 	     resolv function.  */
@@ -549,6 +558,7 @@
 	  *reloc_addr
 	    = (sym == NULL ? 0 : sym_map->l_tls_offset - sym->st_value)
 	      + reloc->r_addend;
+	  CHECK_STATIC_TLS (map, sym_map);
 	  break;
 	case R_386_TLS_TPOFF:
 	  /* The offset is negative, forward from the thread pointer.  */
@@ -558,8 +568,32 @@
 	  *reloc_addr
 	    = (sym == NULL ? 0 : sym->st_value - sym_map->l_tls_offset)
 	      + reloc->r_addend;
+	  CHECK_STATIC_TLS (map, sym_map);
 	  break;
-#endif	/* use TLS */
+# endif	/* use TLS */
+# ifndef RESOLVE_CONFLICT_FIND_MAP
+	  /* Not needed for dl-conflict.c.  */
+	case R_386_COPY:
+	  if (sym == NULL)
+	    /* This can happen in trace mode if an object could not be
+	       found.  */
+	    break;
+	  if (__builtin_expect (sym->st_size > refsym->st_size, 0)
+	      || (__builtin_expect (sym->st_size < refsym->st_size, 0)
+		  && GL(dl_verbose)))
+	    {
+	      const char *strtab;
+
+	      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
+	      _dl_error_printf ("\
+%s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				rtld_progname ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	    }
+	  memcpy (reloc_addr, (void *) value, MIN (sym->st_size,
+						   refsym->st_size));
+	  break;
+# endif /* !RESOLVE_CONFLICT_FIND_MAP */
 	default:
 	  /* We add these checks in the version to relocate ld.so only
 	     if we are still debugging.  */
@@ -568,7 +602,7 @@
 	}
     }
 }
-#endif
+#endif	/* !RTLD_BOOTSTRAP */
 
 static inline void
 elf_machine_rel_relative (Elf32_Addr l_addr, const Elf32_Rel *reloc,
@@ -585,7 +619,7 @@
 {
   *reloc_addr = l_addr + reloc->r_addend;
 }
-#endif
+#endif	/* !RTLD_BOOTSTRAP */
 
 static inline void
 elf_machine_lazy_rel (struct link_map *map,
@@ -614,6 +648,6 @@
 {
 }
 
-#endif
+#endif	/* !RTLD_BOOTSTRAP */
 
 #endif /* RESOLVE */
