http://lists.gnu.org/archive/html/bug-bash/2005-12/msg00033.html

Configuration Information [Automatically generated, do not change]:
Machine: ia64
OS: linux
Compiler: gcc -I/usr/src/packages/BUILD/bash-3.1 -L/usr/src/packages/BUILD/bash-3.1/../readline-5.1
Compilation CFLAGS:  -DPROGRAM='bash' -DCONF_HOSTTYPE='ia64' -DCONF_OSTYPE='linux' -DCONF_MACHTYPE='ia64-suse-linux' -DCONF_VENDOR='suse' -DLOCALEDIR='/usr/share/locale' -DPACKAGE='bash' -DSHELL -DHAVE_CONFIG_H   -I.  -I. -I./include -I./lib   -O2 -fmessage-length=0 -Wall -D_FORTIFY_SOURCE=2 -g -D_GNU_SOURCE -DRECYCLES_PIDS -Wall -pipe -g -fbranch-probabilities
uname output: Linux sykes 2.6.13-15-default #1 SMP Tue Sep 13 14:56:15 UTC 2005 ia64 ia64 ia64 GNU/Linux
Machine Type: ia64-suse-linux

Bash Version: 3.1
Patch Level: 0
Release Status: release

Description:
When using the readline callback interface (rl_callback_read_char) you'll
get a segfault when using the delete-char function via a multi-character
key.  The problem is (1) that rl_delete_char returns non-zero even if
successful and (2) that _rl_dispatch_subseq reports the return value of
any readline function as if it were the result of the keymap dispatch.
The result is that _rl_dispatch_callback doesn't clear the
RL_STATE_MULTIKEY flag, and the next input crashes because _rl_kscxt is
NULL when _rl_dispatch_callback is called the next time.  This is only a
problem with the callback interface, because otherwise RL_STATE_MULTIKEY
is never set.

Repeat-By:
Build gdb with readline 5.1.

Fix:
 lib/readline/readline.c |    2 +-
 lib/readline/text.c     |    8 +++-----
 2 files changed, 4 insertions(+), 6 deletions(-)

Index: bash-3.1/lib/readline/text.c
===================================================================
--- bash-3.1.orig/lib/readline/text.c	2005-12-13 14:07:38.000000000 +0100
+++ bash-3.1/lib/readline/text.c	2005-12-13 14:09:53.000000000 +0100
@@ -1071,8 +1071,6 @@ int
 rl_delete (count, key)
      int count, key;
 {
-  int r;
-
   if (count < 0)
     return (_rl_rubout_char (-count, key));
 
@@ -1090,17 +1088,17 @@ rl_delete (count, key)
       else
 	rl_forward_byte (count, key);
 
-      r = rl_kill_text (orig_point, rl_point);
+      rl_kill_text (orig_point, rl_point);
       rl_point = orig_point;
-      return r;
     }
   else
     {
       int new_point;
 
       new_point = MB_NEXTCHAR (rl_line_buffer, rl_point, 1, MB_FIND_NONZERO);
-      return (rl_delete_text (rl_point, new_point));
+      rl_delete_text (rl_point, new_point);
     }
+  return 0;
 }
 
 /* Delete the character under the cursor, unless the insertion
Index: bash-3.1/lib/readline/readline.c
===================================================================
--- bash-3.1.orig/lib/readline/readline.c	2005-12-13 14:07:24.000000000 +0100
+++ bash-3.1/lib/readline/readline.c	2005-12-13 14:38:01.000000000 +0100
@@ -721,7 +721,7 @@ _rl_dispatch_subseq (key, map, got_subse
 
 	  rl_dispatching = 1;
 	  RL_SETSTATE(RL_STATE_DISPATCHING);
-	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
+	  (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
 	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
 	  rl_dispatching = 0;
 


_______________________________________________
Bug-bash mailing list
Bug-bash@gnu.org
http://lists.gnu.org/mailman/listinfo/bug-bash
