--- db.1.85/btree/bt_delete.c.jj	Thu Jul 28 16:30:03 1994
+++ db.1.85/btree/bt_delete.c	Wed Apr 19 17:56:12 2000
@@ -154,7 +154,7 @@ __bt_stkacq(t, hp, c)
 	pgno_t pgno;
 	recno_t nextpg, prevpg;
 	int exact, level;
-	
+
 	/*
 	 * Find the first occurrence of the key in the tree.  Toss the
 	 * currently locked page so we don't hit an already-locked page.
@@ -270,7 +270,7 @@ __bt_stkacq(t, hp, c)
 		if ((h = mpool_get(t->bt_mp, prevpg, 0)) == NULL)
 			return (1);
 	}
-	
+
 
 ret:	mpool_put(t->bt_mp, h, 0);
 	return ((*hp = mpool_get(t->bt_mp, c->pg.pgno, 0)) == NULL);
@@ -402,7 +402,7 @@ __bt_pdelete(t, h)
 		/* Get the parent page. */
 		if ((pg = mpool_get(t->bt_mp, parent->pgno, 0)) == NULL)
 			return (RET_ERROR);
-		
+
 		index = parent->index;
 		bi = GETBINTERNAL(pg, index);
 
@@ -418,7 +418,7 @@ __bt_pdelete(t, h)
 		 * root page. If it's the rootpage, turn it back into an empty
 		 * leaf page.
 		 */
-		if (NEXTINDEX(pg) == 1)
+		if (NEXTINDEX(pg) == 1) {
 			if (pg->pgno == P_ROOT) {
 				pg->lower = BTDATAOFF;
 				pg->upper = t->bt_psize;
@@ -428,7 +428,7 @@ __bt_pdelete(t, h)
 					return (RET_ERROR);
 				continue;
 			}
-		else {
+		} else {
 			/* Pack remaining key items at the end of the page. */
 			nksize = NBINTERNAL(bi->ksize);
 			from = (char *)pg + pg->upper;
@@ -571,7 +571,7 @@ __bt_curdel(t, key, h, index)
 			key = &c->key;
 		}
 		/* Check previous key, if not at the beginning of the page. */
-		if (index > 0) { 
+		if (index > 0) {
 			e.page = h;
 			e.index = index - 1;
 			if (__bt_cmp(t, key, &e) == 0) {
--- db.1.85/btree/bt_open.c.jj	Thu Aug 18 15:30:42 1994
+++ db.1.85/btree/bt_open.c	Wed Apr 19 17:56:12 2000
@@ -125,7 +125,7 @@ __bt_open(fname, flags, mode, openinfo, 
 		 */
 		if (b.psize &&
 		    (b.psize < MINPSIZE || b.psize > MAX_PAGE_OFFSET + 1 ||
-		    b.psize & sizeof(indx_t) - 1))
+		    b.psize & (sizeof(indx_t) - 1)))
 			goto einval;
 
 		/* Minimum number of keys per page; absolute minimum is 2. */
@@ -200,7 +200,7 @@ __bt_open(fname, flags, mode, openinfo, 
 		default:
 			goto einval;
 		}
-		
+
 		if ((t->bt_fd = open(fname, flags, mode)) < 0)
 			goto err;
 
@@ -245,7 +245,7 @@ __bt_open(fname, flags, mode, openinfo, 
 		if (m.magic != BTREEMAGIC || m.version != BTREEVERSION)
 			goto eftype;
 		if (m.psize < MINPSIZE || m.psize > MAX_PAGE_OFFSET + 1 ||
-		    m.psize & sizeof(indx_t) - 1)
+		    m.psize & (sizeof(indx_t) - 1))
 			goto eftype;
 		if (m.flags & ~SAVEMETA)
 			goto eftype;
@@ -259,7 +259,9 @@ __bt_open(fname, flags, mode, openinfo, 
 		 * Don't overflow the page offset type.
 		 */
 		if (b.psize == 0) {
+#ifdef _STATBUF_ST_BLKSIZE
 			b.psize = sb.st_blksize;
+#endif
 			if (b.psize < MINPSIZE)
 				b.psize = MINPSIZE;
 			if (b.psize > MAX_PAGE_OFFSET + 1)
@@ -278,8 +280,8 @@ __bt_open(fname, flags, mode, openinfo, 
 	t->bt_psize = b.psize;
 
 	/* Set the cache size; must be a multiple of the page size. */
-	if (b.cachesize && b.cachesize & b.psize - 1)
-		b.cachesize += (~b.cachesize & b.psize - 1) + 1;
+	if (b.cachesize && b.cachesize & (b.psize - 1))
+		b.cachesize += (~b.cachesize & (b.psize - 1)) + 1;
 	if (b.cachesize < b.psize * MINCACHE)
 		b.cachesize = b.psize * MINCACHE;
 
@@ -388,18 +390,30 @@ tmp()
 {
 	sigset_t set, oset;
 	int fd;
-	char *envtmp;
-	char path[MAXPATHLEN];
+	const char *envtmp;
+	char *path;
+	static const char fmt[] = "%s/bt.XXXXXX";
+	size_t n;
 
 	envtmp = getenv("TMPDIR");
-	(void)snprintf(path,
-	    sizeof(path), "%s/bt.XXXXXX", envtmp ? envtmp : "/tmp");
+	if (!envtmp)
+	  envtmp = "/tmp";
+	n = strlen (envtmp) + sizeof fmt;
+#ifdef	__GNUC__
+	path = __builtin_alloca(n);
+#else
+	path = malloc(n);
+#endif
+	(void)snprintf(path, n, fmt, envtmp ? envtmp : "/tmp");
 
 	(void)sigfillset(&set);
 	(void)sigprocmask(SIG_BLOCK, &set, &oset);
 	if ((fd = mkstemp(path)) != -1)
 		(void)unlink(path);
 	(void)sigprocmask(SIG_SETMASK, &oset, NULL);
+#ifndef	__GNUC__
+	free(path);
+#endif
 	return(fd);
 }
 
--- db.1.85/btree/bt_page.c.jj	Thu Jul 14 03:29:02 1994
+++ db.1.85/btree/bt_page.c	Wed Apr 19 17:56:12 2000
@@ -65,6 +65,7 @@ __bt_free(t, h)
 	h->prevpg = P_INVALID;
 	h->nextpg = t->bt_free;
 	t->bt_free = h->pgno;
+	F_SET(t, B_METADIRTY);
 
 	/* Make sure the page gets written back. */
 	return (mpool_put(t->bt_mp, h, MPOOL_DIRTY));
@@ -92,6 +93,7 @@ __bt_new(t, npg)
 	    (h = mpool_get(t->bt_mp, t->bt_free, 0)) != NULL) {
 		*npg = t->bt_free;
 		t->bt_free = h->nextpg;
+		F_SET(t, B_METADIRTY);
 		return (h);
 	}
 	return (mpool_new(t->bt_mp, npg));
--- db.1.85/btree/bt_put.c.jj	Tue Jul 26 20:56:14 1994
+++ db.1.85/btree/bt_put.c	Wed Apr 19 17:56:12 2000
@@ -201,7 +201,7 @@ delete:		if (__bt_dleaf(t, key, h, index
 	 * into the offset array, shift the pointers up.
 	 */
 	nbytes = NBLEAFDBT(key->size, data->size);
-	if (h->upper - h->lower < nbytes + sizeof(indx_t)) {
+	if ((u_int32_t) (h->upper - h->lower) < nbytes + sizeof(indx_t)) {
 		if ((status = __bt_split(t, h, key,
 		    data, dflags, nbytes, index)) != RET_SUCCESS)
 			return (status);
@@ -223,7 +223,7 @@ delete:		if (__bt_dleaf(t, key, h, index
 	    t->bt_cursor.pg.pgno == h->pgno && t->bt_cursor.pg.index >= index)
 		++t->bt_cursor.pg.index;
 
-	if (t->bt_order == NOT)
+	if (t->bt_order == NOT) {
 		if (h->nextpg == P_INVALID) {
 			if (index == NEXTINDEX(h) - 1) {
 				t->bt_order = FORWARD;
@@ -237,6 +237,7 @@ delete:		if (__bt_dleaf(t, key, h, index
 				t->bt_last.pgno = h->pgno;
 			}
 		}
+	}
 
 	mpool_put(t->bt_mp, h, MPOOL_DIRTY);
 
@@ -284,7 +285,7 @@ bt_fast(t, key, data, exactp)
 	 * have to search to get split stack.
 	 */
 	nbytes = NBLEAFDBT(key->size, data->size);
-	if (h->upper - h->lower < nbytes + sizeof(indx_t))
+	if ((u_int32_t) (h->upper - h->lower) < nbytes + sizeof(indx_t))
 		goto miss;
 
 	if (t->bt_order == FORWARD) {
--- db.1.85/btree/bt_seq.c.jj	Tue Jul 26 18:57:24 1994
+++ db.1.85/btree/bt_seq.c	Wed Apr 19 17:56:12 2000
@@ -92,7 +92,7 @@ __bt_seq(dbp, key, data, flags)
 	}
 
 	/*
-	 * If scan unitialized as yet, or starting at a specific record, set
+	 * If scan uninitialized as yet, or starting at a specific record, set
 	 * the scan to a specific key.  Both __bt_seqset and __bt_seqadv pin
 	 * the page the cursor references if they're successful.
 	 */
@@ -358,13 +358,13 @@ __bt_first(t, key, erval, exactp)
 	 * page) and return it.
 	 */
 	if ((ep = __bt_search(t, key, exactp)) == NULL)
-		return (NULL);
+		return (RET_SPECIAL);
 	if (*exactp) {
 		if (F_ISSET(t, B_NODUPS)) {
 			*erval = *ep;
 			return (RET_SUCCESS);
 		}
-			
+
 		/*
 		 * Walk backwards, as long as the entry matches and there are
 		 * keys left in the tree.  Save a copy of each match in case
--- db.1.85/btree/bt_split.c.jj	Tue Jul 26 20:22:02 1994
+++ db.1.85/btree/bt_split.c	Wed Apr 19 17:56:12 2000
@@ -215,7 +215,8 @@ __bt_split(t, sp, key, data, flags, ilen
 		}
 
 		/* Split the parent page if necessary or shift the indices. */
-		if (h->upper - h->lower < nbytes + sizeof(indx_t)) {
+		if ((u_int32_t) (h->upper - h->lower)
+		    < nbytes + sizeof(indx_t)) {
 			sp = h;
 			h = h->pgno == P_ROOT ?
 			    bt_root(t, h, &l, &r, &skip, nbytes) :
@@ -673,7 +674,8 @@ bt_psplit(t, h, l, r, pskip, ilen)
 		 * where we decide to try and copy too much onto the left page.
 		 * Make sure that doesn't happen.
 		 */
-		if (skip <= off && used + nbytes >= full) {
+		if ((skip <= off && used + nbytes + sizeof(indx_t) >= full)
+		    || nxt == top - 1) {
 			--off;
 			break;
 		}
@@ -686,7 +688,7 @@ bt_psplit(t, h, l, r, pskip, ilen)
 			memmove((char *)l + l->upper, src, nbytes);
 		}
 
-		used += nbytes;
+		used += nbytes + sizeof(indx_t);
 		if (used >= half) {
 			if (!isbigkey || bigkeycnt == 3)
 				break;
--- db.1.85/btree/bt_utils.c.jj	Wed Jul 20 17:06:53 1994
+++ db.1.85/btree/bt_utils.c	Wed Apr 19 17:56:12 2000
@@ -76,7 +76,7 @@ __bt_ret(t, e, key, rkey, data, rdata, c
 	bl = GETBLEAF(e->page, e->index);
 
 	/*
-	 * We must copy big keys/data to make them contigous.  Otherwise,
+	 * We must copy big keys/data to make them contiguous.  Otherwise,
 	 * leave the page pinned and don't copy unless the user specified
 	 * concurrent access.
 	 */
--- db.1.85/btree/btree.h.jj	Thu Aug 18 15:30:43 1994
+++ db.1.85/btree/btree.h	Wed Apr 19 17:58:46 2000
@@ -43,6 +43,14 @@
 
 #include <mpool.h>
 
+#define mpool_open __mpool_open
+#define mpool_filter __mpool_filter
+#define mpool_new __mpool_new
+#define mpool_get __mpool_get
+#define mpool_put __mpool_put
+#define mpool_sync __mpool_sync
+#define mpool_close __mpool_close
+
 #define	DEFMINKEYPAGE	(2)		/* Minimum keys per page */
 #define	MINCACHE	(5)		/* Minimum cached pages */
 #define	MINPSIZE	(512)		/* Minimum page size */
@@ -161,7 +169,7 @@ typedef struct _rinternal {
 #define NRINTERNAL							\
 	LALIGN(sizeof(recno_t) + sizeof(pgno_t))
 
-/* Copy a RINTERAL entry to the page. */
+/* Copy a RINTERNAL entry to the page. */
 #define	WR_RINTERNAL(p, nrecs, pgno) {					\
 	*(recno_t *)p = nrecs;						\
 	p += sizeof(recno_t);						\
--- db.1.85/hash/extern.h.jj	Thu Jun 16 22:30:14 1994
+++ db.1.85/hash/extern.h	Wed Apr 19 17:56:12 2000
@@ -52,7 +52,7 @@ void	 __free_ovflpage __P((HTAB *, BUFHE
 BUFHEAD	*__get_buf __P((HTAB *, u_int32_t, BUFHEAD *, int));
 int	 __get_page __P((HTAB *, char *, u_int32_t, int, int, int));
 int	 __ibitmap __P((HTAB *, int, int, int));
-u_int32_t	 __log2 __P((u_int32_t));
+u_int32_t	 __hash_log2 __P((u_int32_t));
 int	 __put_page __P((HTAB *, char *, u_int32_t, int, int));
 void	 __reclaim_buf __P((HTAB *, BUFHEAD *));
 int	 __split_page __P((HTAB *, u_int32_t, u_int32_t));
--- db.1.85/hash/hash.c.jj	Fri Jun 24 17:12:29 1994
+++ db.1.85/hash/hash.c	Wed Apr 19 17:56:12 2000
@@ -157,7 +157,8 @@ __hash_open(file, flags, mode, info, dfl
 		if (hashp->VERSION != HASHVERSION &&
 		    hashp->VERSION != OLDHASHVERSION)
 			RETURN_ERROR(EFTYPE, error1);
-		if (hashp->hash(CHARKEY, sizeof(CHARKEY)) != hashp->H_CHARKEY)
+		if (hashp->hash(CHARKEY, sizeof(CHARKEY))
+		    != (u_int32_t) hashp->H_CHARKEY)
 			RETURN_ERROR(EFTYPE, error1);
 		/*
 		 * Figure out how many segments we need.  Max_Bucket is the
@@ -189,7 +190,7 @@ __hash_open(file, flags, mode, info, dfl
 		__buf_init(hashp, DEF_BUFSIZE);
 
 	hashp->new_file = new_table;
-	hashp->save_file = file && (hashp->flags & O_RDWR);
+	hashp->save_file = file && (hashp->flags & O_ACCMODE) != O_RDONLY;
 	hashp->cbucket = -1;
 	if (!(dbp = (DB *)malloc(sizeof(DB)))) {
 		save_errno = errno;
@@ -281,7 +282,9 @@ init_hash(hashp, file, info)
 	const char *file;
 	HASHINFO *info;
 {
+#ifdef _STATBUF_ST_BLKSIZE
 	struct stat statbuf;
+#endif
 	int nelem;
 
 	nelem = 1;
@@ -298,17 +301,19 @@ init_hash(hashp, file, info)
 	memset(hashp->BITMAPS, 0, sizeof (hashp->BITMAPS));
 
 	/* Fix bucket size to be optimal for file system */
+#ifdef _STATBUF_ST_BLKSIZE
 	if (file != NULL) {
 		if (stat(file, &statbuf))
 			return (NULL);
 		hashp->BSIZE = statbuf.st_blksize;
-		hashp->BSHIFT = __log2(hashp->BSIZE);
+		hashp->BSHIFT = __hash_log2(hashp->BSIZE);
 	}
+#endif
 
 	if (info) {
 		if (info->bsize) {
 			/* Round pagesize up to power of 2 */
-			hashp->BSHIFT = __log2(info->bsize);
+			hashp->BSHIFT = __hash_log2(info->bsize);
 			hashp->BSIZE = 1 << hashp->BSHIFT;
 			if (hashp->BSIZE > MAX_BSIZE) {
 				errno = EINVAL;
@@ -357,7 +362,7 @@ init_htab(hashp, nelem)
 	 */
 	nelem = (nelem - 1) / hashp->FFACTOR + 1;
 
-	l2 = __log2(MAX(nelem, 2));
+	l2 = __hash_log2(MAX(nelem, 2));
 	nbuckets = 1 << l2;
 
 	hashp->SPARES[l2] = l2 + 1;
@@ -375,7 +380,7 @@ init_htab(hashp, nelem)
 	    hashp->BSHIFT) + 1;
 
 	nsegs = (nbuckets - 1) / hashp->SGSIZE + 1;
-	nsegs = 1 << __log2(nsegs);
+	nsegs = 1 << __hash_log2(nsegs);
 
 	if (nsegs > hashp->DSIZE)
 		hashp->DSIZE = nsegs;
@@ -505,7 +510,7 @@ flush_meta(hashp)
 	else
 		if (wsize != sizeof(HASHHDR)) {
 			errno = EFTYPE;
-			hashp->errno = errno;
+			hashp->errnum = errno;
 			return (-1);
 		}
 	for (i = 0; i < NCACHED; i++)
@@ -536,7 +541,7 @@ hash_get(dbp, key, data, flag)
 
 	hashp = (HTAB *)dbp->internal;
 	if (flag) {
-		hashp->errno = errno = EINVAL;
+		hashp->errnum = errno = EINVAL;
 		return (ERROR);
 	}
 	return (hash_access(hashp, HASH_GET, (DBT *)key, data));
@@ -553,11 +558,11 @@ hash_put(dbp, key, data, flag)
 
 	hashp = (HTAB *)dbp->internal;
 	if (flag && flag != R_NOOVERWRITE) {
-		hashp->errno = errno = EINVAL;
+		hashp->errnum = errno = EINVAL;
 		return (ERROR);
 	}
 	if ((hashp->flags & O_ACCMODE) == O_RDONLY) {
-		hashp->errno = errno = EPERM;
+		hashp->errnum = errno = EPERM;
 		return (ERROR);
 	}
 	return (hash_access(hashp, flag == R_NOOVERWRITE ?
@@ -574,11 +579,11 @@ hash_delete(dbp, key, flag)
 
 	hashp = (HTAB *)dbp->internal;
 	if (flag && flag != R_CURSOR) {
-		hashp->errno = errno = EINVAL;
+		hashp->errnum = errno = EINVAL;
 		return (ERROR);
 	}
 	if ((hashp->flags & O_ACCMODE) == O_RDONLY) {
-		hashp->errno = errno = EPERM;
+		hashp->errnum = errno = EPERM;
 		return (ERROR);
 	}
 	return (hash_access(hashp, HASH_DELETE, (DBT *)key, NULL));
@@ -729,7 +734,7 @@ hash_seq(dbp, key, data, flag)
 
 	hashp = (HTAB *)dbp->internal;
 	if (flag && flag != R_FIRST && flag != R_NEXT) {
-		hashp->errno = errno = EINVAL;
+		hashp->errnum = errno = EINVAL;
 		return (ERROR);
 	}
 #ifdef HASH_STATISTICS
@@ -744,7 +749,7 @@ hash_seq(dbp, key, data, flag)
 	for (bp = NULL; !bp || !bp[0]; ) {
 		if (!(bufp = hashp->cpage)) {
 			for (bucket = hashp->cbucket;
-			    bucket <= hashp->MAX_BUCKET;
+			    bucket <= (u_int32_t) hashp->MAX_BUCKET;
 			    bucket++, hashp->cndx = 1) {
 				bufp = __get_buf(hashp, bucket, NULL, 0);
 				if (!bufp)
@@ -842,13 +847,13 @@ __expand_table(hashp)
 	 * * increases), we need to copy the current contents of the spare
 	 * split bucket to the next bucket.
 	 */
-	spare_ndx = __log2(hashp->MAX_BUCKET + 1);
+	spare_ndx = __hash_log2(hashp->MAX_BUCKET + 1);
 	if (spare_ndx > hashp->OVFL_POINT) {
 		hashp->SPARES[spare_ndx] = hashp->SPARES[hashp->OVFL_POINT];
 		hashp->OVFL_POINT = spare_ndx;
 	}
 
-	if (new_bucket > hashp->HIGH_MASK) {
+	if (new_bucket > (u_int32_t) hashp->HIGH_MASK) {
 		/* Starting a new doubling */
 		hashp->LOW_MASK = hashp->HIGH_MASK;
 		hashp->HIGH_MASK = new_bucket | hashp->LOW_MASK;
@@ -868,7 +873,7 @@ hash_realloc(p_ptr, oldsize, newsize)
 {
 	register void *p;
 
-	if (p = malloc(newsize)) {
+	if ((p = malloc(newsize))) {
 		memmove(p, *p_ptr, oldsize);
 		memset((char *)p + oldsize, 0, newsize - oldsize);
 		free(*p_ptr);
--- db.1.85/hash/hash.h.jj	Fri Jun 24 17:12:29 1994
+++ db.1.85/hash/hash.h	Wed Apr 19 17:56:12 2000
@@ -71,28 +71,28 @@ typedef struct hashhdr {		/* Disk reside
 	int		dsize;		/* Directory Size */
 	int		ssize;		/* Segment Size */
 	int		sshift;		/* Segment shift */
-	int		ovfl_point;	/* Where overflow pages are being 
+	int		ovfl_point;	/* Where overflow pages are being
 					 * allocated */
 	int		last_freed;	/* Last overflow page freed */
 	int		max_bucket;	/* ID of Maximum bucket in use */
 	int		high_mask;	/* Mask to modulo into entire table */
-	int		low_mask;	/* Mask to modulo into lower half of 
+	int		low_mask;	/* Mask to modulo into lower half of
 					 * table */
 	int		ffactor;	/* Fill factor */
 	int		nkeys;		/* Number of keys in hash table */
 	int		hdrpages;	/* Size of table header */
 	int		h_charkey;	/* value of hash(CHARKEY) */
-#define NCACHED	32			/* number of bit maps and spare 
+#define NCACHED	32			/* number of bit maps and spare
 					 * points */
 	int		spares[NCACHED];/* spare pages for overflow */
-	u_int16_t	bitmaps[NCACHED];	/* address of overflow page 
+	u_int16_t	bitmaps[NCACHED];	/* address of overflow page
 						 * bitmaps */
 } HASHHDR;
 
 typedef struct htab	 {		/* Memory resident data structure */
 	HASHHDR 	hdr;		/* Header */
 	int		nsegs;		/* Number of allocated segments */
-	int		exsegs;		/* Number of extra allocated 
+	int		exsegs;		/* Number of extra allocated
 					 * segments */
 	u_int32_t			/* Hash function */
 	    (*hash)__P((const void *, size_t));
@@ -103,16 +103,16 @@ typedef struct htab	 {		/* Memory reside
 	BUFHEAD 	*cpage;		/* Current page */
 	int		cbucket;	/* Current bucket */
 	int		cndx;		/* Index of next item on cpage */
-	int		errno;		/* Error Number -- for DBM 
-					 * compatability */
-	int		new_file;	/* Indicates if fd is backing store 
+	int		errnum;		/* Error Number -- for DBM
+					 * compatibility */
+	int		new_file;	/* Indicates if fd is backing store
 					 * or no */
-	int		save_file;	/* Indicates whether we need to flush 
+	int		save_file;	/* Indicates whether we need to flush
 					 * file at
 					 * exit */
 	u_int32_t	*mapp[NCACHED];	/* Pointers to page maps */
 	int		nmaps;		/* Initial number of bitmaps */
-	int		nbufs;		/* Number of buffers left to 
+	int		nbufs;		/* Number of buffers left to
 					 * allocate */
 	BUFHEAD 	bufhead;	/* Header of buffer lru list */
 	SEGMENT 	*dir;		/* Hash Bucket directory */
@@ -170,7 +170,7 @@ typedef struct htab	 {		/* Memory reside
 #define	OADDR_OF(S,O)	((u_int32_t)((u_int32_t)(S) << SPLITSHIFT) + (O))
 
 #define BUCKET_TO_PAGE(B) \
-	(B) + hashp->HDRPAGES + ((B) ? hashp->SPARES[__log2((B)+1)-1] : 0)
+	(B) + hashp->HDRPAGES + ((B) ? hashp->SPARES[__hash_log2((B)+1)-1] : 0)
 #define OADDR_TO_PAGE(B) 	\
 	BUCKET_TO_PAGE ( (1 << SPLITNUM((B))) -1 ) + OPAGENUM((B));
 
@@ -194,7 +194,7 @@ typedef struct htab	 {		/* Memory reside
  *		so it starts on this page and continues on the next.
  *		The format of the page is:
  *		    KEY_OFF PARTIAL_KEY OVFL_PAGENO OVFLPAGE
- *		
+ *
  *		    KEY_OFF -- offset of the beginning of the key
  *		    PARTIAL_KEY -- 1
  *		    OVFL_PAGENO - page number of the next overflow page
@@ -229,7 +229,7 @@ typedef struct htab	 {		/* Memory reside
  *		    OVFL_PAGENO - page number of the next overflow page
  *		    OVFLPAGE -- 0
  *
- * FULL_KEY_DATA 
+ * FULL_KEY_DATA
  *		This must be the first key/data pair on the page.
  *		There are two cases:
  *
--- db.1.85/hash/hash_bigkey.c.jj	Fri Jun 24 17:12:30 1994
+++ db.1.85/hash/hash_bigkey.c	Wed Apr 19 17:56:12 2000
@@ -121,7 +121,7 @@ __big_insert(hashp, bufp, key, val)
 		if (!bufp)
 			return (-1);
 		n = p[0];
-		if (!key_size)
+		if (!key_size) {
 			if (FREESPACE(p)) {
 				move_bytes = MIN(FREESPACE(p), val_size);
 				off = OFFSET(p) - move_bytes;
@@ -134,6 +134,7 @@ __big_insert(hashp, bufp, key, val)
 				OFFSET(p) = off;
 			} else
 				p[n - 2] = FULL_KEY;
+		}
 		p = (u_int16_t *)bufp->page;
 		cp = bufp->page;
 		bufp->flags |= BUF_MOD;
@@ -147,7 +148,7 @@ __big_insert(hashp, bufp, key, val)
 		 * Here's the hack to make sure that if the data ends on the
 		 * same page as the key ends, FREESPACE is at least one.
 		 */
-		if (space == val_size && val_size == val->size)
+		if ((int) space == val_size && (size_t) val_size == val->size)
 			move_bytes--;
 		off = OFFSET(p) - move_bytes;
 		memmove(cp + off, val_data, move_bytes);
@@ -249,7 +250,7 @@ __big_delete(hashp, bufp)
 	bufp->flags |= BUF_MOD;
 	if (rbufp)
 		__free_ovflpage(hashp, rbufp);
-	if (last_bfp != rbufp)
+	if (last_bfp && last_bfp != rbufp)
 		__free_ovflpage(hashp, last_bfp);
 
 	hashp->NKEYS--;
@@ -431,7 +432,7 @@ __big_return(hashp, bufp, ndx, val, set_
 		}
 
 	val->size = collect_data(hashp, bufp, (int)len, set_current);
-	if (val->size == -1)
+	if (val->size == (size_t) -1)
 		return (-1);
 	if (save_p->addr != save_addr) {
 		/* We are pretty short on buffers. */
@@ -510,7 +511,7 @@ __big_keydata(hashp, bufp, key, val, set
 	int set;
 {
 	key->size = collect_key(hashp, bufp, 0, val, set);
-	if (key->size == -1)
+	if (key->size == (size_t) -1)
 		return (-1);
 	key->data = (u_char *)hashp->tmp_key;
 	return (0);
@@ -590,7 +591,7 @@ __big_split(hashp, op, np, big_keyp, add
 		return (-1);
 	change = (__call_hash(hashp, key.data, key.size) != obucket);
 
-	if (ret->next_addr = __find_last_page(hashp, &big_keyp)) {
+	if ((ret->next_addr = __find_last_page(hashp, &big_keyp))) {
 		if (!(ret->nextp =
 		    __get_buf(hashp, ret->next_addr, big_keyp, 0)))
 			return (-1);;
--- db.1.85/hash/hash_log2.c.jj	Tue May 31 22:56:53 1994
+++ db.1.85/hash/hash_log2.c	Wed Apr 19 17:56:12 2000
@@ -42,8 +42,10 @@ static char sccsid[] = "@(#)hash_log2.c	
 
 #include <db.h>
 
+u_int32_t __hash_log2 __P((u_int32_t));
+
 u_int32_t
-__log2(num)
+__hash_log2(num)
 	u_int32_t num;
 {
 	register u_int32_t i, limit;
--- db.1.85/hash/ndbm.c.jj	Thu Jul 21 20:02:40 1994
+++ db.1.85/hash/ndbm.c	Wed Apr 19 17:56:12 2000
@@ -47,6 +47,7 @@ static char sccsid[] = "@(#)ndbm.c	8.4 (
 
 #include <stdio.h>
 #include <string.h>
+#include <stdlib.h>
 
 #include <ndbm.h>
 #include "hash.h"
@@ -61,8 +62,16 @@ dbm_open(file, flags, mode)
 	const char *file;
 	int flags, mode;
 {
+  	DBM *db;
 	HASHINFO info;
-	char path[MAXPATHLEN];
+	const size_t len = strlen(file) + sizeof (DBM_SUFFIX);
+#ifdef __GNUC__
+	char path[len];
+#else
+	char *path = malloc(len);
+	if (path == NULL)
+		return NULL;
+#endif
 
 	info.bsize = 4096;
 	info.ffactor = 40;
@@ -72,7 +81,11 @@ dbm_open(file, flags, mode)
 	info.lorder = 0;
 	(void)strcpy(path, file);
 	(void)strcat(path, DBM_SUFFIX);
-	return ((DBM *)__hash_open(path, flags, mode, &info, 0));
+	db = (DBM *)__hash_open(path, flags, mode, &info, 0);
+#ifndef	__GNUC__
+	free(path);
+#endif
+	return db;
 }
 
 extern void
@@ -180,7 +193,7 @@ dbm_error(db)
 	HTAB *hp;
 
 	hp = (HTAB *)db->internal;
-	return (hp->errno);
+	return (hp->errnum);
 }
 
 extern int
@@ -190,7 +203,7 @@ dbm_clearerr(db)
 	HTAB *hp;
 
 	hp = (HTAB *)db->internal;
-	hp->errno = 0;
+	hp->errnum = 0;
 	return (0);
 }
 
--- db.1.85/recno/rec_close.c.jj	Thu Aug 18 17:23:29 1994
+++ db.1.85/recno/rec_close.c	Wed Apr 19 17:56:12 2000
@@ -79,13 +79,14 @@ __rec_close(dbp)
 	if (F_ISSET(t, R_MEMMAPPED) && munmap(t->bt_smap, t->bt_msize))
 		status = RET_ERROR;
 
-	if (!F_ISSET(t, R_INMEM))
+	if (!F_ISSET(t, R_INMEM)) {
 		if (F_ISSET(t, R_CLOSEFP)) {
 			if (fclose(t->bt_rfp))
 				status = RET_ERROR;
 		} else
 			if (close(t->bt_rfd))
 				status = RET_ERROR;
+	}
 
 	if (__bt_close(dbp) == RET_ERROR)
 		status = RET_ERROR;
@@ -150,7 +151,7 @@ __rec_sync(dbp, flags)
 		 */
 		status = (dbp->seq)(dbp, &key, &data, R_FIRST);
 		while (status == RET_SUCCESS) {
-			if (write(t->bt_rfd, data.data, data.size) != data.size)
+			if ((size_t) write(t->bt_rfd, data.data, data.size) != data.size)
 				return (RET_ERROR);
 			status = (dbp->seq)(dbp, &key, &data, R_NEXT);
 		}
@@ -162,7 +163,7 @@ __rec_sync(dbp, flags)
 		while (status == RET_SUCCESS) {
 			iov[0].iov_base = data.data;
 			iov[0].iov_len = data.size;
-			if (writev(t->bt_rfd, iov, 2) != data.size + 1)
+			if ((size_t) writev(t->bt_rfd, iov, 2) != data.size + 1)
 				return (RET_ERROR);
 			status = (dbp->seq)(dbp, &key, &data, R_NEXT);
 		}
--- db.1.85/recno/rec_put.c.jj	Thu Aug 18 17:24:16 1994
+++ db.1.85/recno/rec_put.c	Wed Apr 19 17:56:12 2000
@@ -170,7 +170,7 @@ einval:		errno = EINVAL;
 
 	if (flags == R_SETCURSOR)
 		t->bt_cursor.rcursor = nrec;
-	
+
 	F_SET(t, R_MODIFIED);
 	return (__rec_ret(t, NULL, nrec, key, NULL));
 }
@@ -256,7 +256,7 @@ __rec_iput(t, nrec, data, flags)
 	 * the offset array, shift the pointers up.
 	 */
 	nbytes = NRLEAFDBT(data->size);
-	if (h->upper - h->lower < nbytes + sizeof(indx_t)) {
+	if ((u_int32_t) (h->upper - h->lower) < nbytes + sizeof(indx_t)) {
 		status = __bt_split(t, h, NULL, data, dflags, nbytes, index);
 		if (status == RET_SUCCESS)
 			++t->bt_nrecs;
--- db.1.85/recno/rec_seq.c.jj	Thu Jul 14 03:35:40 1994
+++ db.1.85/recno/rec_seq.c	Wed Apr 19 17:56:12 2000
@@ -31,7 +31,7 @@
  * SUCH DAMAGE.
  */
 
-#ifndef lint
+#if defined(LIBC_SCCS) && !defined(lint)
 static char sccsid[] = "@(#)rec_seq.c	8.3 (Berkeley) 7/14/94";
 #endif /* not lint */
 
--- db.1.85/recno/rec_utils.c.jj	Sat Jul 16 16:55:08 1994
+++ db.1.85/recno/rec_utils.c	Wed Apr 19 17:56:12 2000
@@ -90,7 +90,7 @@ dataonly:
 		return (RET_SUCCESS);
 
 	/*
-	 * We must copy big keys/data to make them contigous.  Otherwise,
+	 * We must copy big keys/data to make them contiguous.  Otherwise,
 	 * leave the page pinned and don't copy unless the user specified
 	 * concurrent access.
 	 */
--- db.1.85/mpool/mpool.c.jj	Tue Jul 26 21:19:35 1994
+++ db.1.85/mpool/mpool.c	Wed Apr 19 18:06:21 2000
@@ -50,6 +50,14 @@ static char sccsid[] = "@(#)mpool.c	8.5 
 #define	__MPOOLINTERFACE_PRIVATE
 #include <mpool.h>
 
+#define mpool_open __mpool_open
+#define mpool_filter __mpool_filter
+#define mpool_new __mpool_new
+#define mpool_get __mpool_get
+#define mpool_put __mpool_put
+#define mpool_sync __mpool_sync
+#define mpool_close __mpool_close
+
 static BKT *mpool_bkt __P((MPOOL *));
 static BKT *mpool_look __P((MPOOL *, pgno_t));
 static int  mpool_write __P((MPOOL *, BKT *));
@@ -109,7 +117,7 @@ mpool_filter(mp, pgin, pgout, pgcookie)
 	mp->pgout = pgout;
 	mp->pgcookie = pgcookie;
 }
-	
+
 /*
  * mpool_new --
  *	Get a new page of memory.
@@ -205,7 +213,8 @@ mpool_get(mp, pgno, flags)
 	off = mp->pagesize * pgno;
 	if (lseek(mp->fd, off, SEEK_SET) != off)
 		return (NULL);
-	if ((nr = read(mp->fd, bp->page, mp->pagesize)) != mp->pagesize) {
+	if ((u_long) (nr = read(mp->fd, bp->page, mp->pagesize))
+	    != mp->pagesize) {
 		if (nr >= 0)
 			errno = EFTYPE;
 		return (NULL);
@@ -300,6 +309,23 @@ mpool_sync(mp)
 	return (fsync(mp->fd) ? RET_ERROR : RET_SUCCESS);
 }
 
+#undef mpool_open
+#undef mpool_filter
+#undef mpool_new
+#undef mpool_get
+#undef mpool_put
+#undef mpool_close
+#undef mpool_sync
+#define weak_alias(original, alias) \
+	asm (".weak " #alias "\n" #alias " = " #original);
+weak_alias (__mpool_open, mpool_open)
+weak_alias (__mpool_filter, mpool_filter)
+weak_alias (__mpool_new, mpool_new)
+weak_alias (__mpool_get, mpool_get)
+weak_alias (__mpool_put, mpool_put)
+weak_alias (__mpool_close, mpool_close)
+weak_alias (__mpool_sync, mpool_sync)
+
 /*
  * mpool_bkt
  *	Get a page from the cache (or create one).
@@ -380,7 +406,7 @@ mpool_write(mp, bp)
 	off = mp->pagesize * bp->pgno;
 	if (lseek(mp->fd, off, SEEK_SET) != off)
 		return (RET_ERROR);
-	if (write(mp->fd, bp->page, mp->pagesize) != mp->pagesize)
+	if ((u_long) write(mp->fd, bp->page, mp->pagesize) != mp->pagesize)
 		return (RET_ERROR);
 
 	bp->flags &= ~MPOOL_DIRTY;
@@ -436,7 +462,7 @@ mpool_stat(mp)
 	    mp->pagealloc, mp->pageflush);
 	if (mp->cachehit + mp->cachemiss)
 		(void)fprintf(stderr,
-		    "%.0f%% cache hit rate (%lu hits, %lu misses)\n", 
+		    "%.0f%% cache hit rate (%lu hits, %lu misses)\n",
 		    ((double)mp->cachehit / (mp->cachehit + mp->cachemiss))
 		    * 100, mp->cachehit, mp->cachemiss);
 	(void)fprintf(stderr, "%lu page reads, %lu page writes\n",
@@ -456,7 +482,7 @@ mpool_stat(mp)
 			cnt = 0;
 		} else
 			sep = ", ";
-			
+
 	}
 	(void)fprintf(stderr, "\n");
 }
--- db.1.85/db/db.c.jj	Tue Feb 22 00:07:47 1994
+++ db.1.85/db/db.c	Wed Apr 19 18:06:46 2000
@@ -44,6 +44,8 @@ static char sccsid[] = "@(#)db.c	8.4 (Be
 
 #include <db.h>
 
+#define dbopen __dbopen
+
 DB *
 dbopen(fname, flags, mode, type, openinfo)
 	const char *fname;
@@ -72,9 +74,13 @@ dbopen(fname, flags, mode, type, openinf
 	errno = EINVAL;
 	return (NULL);
 }
+#undef dbopen
+#define weak_alias(original, alias) \
+        asm (".weak " #alias "\n" #alias " = " #original);
+weak_alias (__dbopen, dbopen)
 
 static int
-__dberr()
+__dberr __P((void))
 {
 	return (RET_ERROR);
 }
@@ -90,10 +96,14 @@ __dbpanic(dbp)
 	DB *dbp;
 {
 	/* The only thing that can succeed is a close. */
-	dbp->del = (int (*)())__dberr;
-	dbp->fd = (int (*)())__dberr;
-	dbp->get = (int (*)())__dberr;
-	dbp->put = (int (*)())__dberr;
-	dbp->seq = (int (*)())__dberr;
-	dbp->sync = (int (*)())__dberr;
+	dbp->del = (int (*)__P((const struct __db *,
+				const DBT *, u_int))) __dberr;
+	dbp->get = (int (*)__P((const struct __db *,
+				const DBT *, DBT *, u_int))) __dberr;
+	dbp->put = (int (*)__P((const struct __db *,
+				DBT *, const DBT *, u_int))) __dberr;
+	dbp->seq = (int (*)__P((const struct __db *,
+				DBT *, DBT *, u_int))) __dberr;
+	dbp->sync = (int (*)__P((const struct __db *, u_int))) __dberr;
+	dbp->fd = (int (*)__P((const struct __db *))) __dberr;
 }
--- db.1.85/PORT/include/ndbm.h.jj	Thu Jun  3 05:32:29 1993
+++ db.1.85/PORT/include/ndbm.h	Wed Apr 19 17:56:12 2000
@@ -36,8 +36,8 @@
  *	@(#)ndbm.h	8.1 (Berkeley) 6/2/93
  */
 
-#ifndef _NDBM_H_
-#define	_NDBM_H_
+#ifndef _NDBM_H
+#define	_NDBM_H 1
 
 #include <db.h>
 
@@ -72,6 +72,8 @@ datum	 dbm_nextkey __P((DBM *));
 DBM	*dbm_open __P((const char *, int, int));
 int	 dbm_store __P((DBM *, datum, datum, int));
 int	 dbm_dirfno __P((DBM *));
+int	 dbm_error __P((DBM *));
+int	 dbm_clearerr __P((DBM *));
 __END_DECLS
 
-#endif /* !_NDBM_H_ */
+#endif /* ndbm.h */
--- db.1.85/PORT/linux/include/compat.h.jj	Tue Jun 21 00:13:19 1994
+++ db.1.85/PORT/linux/include/compat.h	Wed Apr 19 17:56:12 2000
@@ -1,155 +1,9 @@
-/*-
- * Copyright (c) 1991, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)compat.h	8.13 (Berkeley) 2/21/94
- */
-
-#ifndef	_COMPAT_H_
-#define	_COMPAT_H_
+/* Values for building 4.4 BSD db routines in the GNU C library.  */
 
-#include <sys/types.h>
+#ifndef _compat_h_
+#define _compat_h_
 
-/*
- * If your system doesn't typedef u_long, u_short, or u_char, change
- * the 0 to a 1.
- */
-#if 0
-typedef unsigned char	u_char;		/* 4.[34]BSD names. */
-typedef unsigned int	u_int;
-typedef unsigned long	u_long;
-typedef unsigned short	u_short;
-#endif
-
-/* If your system doesn't typedef size_t, change the 0 to a 1. */
-#if 0
-typedef unsigned int	size_t;		/* POSIX, 4.[34]BSD names. */
-#endif
-
-/* If your system doesn't typedef ssize_t, change the 0 to a 1. */
-#if 0
-typedef	int		ssize_t;	/* POSIX names. */
-#endif
-
-/*
- * If your system doesn't have the POSIX type for a signal mask,
- * change the 0 to a 1.
- */
-#if 0					/* POSIX 1003.1 signal mask type. */
-typedef unsigned int	sigset_t;
-#endif
-
-/*
- * If your system's vsprintf returns a char *, not an int,
- * change the 0 to a 1.
- */
-#if 0
-#define	VSPRINTF_CHARSTAR
-#endif
-
-/*
- * If you don't have POSIX 1003.1 signals, the signal code surrounding the 
- * temporary file creation is intended to block all of the possible signals
- * long enough to create the file and unlink it.  All of this stuff is
- * intended to use old-style BSD calls to fake POSIX 1003.1 calls.
- */
-#ifdef	NO_POSIX_SIGNALS
-#define	sigemptyset(set)	(*(set) = 0)
-#define	sigfillset(set)		(*(set) = ~(sigset_t)0, 0)
-#define	sigaddset(set,signo)	(*(set) |= sigmask(signo), 0)
-#define	sigdelset(set,signo)	(*(set) &= ~sigmask(signo), 0)
-#define	sigismember(set,signo)	((*(set) & sigmask(signo)) != 0)
-
-#define	SIG_BLOCK	1
-#define	SIG_UNBLOCK	2
-#define	SIG_SETMASK	3
-
-static int __sigtemp;		/* For the use of sigprocmask */
-
-/* Repeated test of oset != NULL is to avoid "*0". */
-#define	sigprocmask(how, set, oset)					\
-	((__sigtemp =							\
-	(((how) == SIG_BLOCK) ?						\
-		sigblock(0) | *(set) :					\
-	(((how) == SIG_UNBLOCK) ?					\
-		sigblock(0) & ~(*(set)) :				\
-	((how) == SIG_SETMASK ?						\
-		*(set) : sigblock(0))))),				\
-	((oset) ? (*(oset ? oset : set) = sigsetmask(__sigtemp)) :	\
-		sigsetmask(__sigtemp)), 0)
-#endif
-
-/*
- * If your system doesn't have an include file with the appropriate
- * byte order set, make sure you specify the correct one.
- */
-#ifndef BYTE_ORDER
-#define	LITTLE_ENDIAN	1234		/* LSB first: i386, vax */
-#define	BIG_ENDIAN	4321		/* MSB first: 68000, ibm, net */
-#define	BYTE_ORDER	LITTLE_ENDIAN	/* Set for your system. */
-#endif
-
-#if defined(SYSV) || defined(SYSTEM5)
-#define	index(a, b)		strchr(a, b)
-#define	rindex(a, b)		strrchr(a, b)
-#define	bzero(a, b)		memset(a, 0, b)
-#define	bcmp(a, b, n)		memcmp(a, b, n)
-#define	bcopy(a, b, n)		memmove(b, a, n)
-#endif
-
-#if defined(BSD) || defined(BSD4_3)
-#define	strchr(a, b)		index(a, b)
-#define	strrchr(a, b)		rindex(a, b)
-#define	memcmp(a, b, n)		bcmp(a, b, n)
-#define	memmove(a, b, n)	bcopy(b, a, n)
-#endif
-
-/*
- * 32-bit machine.  The db routines are theoretically independent of
- * the size of u_shorts and u_longs, but I don't know that anyone has
- * ever actually tried it.  At a minimum, change the following #define's
- * if you are trying to compile on a different type of system.
- */
-#ifndef USHRT_MAX
-#define	USHRT_MAX		0xFFFF
-#define	ULONG_MAX		0xFFFFFFFF
-#endif
-
-#ifndef O_ACCMODE			/* POSIX 1003.1 access mode mask. */
-#define	O_ACCMODE	(O_RDONLY|O_WRONLY|O_RDWR)
-#endif
-
-#ifndef	_POSIX2_RE_DUP_MAX		/* POSIX 1003.2 RE limit. */
-#define	_POSIX2_RE_DUP_MAX	255
-#endif
+#include <fcntl.h>
 
 /*
  * If you can't provide lock values in the open(2) call.  Note, this
@@ -163,41 +17,26 @@ static int __sigtemp;		/* For the use of
 #define	O_SHLOCK	0
 #endif
 
+#include <errno.h>
+
 #ifndef EFTYPE
 #define	EFTYPE		EINVAL		/* POSIX 1003.1 format errno. */
 #endif
 
-#ifndef	WCOREDUMP			/* 4.4BSD extension */
-#define	WCOREDUMP(a)	0
-#endif
-
-#ifndef	STDERR_FILENO
-#define	STDIN_FILENO	0		/* ANSI C #defines */
-#define	STDOUT_FILENO	1
-#define	STDERR_FILENO	2
-#endif
-
-#ifndef SEEK_END
-#define	SEEK_SET	0		/* POSIX 1003.1 seek values */
-#define	SEEK_CUR	1
-#define	SEEK_END	2
-#endif
+#include <unistd.h>
+#include <limits.h>
 
 #ifndef _POSIX_VDISABLE			/* POSIX 1003.1 disabling char. */
 #define	_POSIX_VDISABLE	0		/* Some systems used 0. */
 #endif
 
+#include <termios.h>
+
 #ifndef	TCSASOFT			/* 4.4BSD extension. */
 #define	TCSASOFT	0
 #endif
 
-#ifndef _POSIX2_RE_DUP_MAX		/* POSIX 1003.2 values. */
-#define	_POSIX2_RE_DUP_MAX	255
-#endif
-
-#ifndef NULL				/* ANSI C #defines NULL everywhere. */
-#define	NULL		0
-#endif
+#include <sys/param.h>
 
 #ifndef	MAX				/* Usually found in <sys/param.h>. */
 #define	MAX(_a,_b)	((_a)<(_b)?(_b):(_a))
@@ -206,26 +45,5 @@ static int __sigtemp;		/* For the use of
 #define	MIN(_a,_b)	((_a)<(_b)?(_a):(_b))
 #endif
 
-/* Default file permissions. */
-#ifndef DEFFILEMODE			/* 4.4BSD extension. */
-#define	DEFFILEMODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
-#endif
-
-#ifndef S_ISDIR				/* POSIX 1003.1 file type tests. */
-#define	S_ISDIR(m)	((m & 0170000) == 0040000)	/* directory */
-#define	S_ISCHR(m)	((m & 0170000) == 0020000)	/* char special */
-#define	S_ISBLK(m)	((m & 0170000) == 0060000)	/* block special */
-#define	S_ISREG(m)	((m & 0170000) == 0100000)	/* regular file */
-#define	S_ISFIFO(m)	((m & 0170000) == 0010000)	/* fifo */
-#endif
-#ifndef S_ISLNK				/* BSD POSIX 1003.1 extensions */
-#define	S_ISLNK(m)	((m & 0170000) == 0120000)	/* symbolic link */
-#define	S_ISSOCK(m)	((m & 0170000) == 0140000)	/* socket */
-#endif
-
-/* The type of a va_list. */
-#ifndef _BSD_VA_LIST_			/* 4.4BSD #define. */
-#define	_BSD_VA_LIST_	char *
-#endif
 
-#endif /* !_COMPAT_H_ */
+#endif /* compat.h */
--- db.1.85/PORT/linux/Makefile.jj	Thu Jul 14 03:43:16 1994
+++ db.1.85/PORT/linux/Makefile	Thu Apr 20 08:54:43 2000
@@ -1,8 +1,16 @@
 #	@(#)Makefile	8.9 (Berkeley) 7/14/94
 
 LIBDB=	libdb.a
+ARCH=$(shell uname -m)
+ifeq ($(ARCH),alpha)
+SOVER=2.1
+else
+SOVER=2
+endif
+LIBDBSO=libdb.so.$(SOVER)
+PROG=	db_dump185
 OBJ1=	hash.o hash_bigkey.o hash_buf.o hash_func.o hash_log2.o hash_page.o \
-	hsearch.o ndbm.o
+	ndbm.o
 OBJ2=	bt_close.o bt_conv.o bt_debug.o bt_delete.o bt_get.o bt_open.o \
 	bt_overflow.o bt_page.o bt_put.o bt_search.o bt_seq.o bt_split.o \
 	bt_utils.o
@@ -10,93 +18,49 @@ OBJ3=	db.o
 OBJ4=	mpool.o
 OBJ5=	rec_close.o rec_delete.o rec_get.o rec_open.o rec_put.o rec_search.o \
 	rec_seq.o rec_utils.o
+MISC=
+OBJS=	$(OBJ1) $(OBJ2) $(OBJ3) $(OBJ4) $(OBJ5) $(MISC)
+SHOBJS=	$(patsubst %.o,%.os,$(OBJS))
 
-MISC=	snprintf.o
+all: $(LIBDB) $(LIBDBSO) $(PROG)
 
-${LIBDB}: ${OBJ1} ${OBJ2} ${OBJ3} ${OBJ4} ${OBJ5} ${MISC}
+$(LIBDB): $(OBJS)
 	rm -f $@
-	ar cq $@ \
-	    `lorder ${OBJ1} ${OBJ2} ${OBJ3} ${OBJ4} ${OBJ5} ${MISC} | tsort`
+	ar cq $@ $(OBJS)
 	ranlib $@
 
-clean:
-	rm -f ${LIBDB} ${OBJ1} ${OBJ2} ${OBJ3} ${OBJ4} ${OBJ5} ${MISC}
+$(LIBDBSO): $(SHOBJS)
+	$(CC) -Wl,-O1 -Wl,--version-script=libdb.map -Wl,-soname=$(LIBDBSO) -shared -o $@ $^
+	ln -sf $@ libdb.so
 
-OORG=	-O
-CL=	${CC} -c -D__DBINTERFACE_PRIVATE ${OORG} -I. -Iinclude
+$(PROG): db_dump185.o $(LIBDBSO)
+	$(CC) -o $@ db_dump185.o -L. -ldb
 
-hash.o: ../../hash/hash.c
-	${CL} -I../../hash ../../hash/hash.c
-hash_bigkey.o: ../../hash/hash_bigkey.c
-	${CL} -I../../hash ../../hash/hash_bigkey.c
-hash_buf.o: ../../hash/hash_buf.c
-	${CL} -I../../hash ../../hash/hash_buf.c
-hash_func.o: ../../hash/hash_func.c
-	${CL} -I../../hash ../../hash/hash_func.c
-hash_log2.o: ../../hash/hash_log2.c
-	${CL} -I../../hash ../../hash/hash_log2.c
-hash_page.o: ../../hash/hash_page.c
-	${CL} -I../../hash ../../hash/hash_page.c
-hsearch.o: ../../hash/hsearch.c
-	${CL} -I../../hash ../../hash/hsearch.c
-ndbm.o: ../../hash/ndbm.c
-	${CL} -I../../hash ../../hash/ndbm.c
-
-bt_close.o: ../../btree/bt_close.c
-	${CL} -I../../btree ../../btree/bt_close.c
-bt_conv.o: ../../btree/bt_conv.c
-	${CL} -I../../btree ../../btree/bt_conv.c
-bt_debug.o: ../../btree/bt_debug.c
-	${CL} -I../../btree ../../btree/bt_debug.c
-bt_delete.o: ../../btree/bt_delete.c
-	${CL} -I../../btree ../../btree/bt_delete.c
-bt_get.o: ../../btree/bt_get.c
-	${CL} -I../../btree ../../btree/bt_get.c
-bt_open.o: ../../btree/bt_open.c
-	${CL} -I../../btree ../../btree/bt_open.c
-bt_overflow.o: ../../btree/bt_overflow.c
-	${CL} -I../../btree ../../btree/bt_overflow.c
-bt_page.o: ../../btree/bt_page.c
-	${CL} -I../../btree ../../btree/bt_page.c
-bt_put.o: ../../btree/bt_put.c
-	${CL} -I../../btree ../../btree/bt_put.c
-bt_search.o: ../../btree/bt_search.c
-	${CL} -I../../btree ../../btree/bt_search.c
-bt_seq.o: ../../btree/bt_seq.c
-	${CL} -I../../btree ../../btree/bt_seq.c
-bt_split.o: ../../btree/bt_split.c
-	${CL} -I../../btree ../../btree/bt_split.c
-bt_stack.o: ../../btree/bt_stack.c
-	${CL} -I../../btree ../../btree/bt_stack.c
-bt_utils.o: ../../btree/bt_utils.c
-	${CL} -I../../btree ../../btree/bt_utils.c
+clean:
+	rm -f $(LIBDB) $(LIBDBSO) $(OBJS) $(SHOBJS)
 
-db.o: ../../db/db.c
-	${CL} ../../db/db.c
+OORG=	-O2
+CL=	$(CC) -c -D__DBINTERFACE_PRIVATE $(OORG) -I. -Iinclude
 
+db_dump185.o: db_dump185.c
+	$(CL) -o $@ $<
+%.o: ../../hash/%.c
+	$(CL) -I../../hash -g -o $@ $<
+%.os: ../../hash/%.c
+	$(CL) -I../../hash -fpic -o $@ $<
+%.o: ../../btree/%.c
+	$(CL) -I../../btree -g -o $@ $<
+%.os: ../../btree/%.c
+	$(CL) -I../../btree -fpic -o $@ $<
+db.o: ../../db/db.c
+	$(CL) -g -o $@ $<
+db.os: ../../db/db.c
+	$(CL) -fpic -o $@ $<
 mpool.o: ../../mpool/mpool.c
-	${CL} -I../../mpool ../../mpool/mpool.c
-
-rec_close.o: ../../recno/rec_close.c
-	${CL} -I../../recno ../../recno/rec_close.c
-rec_delete.o: ../../recno/rec_delete.c
-	${CL} -I../../recno ../../recno/rec_delete.c
-rec_get.o: ../../recno/rec_get.c
-	${CL} -I../../recno ../../recno/rec_get.c
-rec_open.o: ../../recno/rec_open.c
-	${CL} -I../../recno ../../recno/rec_open.c
-rec_put.o: ../../recno/rec_put.c
-	${CL} -I../../recno ../../recno/rec_put.c
-rec_search.o: ../../recno/rec_search.c
-	${CL} -I../../recno ../../recno/rec_search.c
-rec_seq.o: ../../recno/rec_seq.c
-	${CL} -I../../recno ../../recno/rec_seq.c
-rec_utils.o: ../../recno/rec_utils.c
-	${CL} -I../../recno ../../recno/rec_utils.c
-
-memmove.o:
-	${CC} -DMEMMOVE -c -O -I. -Iinclude clib/memmove.c
-mktemp.o:
-	${CC} -c -O -I. -Iinclude clib/mktemp.c
-snprintf.o:
-	${CC} -c -O -I. -Iinclude clib/snprintf.c
+	$(CL) -g -o $@ $<
+mpool.os: ../../mpool/mpool.c
+	$(CL) -fpic -o $@ $<
+%.o: ../../recno/%.c
+	$(CL) -I../../recno -g -o $@ $<
+%.os: ../../recno/%.c
+	$(CL) -I../../recno -fpic -o $@ $<
--- db.1.85/PORT/linux/libdb.map.jj	Wed Apr 19 17:56:12 2000
+++ db.1.85/PORT/linux/libdb.map	Wed Apr 19 17:56:12 2000
@@ -0,0 +1,11 @@
+GLIBC_2.0 {
+  global:
+    # the real DB entry point.
+    dbopen; __dbopen;
+
+    # The compatibility functions.
+    dbm_clearerr; dbm_close; dbm_delete; dbm_dirfno; dbm_error;
+    dbm_fetch; dbm_firstkey; dbm_nextkey; dbm_open; dbm_store;
+  local:
+    *;
+};
--- db.1.85/PORT/linux/db_dump185.c.jj	Thu Apr 20 08:49:24 2000
+++ db.1.85/PORT/linux/db_dump185.c	Thu Apr 20 08:50:25 2000
@@ -0,0 +1,350 @@
+/*-
+ * See the file LICENSE for redistribution information.
+ *
+ * Copyright (c) 1996, 1997, 1998
+ *	Sleepycat Software.  All rights reserved.
+ */
+
+#ifndef lint
+static const char copyright[] =
+"@(#) Copyright (c) 1996, 1997, 1998\n\
+	Sleepycat Software Inc.  All rights reserved.\n";
+static const char sccsid[] = "@(#)db_dump185.c	10.10 (Sleepycat) 4/10/98";
+#endif
+
+#ifndef NO_SYSTEM_INCLUDES
+#include <sys/types.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#endif
+
+#include "db.h"
+
+/* Hash Table Information */
+typedef struct hashhdr185 {		/* Disk resident portion */
+	int		magic;		/* Magic NO for hash tables */
+	int		version;	/* Version ID */
+	u_int32_t	lorder;		/* Byte Order */
+	int		bsize;		/* Bucket/Page Size */
+	int		bshift;		/* Bucket shift */
+	int		dsize;		/* Directory Size */
+	int		ssize;		/* Segment Size */
+	int		sshift;		/* Segment shift */
+	int		ovfl_point;	/* Where overflow pages are being
+					 * allocated */
+	int		last_freed;	/* Last overflow page freed */
+	int		max_bucket;	/* ID of Maximum bucket in use */
+	int		high_mask;	/* Mask to modulo into entire table */
+	int		low_mask;	/* Mask to modulo into lower half of
+					 * table */
+	int		ffactor;	/* Fill factor */
+	int		nkeys;		/* Number of keys in hash table */
+} HASHHDR185;
+typedef struct htab185	 {		/* Memory resident data structure */
+	HASHHDR185 	hdr;		/* Header */
+} HTAB185;
+
+/* Hash Table Information */
+typedef struct hashhdr186 {	/* Disk resident portion */
+	int32_t	magic;		/* Magic NO for hash tables */
+	int32_t	version;	/* Version ID */
+	int32_t	lorder;		/* Byte Order */
+	int32_t	bsize;		/* Bucket/Page Size */
+	int32_t	bshift;		/* Bucket shift */
+	int32_t	ovfl_point;	/* Where overflow pages are being allocated */
+	int32_t	last_freed;	/* Last overflow page freed */
+	int32_t	max_bucket;	/* ID of Maximum bucket in use */
+	int32_t	high_mask;	/* Mask to modulo into entire table */
+	int32_t	low_mask;	/* Mask to modulo into lower half of table */
+	int32_t	ffactor;	/* Fill factor */
+	int32_t	nkeys;		/* Number of keys in hash table */
+	int32_t	hdrpages;	/* Size of table header */
+	int32_t	h_charkey;	/* value of hash(CHARKEY) */
+#define NCACHED	32		/* number of bit maps and spare points */
+	int32_t	spares[NCACHED];/* spare pages for overflow */
+	u_int16_t	bitmaps[NCACHED];	/* address of overflow page bitmaps */
+} HASHHDR186;
+typedef struct htab186	 {		/* Memory resident data structure */
+	HASHHDR186 	hdr;		/* Header */
+} HTAB186;
+
+typedef struct _epgno {
+	u_int32_t pgno;			/* the page number */
+	u_int16_t index;		/* the index on the page */
+} EPGNO;
+
+typedef struct _epg {
+	void	*page;			/* the (pinned) page */
+	u_int16_t index;		/* the index on the page */
+} EPG;
+
+typedef struct _cursor {
+	EPGNO	 pg;			/* B: Saved tree reference. */
+	DBT	 key;			/* B: Saved key, or key.data == NULL. */
+	u_int32_t rcursor;		/* R: recno cursor (1-based) */
+
+#define	CURS_ACQUIRE	0x01		/*  B: Cursor needs to be reacquired. */
+#define	CURS_AFTER	0x02		/*  B: Unreturned cursor after key. */
+#define	CURS_BEFORE	0x04		/*  B: Unreturned cursor before key. */
+#define	CURS_INIT	0x08		/* RB: Cursor initialized. */
+	u_int8_t flags;
+} CURSOR;
+
+/* The in-memory btree/recno data structure. */
+typedef struct _btree {
+	void	 *bt_mp;		/* memory pool cookie */
+
+	void	 *bt_dbp;		/* pointer to enclosing DB */
+
+	EPG	  bt_cur;		/* current (pinned) page */
+	void	 *bt_pinned;		/* page pinned across calls */
+
+	CURSOR	  bt_cursor;		/* cursor */
+
+	EPGNO	  bt_stack[50];		/* stack of parent pages */
+	EPGNO	 *bt_sp;		/* current stack pointer */
+
+	DBT	  bt_rkey;		/* returned key */
+	DBT	  bt_rdata;		/* returned data */
+
+	int	  bt_fd;		/* tree file descriptor */
+
+	u_int32_t bt_free;		/* next free page */
+	u_int32_t bt_psize;		/* page size */
+	u_int16_t bt_ovflsize;		/* cut-off for key/data overflow */
+	int	  bt_lorder;		/* byte order */
+					/* sorted order */
+	enum { NOT, BACK, FORWARD } bt_order;
+	EPGNO	  bt_last;		/* last insert */
+
+					/* B: key comparison function */
+	int	(*bt_cmp) __P((const DBT *, const DBT *));
+					/* B: prefix comparison function */
+	size_t	(*bt_pfx) __P((const DBT *, const DBT *));
+					/* R: recno input function */
+	int	(*bt_irec) __P((struct _btree *, u_int32_t));
+
+	FILE	 *bt_rfp;		/* R: record FILE pointer */
+	int	  bt_rfd;		/* R: record file descriptor */
+
+	void	 *bt_cmap;		/* R: current point in mapped space */
+	void	 *bt_smap;		/* R: start of mapped space */
+	void	 *bt_emap;		/* R: end of mapped space */
+	size_t	  bt_msize;		/* R: size of mapped region. */
+
+	u_int32_t bt_nrecs;		/* R: number of records */
+	size_t	  bt_reclen;		/* R: fixed record length */
+	u_char	  bt_bval;		/* R: delimiting byte/pad character */
+
+/*
+ * NB:
+ * B_NODUPS and R_RECNO are stored on disk, and may not be changed.
+ */
+#define	B_INMEM		0x00001		/* in-memory tree */
+#define	B_METADIRTY	0x00002		/* need to write metadata */
+#define	B_MODIFIED	0x00004		/* tree modified */
+#define	B_NEEDSWAP	0x00008		/* if byte order requires swapping */
+#define	B_RDONLY	0x00010		/* read-only tree */
+
+#define	B_NODUPS	0x00020		/* no duplicate keys permitted */
+#define	R_RECNO		0x00080		/* record oriented tree */
+
+#define	R_CLOSEFP	0x00040		/* opened a file pointer */
+#define	R_EOF		0x00100		/* end of input file reached. */
+#define	R_FIXLEN	0x00200		/* fixed length records */
+#define	R_MEMMAPPED	0x00400		/* memory mapped file. */
+#define	R_INMEM		0x00800		/* in-memory file */
+#define	R_MODIFIED	0x01000		/* modified file */
+#define	R_RDONLY	0x02000		/* read-only file */
+
+#define	B_DB_LOCK	0x04000		/* DB_LOCK specified. */
+#define	B_DB_SHMEM	0x08000		/* DB_SHMEM specified. */
+#define	B_DB_TXN	0x10000		/* DB_TXN specified. */
+	u_int32_t flags;
+} BTREE;
+
+void	db_btree __P((DB *, int));
+void	db_hash __P((DB *, int));
+void	dbt_dump __P((DBT *));
+void	dbt_print __P((DBT *));
+int	main __P((int, char *[]));
+void	usage __P((void));
+
+const char
+	*progname = "db_dump185";			/* Program name. */
+
+int
+main(argc, argv)
+	int argc;
+	char *argv[];
+{
+	extern char *optarg;
+	extern int optind;
+	DB *dbp;
+	DBT key, data;
+	int ch, pflag, rval;
+
+	pflag = 0;
+	while ((ch = getopt(argc, argv, "f:p")) != EOF)
+		switch (ch) {
+		case 'f':
+			if (freopen(optarg, "w", stdout) == NULL)
+				err(1, "%s", optarg);
+			break;
+		case 'p':
+			pflag = 1;
+			break;
+		case '?':
+		default:
+			usage();
+		}
+	argc -= optind;
+	argv += optind;
+
+	if (argc != 1)
+		usage();
+
+	if ((dbp = dbopen(argv[0], O_RDONLY, 0, DB_BTREE, NULL)) == NULL) {
+		if ((dbp = dbopen(argv[0], O_RDONLY, 0, DB_HASH, NULL)) == NULL)
+			err(1, "%s", argv[0]);
+		db_hash(dbp, pflag);
+	} else
+		db_btree(dbp, pflag);
+
+	/*
+	 * !!!
+	 * DB 1.85 DBTs are a subset of DB 2.0 DBTs, so we just use the
+	 * new dump/print routines.
+	 */
+	if (pflag)
+		while (!(rval = dbp->seq(dbp, &key, &data, R_NEXT))) {
+			dbt_print(&key);
+			dbt_print(&data);
+		}
+	else
+		while (!(rval = dbp->seq(dbp, &key, &data, R_NEXT))) {
+			dbt_dump(&key);
+			dbt_dump(&data);
+		}
+
+	if (rval == -1)
+		err(1, "seq");
+	return (0);
+}
+
+/*
+ * db_hash --
+ *	Dump out hash header information.
+ */
+void
+db_hash(dbp, pflag)
+	DB *dbp;
+	int pflag;
+{
+	HTAB185 *hash185p;
+	HTAB186 *hash186p;
+
+	printf("format=%s\n", pflag ? "print" : "bytevalue");
+	printf("type=hash\n");
+
+	/* DB 1.85 was version 2, DB 1.86 was version 3. */
+	hash185p = dbp->internal;
+	if (hash185p->hdr.version > 2) {
+		hash186p = dbp->internal;
+		printf("h_ffactor=%lu\n", (u_long)hash186p->hdr.ffactor);
+		if (hash186p->hdr.lorder != 0)
+			printf("db_lorder=%lu\n", (u_long)hash186p->hdr.lorder);
+		printf("db_pagesize=%lu\n", (u_long)hash186p->hdr.bsize);
+	} else {
+		printf("h_ffactor=%lu\n", (u_long)hash185p->hdr.ffactor);
+		if (hash185p->hdr.lorder != 0)
+			printf("db_lorder=%lu\n", (u_long)hash185p->hdr.lorder);
+		printf("db_pagesize=%lu\n", (u_long)hash185p->hdr.bsize);
+	}
+	printf("HEADER=END\n");
+}
+
+/*
+ * db_btree --
+ *	Dump out btree header information.
+ */
+void
+db_btree(dbp, pflag)
+	DB *dbp;
+	int pflag;
+{
+	BTREE *btp;
+
+	btp = dbp->internal;
+
+	printf("format=%s\n", pflag ? "print" : "bytevalue");
+	printf("type=btree\n");
+#ifdef NOT_AVAILABLE_IN_185
+	printf("bt_minkey=%lu\n", (u_long)XXX);
+	printf("bt_maxkey=%lu\n", (u_long)XXX);
+#endif
+	if (btp->bt_lorder != 0)
+		printf("db_lorder=%lu\n", (u_long)btp->bt_lorder);
+	printf("db_pagesize=%lu\n", (u_long)btp->bt_psize);
+	if (!(btp->flags & B_NODUPS))
+		printf("duplicates=1\n");
+	printf("HEADER=END\n");
+}
+
+static char hex[] = "0123456789abcdef";
+
+/*
+ * dbt_dump --
+ *	Write out a key or data item using byte values.
+ */
+void
+dbt_dump(dbtp)
+	DBT *dbtp;
+{
+	size_t len;
+	u_int8_t *p;
+
+	for (len = dbtp->size, p = dbtp->data; len--; ++p)
+		(void)printf("%c%c",
+		    hex[(*p & 0xf0) >> 4], hex[*p & 0x0f]);
+	printf("\n");
+}
+
+/*
+ * dbt_print --
+ *	Write out a key or data item using printable characters.
+ */
+void
+dbt_print(dbtp)
+	DBT *dbtp;
+{
+	size_t len;
+	u_int8_t *p;
+
+	for (len = dbtp->size, p = dbtp->data; len--; ++p)
+		if (isprint(*p)) {
+			if (*p == '\\')
+				(void)printf("\\");
+			(void)printf("%c", *p);
+		} else
+			(void)printf("\\%c%c",
+			    hex[(*p & 0xf0) >> 4], hex[*p & 0x0f]);
+	printf("\n");
+}
+
+/*
+ * usage --
+ *	Display the usage message.
+ */
+void
+usage()
+{
+	(void)fprintf(stderr, "usage: db_dump185 [-p] [-f file] db_file\n");
+	exit(1);
+}
--- db.1.85/include/mpool.h.jj	Thu Jul 14 03:33:26 1994
+++ db.1.85/include/mpool.h	Wed Apr 19 17:56:12 2000
@@ -33,6 +33,9 @@
  *	@(#)mpool.h	8.2 (Berkeley) 7/14/94
  */
 
+#ifndef _MPOOL_H
+#define _MPOOL_H 1
+
 #include <sys/queue.h>
 
 /*
@@ -67,9 +70,9 @@ typedef struct MPOOL {
 	u_long	pagesize;		/* file page size */
 	int	fd;			/* file descriptor */
 					/* page in conversion routine */
-	void    (*pgin) __P((void *, pgno_t, void *));
+	void    (*pgin) __PMT((void *, pgno_t, void *));
 					/* page out conversion routine */
-	void    (*pgout) __P((void *, pgno_t, void *));
+	void    (*pgout) __PMT((void *, pgno_t, void *));
 	void	*pgcookie;		/* cookie for page in/out routines */
 #ifdef STATISTICS
 	u_long	cachehit;
@@ -85,15 +88,25 @@ typedef struct MPOOL {
 } MPOOL;
 
 __BEGIN_DECLS
+MPOOL	*__mpool_open __P((void *, int, pgno_t, pgno_t));
 MPOOL	*mpool_open __P((void *, int, pgno_t, pgno_t));
+void	 __mpool_filter __P((MPOOL *, void (*)(void *, pgno_t, void *),
+	    void (*)(void *, pgno_t, void *), void *));
 void	 mpool_filter __P((MPOOL *, void (*)(void *, pgno_t, void *),
 	    void (*)(void *, pgno_t, void *), void *));
+void	*__mpool_new __P((MPOOL *, pgno_t *));
 void	*mpool_new __P((MPOOL *, pgno_t *));
+void	*__mpool_get __P((MPOOL *, pgno_t, u_int));
 void	*mpool_get __P((MPOOL *, pgno_t, u_int));
+int	 __mpool_put __P((MPOOL *, void *, u_int));
 int	 mpool_put __P((MPOOL *, void *, u_int));
+int	 __mpool_sync __P((MPOOL *));
 int	 mpool_sync __P((MPOOL *));
+int	 __mpool_close __P((MPOOL *));
 int	 mpool_close __P((MPOOL *));
 #ifdef STATISTICS
 void	 mpool_stat __P((MPOOL *));
 #endif
 __END_DECLS
+
+#endif /* mpool.h */
--- db.1.85/include/db.h.jj	Tue Jun 21 21:59:28 1994
+++ db.1.85/include/db.h	Wed Apr 19 17:56:12 2000
@@ -33,8 +33,8 @@
  *	@(#)db.h	8.7 (Berkeley) 6/16/94
  */
 
-#ifndef _DB_H_
-#define	_DB_H_
+#ifndef _DB_H
+#define	_DB_H 1
 
 #include <sys/types.h>
 #include <sys/cdefs.h>
@@ -117,14 +117,14 @@ typedef enum { DB_BTREE, DB_HASH, DB_REC
 /* Access method description structure. */
 typedef struct __db {
 	DBTYPE type;			/* Underlying db type. */
-	int (*close)	__P((struct __db *));
-	int (*del)	__P((const struct __db *, const DBT *, u_int));
-	int (*get)	__P((const struct __db *, const DBT *, DBT *, u_int));
-	int (*put)	__P((const struct __db *, DBT *, const DBT *, u_int));
-	int (*seq)	__P((const struct __db *, DBT *, DBT *, u_int));
-	int (*sync)	__P((const struct __db *, u_int));
+	int (*close)	__PMT((struct __db *));
+	int (*del)	__PMT((const struct __db *, const DBT *, u_int));
+	int (*get)	__PMT((const struct __db *, const DBT *, DBT *, u_int));
+	int (*put)	__PMT((const struct __db *, DBT *, const DBT *, u_int));
+	int (*seq)	__PMT((const struct __db *, DBT *, DBT *, u_int));
+	int (*sync)	__PMT((const struct __db *, u_int));
 	void *internal;			/* Access method private. */
-	int (*fd)	__P((const struct __db *));
+	int (*fd)	__PMT((const struct __db *));
 } DB;
 
 #define	BTREEMAGIC	0x053162
@@ -139,9 +139,9 @@ typedef struct {
 	int	minkeypage;	/* minimum keys per page */
 	u_int	psize;		/* page size */
 	int	(*compare)	/* comparison function */
-	    __P((const DBT *, const DBT *));
+	    __PMT((const DBT *, const DBT *));
 	size_t	(*prefix)	/* prefix function */
-	    __P((const DBT *, const DBT *));
+	    __PMT((const DBT *, const DBT *));
 	int	lorder;		/* byte order */
 } BTREEINFO;
 
@@ -155,7 +155,7 @@ typedef struct {
 	u_int	nelem;		/* number of elements */
 	u_int	cachesize;	/* bytes to cache */
 	u_int32_t		/* hash function */
-		(*hash) __P((const void *, size_t));
+		(*hash) __PMT((const void *, size_t));
 	int	lorder;		/* byte order */
 } HASHINFO;
 
@@ -224,6 +224,7 @@ typedef struct {
 #endif
 
 __BEGIN_DECLS
+DB *__dbopen __P((const char *, int, int, DBTYPE, const void *));
 DB *dbopen __P((const char *, int, int, DBTYPE, const void *));
 
 #ifdef __DBINTERFACE_PRIVATE
@@ -233,4 +234,5 @@ DB	*__rec_open __P((const char *, int, i
 void	 __dbpanic __P((DB *dbp));
 #endif
 __END_DECLS
-#endif /* !_DB_H_ */
+
+#endif /* db.h */
