#LyX 1.1 created this file. For more info see http://www.lyx.org/
\lyxformat 218
\textclass docbook-chapter
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Title

eclass howto
\layout Author

Dan Armak
\layout Date

Updated for 20020125
\layout Section

Introduction
\layout Standard

eclasses are parts of ebuilds; that is, they have the same syntax ebuilds
 do, but do not define all the required variables and functions.
 ebuilds can inherit from eclasses, and eclasses can inherit from other
 eclasses.
 As in OOP, this is used to ensure maximum code reuse among similar ebuilds.
\layout Standard

This inheritance is implmented via simple bash sourcing.
 So, when you 'inherit
\begin_inset Quotes erd
\end_inset 

 something its functions and variables override your own.
 For this reason, variables and funcitons are usually extended and not just
 set (more on this later).
\layout Standard

The most similar group of ebuilds is the kde apps.
 These were accordingly selected to be the test case for eclasses, and I
 believe I can now say the test has been successful.
 Eclasses for non-kde ebuilds may follow, but there are no concrete plans
 as of this time.
\layout Standard

Because of the current customizable KDEDIR (KDE?DIR, KDE?LIBSDIR) scheme,
 all kde ebuilds (including ebuilds for apps with optional kde support)
 
\emph on 
must 
\emph default 
use the eclasses.
 As a minimum, inherit kde-dirs to get the set-qtdir(), set-kdedir() functions.
\layout Standard

Section two explains how eclasses work; section three explains how to write
 inheriting ebuilds.
 If you just want to write an eubild for a kde app, section 3 is a good
 concise introduction.
 Section 2 makes for deeper understanding but is probably not worth the
 time if you're just making an ebuild or two.
\layout Section

The eclasses
\layout Standard

The best way of becoming familiar with the current eclass structure is an
 explanation of what each eclass does.
\layout Subsection

inherit.eclass
\layout Standard

This is the basic eclass.
 It should always be present (i.e.
 inherited).
 No other eclass iherits from it, however: an inheriting ebuild needs to
 inherit it explicitly before it does anything else, by saying:
\layout Code

.
 /usr/portage/eclass/inherit.eclass || die
\layout Standard

Eclasses do not need this first line, since they are always sourced from
 an ebuild which already has it.
\layout Standard

The second line would typically be:
\layout Code

inherit <list of eclasses>
\layout Standard

This eclass defines the inherit() function which handles sourcing of eclasses:
\layout Code

ECLASSDIR=/usr/portage/eclass
\layout Code

inherit() {
\layout Code

    while [ "$1" ]; do
\layout Code

        source ${ECLASSDIR}/${1}.eclass
\layout Code

    shift
\layout Code

    done
\layout Code

}
\layout Standard

This function simply sources files from a hard-coded location.
 If, in the future, we will decide to move eclasses to a different location,
 any name-to-file resolution code will go in here.
\layout Subsection

Generic eclass features
\layout Subsubsection

Debug output
\layout Subsection

virtual.eclass
\layout Standard

Defines empty variables and functions; defines EXPORT_FUNCTIONS().
 Also inherits debug.eclass so that everyone gets that.
\layout Standard

This eclass is inherited by most other eclasses e.g.
 base, kde*.
 As a rule, any eclass that defines some of the base functions needs it.
 Therefore the only ebuilds which don't get it are the ones that only inherit
 one of the smaller eclasses e.g.
 c, autoconf.
\layout Standard

It defines all ebuild vars and funcs to be empty.
\layout Standard

It also defines the EXPORT_FUNCTIONS() function which looks like this:
\layout Code

EXPORT_FUNCTIONS() {
\layout Code

    while [ "$1" ]; do
\layout Code

        eval "$1() { ${ECLASS}_$1 ; }" > /dev/null
\layout Code

    shift
\layout Code

    done
\layout Code

}
\layout Standard

This means that after foo.eclass has defined e.g.
 src_unpack() and src_install(), it says:
\layout Standard

ECLASS=foo
\layout Standard

EXPORT_FUNCTIONS src_unpack src_install
\layout Standard

Actually, the ECLASS setting is put at the beginning of the eclass, directly
 after the inherit statements.
 It will in the future be used by other functions as well.
 Someday we will (I hope) adapt the portage ebuild filename->name algorithm
 and get the ECLASS setting the same way we do $P and $PN.
\layout Standard

EXPORT_FUNCTIONS() creates stub functions called ${ECLASS}_blah for every
 parameter blah passed to it.
 The stub function does nothing but call blah.
\layout Standard

When you inherit more than one eclass (almost always), your ebuild functions
 are those defined by the 1st eclass inherited.
 Since eclasses usually inherit other eclasses, you do not want to keep
 track of that.
 Instead, you prefix all your functions from foo.eclass with foo_, or ${ECLASS}_.
 This way, people can call a specific function from a specific eclass and
 know what they are going to get.
\layout Standard

Because you still want default functions to be defined with the original
 ebuild names, you call EXPORT_FUNCTIONS() at the end of every eclass.
 This makes sure that the default functions you passed as parameters are
 stubs calling the ones you just defined.
\layout Standard

I looked at adding ${EBUILD}_ instead of literal strings to the actual function
 definitions, but the bash syntax for that is too ugly.
\layout Subsubsection

ebuild function sections
\layout Standard

Although this is not an integral part of eclasses, this is a good place
 to introduce function sections.
 
\layout Standard

One rarely uses predefined functions as-is; you usually want to extend them.
 Once they have unique names (foo_src_unpack) it's easy to add code that
 executes before or after them.
 Function sections break them down and allow code to execute between any
 two sections.
\layout Standard

The implementation is simple.
 Let's take as an example the src_compile() function from base.eclass.
 It looks like this:
\layout Code

base_src_compile() {
\layout Code

./configure || die
\layout Code

make || die
\layout Code

}
\layout Standard

Here is the same function, divided into sections:
\layout Code

base_src_compile() {
\layout Code

 
\layout Code

    [ -z "$1" ] && base_src_compile all
\layout Code

 
\layout Code

    while [ "$1" ]; do
\layout Code

\layout Code

        case $1 in
\layout Code

            configure)
\layout Code

                ./configure || die;;
\layout Code

            make)
\layout Code

                make || die;;
\layout Code

            all)
\layout Code

                base_src_compile configure make;;
\layout Code

        esac
\layout Code

\layout Code

    shift
\layout Code

    done
\layout Code

 
\layout Code

}
\layout Standard

The code has been divided into two 
\begin_inset Quotes eld
\end_inset 

sections
\begin_inset Quotes erd
\end_inset 

: 
\emph on 
configure
\emph default 
 and 
\emph on 
make
\emph default 
.
 In our simple example, they correspond to the two commands in the original
 function.
\layout Standard

In the center of the new function is a while;case...esac;shift;done block.
 This block matches the parameters to the functions with the defined section
 names and executes the corresponding lines of code.
\layout Standard

The special case 
\emph on 
all
\emph default 
 calls the same function recursively with a list of sections in order.
 It's up to the eclass's author to maintain this list, which is very important.
\layout Standard

The line before the block says that a call without parameters should be
 treated the same as a call with the single parameter 
\emph on 
all.
 
\emph default 
As you see, this function recurses a lot.
 Note, however, that the call 
\emph on 
base_src_compile configure all make 
\emph default 
is also legal; it will execute 
\emph on 
base_src_compile configure configure make make
\emph default 
.
\layout Standard

Now, in your ebuild (or eclass) that inherits from base.eclass, you get the
 stub function src_compile which calls base_src_compile without parameters.
 This makes base_src_compile execute 
\emph on 
all
\emph default 
, that is, all its sections.
 You can leave it as-is.
 If you wish to extend it, you define a new src_compile and call base_src_compil
e a section at a time:
\layout Code

src_compile() {
\layout Code

    myfunc1
\layout Code

    base_src_compile configure
\layout Code

    myfunc2
\layout Code

    base_src_compile make
\layout Code

}
\layout Standard

The only way to know what functions contain what sections is to read the
 eclasses.
\layout Standard

A final note: not all functions execute all their sections when called with
 
\emph on 
all
\emph default 
 or without parameters.
 Some sections may be non-standard and must be called explicitly.
 Current examples include base_src_unpack
\emph on 
 patch.
\layout Standard

A more final note: the eclasses also include some debug statements, which
 are not part of the function/section structure.
 More on this at the debug.eclass section.
\layout Subsection

base.eclass
\layout Standard

This eclass defines some default variables and functions, similar to those
 you'd get by default in a non-inheriting ebuild.
\layout Standard

It is inherited by higher-level eclasses like the kde ones.
\layout Standard

Note that in base_src_unpack there is one non-default section (i.e.
 it doesn't execute for section 
\emph on 
all
\emph default 
).
 It is called 
\emph on 
patch
\emph default 
 and it looks like this:
\layout Code

cd ${S}
\layout Code

patch -p0 < ${FILESDIR}/${P}-gentoo.diff
\layout Standard

There is also a helper function provided by base.eclass, called newdepend().
 It simply adds all parameters to both DEPEND and RDEPEND, saving you the
 trouble of writing and maintaining two lists of dependencies.
\layout Subsection

depend.eclass
\layout Standard

Added in v4.
 This provides two pairs of functions: need-kdelibs(), need-qt() and set-kdedir(
), set-qtdir().
 These functions handle the details of the multi-qt and multi-kdelibs schemes.
 These schemes set rules for having multiple versions of qt and/or of kdelibs
 installed side-by-side.
\layout Standard

The need-* functions are called with a parameter which is the version number
 required.
 They then add the corresponding dependencies to DEPEND and RDEPEND, and
 set the variables kde_version and qt_version which are used by the set-*dir
 functions.
 If no parameter is passed, a version number of 0 (zero) is used.
\layout Standard

It is important to call these functions from the main part of the ebuild,
 so that any changes to DEPEND and RDEPEND affect emerge.
\layout Standard

The set-* dir functions are both called from the beginning of the configure
 section of the kde_src_compile() function.
 They read the qt_version and kde_version variables set by need-*, check
 which multi-*-scheme conforming libs are installed, and set KDEDIR and
 QTDIR to the location of the latest version installed that fulfills the
 requirements.
 When the new portage dependency functionality is released, this is where
 the changes needed for kde/qt-3 support will go.
\layout Standard

If no multi-*-scheme-compatible3 installation is found, KDEDIR and QTDIR
 are left untouched, assuming that the machine is an older one which sets
 hardcoded QTDIR and KDEDIR values from /etc/env.d.
\layout Subsection

kde.eclass
\layout Standard

Used by all kde apps, whether directly or indirectly.
 This is a med-level eclass, which is intended to provide not only sensible
 defaults but functions which can be used as-is more often then not.
 In fact, none of the high-level kde-* eclasses which inherit from here
 change the functions in any way, and the ebuilds rarely do so.
 This eclass contains the meat of the kde eclass system, while virtual and
 base can be said to provide the skeleton.
\layout Standard

It inherits autoconf, base and depend.
\layout Standard

Read it to find out what it defines.
 It is quite self-explanatory.
\layout Standard

Briefly, it handles all standard kde apps that use GNU standard configure/make/m
ake install cycles.
 It handles all the std.
 configure options e.g.
 qtmt.
\layout Standard

Note: some kde apps, like widget styles and i18n packages, do not need to
 compile anything.
 Therefore kde.eclass does not inherit c.
 These packages can then inherit straight from here.
 All other packages, which need to compile c code, should inherit from kde-base.e
class.
\layout Standard

As of v3.3, kde-objprelink was merged with kde, which now provides the objprelink
 deps (>=objprelink-0-r1), the options passed to configure and a function
 kde-objprelink-patch() that applies the kde-admin-acinclude patch.
 Call it at the end of your src_unpack if you need it.
\layout Subsection

kde-base.eclass
\layout Standard

Meant for standard kde apps, of both 2.1 and 2.2 architectures.
 Inherits c,kde and adds qt deps.
 Sets HOMEPAGE=apps.kde.com.
\layout Subsection

kde-i18n.eclass
\layout Standard

Meant for the kde-i18n-* packages.
 Niche use.
\layout Standard

In fact, all kde-i18n ebuilds are completely identical and so all they have
 to do is inherit from this eclass.
\layout Standard

Inherits from kde,kde.org.
 Makes a few differences, such as PROVIDE virtual/kde-i18n, correct $S,
 HOMEPAGE and DESCRIPTION.
\layout Subsection

koffice-i18n.eclass
\layout Standard

Meant for the koffice-i18n-* packages.
 Niche use.
 Very similar to kde-i18n.eclass.
\layout Standard

All kde-i18n ebuilds are completely identical and so all they have to do
 is inherit from this eclass.
\layout Subsection

kde-dist.eclass
\layout Standard

Meant for the base kde distribution packages in kde-base/*.
 Inherits kde-base, kde.org and kde-objprelink.
 Adds the correct DESCRIPTION and HOMEPAGE and kdelibs-${PV} deps.
 The simpler/smaller kde-base/ packages (e.g.
 kdetoys) make no changes at all; most of those that do only add deps.
\layout Subsection

c.eclass
\layout Standard

Adds gcc and glibc to DEPEND and RDEPEND.
\layout Subsection

autoconf.eclass
\layout Standard

Adds make/automake/autoconf to DEPEND.
\layout Subsection

debug.eclass
\layout Standard

Adds verbose output debugging functions.
 Is inherited by virtual.eclass.
\layout Standard

A function with debugging looks like this:
\layout Code

base_src_install() {
\layout Code

 
\layout Code

        debug-print-function base_src_install $*
\layout Code

        [ -z "$1" ] && base_src_install all
\layout Code

 
\layout Code

        while [ "$1" ]; do
\layout Code

 
\layout Code

        case $1 in
\layout Code

                make)
\layout Code

                        debug-print-section make
\layout Code

                        make DESTDIR=${D} install || die
\layout Code

                        ;;
\layout Code

            all)
\layout Code

                        debug-prnit-section all
\layout Code

                        base_src_install make
\layout Code

                        ;;
\layout Code

        esac
\layout Code

 
\layout Code

        shift
\layout Code

        done
\layout Code

 
\layout Code

}
\layout Standard

debug-print-function() prints 
\begin_inset Quotes eld
\end_inset 

now in function $1
\begin_inset Quotes erd
\end_inset 

, 
\begin_inset Quotes eld
\end_inset 

parameters are $2...
\begin_inset Quotes erd
\end_inset 

 (all following parameters to the function).
\layout Standard

debug-print-section() prints 
\begin_inset Quotes eld
\end_inset 

now in section $1
\begin_inset Quotes erd
\end_inset 

.
\layout Standard

debug-print() prints raw 
\begin_inset Quotes eld
\end_inset 

$1
\begin_inset Quotes erd
\end_inset 

.
\layout Standard

Inside debug.eclass are several settings, which can later be moved to some
 external config file.
 They include turning debug on or off and redirecting its output.
\layout Standard

The functions are used in all ebuild functions/sections of all eclasses,
 and in the helper functions inherit() and EXPORT_FUNCTIONS().
\layout Standard

Note that all debugging output is off by default.
 You can change this setting in debug.eclass (for now), but be careful not
 to commit the new setting to cvs.
 In addition, debug output is further disabled in inherit() in inherit.eclass
 to avoid extra-inheriting.
 You can enable it there by uncommenting the appropriate lines.
\layout Subsection

kde-objprelink.eclass
\layout Standard

This eclass has been removed in v3.3 Its contents were merged into kde.eclass.
\layout Section

The inheriting ebuilds
\layout Standard

Not much here as yet.
 Look at the kde*-2.2.1-r1 ebuilds for examples.
 As a rule, read the eclass you are inheriting from and put any necessary
 changes in your ebuild.
 For now, a collection of tips:
\layout Itemize

Always extend variables and functions.
 You should almost never need to replace them.
 In particular, always remember to use DEPEND=
\begin_inset Quotes erd
\end_inset 

$DEPEND...
\begin_inset Quotes erd
\end_inset 

 and the same for RDEPEND.
\layout Itemize

The eclasses have DESCRIPTION=
\begin_inset Quotes erd
\end_inset 

Derived from $ECLASS
\begin_inset Quotes erd
\end_inset 

 set.
 This is to remind you to write a description of your own for your ebuilds.
 Otherwise the inherited one will show through as a reminder.
\layout Itemize

Remember to always call need-kdelibs().
 need-qt(0 is more optional, since you can depend on kdelibs to make sure
 qt is installed.
 There's no harm in explicitly calling need-qt, though.
\layout Itemize

If you override kde_src_compile, section configure, remember that you 
\emph on 
must
\emph default 
 call set-kdedir and set-qtdir somewhere before calling configure.
\the_end
