                # ABI Patch for ppc/xpcom for gcc-3.x
                # http://bugzilla.mozilla.org/show_bug.cgi?id=142594

                if [ "${ARCH}" = "ppc" ] ; then
                        patch -p0 < ${FILESDIR}/mozilla-1.1-abi-xpcom-ppc.patch || die
                fi



Index: xpcom//reflect/xptcall/src/md/unix/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/xpcom/reflect/xptcall/src/md/unix/Makefile.in,v
retrieving revision 1.63.2.1
diff -u -p -r1.63.2.1 Makefile.in
--- xpcom//reflect/xptcall/src/md/unix/Makefile.in	10 Apr 2002 03:37:34 -0000	1.63.2.1
+++ xpcom//reflect/xptcall/src/md/unix/Makefile.in	6 May 2002 19:09:25 -0000
@@ -211,16 +211,35 @@ endif
 CXXFLAGS 	:=  $(filter-out $(MOZ_OPTIMIZE_FLAGS), $(CXXFLAGS))
 endif
 
+#
+# Linux/PPC
+#
 ifeq ($(OS_ARCH)$(OS_TEST),Linuxppc)
 CPPSRCS		:= xptcinvoke_ppc_linux.cpp xptcstubs_ppc_linux.cpp
 ASFILES		:= xptcinvoke_asm_ppc_linux.s xptcstubs_asm_ppc_linux.s
+
+GXXABIVERSION	:= $(shell $(CXX) -x c++ -dM -E - </dev/null \
+			   | grep -w __GXX_ABI_VERSION \
+			   | sed -e 's/.*__/__/' \
+			   | sed -e 's/N\W\{1,\}/N=/')
+
+ifneq ($(GXXABIVERSION),)
+ABIDEFINE	:= -D$(GXXABIVERSION)
+endif
+AS		:= $(CC) -c -x assembler-with-cpp $(ABIDEFINE)
 endif
 
+#
+# NetBSD/PPC
+#
 ifneq (,$(filter NetBSDmacppc NetBSDbebox NetBSDofppc NetBSDprep NetBSDamigappc,$(OS_ARCH)$(OS_TEST)))                           
 CPPSRCS		:= xptcinvoke_ppc_netbsd.cpp xptcstubs_ppc_netbsd.cpp
 ASFILES		:= xptcinvoke_asm_ppc_netbsd.s xptcstubs_asm_ppc_netbsd.s
 endif
 
+#
+# Darwin/PPC
+#
 ifeq ($(OS_ARCH),Darwin)
 CPPSRCS		:= xptcinvoke_ppc_rhapsody.cpp xptcstubs_ppc_rhapsody.cpp
 ASFILES		:= xptcinvoke_asm_ppc_rhapsody.s xptcstubs_asm_ppc_rhapsody.s
Index: xpcom//reflect/xptcall/src/md/unix/xptcinvoke_asm_ppc_linux.s
===================================================================
RCS file: /cvsroot/mozilla/xpcom/reflect/xptcall/src/md/unix/xptcinvoke_asm_ppc_linux.s,v
retrieving revision 1.4.210.1
diff -u -p -r1.4.210.1 xptcinvoke_asm_ppc_linux.s
--- xpcom//reflect/xptcall/src/md/unix/xptcinvoke_asm_ppc_linux.s	10 Apr 2002 03:37:36 -0000	1.4.210.1
+++ xpcom//reflect/xptcall/src/md/unix/xptcinvoke_asm_ppc_linux.s	6 May 2002 19:09:25 -0000
@@ -62,8 +62,8 @@ XPTC_InvokeByIndex:
 	addi    r0,r10,96			# reserve stack for GPR and FPR register save area r0 = r10 + 96
 	lwz     r9,0(sp)			# r9 = backchain
 	neg     r0,r0
-	stwux   r9,sp,r0			# reserve stack sapce and save SP backchain
-	
+	stwux   r9,sp,r0			# reserve stack space and save SP backchain
+
 	addi    r3,sp,8				# r3 <= args
 	mr      r4,r5				# r4 <= paramCount
 	mr      r5,r6				# r5 <= params
@@ -85,7 +85,9 @@ XPTC_InvokeByIndex:
 	lwz     r3,8(r31)			# r3 <= that
 	lwz     r4,12(r31)			# r4 <= methodIndex
 	lwz     r5,0(r3)			# r5 <= vtable ( == *that )
+#if __GXX_ABI_VERSION - 0 < 100 /* G++ pre-V3 ABI */
 	addi	r4,r4,2				# skip first two vtable entries
+#endif
 	slwi    r4,r4,2				# convert to offset ( *= 4 )
 	lwzx    r0,r5,r4			# r0 <= methodpointer ( == vtable + offset )
 
Index: xpcom//reflect/xptcall/src/md/unix/xptcstubs_ppc_linux.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/reflect/xptcall/src/md/unix/xptcstubs_ppc_linux.cpp,v
retrieving revision 1.5.38.1
diff -u -p -r1.5.38.1 xptcstubs_ppc_linux.cpp
--- xpcom//reflect/xptcall/src/md/unix/xptcstubs_ppc_linux.cpp	10 Apr 2002 03:37:43 -0000	1.5.38.1
+++ xpcom//reflect/xptcall/src/md/unix/xptcstubs_ppc_linux.cpp	6 May 2002 19:09:25 -0000
@@ -189,7 +189,9 @@ PrepareAndDispatch(nsXPTCStubBase* self,
 // however, it's quick, dirty, and'll break when the ABI changes on
 // us, which is what we want ;-).
 
-#define STUB_ENTRY(n)                                       \
+#if __GXX_ABI_VERSION - 0 < 100
+// gcc-2 version
+# define STUB_ENTRY(n)                                       \
 __asm__ (                                                   \
         ".section \".text\" \n\t"                           \
         ".align 2 \n\t"                                     \
@@ -200,6 +202,46 @@ __asm__ (                               
 	"li     11,"#n" \n\t"                               \
 	"b      SharedStub@local \n"                        \
 );
+#else
+// gcc-3 version
+//
+// As G++3 ABI contains the length of the functionname in the mangled
+// name, it is difficult to get a generic assembler mechanism like
+// in the G++ 2.95 case.
+// Create names would be like:
+// _ZN14nsXPTCStubBase5Stub1Ev
+// _ZN14nsXPTCStubBase6Stub12Ev
+// _ZN14nsXPTCStubBase7Stub123Ev
+// _ZN14nsXPTCStubBase8Stub1234Ev
+// etc.
+// Use assembler directives to get the names right...
+
+# define STUB_ENTRY(n)							\
+__asm__ (								\
+	".align	2 \n\t"							\
+	".if	"#n" < 10 \n\t"						\
+	".globl	_ZN14nsXPTCStubBase5Stub"#n"Ev \n\t"			\
+	".type	_ZN14nsXPTCStubBase5Stub"#n"Ev,@function \n\n"		\
+"_ZN14nsXPTCStubBase5Stub"#n"Ev: \n\t"					\
+									\
+	".elseif "#n" < 100 \n\t"					\
+	".globl	_ZN14nsXPTCStubBase6Stub"#n"Ev \n\t"			\
+	".type	_ZN14nsXPTCStubBase6Stub"#n"Ev,@function \n\n"		\
+"_ZN14nsXPTCStubBase6Stub"#n"Ev: \n\t"					\
+									\
+	".elseif "#n" < 1000 \n\t"					\
+	".globl	_ZN14nsXPTCStubBase7Stub"#n"Ev \n\t"			\
+	".type	_ZN14nsXPTCStubBase7Stub"#n"Ev,@function \n\n"		\
+"_ZN14nsXPTCStubBase7Stub"#n"Ev: \n\t"					\
+									\
+	".else \n\t"							\
+	".err	\"stub number "#n" >= 1000 not yet supported\"\n"	\
+	".endif \n\t"							\
+									\
+	"li	11,"#n" \n\t"						\
+	"b	SharedStub@local \n"					\
+);
+#endif
 
 #define SENTINEL_ENTRY(n)                            \
 nsresult nsXPTCStubBase::Sentinel##n()               \
Index: xpcom//reflect/xptcall/tests/TestXPTCInvoke.cpp
===================================================================
RCS file: /cvsroot/mozilla/xpcom/reflect/xptcall/tests/TestXPTCInvoke.cpp,v
retrieving revision 1.22.2.1
diff -u -p -r1.22.2.1 TestXPTCInvoke.cpp
--- xpcom//reflect/xptcall/tests/TestXPTCInvoke.cpp	10 Apr 2002 03:37:52 -0000	1.22.2.1
+++ xpcom//reflect/xptcall/tests/TestXPTCInvoke.cpp	6 May 2002 19:09:26 -0000
@@ -87,6 +87,14 @@ public:
                                  float p17, float p18, float p19, float p20, 
                                  float *retval) = 0;
 
+    NS_IMETHOD AddMixedInts(PRInt64 p1, PRInt32 p2, PRInt64 p3, PRInt32 p4,
+			    PRInt32 p5, PRInt64 p6, PRInt32 p7, PRInt32 p8,
+			    PRInt64 p9, PRInt32 p10, PRInt64* retval) = 0;
+
+    NS_IMETHOD AddMixedInts2(PRInt32 p1, PRInt64 p2, PRInt32 p3, PRInt64 p4,
+			     PRInt64 p5, PRInt32 p6, PRInt64 p7, PRInt64 p8,
+			     PRInt32 p9, PRInt64 p10, PRInt64* retval) = 0;
+
     NS_IMETHOD PassTwoStrings(const char* s1, const char* s2, char** retval) = 0;
 
 };
@@ -113,6 +121,13 @@ public:
     NS_IMETHOD AddManyFloats(float p1, float p2, float p3, float p4,
                              float p5, float p6, float p7, float p8,
                              float p9, float p10, float* retval);
+    NS_IMETHOD AddMixedInts(PRInt64 p1, PRInt32 p2, PRInt64 p3, PRInt32 p4,
+			    PRInt32 p5, PRInt64 p6, PRInt32 p7, PRInt32 p8,
+			    PRInt64 p9, PRInt32 p10, PRInt64* retval);
+
+    NS_IMETHOD AddMixedInts2(PRInt32 p1, PRInt64 p2, PRInt32 p3, PRInt64 p4,
+			     PRInt64 p5, PRInt32 p6, PRInt64 p7, PRInt64 p8,
+			     PRInt32 p9, PRInt64 p10, PRInt64* retval);
 
     NS_IMETHOD AddManyManyFloats(float p1, float p2, float p3, float p4,
                                  float p5, float p6, float p7, float p8,
@@ -231,6 +246,24 @@ InvokeTestTarget::AddManyManyFloats(floa
 }
 
 NS_IMETHODIMP
+InvokeTestTarget::AddMixedInts(PRInt64 p1, PRInt32 p2, PRInt64 p3, PRInt32 p4,
+			       PRInt32 p5, PRInt64 p6, PRInt32 p7, PRInt32 p8,
+			       PRInt64 p9, PRInt32 p10, PRInt64* retval)
+{
+    *retval = p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
+InvokeTestTarget::AddMixedInts2(PRInt32 p1, PRInt64 p2, PRInt32 p3, PRInt64 p4,
+				PRInt64 p5, PRInt32 p6, PRInt64 p7, PRInt64 p8,
+				PRInt32 p9, PRInt64 p10, PRInt64* retval)
+{
+    *retval = p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10;
+    return NS_OK;
+}
+
+NS_IMETHODIMP
 InvokeTestTarget::PassTwoStrings(const char* s1, const char* s2, char** retval)
 {
     char *ret = "milk";
@@ -306,6 +339,22 @@ int main()
     else
         printf("\tFAILED");
 
+    if(NS_SUCCEEDED(test->AddMixedInts(1,2,3,4,5,6,7,8,9,10,&out64)))
+    {
+        LL_L2I(tmp32, out64);
+        printf("\t1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = %d\n", (int)tmp32);
+    }
+    else
+        printf("\tFAILED");
+
+    if(NS_SUCCEEDED(test->AddMixedInts2(1,2,3,4,5,6,7,8,9,10,&out64)))
+    {
+        LL_L2I(tmp32, out64);
+        printf("\t1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = %d\n", (int)tmp32);
+    }
+    else
+        printf("\tFAILED");
+
     if(NS_SUCCEEDED(test->PassTwoStrings("moo","cow",&outS)))
         printf(" = %s\n", outS);
     else
@@ -384,8 +433,8 @@ int main()
     var[2].flags = nsXPTCVariant::PTR_IS_DATA;
     var[2].ptr = &var[2].val.i64;
 
-     if(NS_SUCCEEDED(XPTC_InvokeByIndex(test, 6, 3, var)))
-         printf("\t2L * 2L = %d\n", (int)var[2].val.i64);
+    if(NS_SUCCEEDED(XPTC_InvokeByIndex(test, 6, 3, var)))
+        printf("\t2L * 2L = %d\n", (int)var[2].val.i64);
     else
         printf("\tFAILED");
 
@@ -555,6 +604,8 @@ int main()
     if(NS_SUCCEEDED(XPTC_InvokeByIndex(test, 10, 11, var)))
         printf("\t1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = %ff\n",
                 (double) var[10].val.f);
+    else
+        printf("\tFAILED");
 
     var[0].val.f = 1.0f;
     var[0].type = nsXPTType::T_FLOAT;
@@ -645,6 +696,108 @@ int main()
         printf("\t1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 15 + 16 + 17 + 18 + 19 + 20 = %ff\n",
                 (double) var[20].val.f);
 
+    var[0].val.i64 = 1;
+    var[0].type = nsXPTType::T_I64;
+    var[0].flags = 0;
+
+    var[1].val.i32 = 2;
+    var[1].type = nsXPTType::T_I32;
+    var[1].flags = 0;
+
+    var[2].val.i64 = 3;
+    var[2].type = nsXPTType::T_I64;
+    var[2].flags = 0;
+
+    var[3].val.i32 = 4;
+    var[3].type = nsXPTType::T_I32;
+    var[3].flags = 0;
+
+    var[4].val.i32 = 5;
+    var[4].type = nsXPTType::T_I32;
+    var[4].flags = 0;
+
+    var[5].val.i64 = 6;
+    var[5].type = nsXPTType::T_I64;
+    var[5].flags = 0;
+
+    var[6].val.i32 = 7;
+    var[6].type = nsXPTType::T_I32;
+    var[6].flags = 0;
+
+    var[7].val.i32 = 8;
+    var[7].type = nsXPTType::T_I32;
+    var[7].flags = 0;
+
+    var[8].val.i64 = 9;
+    var[8].type = nsXPTType::T_I64;
+    var[8].flags = 0;
+
+    var[9].val.i32 = 10;
+    var[9].type = nsXPTType::T_I32;
+    var[9].flags = 0;
+
+    var[10].val.i64 = 0;
+    var[10].type = nsXPTType::T_I64;
+    var[10].flags = nsXPTCVariant::PTR_IS_DATA;
+    var[10].ptr = &var[10].val.i64;
+
+    if(NS_SUCCEEDED(XPTC_InvokeByIndex(test, 12, 11, var)))
+        printf("\t1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = %d\n",
+	       (int)var[10].val.i64);
+    else
+        printf("\tFAILED");
+
+    var[0].val.i32 = 1;
+    var[0].type = nsXPTType::T_I32;
+    var[0].flags = 0;
+
+    var[1].val.i64 = 2;
+    var[1].type = nsXPTType::T_I64;
+    var[1].flags = 0;
+
+    var[2].val.i32 = 3;
+    var[2].type = nsXPTType::T_I32;
+    var[2].flags = 0;
+
+    var[3].val.i64 = 4;
+    var[3].type = nsXPTType::T_I64;
+    var[3].flags = 0;
+
+    var[4].val.i64 = 5;
+    var[4].type = nsXPTType::T_I64;
+    var[4].flags = 0;
+
+    var[5].val.i32 = 6;
+    var[5].type = nsXPTType::T_I32;
+    var[5].flags = 0;
+
+    var[6].val.i64 = 7;
+    var[6].type = nsXPTType::T_I64;
+    var[6].flags = 0;
+
+    var[7].val.i64 = 8;
+    var[7].type = nsXPTType::T_I64;
+    var[7].flags = 0;
+
+    var[8].val.i32 = 9;
+    var[8].type = nsXPTType::T_I32;
+    var[8].flags = 0;
+
+    var[9].val.i64 = 10;
+    var[9].type = nsXPTType::T_I64;
+    var[9].flags = 0;
+
+    var[10].val.i64 = 0;
+    var[10].type = nsXPTType::T_I64;
+    var[10].flags = nsXPTCVariant::PTR_IS_DATA;
+    var[10].ptr = &var[10].val.i64;
+
+    if(NS_SUCCEEDED(XPTC_InvokeByIndex(test, 13, 11, var)))
+        printf("\t1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 = %d\n",
+	       (int)var[10].val.i64);
+    else
+        printf("\tFAILED");
+
     var[0].val.p = (void*)"moo";
     var[0].type = nsXPTType::T_CHAR_STR;
     var[0].flags = 0;
@@ -658,7 +811,7 @@ int main()
     var[2].flags = nsXPTCVariant::PTR_IS_DATA;
     var[2].ptr = &var[2].val.p;
     
-    if(NS_SUCCEEDED(XPTC_InvokeByIndex(test, 12, 3, var)))
+    if(NS_SUCCEEDED(XPTC_InvokeByIndex(test, 14, 3, var)))
         printf(" = %s\n", var[2].val.p);
     else
         printf("\tFAILED");

