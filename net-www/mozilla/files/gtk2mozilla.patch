diff -u mozilla/embedding/browser/Makefile.in mold/embedding/browser/Makefile.in
--- mozilla/embedding/browser/Makefile.in	Wed Apr 10 04:35:58 2002
+++ mold/embedding/browser/Makefile.in	Tue May 14 13:16:45 2002
@@ -31,6 +31,10 @@
 DIRS += gtk
 endif
 
+ifdef MOZ_ENABLE_GTK2
+DIRS += gtk
+endif
+
 ifdef MOZ_ENABLE_PHOTON
 DIRS += photon
 endif
Common subdirectories: mozilla/embedding/browser/activex and mold/embedding/browser/activex
Common subdirectories: mozilla/embedding/browser/build and mold/embedding/browser/build
Common subdirectories: mozilla/embedding/browser/chrome and mold/embedding/browser/chrome
Common subdirectories: mozilla/embedding/browser/cocoa and mold/embedding/browser/cocoa
Common subdirectories: mozilla/embedding/browser/gtk and mold/embedding/browser/gtk
Common subdirectories: mozilla/embedding/browser/macbuild and mold/embedding/browser/macbuild
Common subdirectories: mozilla/embedding/browser/photon and mold/embedding/browser/photon
Common subdirectories: mozilla/embedding/browser/powerplant and mold/embedding/browser/powerplant
Common subdirectories: mozilla/embedding/browser/webBrowser and mold/embedding/browser/webBrowser
Common subdirectories: mozilla/embedding/browser/gtk/src/.deps and mold/embedding/browser/gtk/src/.deps
Common subdirectories: mozilla/embedding/browser/gtk/src/CVS and mold/embedding/browser/gtk/src/CVS
diff -u -N mozilla/embedding/browser/gtk/src/EmbedWindow.cpp mold/embedding/browser/gtk/src/EmbedWindow.cpp
--- mozilla/embedding/browser/gtk/src/EmbedWindow.cpp	Wed Apr 10 04:37:03 2002
+++ mold/embedding/browser/gtk/src/EmbedWindow.cpp	Tue May 14 10:41:23 2002
@@ -226,9 +226,11 @@
 {
   GtkWidget* parent = GTK_WIDGET(mOwner->mOwningWidget)->parent;
 
+#ifdef MOZ_WIDGET_GTK
   if (GTK_IS_CONTAINER(parent))
     gtk_container_focus(GTK_CONTAINER(parent),
                         GTK_DIR_TAB_FORWARD);
+#endif
   return NS_OK;
 }
 
@@ -237,9 +239,11 @@
 {
   GtkWidget* parent = GTK_WIDGET(mOwner->mOwningWidget)->parent;
 
+#ifdef MOZ_WIDGET_GTK
   if (GTK_IS_CONTAINER(parent))
     gtk_container_focus(GTK_CONTAINER(parent),
                         GTK_DIR_TAB_BACKWARD);
+#endif
   return NS_OK;
 }
 
@@ -300,7 +304,9 @@
 NS_IMETHODIMP
 EmbedWindow::SetTitle(const PRUnichar *aTitle)
 {
+  g_print ("set title\n");
   mTitle = aTitle;
+  g_assert (mOwner->mOwningWidget != NULL);
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
 		  moz_embed_signals[TITLE]);
   return NS_OK;
@@ -405,7 +411,9 @@
            0, 0,
            sTipWindow->allocation.width, sTipWindow->allocation.height);
 
+#ifdef MOZ_WIDGET_GTK
   gtk_widget_popup(sTipWindow, aXCoords + root_x, aYCoords + root_y);
+#endif /* MOZ_WIDGET_GTK */
   
   nsMemory::Free( (void*)tipString );
 
diff -u -N mozilla/embedding/browser/gtk/src/Makefile.in mold/embedding/browser/gtk/src/Makefile.in
--- mozilla/embedding/browser/gtk/src/Makefile.in	Thu Apr 11 20:27:09 2002
+++ mold/embedding/browser/gtk/src/Makefile.in	Tue May 14 10:41:23 2002
@@ -56,6 +56,11 @@
 		EmbedWindowCreator.cpp \
 		EmbedStream.cpp
 
+ifdef MOZ_ENABLE_GTK2
+CSRCS           = \
+		gtkmozembedmarshal.c
+endif
+
 ifdef BUILD_STATIC_LIBS
 # Static build stuff
 DEFINES         += -D_BUILD_STATIC_BIN=1
@@ -88,12 +93,20 @@
 		gtkmozembed.h \
 		gtkmozembed_internal.h
 
+ifdef MOZ_ENABLE_GTK
 EXTRA_DSO_LDOPTS = \
 		$(MOZ_COMPONENT_LIBS) \
 		-lgtksuperwin \
 		$(NULL)
+endif
+
+ifdef MOZ_ENABLE_GTK2
+EXTRA_DSO_LDOPTS = \
+		$(MOZ_COMPONENT_LIBS) \
+		$(NULL)
+endif
 
-EXTRA_DSO_LDOPTS += $(MOZ_GTK_LDFLAGS)
+EXTRA_DSO_LDOPTS += $(MOZ_GTK_LDFLAGS) $(MOZ_GTK2_LIBS)
 
 include $(topsrcdir)/config/rules.mk
 
@@ -108,7 +121,8 @@
 endif
 endif
 
-CXXFLAGS        += $(MOZ_GTK_CFLAGS)
+CXXFLAGS        += $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
+CFLAGS          += $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
 
 ifdef BUILD_STATIC_LIBS
 
diff -u -N mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp mold/embedding/browser/gtk/src/gtkmozembed2.cpp
--- mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp	Wed Apr 10 04:37:03 2002
+++ mold/embedding/browser/gtk/src/gtkmozembed2.cpp	Tue May 14 10:41:23 2002
@@ -36,11 +36,32 @@
 #include <nsXPIDLString.h>
 #include <nsReadableUtils.h>
 
+#ifdef MOZ_WIDGET_GTK
+
 // so we can get callbacks from the mozarea
 #include <gtkmozarea.h>
 
+// so we get the right marshaler for gtk 1.2
+#define gtkmozembed_VOID__INT_UINT \
+  gtk_marshal_NONE__INT_INT
+#define gtkmozembed_VOID__POINTER_INT_INT \
+  gtk_marshal_NONE__POINTER_INT_INT
+#define gtkmozembed_VOID__POINTER_INT_UINT \
+  gtk_marshal_NONE__POINTER_INT_INT
+#define gtkmozembed_VOID__POINTER_INT_POINTER \
+  gtk_marshal_NONE__POINTER_INT_POINTER
+
+#endif /* MOZ_WIDGET_GTK */
+
+#ifdef MOZ_WIDGET_GTK2
+
+#include "gtkmozembedmarshal.h"
+
+#endif /* MOZ_WIDGET_GTK2 */
+
 class nsIDirectoryServiceProvider;
 
+#ifdef MOZ_WIDGET_GTK
 // Some "massaged" enum information for the GTK Type System
 static GtkFlagValue gtk_moz_embed_progress_flags_values[] = {
   { GTK_MOZ_EMBED_FLAG_START,
@@ -138,6 +159,7 @@
   { 0,
     NULL, NULL }
 };
+#endif /* MOZ_WIDGET_GTK */
 
 
 // class and instance initialization
@@ -180,6 +202,7 @@
 		       GdkEventFocus *aGdkFocusEvent,
 		       GtkMozEmbed   *aEmbed);
 
+#ifdef MOZ_WIDGET_GTK
 // signal handlers for tracking the focus and and focus out events on
 // the toplevel window.
 
@@ -189,6 +212,7 @@
 static void
 handle_toplevel_focus_out(GtkMozArea    *aArea,
 			  GtkMozEmbed   *aEmbed);
+#endif /* MOZ_WIDGET_GTK */
 
 // globals for this type of widget
 
@@ -249,191 +273,193 @@
   moz_embed_signals[LINK_MESSAGE] = 
     gtk_signal_new ("link_message",
 		    GTK_RUN_FIRST,
-		    object_class->type,
+		    GTK_CLASS_TYPE(klass),
 		    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, link_message),
 		    gtk_marshal_NONE__NONE,
 		    GTK_TYPE_NONE, 0);
   moz_embed_signals[JS_STATUS] =
     gtk_signal_new ("js_status",
 		    GTK_RUN_FIRST,
-		    object_class->type,
+		    GTK_CLASS_TYPE(klass),
 		    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, js_status),
 		    gtk_marshal_NONE__NONE,
 		    GTK_TYPE_NONE, 0);
   moz_embed_signals[LOCATION] =
     gtk_signal_new ("location",
 		    GTK_RUN_FIRST,
-		    object_class->type,
+		    GTK_CLASS_TYPE(klass),
 		    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, location),
 		    gtk_marshal_NONE__NONE,
 		    GTK_TYPE_NONE, 0);
   moz_embed_signals[TITLE] = 
     gtk_signal_new("title",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, title),
 		   gtk_marshal_NONE__NONE,
 		   GTK_TYPE_NONE, 0);
   moz_embed_signals[PROGRESS] =
     gtk_signal_new("progress",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, progress),
 		   gtk_marshal_NONE__INT_INT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_INT, GTK_TYPE_INT);
   moz_embed_signals[PROGRESS_ALL] = 
     gtk_signal_new("progress_all",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, progress_all),
-		   gtk_marshal_NONE__POINTER_INT_INT,
+		   gtkmozembed_VOID__POINTER_INT_INT,
 		   GTK_TYPE_NONE, 3, GTK_TYPE_STRING,
 		   GTK_TYPE_INT, GTK_TYPE_INT);
   moz_embed_signals[NET_STATE] =
     gtk_signal_new("net_state",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, net_state),
-		   gtk_marshal_NONE__INT_INT,
+		   gtkmozembed_VOID__INT_UINT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_INT, GTK_TYPE_UINT);
   moz_embed_signals[NET_STATE_ALL] =
     gtk_signal_new("net_state_all",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, net_state_all),
-		   gtk_marshal_NONE__POINTER_INT_INT,
+		   gtkmozembed_VOID__POINTER_INT_UINT,
 		   GTK_TYPE_NONE, 3, GTK_TYPE_STRING,
 		   GTK_TYPE_INT, GTK_TYPE_UINT);
   moz_embed_signals[NET_START] =
     gtk_signal_new("net_start",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, net_start),
 		   gtk_marshal_NONE__NONE,
 		   GTK_TYPE_NONE, 0);
   moz_embed_signals[NET_STOP] =
     gtk_signal_new("net_stop",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, net_stop),
 		   gtk_marshal_NONE__NONE,
 		   GTK_TYPE_NONE, 0);
   moz_embed_signals[NEW_WINDOW] =
     gtk_signal_new("new_window",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, new_window),
 		   gtk_marshal_NONE__POINTER_UINT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_POINTER, GTK_TYPE_UINT);
   moz_embed_signals[VISIBILITY] =
     gtk_signal_new("visibility",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, visibility),
 		   gtk_marshal_NONE__BOOL,
 		   GTK_TYPE_NONE, 1, GTK_TYPE_BOOL);
   moz_embed_signals[DESTROY_BROWSER] =
     gtk_signal_new("destroy_browser",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, destroy_brsr),
 		   gtk_marshal_NONE__NONE,
 		   GTK_TYPE_NONE, 0);
   moz_embed_signals[OPEN_URI] = 
     gtk_signal_new("open_uri",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, open_uri),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_STRING);
   moz_embed_signals[SIZE_TO] =
     gtk_signal_new("size_to",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, size_to),
 		   gtk_marshal_NONE__INT_INT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_INT, GTK_TYPE_INT);
   moz_embed_signals[DOM_KEY_DOWN] =
     gtk_signal_new("dom_key_down",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_key_down),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_KEY_PRESS] =
     gtk_signal_new("dom_key_press",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_key_press),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_KEY_UP] =
     gtk_signal_new("dom_key_up",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_key_up),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_DOWN] =
     gtk_signal_new("dom_mouse_down",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_down),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_UP] =
     gtk_signal_new("dom_mouse_up",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_up),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_CLICK] =
     gtk_signal_new("dom_mouse_click",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_click),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_DBL_CLICK] =
     gtk_signal_new("dom_mouse_dbl_click",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_dbl_click),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_OVER] =
     gtk_signal_new("dom_mouse_over",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_over),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_OUT] =
     gtk_signal_new("dom_mouse_out",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_out),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[SECURITY_CHANGE] =
     gtk_signal_new("security_change",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, security_change),
 		   gtk_marshal_NONE__POINTER_UINT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_POINTER, GTK_TYPE_UINT);
   moz_embed_signals[STATUS_CHANGE] =
     gtk_signal_new("status_change",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, status_change),
-		   gtk_marshal_NONE__POINTER_INT_POINTER,
+		   gtkmozembed_VOID__POINTER_INT_POINTER,
 		   GTK_TYPE_NONE, 3,
 		   GTK_TYPE_POINTER, GTK_TYPE_INT, GTK_TYPE_POINTER);
 
+#ifdef MOZ_WIDGET_GTK
   gtk_object_class_add_signals(object_class, moz_embed_signals,
 			       EMBED_LAST_SIGNAL);
+#endif /* MOZ_WIDGET_GTK */
 
 }
 
@@ -443,6 +469,8 @@
   EmbedPrivate *priv = new EmbedPrivate();
   embed->data = priv;
   gtk_widget_set_name(GTK_WIDGET(embed), "gtkmozembed");
+
+  GTK_WIDGET_UNSET_FLAGS (GTK_WIDGET(embed), GTK_NO_WINDOW);
 }
 
 GtkWidget *
@@ -538,6 +566,7 @@
 				 embed,
 				 GTK_OBJECT(child_widget));
 
+#ifdef MOZ_WIDGET_GTK
   // connect to the toplevel focus out events for the child
   GtkMozArea *mozarea = GTK_MOZAREA(child_widget);
   gtk_signal_connect_while_alive(GTK_OBJECT(mozarea),
@@ -551,6 +580,7 @@
 				 GTK_SIGNAL_FUNC(handle_toplevel_focus_out),
 				 embed,
 				 GTK_OBJECT(mozarea));
+#endif /* MOZ_WIDGET_GTK */
 }
 
 static void
@@ -663,6 +693,8 @@
   return FALSE;
 }
 
+#ifdef MOZ_WIDGET_GTK
+
 static void
 handle_toplevel_focus_in (GtkMozArea    *aArea,
 			  GtkMozEmbed   *aEmbed)
@@ -683,6 +715,8 @@
   embedPrivate->TopLevelFocusOut();
 }
 
+#endif /* MOZ_WIDGET_GTK */
+
 // Widget methods
 
 void
@@ -1011,6 +1045,8 @@
   return embedPrivate->mChromeMask;
 }
 
+#ifdef MOZ_WIDGET_GTK
+
 GtkType
 gtk_moz_embed_progress_flags_get_type(void)
 {
@@ -1059,6 +1095,8 @@
   return chrome_flags_type;
 }
 
+#endif /* MOZ_WIDGET_GTK */
+
 void
 gtk_moz_embed_get_nsIWebBrowser  (GtkMozEmbed *embed, nsIWebBrowser **retval)
 {
@@ -1183,14 +1221,16 @@
   moz_embed_single_signals[NEW_WINDOW_ORPHAN] =
     gtk_signal_new("new_window_orphan",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GTK_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedSingleClass,
 				     new_window_orphan),
 		   gtk_marshal_NONE__POINTER_UINT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_POINTER, GTK_TYPE_UINT);
   
+#ifdef MOZ_WIDGET_GTK
   gtk_object_class_add_signals(object_class, moz_embed_single_signals,
 			       SINGLE_LAST_SIGNAL);
+#endif /* MOZ_WIDGET_GTK */
 }
 
 static void
diff -u -N mozilla/embedding/browser/gtk/src/gtkmozembedmarshal.c mold/embedding/browser/gtk/src/gtkmozembedmarshal.c
--- mozilla/embedding/browser/gtk/src/gtkmozembedmarshal.c	Thu Jan  1 01:00:00 1970
+++ mold/embedding/browser/gtk/src/gtkmozembedmarshal.c	Tue May 14 13:24:29 2002
@@ -0,0 +1,203 @@
+
+#include	<glib-object.h>
+
+
+#ifdef G_ENABLE_DEBUG
+#define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
+#define g_marshal_value_peek_char(v)     g_value_get_char (v)
+#define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
+#define g_marshal_value_peek_int(v)      g_value_get_int (v)
+#define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
+#define g_marshal_value_peek_long(v)     g_value_get_long (v)
+#define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
+#define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
+#define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
+#define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
+#define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
+#define g_marshal_value_peek_float(v)    g_value_get_float (v)
+#define g_marshal_value_peek_double(v)   g_value_get_double (v)
+#define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
+#define g_marshal_value_peek_param(v)    g_value_get_param (v)
+#define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
+#define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
+#define g_marshal_value_peek_object(v)   g_value_get_object (v)
+#else /* !G_ENABLE_DEBUG */
+/* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
+ *          Do not access GValues directly in your code. Instead, use the
+ *          g_value_get_*() functions
+ */
+#define g_marshal_value_peek_boolean(v)  (v)->data[0].v_int
+#define g_marshal_value_peek_char(v)     (v)->data[0].v_int
+#define g_marshal_value_peek_uchar(v)    (v)->data[0].v_uint
+#define g_marshal_value_peek_int(v)      (v)->data[0].v_int
+#define g_marshal_value_peek_uint(v)     (v)->data[0].v_uint
+#define g_marshal_value_peek_long(v)     (v)->data[0].v_long
+#define g_marshal_value_peek_ulong(v)    (v)->data[0].v_ulong
+#define g_marshal_value_peek_int64(v)    (v)->data[0].v_int64
+#define g_marshal_value_peek_uint64(v)   (v)->data[0].v_uint64
+#define g_marshal_value_peek_enum(v)     (v)->data[0].v_int
+#define g_marshal_value_peek_flags(v)    (v)->data[0].v_uint
+#define g_marshal_value_peek_float(v)    (v)->data[0].v_float
+#define g_marshal_value_peek_double(v)   (v)->data[0].v_double
+#define g_marshal_value_peek_string(v)   (v)->data[0].v_pointer
+#define g_marshal_value_peek_param(v)    (v)->data[0].v_pointer
+#define g_marshal_value_peek_boxed(v)    (v)->data[0].v_pointer
+#define g_marshal_value_peek_pointer(v)  (v)->data[0].v_pointer
+#define g_marshal_value_peek_object(v)   (v)->data[0].v_pointer
+#endif /* !G_ENABLE_DEBUG */
+
+
+/* NONE:INT,UINT (/dev/stdin:1) */
+void
+gtkmozembed_VOID__INT_UINT (GClosure     *closure,
+                            GValue       *return_value,
+                            guint         n_param_values,
+                            const GValue *param_values,
+                            gpointer      invocation_hint,
+                            gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__INT_UINT) (gpointer     data1,
+                                               gint         arg_1,
+                                               guint        arg_2,
+                                               gpointer     data2);
+  register GMarshalFunc_VOID__INT_UINT callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 3);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__INT_UINT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_int (param_values + 1),
+            g_marshal_value_peek_uint (param_values + 2),
+            data2);
+}
+
+/* NONE:POINTER,INT,INT (/dev/stdin:2) */
+void
+gtkmozembed_VOID__POINTER_INT_INT (GClosure     *closure,
+                                   GValue       *return_value,
+                                   guint         n_param_values,
+                                   const GValue *param_values,
+                                   gpointer      invocation_hint,
+                                   gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__POINTER_INT_INT) (gpointer     data1,
+                                                      gpointer     arg_1,
+                                                      gint         arg_2,
+                                                      gint         arg_3,
+                                                      gpointer     data2);
+  register GMarshalFunc_VOID__POINTER_INT_INT callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__POINTER_INT_INT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_pointer (param_values + 1),
+            g_marshal_value_peek_int (param_values + 2),
+            g_marshal_value_peek_int (param_values + 3),
+            data2);
+}
+
+/* NONE:POINTER,INT,UINT (/dev/stdin:3) */
+void
+gtkmozembed_VOID__POINTER_INT_UINT (GClosure     *closure,
+                                    GValue       *return_value,
+                                    guint         n_param_values,
+                                    const GValue *param_values,
+                                    gpointer      invocation_hint,
+                                    gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__POINTER_INT_UINT) (gpointer     data1,
+                                                       gpointer     arg_1,
+                                                       gint         arg_2,
+                                                       guint        arg_3,
+                                                       gpointer     data2);
+  register GMarshalFunc_VOID__POINTER_INT_UINT callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__POINTER_INT_UINT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_pointer (param_values + 1),
+            g_marshal_value_peek_int (param_values + 2),
+            g_marshal_value_peek_uint (param_values + 3),
+            data2);
+}
+
+/* NONE:POINTER,INT,POINTER (/dev/stdin:4) */
+void
+gtkmozembed_VOID__POINTER_INT_POINTER (GClosure     *closure,
+                                       GValue       *return_value,
+                                       guint         n_param_values,
+                                       const GValue *param_values,
+                                       gpointer      invocation_hint,
+                                       gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__POINTER_INT_POINTER) (gpointer     data1,
+                                                          gpointer     arg_1,
+                                                          gint         arg_2,
+                                                          gpointer     arg_3,
+                                                          gpointer     data2);
+  register GMarshalFunc_VOID__POINTER_INT_POINTER callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__POINTER_INT_POINTER) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_pointer (param_values + 1),
+            g_marshal_value_peek_int (param_values + 2),
+            g_marshal_value_peek_pointer (param_values + 3),
+            data2);
+}
+
diff -u -N mozilla/embedding/browser/gtk/src/gtkmozembedmarshal.h mold/embedding/browser/gtk/src/gtkmozembedmarshal.h
--- mozilla/embedding/browser/gtk/src/gtkmozembedmarshal.h	Thu Jan  1 01:00:00 1970
+++ mold/embedding/browser/gtk/src/gtkmozembedmarshal.h	Tue May 14 13:24:29 2002
@@ -0,0 +1,48 @@
+
+#ifndef __gtkmozembed_MARSHAL_H__
+#define __gtkmozembed_MARSHAL_H__
+
+#include	<glib-object.h>
+
+G_BEGIN_DECLS
+
+/* NONE:INT,UINT (/dev/stdin:1) */
+extern void gtkmozembed_VOID__INT_UINT (GClosure     *closure,
+                                        GValue       *return_value,
+                                        guint         n_param_values,
+                                        const GValue *param_values,
+                                        gpointer      invocation_hint,
+                                        gpointer      marshal_data);
+#define gtkmozembed_NONE__INT_UINT	gtkmozembed_VOID__INT_UINT
+
+/* NONE:POINTER,INT,INT (/dev/stdin:2) */
+extern void gtkmozembed_VOID__POINTER_INT_INT (GClosure     *closure,
+                                               GValue       *return_value,
+                                               guint         n_param_values,
+                                               const GValue *param_values,
+                                               gpointer      invocation_hint,
+                                               gpointer      marshal_data);
+#define gtkmozembed_NONE__POINTER_INT_INT	gtkmozembed_VOID__POINTER_INT_INT
+
+/* NONE:POINTER,INT,UINT (/dev/stdin:3) */
+extern void gtkmozembed_VOID__POINTER_INT_UINT (GClosure     *closure,
+                                                GValue       *return_value,
+                                                guint         n_param_values,
+                                                const GValue *param_values,
+                                                gpointer      invocation_hint,
+                                                gpointer      marshal_data);
+#define gtkmozembed_NONE__POINTER_INT_UINT	gtkmozembed_VOID__POINTER_INT_UINT
+
+/* NONE:POINTER,INT,POINTER (/dev/stdin:4) */
+extern void gtkmozembed_VOID__POINTER_INT_POINTER (GClosure     *closure,
+                                                   GValue       *return_value,
+                                                   guint         n_param_values,
+                                                   const GValue *param_values,
+                                                   gpointer      invocation_hint,
+                                                   gpointer      marshal_data);
+#define gtkmozembed_NONE__POINTER_INT_POINTER	gtkmozembed_VOID__POINTER_INT_POINTER
+
+G_END_DECLS
+
+#endif /* __gtkmozembed_MARSHAL_H__ */
+
diff -u -N mozilla/embedding/browser/gtk/src/gtkmozembedmarshal.txt mold/embedding/browser/gtk/src/gtkmozembedmarshal.txt
--- mozilla/embedding/browser/gtk/src/gtkmozembedmarshal.txt	Thu Jan  1 01:00:00 1970
+++ mold/embedding/browser/gtk/src/gtkmozembedmarshal.txt	Tue May 14 13:24:29 2002
@@ -0,0 +1,4 @@
+NONE:INT,UINT
+NONE:POINTER,INT,INT
+NONE:POINTER,INT,UINT
+NONE:POINTER,INT,POINTER
Common subdirectories: mozilla/widget/src/gtk2/.deps and mold/widget/src/gtk2/.deps
Common subdirectories: mozilla/widget/src/gtk2/CVS and mold/widget/src/gtk2/CVS
Only in mold/widget/src/gtk2/: keysym2ucs.o
Only in mold/widget/src/gtk2/: libwidget_gtk2.so
Only in mold/widget/src/gtk2/: mozcontainer.o
Only in mold/widget/src/gtk2/: mozdrawingarea.o
diff -u mozilla/widget/src/gtk2/nsAppShell.cpp mold/widget/src/gtk2/nsAppShell.cpp
--- mozilla/widget/src/gtk2/nsAppShell.cpp	Wed Apr 10 05:35:06 2002
+++ mold/widget/src/gtk2/nsAppShell.cpp	Tue May 14 10:41:23 2002
@@ -48,6 +48,10 @@
 static PLHashTable *sQueueHashTable = nsnull;
 static PLHashTable *sCountHashTable = nsnull;
 
+#ifdef PR_LOGGING
+PRLogModuleInfo *gWidgetLog = nsnull;
+#endif
+
 static gboolean event_processor_callback (GIOChannel *source,
 					  GIOCondition condition,
 					  gpointer data)
@@ -71,6 +75,11 @@
 nsAppShell::nsAppShell(void)
 {
   NS_INIT_REFCNT();
+
+#ifdef PR_LOGGING
+  if (!gWidgetLog)
+    gWidgetLog = PR_NewLogModule("Widget");
+#endif
 }
 
 nsAppShell::~nsAppShell(void)
Only in mold/widget/src/gtk2/: nsAppShell.o
Only in mold/widget/src/gtk2/: nsBidiKeyboard.o
diff -u mozilla/widget/src/gtk2/nsCommonWidget.cpp mold/widget/src/gtk2/nsCommonWidget.cpp
--- mozilla/widget/src/gtk2/nsCommonWidget.cpp	Wed Apr 10 05:35:07 2002
+++ mold/widget/src/gtk2/nsCommonWidget.cpp	Tue May 14 10:41:23 2002
@@ -36,10 +36,6 @@
 #include "nsCommonWidget.h"
 #include "nsGtkKeyUtils.h"
 
-#ifdef PR_LOGGING
-PRLogModuleInfo *gWidgetLog = nsnull;
-#endif
-
 nsCommonWidget::nsCommonWidget()
 {
   mIsTopLevel       = PR_FALSE;
@@ -52,12 +48,6 @@
 
   mPreferredWidth   = 0;
   mPreferredHeight  = 0;
-
-#ifdef PR_LOGGING
-  if (!gWidgetLog)
-    gWidgetLog = PR_NewLogModule("Widget");
-#endif
-
 }
 
 nsCommonWidget::~nsCommonWidget()
Only in mold/widget/src/gtk2/: nsCommonWidget.o
Only in mold/widget/src/gtk2/: nsGtkKeyUtils.o
Only in mold/widget/src/gtk2/: nsLookAndFeel.o
Only in mold/widget/src/gtk2/: nsScrollbar.o
Only in mold/widget/src/gtk2/: nsToolkit.o
Only in mold/widget/src/gtk2/: nsWidgetFactory.o
diff -u mozilla/widget/src/gtk2/nsWindow.cpp mold/widget/src/gtk2/nsWindow.cpp
--- mozilla/widget/src/gtk2/nsWindow.cpp	Wed Apr 10 05:35:08 2002
+++ mold/widget/src/gtk2/nsWindow.cpp	Tue May 14 10:41:23 2002
@@ -209,10 +209,13 @@
   if (mShell) {
     gtk_widget_destroy(mShell);
     mShell = nsnull;
+    mContainer = nsnull;
   }
-
-  mContainer = nsnull;
-
+  else if (mContainer) {
+    gtk_widget_destroy(GTK_WIDGET(mContainer));
+    mContainer = nsnull;
+  }
+  
   if (mDrawingarea) {
     g_object_unref(mDrawingarea);
     mDrawingarea = nsnull;
@@ -1183,21 +1186,24 @@
 
   // figure out our parent window
   MozDrawingarea *parentArea = nsnull;
-  MozContainer   *parentContainer = nsnull;
+  MozContainer   *parentMozContainer = nsnull;
+  GtkContainer   *parentGtkContainer = nsnull;
+  GdkWindow      *parentGdkWindow = nsnull;
   GtkWindow      *topLevelParent = nsnull;
-  if (aParent || aNativeParent) {
-    GdkWindow *parentWindow;
-    // get the drawing area and the container from the parent
-    if (aParent)
-      parentWindow = GDK_WINDOW(aParent->GetNativeData(NS_NATIVE_WINDOW));
-    else
-      parentWindow = GDK_WINDOW(aNativeParent);
 
+  if (aParent)
+    parentGdkWindow = GDK_WINDOW(aParent->GetNativeData(NS_NATIVE_WINDOW));
+  else if (aNativeParent && GDK_IS_WINDOW(aNativeParent))
+    parentGdkWindow = GDK_WINDOW(aNativeParent);
+  else if (aNativeParent && GTK_IS_CONTAINER(aNativeParent))
+    parentGtkContainer = GTK_CONTAINER(aNativeParent);
+
+  if (parentGdkWindow) {
     // find the mozarea on that window
     gpointer user_data = nsnull;
-    user_data = g_object_get_data(G_OBJECT(parentWindow), "mozdrawingarea");
+    user_data = g_object_get_data(G_OBJECT(parentGdkWindow), "mozdrawingarea");
     parentArea = MOZ_DRAWINGAREA(user_data);
-
+    
     NS_ASSERTION(parentArea, "no drawingarea for parent widget!\n");
     if (!parentArea)
       return NS_ERROR_FAILURE;
@@ -1210,15 +1216,15 @@
       return NS_ERROR_FAILURE;
 
     // XXX support generic containers here for embedding!
-    parentContainer = MOZ_CONTAINER(user_data);
-    NS_ASSERTION(parentContainer, "owning widget is not a mozcontainer!\n");
-    if (!parentContainer)
+    parentMozContainer = MOZ_CONTAINER(user_data);
+    NS_ASSERTION(parentMozContainer, "owning widget is not a mozcontainer!\n");
+    if (!parentMozContainer)
       return NS_ERROR_FAILURE;
 
     // get the toplevel window just in case someone needs to use it
     // for setting transients or whatever.
     topLevelParent =
-      GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(parentContainer)));
+      GTK_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(parentMozContainer)));
   }
 
   // ok, create our windows
@@ -1278,7 +1284,16 @@
     break;
   case eWindowType_child:
     {
-      mDrawingarea = moz_drawingarea_new(parentArea, parentContainer);
+      if (parentMozContainer) {
+	mDrawingarea = moz_drawingarea_new(parentArea, parentMozContainer);
+      }
+      else {
+	mContainer = MOZ_CONTAINER(moz_container_new());
+	gtk_container_add(parentGtkContainer, GTK_WIDGET(mContainer));
+	gtk_widget_realize(GTK_WIDGET(mContainer));
+
+	mDrawingarea = moz_drawingarea_new(nsnull, mContainer);
+      }
     }
     break;
   default:
@@ -1310,6 +1325,7 @@
     g_signal_connect(G_OBJECT(mShell), "delete_event",
 		     G_CALLBACK(delete_event_cb), NULL);
   }
+
   if (mContainer) {
     g_signal_connect_after(G_OBJECT(mContainer), "size_allocate",
 			   G_CALLBACK(size_allocate_cb), NULL);
@@ -1344,11 +1360,13 @@
     LOG(("\tmShell %p %p %lx\n", (void *)mShell, (void *)mShell->window,
 	 GDK_WINDOW_XWINDOW(mShell->window)));
   }
+
   if (mContainer) {
     LOG(("\tmContainer %p %p %lx\n", (void *)mContainer,
 	 (void *)GTK_WIDGET(mContainer)->window,
 	 GDK_WINDOW_XWINDOW(GTK_WIDGET(mContainer)->window)));
   }
+
   if (mDrawingarea) {
     LOG(("\tmDrawingarea %p %p %p %lx %lx\n", (void *)mDrawingarea,
 	 (void *)mDrawingarea->clip_window,
@@ -1372,8 +1390,17 @@
   // clear our resize flag
   mNeedsResize = PR_FALSE;
 
-  if (mIsTopLevel)
+  if (mIsTopLevel) {
     gtk_window_resize(GTK_WINDOW(mShell), aWidth, aHeight);
+  }
+  else if (mContainer) {
+    GtkAllocation allocation;
+    allocation.x = 0;
+    allocation.y = 0;
+    allocation.width = aWidth;
+    allocation.height = aHeight;
+    gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
+  }
   
   moz_drawingarea_resize (mDrawingarea, aWidth, aHeight);
 }
@@ -1404,6 +1431,15 @@
       moz_drawingarea_resize(mDrawingarea, aWidth, aHeight);
     }
   }
+  else if (mContainer) {
+    GtkAllocation allocation;
+    allocation.x = 0;
+    allocation.y = 0;
+    allocation.width = aWidth;
+    allocation.height = aHeight;
+    gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
+    moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
+  }
   else {
     moz_drawingarea_move_resize(mDrawingarea, aX, aY, aWidth, aHeight);
   }
@@ -1422,8 +1458,12 @@
       gtk_widget_show(mShell);
       
     }
+    else if (mContainer) {
+      moz_drawingarea_set_visibility(mDrawingarea, TRUE);
+      gtk_widget_show(GTK_WIDGET(mContainer));
+    }
     else {
-      moz_drawingarea_set_visibility(mDrawingarea, aAction);
+      moz_drawingarea_set_visibility(mDrawingarea, TRUE);
     }
   }
   else {
@@ -1431,7 +1471,11 @@
       gtk_widget_hide(GTK_WIDGET(mShell));
       gtk_widget_hide(GTK_WIDGET(mContainer));
     }
-    moz_drawingarea_set_visibility(mDrawingarea, aAction);
+    else if (mContainer) {
+      gtk_widget_hide(GTK_WIDGET(mContainer));
+      moz_drawingarea_set_visibility(mDrawingarea, FALSE);
+    }
+    moz_drawingarea_set_visibility(mDrawingarea, FALSE);
   }
 }
 
Only in mold/widget/src/gtk2/: nsWindow.o
Common subdirectories: a/xpinstall/packager/CVS and mozilla/xpinstall/packager/CVS
Only in mozilla/xpinstall/packager/: Makefile
Common subdirectories: a/xpinstall/packager/common and mozilla/xpinstall/packager/common
Common subdirectories: a/xpinstall/packager/mac and mozilla/xpinstall/packager/mac
diff -u a/xpinstall/packager/packages-unix mozilla/xpinstall/packager/packages-unix
--- a/xpinstall/packager/packages-unix	Tue May 14 22:02:24 2002
+++ mozilla/xpinstall/packager/packages-unix	Tue May 14 23:34:16 2002
@@ -173,7 +173,7 @@
 bin/components/webBrowser_core.xpt
 bin/components/libwallet.so
 bin/components/libwalletviewers.so
-bin/components/libwidget_gtk.so
+bin/components/libwidget_gtk2.so
 bin/components/libxpconnect.so
 bin/components/locale.xpt
 bin/components/mozbrwsr.xpt
Common subdirectories: a/xpinstall/packager/unix and mozilla/xpinstall/packager/unix
Common subdirectories: a/xpinstall/packager/windows and mozilla/xpinstall/packager/windows
