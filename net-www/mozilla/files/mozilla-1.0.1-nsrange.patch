--- mozilla/content/base/src/nsRange.h.nsrange	2002-07-10 07:10:09.000000000 +0200
+++ mozilla/content/base/src/nsRange.h	2002-08-27 17:18:47.000000000 +0200
@@ -209,6 +209,8 @@
   // the range spec after the removal of nodes within the range.
   static nsresult CollapseRangeAfterDelete(nsIDOMRange *aRange);
 
+  static PRInt32  GetNodeLength(nsIDOMNode *aNode);
+
   nsresult      DoSetRange(nsIDOMNode* aStartN, PRInt32 aStartOffset,
                              nsIDOMNode* aEndN, PRInt32 aEndOffset);
 
--- mozilla/content/base/src/nsRange.cpp.nsrange	2002-07-16 15:09:01.000000000 +0200
+++ mozilla/content/base/src/nsRange.cpp	2002-08-27 17:53:01.000000000 +0200
@@ -635,6 +635,33 @@
   return res;
 }
 
+// Get the length of aNode                                                      
+PRInt32 nsRange::GetNodeLength(nsIDOMNode *aNode)
+{
+  if (!aNode)
+    return 0;                                                                   
+
+  PRUint16 nodeType;
+  PRUint32 len = -1;
+  
+  aNode->GetNodeType(&nodeType);
+  if( (nodeType == nsIDOMNode::CDATA_SECTION_NODE) ||
+      (nodeType == nsIDOMNode::TEXT_NODE) )
+  {
+    nsCOMPtr<nsIDOMText> textText = do_QueryInterface(aNode);
+    if (textText)
+      textText->GetLength(&len);
+  }
+  else
+    {
+      nsCOMPtr<nsIDOMNodeList> childList;
+      nsresult res = aNode->GetChildNodes(getter_AddRefs(childList));
+      if (NS_SUCCEEDED(res) && childList)
+        childList->GetLength(&len);
+    }
+  return len;
+}
+
 // It's important that all setting of the range start/end points 
 // go through this function, which will do all the right voodoo
 // for content notification of range ownership.  
@@ -990,6 +990,10 @@
   if(IsDetached())
     return NS_ERROR_DOM_INVALID_STATE_ERR;
 
+  PRInt32 len = GetNodeLength(aParent);
+  if ( (aOffset < 0) || (len < 0) || (aOffset > len) )
+    return NS_ERROR_DOM_INDEX_SIZE_ERR;
+
   nsresult res;
   
   if (!aParent) return NS_ERROR_NULL_POINTER;
@@ -1020,6 +1051,7 @@
 
   if(IsDetached())
     return NS_ERROR_DOM_INVALID_STATE_ERR;
+
   if (nsnull == aSibling)// Not the correct one to throw, but spec doesn't say what is
     return NS_ERROR_DOM_NOT_OBJECT_ERR;
 
@@ -1157,6 +1189,10 @@
   if(IsDetached())
     return NS_ERROR_DOM_INVALID_STATE_ERR;
 
+  PRInt32 len = GetNodeLength(aParent);
+  if ( (aOffset < 0) || (len < 0) || (aOffset > len) )
+    return NS_ERROR_DOM_INDEX_SIZE_ERR;
+
   nsresult res;
   
   if (!aParent) return NS_ERROR_NULL_POINTER;
@@ -2229,23 +2265,9 @@
       this->InsertNode(aN);
 
     // re-define the range so that it contains the same content as it did before
-    tEndContainer->GetNodeType(&tEndNodeType);
-    if( (nsIDOMNode::CDATA_SECTION_NODE == tEndNodeType) ||
-       (nsIDOMNode::TEXT_NODE == tEndNodeType) )
-    {
-      nsCOMPtr<nsIDOMText> tEndContainerText = do_QueryInterface(tEndContainer);
-      PRUint32 tInt;
-      tEndContainerText->GetLength(&tInt);
-      tEndOffset = tInt;
-    }
-    else
-    {
-      nsCOMPtr<nsIDOMNodeList>tChildList;
-      res = tEndContainer->GetChildNodes(getter_AddRefs(tChildList));
-      PRUint32 tInt;
-      tChildList->GetLength(&tInt);
-      tEndOffset = tInt;
-    }
+    tEndOffset = GetNodeLength(tEndContainer);
+    if (tEndOffset == -1)  // failure code
+      return NS_ERROR_FAILURE;
     this->DoSetRange(tStartContainer, 0, tEndContainer, tEndOffset);
   }
   this->SelectNode(aN);
