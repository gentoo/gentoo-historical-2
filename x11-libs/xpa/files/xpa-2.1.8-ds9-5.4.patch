--- xpa-2.1.8.orig/configure.ac	2007-04-04 15:09:51.000000000 +0100
+++ xpa-2.1.8/configure.ac	2007-12-18 20:09:26.000000000 +0000
@@ -41,7 +41,7 @@
 
 AC_C_CONST
 
-AC_CHECK_FUNCS(strchr memcpy snprintf atexit)
+AC_CHECK_FUNCS(strchr memcpy snprintf atexit setenv posix_spawn)
 
 AC_CHECK_FUNC(connect)
 if test $ac_cv_func_connect = no; then
@@ -60,7 +60,7 @@
 AC_MSG_CHECKING(for threaded xpans)
 AC_ARG_ENABLE(threaded-xpans, [  --enable-threaded-xpans    build threaded xpans],
     [fun_ok=$enableval], [fun_ok=no])
-if test "$fun_ok" != "no"; then
+if test "$fun_ok" = "yes"; then
   AC_MSG_RESULT($fun_ok)
   AC_CHECK_LIB(pthread, pthread_create, have_pthread=yes)
   if test  x"${have_pthread}" = x"yes"; then
@@ -78,7 +78,7 @@
 AC_MSG_CHECKING(for shared library build)
 AC_ARG_ENABLE(shared, [  --enable-shared    build shared libraries],
     [fun_ok=$enableval], [fun_ok=no])
-if test "$fun_ok" != "no"; then
+if test "$fun_ok" = "yes"; then
   fpic="yes"
   DOSHARED=shlib
   AC_SUBST(DOSHARED)
@@ -93,8 +93,16 @@
 AC_SUBST(LLIB)
 AC_MSG_RESULT($fun_ok)
 
+AC_MSG_CHECKING(for request to use posix_spawn)
+AC_ARG_ENABLE(posix_spawn, [  --enable-posix_spawn    use posix_spawn() if available],
+    [fun_ok=$enableval], [fun_ok=no])
+AC_MSG_RESULT($fun_ok)
+if test "$fun_ok" = "yes"; then
+  AC_CHECK_FUNCS(posix_spawn)
+fi
+
 AC_PATH_XTRA
-if test x"${have_x}" != "xno"; then
+if test x"${have_x}" = "xyes"; then
     AC_DEFINE(HAVE_XT)
 fi
 
--- xpa-2.1.8.orig/launch.c	2006-01-27 16:51:02.000000000 +0000
+++ xpa-2.1.8/launch.c	2007-12-18 20:09:26.000000000 +0000
@@ -1,35 +1,9 @@
 /*
- *	Copyright (c) 1999-2003 Smithsonian Astrophysical Observatory
+ *	Copyright (c) 1999-2007 Smithsonian Astrophysical Observatory
  */
 
 #include <launch.h>
 
-#define LAUNCHARGS 1024
-
-/* we one of these must be defined ... */
-#if !defined(USE_PIPE) && !defined(USE_WAITPID)
-#define USE_PIPE 1
-#endif
-/* ... but not both */
-#if defined(USE_PIPE) && defined(USE_WAITPID)
-#error "USE_PIPE and USE_WAITPID are mutually exclusive"
-#endif
-
-#ifdef USE_WAITPID
-#define WAIT_TRIES  100
-#define WAIT_MSEC  5000
-#endif
-
-#ifndef WAIT_MSEC
-#define WAIT_MSEC  5000
-#endif
-
-static pid_t _launchpid=0;
-
-/* spawnvp seems to be broken on cygwin as of 1/06, so just use fork/exec */
-#if HAVE_CYGWIN
-#define HAVE_CYGWIN_USE_SPAWNVP 0
-#endif
 /*
  *----------------------------------------------------------------------------
  *
@@ -40,96 +14,104 @@
  *----------------------------------------------------------------------------
  */
 
-#if HAVE_CYGWIN||HAVE_MINGW32
+static pid_t pid=0;
 
+/* wait for child process to start, using waitpid() */
 #ifdef ANSI_FUNC
-static int launch_win32(char *cmdstring, int attach, char **stdfiles)
+static int launch_pipes(int *pipes, int flag)
 #else
-static int launch_win32(cmdstring, attach, stdfiles)
-     char *cmdstring;
-     int attach;
-     char **stdfiles;
+static int launch_pipes(pipes, flag)
+     int *pipes;
+     int flag;
 #endif
 {
-  int i, j;
-  int len;
-  int got;
-  int status;
-  char *argv[LAUNCHARGS+1];
-  char *path=NULL;
-  char *s=NULL, *t=NULL;
-  struct timeval tv;
-
-  /* for now, we can't support stdfiles */
-  if( stdfiles )
-    return(-1);
-
-  /* package up the arguments for new process */
-  t = (char *)xstrdup(cmdstring);
-  for(i=0, got=0, s=(char *)strtok(t, " \t"); s;
-      i++, s=(char *)strtok(NULL," \t")){
-    if( i < LAUNCHARGS ){ 
-      /* save argument */
-      argv[i] = xstrdup(s);
-      /* change back special char to spaces, if necessary */
-      len = strlen(argv[i]);
-      for(j=0; j<len; j++){
-	if( argv[i][j] == LAUNCH_SPACE){
-	  argv[i][j] = ' ';
-	}
-      }
-      argv[i+1] = NULL;
-      /* save program name */
-      if( i == 0 ) path = (char *)argv[i];
-      got++;
-    }
+  int i;
+  char tbuf[SZ_LINE];
+  if( pipes ){
+    for(i=0; i<4; i++){
+      pipes[i] = -1;
+    }
+    if( (pipe(&pipes[0]) < 0) || (pipe(&pipes[2]) < 0) ) return -1;
+    if( flag ){
+#if HAVE_SETENV
+      snprintf(tbuf, SZ_LINE-1, "%d,%d,%d,%d", 
+	       pipes[0], pipes[1], pipes[2], pipes[3]);
+      setenv("LAUNCH_PIPES", tbuf, 1);
+#else
+      snprintf(tbuf, SZ_LINE-1, "LAUNCH_PIPES=%d,%d,%d,%d", 
+	       pipes[0], pipes[1], pipes[2], pipes[3]);
+      putenv(xstrdup(tbuf));
+#endif
   }
-  if( t ) xfree(t);
-  if( attach )
-    i = _P_WAIT;
-  else
-    i = _P_NOWAIT;
-  if((status = spawnvp(i, path, (void *)argv)) != -1){
-    status = 0;
-    /* wait for child to start */
-    tv.tv_sec = 0;
-    tv.tv_usec = WAIT_MSEC;
-    xselect(1, NULL, NULL, NULL, &tv);
   }
-  for(i=0; i<got; i++)
-    if( argv[i] ) xfree((char *)argv[i]);
-  return(status);
+  return 0;
 }
 
+#ifdef ANSI_FUNC
+static int cleanup_pipes(int *pipes)
+#else
+static int cleanup_pipes(pipes)
+     int *pipes;
 #endif
+{
+  if( pipes ){
+    /* close child pipes */
+    close(pipes[1]);
+    close(pipes[2]);
+    /* move parent write into slot 1 */
+    pipes[1] = pipes[3];
+    /* set unused pipes to impossible value */
+    pipes[2] = -1;
+    pipes[3] = -1;
+  }
+  return 0;
+}
 
-/*
- *----------------------------------------------------------------------------
- *
- *
- * 			Public Routines and Data
- *
- *
- *----------------------------------------------------------------------------
- */
-
-/*
- *
- * launchpid() -- return pid of last  launched process 
- *
- */
+#if LAUNCH_USE_WAITPID
+/* wait for child process to start, using waitpid() */
 #ifdef ANSI_FUNC
-pid_t launchpid(void)
+static int launch_waitstart(pid_t pid)
 #else
-pid_t launchpid()
+static int launch_waitstart(pid)
+     pid_t pid;
 #endif
 {
-  return _launchpid;
+  int i, got;
+  int status=0;
+  struct timeval tv;
+  /* wait up to LAUNCH_WAIT_TRIES millisec to make sure the child started,
+     but if we get an error, we can exit immediately */
+  for(i=0; i<LAUNCH_WAIT_TRIES; i++){
+    errno = 0;
+    got=waitpid(pid, &status, WNOHANG);
+    /* look for error termination */
+    if( (got < 0) || ((got == 0) && xerrno) ){
+      got = -1;
+      /* make sure status shows error */
+      if( status == 0 )
+	status = -1;
+      break;
 }
-
-#if HAVE_MINGW32==0
+    /* look for normal termination */
+    else if( got > 0 ){
+      break;
+    }
+    /* no termination, sleep and wait some more */
+    else{
+      tv.tv_sec = 0;
+      tv.tv_usec = LAUNCH_WAIT_MSEC;
+      xselect(1, NULL, NULL, NULL, &tv);
+    }
+  }
+  /* no termination means the child is still running */
+  if( got == 0 ) status = 0;
+  /* return the news */
+  return status;
+}
+#endif
 
 /* 
+ *  standard unix version of launch:
  *  adapted from the system() code in:
  *  W. Richard Stevens
  *  "Advanced Programming in the Unix Environment" 
@@ -137,71 +119,86 @@
  *  p. 314
  */
 #ifdef ANSI_FUNC
-int launch(char *cmdstring, int attach, char **stdfiles)
+static int launch_fork_exec(char *cmdstring, int attach, 
+			    char **stdfiles, int *pipes)
 #else
-int launch(cmdstring, attach, stdfiles)
+  static int launch_fork_exec(cmdstring, attach, stdfiles, pipes)
      char *cmdstring;
      int attach;
      char **stdfiles;
+     int *pipes;
 #endif
 {
   int			status;
-  pid_t			pid;
+  int tpipes[4];
   struct sigaction	ignore, saveintr, savequit;
   sigset_t		chldmask, savemask;
-#ifdef USE_PIPE
+#if LAUNCH_USE_PIPE
   int			fd[2];
 #endif
 
   /* return false if no command is specified */
-  if( !cmdstring || !*cmdstring )
-    return(-1);
+  if( !cmdstring || !*cmdstring ) return -1;
 
   ignore.sa_handler = SIG_IGN;	/* ignore SIGINT and SIGQUIT */
   sigemptyset(&ignore.sa_mask);
   ignore.sa_flags = 0;
   if (sigaction(SIGINT, &ignore, &saveintr) < 0)
-    return(-1);
+    return -1;
   if (sigaction(SIGQUIT, &ignore, &savequit) < 0)
-    return(-1);
+    return -1;
   
   sigemptyset(&chldmask);	/* now block SIGCHLD */
   sigaddset(&chldmask, SIGCHLD);
   if (sigprocmask(SIG_BLOCK, &chldmask, &savemask) < 0)
-    return(-1);
+    return -1;
   
-#if HAVE_CYGWIN_USE_SPAWNVP
-  /* if we are on the Cygwin platform, use fork/exec only if we are
-     redirecting stdfiles. Otherwise use spawnvp(), which works better. */
-  if( stdfiles ){
-#endif
-
-#ifdef USE_PIPE
+#if LAUNCH_USE_PIPE
   /* open a pipe so parent can hear if the child fails to exec */
   if( !attach ){
     if( pipe(fd) < 0 )
-      return(-1);
+      return -1;
     xfcntl(fd[0], F_SETFD, FD_CLOEXEC);
     xfcntl(fd[1], F_SETFD, FD_CLOEXEC);
   }
 #endif
 
+  /* create temp ipc pipes if necessary */
+  if( pipes ){
+    if( launch_pipes(tpipes, 0) < 0 ) return -1;
+  }
+
   /* start new process */
   if( (pid = fork()) < 0 ){
-#ifdef USE_PIPE
+#if LAUNCH_USE_PIPE
     if( !attach ){
       close(fd[0]);
       close(fd[1]);
     }
 #endif
+    if( pipes ){
+      close(tpipes[0]);
+      close(tpipes[1]);
+      close(tpipes[2]);
+      close(tpipes[3]);
+    }
     status = -1;		/* ERROR: probably out of processes */
-
   } else if( pid == 0 ){	/* child */
     int i, j, len;
-    char *argv[LAUNCHARGS+1];
+    char *argv[LAUNCH_ARGS+1];
     char *path=NULL;
     char *s=NULL, *t=NULL;
 
+    /* reset pipes, if necessary */
+    if( pipes ){
+      /* close parent's read/write pipes */
+      close(tpipes[0]);
+      close(tpipes[3]);
+      /* change child's stdin/stdout to use the passed pipes to parent */
+      dup2(tpipes[2], 0);  close(tpipes[2]);
+      dup2(tpipes[1], 1);  close(tpipes[1]);
+    }
+
     /* close and reopen stdio files, if necessary */
     if( stdfiles ){
       for(i=0; i<3; i++){
@@ -241,7 +238,7 @@
       sigaction(SIGQUIT, &savequit, NULL);
       sigprocmask(SIG_SETMASK, &savemask, NULL);
     }
-#ifdef USE_PIPE
+#if LAUNCH_USE_PIPE
     /* child closes reader -- only writes status */
     else{
       close(fd[0]);
@@ -252,7 +249,7 @@
     t = (char *)xstrdup(cmdstring);
     for(i=0, s=(char *)strtok(t, " \t"); s;
 	i++, s=(char *)strtok(NULL," \t")){
-      if( i < LAUNCHARGS ){ 
+      if( i < LAUNCH_ARGS ){ 
 	/* save argument */
 	argv[i] = xstrdup(s);
 	/* change back special char to spaces, if necessary */
@@ -278,7 +275,7 @@
     /* start up the new program */
     if( execvp(path, argv) ){
       status = 127;
-#ifdef USE_PIPE
+#if LAUNCH_USE_PIPE
       if( !attach ){
 	write(fd[1], &status, 4);
 	close(fd[1]);
@@ -287,7 +284,6 @@
       _exit(status);		/* exec error */
     }
   } else {			/* parent */
-    _launchpid = pid;
     /* wait for program termination from attached process */
     if( attach ){
       while( waitpid(pid, &status, 0) < 0 ){
@@ -298,38 +294,10 @@
       }
     }
     else{
-#ifdef USE_WAITPID
-      int i, got;
-      struct timeval tv;
-      /* we wait up to WAIT_TRIES millisecs to make sure the child started;
-         but if we get an error, we can exit immediately */
-      for(i=0; i<WAIT_TRIES; i++){
-	errno = 0;
-	got=waitpid(pid, &status, WNOHANG);
-	/* look for error termination */
-	if( (got < 0) || ((got == 0) && xerrno) ){
-	  got = -1;
-	  /* make sure status shows error */
-	  if( status == 0 )
-	    status = -1;
-	  break;
-	}
-	/* look for normal termination */
-	else if( got > 0 ){
-	  break;
-	}
-	/* no termination, sleep and wait some more */
-	else{
-	  tv.tv_sec = 0;
-	  tv.tv_usec = WAIT_MSEC;
-	  xselect(1, NULL, NULL, NULL, &tv);
-	}
-      }
-      /* no termination means the child is still running */
-      if( got == 0 )
-	status = 0;
+#if LAUNCH_USE_WAITPID
+      status = launch_waitstart(pid);
 #endif
-#ifdef USE_PIPE
+#if LAUNCH_USE_PIPE
       close(fd[1]);
       if( read(fd[0], &status, 4) == 0 ){
 	status = 0;
@@ -339,37 +307,321 @@
     }
   }
   
-#if HAVE_CYGWIN_USE_SPAWNVP
+  /* cleanup temp ipc pipes and move into user space */
+  if( pipes ){
+    cleanup_pipes(tpipes);
+    pipes[0] = tpipes[0];
+    pipes[1] = tpipes[1];
+  }
+
+  /* restore previous signal actions & reset signal mask */
+  if( sigaction(SIGINT, &saveintr, NULL) < 0 )        return -1;
+  if( sigaction(SIGQUIT, &savequit, NULL) < 0 )       return -1;
+  if( sigprocmask(SIG_SETMASK, &savemask, NULL) < 0 ) return -1;
+  
+  /* return the news */
+  return status;
+}
+
+#if HAVE_POSIX_SPAWN
+
+extern char **environ;
+
+/* spawn calls POSIX posix_spawn */
+#ifdef ANSI_FUNC
+static int launch_posix_spawn(char *cmdstring, int attach, 
+			      char **stdfiles, int *pipes)
+#else
+  static int launch_posix_spawn(cmdstring, attach, stdfiles, pipes)
+     char *cmdstring;
+     int attach;
+     char **stdfiles;
+     int *pipes;
+#endif
+{
+  int i, j, len;
+  int status=0;
+  int got=0;
+  int tpipes[4];
+  char *argv[LAUNCH_ARGS+1];
+  char *path=NULL;
+  char *s=NULL, *t=NULL;
+  posix_spawn_file_actions_t act;
+  posix_spawn_file_actions_t *pact=NULL;
+
+  /* return false if no command is specified */
+  if( !cmdstring || !*cmdstring )
+    return -1;
+
+  /* create temp ipc pipes if necessary */
+  if( pipes ){
+    if( launch_pipes(tpipes, 1) < 0 ) return -1;
+  }
+
+  /* package up the arguments for new process */
+  t = (char *)xstrdup(cmdstring);
+  for(i=0, s=(char *)strtok(t, " \t"); s;
+      i++, s=(char *)strtok(NULL," \t")){
+    if( i < LAUNCH_ARGS ){ 
+      /* save argument */
+      argv[i] = xstrdup(s);
+      /* change back special char to spaces, if necessary */
+      len = strlen(argv[i]);
+      for(j=0; j<len; j++){
+	if( argv[i][j] == LAUNCH_SPACE){
+	  argv[i][j] = ' ';
+	}
+      }
+      /* last arg is always a NULL */
+      argv[i+1] = NULL;
+      /* save program name */
+      if( i == 0 ) path = argv[i];
+      /* inc arg count */
+      got++;
   }
-  /* for Cygwin, call their spawnvp() routine instead of fork()/exec() */
+  }
+  if( t ) xfree(t);
+  /* arrange stdfiles files, if necessary */
+  if( stdfiles ){
+    if( posix_spawn_file_actions_init(&act) != 0) 
+      return -1;
+    /* stdin */
+    if(stdfiles[0] && 
+       posix_spawn_file_actions_addopen(&act, 0, stdfiles[0], O_RDONLY, 0))
+      return -1;
+    /* stdout */
+    if(stdfiles[1] && 
+       posix_spawn_file_actions_addopen(&act, 1, stdfiles[1], O_CREAT|O_WRONLY|O_TRUNC, 0600))
+      return -1;
+    /* stderr */
+    if(stdfiles[2] && 
+       posix_spawn_file_actions_addopen(&act, 2, stdfiles[2], O_CREAT|O_WRONLY|O_TRUNC, 0600))
+      return -1;
+    pact = &act;
+  }
+  /* start the new process */
+  if( (status = posix_spawnp(&pid, path, pact, NULL, argv, environ)) )
+    return status;
+  /* wait for program termination from attached process */
+  if( attach ){
+    while( waitpid(pid, &status, 0) < 0 ){
+      if( xerrno != EINTR ){
+	status = -1; /* error other than EINTR from waitpid() */
+	break;
+      }
+    }
+  }
+#if BIG_DELAY_WHEN_USING_THIS
+  /* wait for child process to start */
   else{
-    status = launch_win32(cmdstring, attach, stdfiles);
+    status = launch_waitstart(pid);
+  }
+#endif
+  /* clean up */
+  if( stdfiles ) posix_spawn_file_actions_destroy(&act);
+  /* cleanup temp ipc pipes and move into user space */
+  if( pipes ){
+    cleanup_pipes(tpipes);
+    pipes[0] = tpipes[0];
+    pipes[1] = tpipes[1];
+  }
+  for(i=0; i<got; i++){
+    if( argv[i] ) xfree((char *)argv[i]);
+  }
+  /* return status */
+  return status;
   }
+
 #endif
 
-  /* restore previous signal actions & reset signal mask */
-  if( sigaction(SIGINT, &saveintr, NULL) < 0 )
-    return(-1);
-  if( sigaction(SIGQUIT, &savequit, NULL) < 0 )
-    return(-1);
-  if( sigprocmask(SIG_SETMASK, &savemask, NULL) < 0 )
-    return(-1);
+#if HAVE_SPAWNVP
+
+#ifdef ANSI_FUNC
+static int launch_spawnvp(char *cmdstring, int attach, 
+			  char **stdfiles, int *pipes)
+#else
+  static int launch_spawnvp(cmdstring, attach, stdfiles, pipes)
+     char *cmdstring;
+     int attach;
+     char **stdfiles;
+     int *pipes;
+#endif
+{
+  int i, j;
+  int len;
+  int got;
+  int status;
+  int tpipes[4];
+  char *argv[LAUNCH_ARGS+1];
+  char *path=NULL;
+  char *s=NULL, *t=NULL;
+  struct timeval tv;
+
+  /* return false if no command is specified */
+  if( !cmdstring || !*cmdstring ) return -1;
+
+  /* for now, we can't support stdfiles */
+  if( stdfiles ) return -1;
   
-  return(status);
+  /* create temp ipc pipes if necessary */
+  if( pipes ){
+    if( launch_pipes(tpipes, 1) < 0 ) return -1;
+  }
+
+  /* package up the arguments for new process */
+  t = (char *)xstrdup(cmdstring);
+  for(i=0, got=0, s=(char *)strtok(t, " \t"); s;
+      i++, s=(char *)strtok(NULL," \t")){
+    if( i < LAUNCH_ARGS ){ 
+      /* save argument */
+      argv[i] = xstrdup(s);
+      /* change back special char to spaces, if necessary */
+      len = strlen(argv[i]);
+      for(j=0; j<len; j++){
+	if( argv[i][j] == LAUNCH_SPACE){
+	  argv[i][j] = ' ';
+	}
 }
+      /* last arg is always a NULL */
+      argv[i+1] = NULL;
+      /* save program name */
+      if( i == 0 ) path = (char *)argv[i];
+      /* inc arg count */
+      got++;
+    }
+  }
+  if( t ) xfree(t);
+  if( attach )
+    i = _P_WAIT;
+  else
+    i = _P_NOWAIT;
+  if((status = spawnvp(i, path, (void *)argv)) != -1){
+    status = 0;
+    /* wait for child to start */
+    tv.tv_sec = 0;
+    tv.tv_usec = LAUNCH_WAIT_MSEC;
+    xselect(1, NULL, NULL, NULL, &tv);
+  }
+  /* clean up */
+  for(i=0; i<got; i++){
+    if( argv[i] ) xfree((char *)argv[i]);
+  }
+  /* cleanup temp ipc pipes and move into user space */
+  if( pipes ){
+    cleanup_pipes(tpipes);
+    pipes[0] = tpipes[0];
+    pipes[1] = tpipes[1];
+  }
+  return status;
+}
+
+#endif
 
+/*
+ *----------------------------------------------------------------------------
+ *
+ *
+ * 			Public Routines and Data
+ *
+ *
+ *----------------------------------------------------------------------------
+ */
+
+/*
+ *
+ * LaunchPid() -- return pid of last  launched process 
+ *
+ */
+#ifdef ANSI_FUNC
+pid_t LaunchPid(void)
 #else
+pid_t LaunchPid()
+#endif
+{
+  return pid;
+}
 
 #ifdef ANSI_FUNC
-int launch(char *cmdstring, int attach, char **stdfiles)
+int Launch(char *cmdstring, int attach, char **stdfiles, int *pipes)
 #else
-int launch(cmdstring, attach, stdfiles)
+int Launch(cmdstring, attach, stdfiles, piles)
      char *cmdstring;
      int attach;
      char **stdfiles;
+     int *pipes;
 #endif
 {
-  return launch_win32(cmdstring, attach, stdfiles);
+  static int which_launch=0;
+  static int which_debug=0;
+  char *s=NULL;
+
+  /* return false if no command is specified */
+  if( !cmdstring || !*cmdstring ) return -1;
+
+  /* sanity check: don't specify stdfiles and pipes simultaneously */
+  if( stdfiles && pipes ){
+    fprintf(stderr, 
+	    "ERROR: stdfiles and pipes are mutually exclusive in Launch()\n");
+    return -1;
 }
 
+  /* if pipes are specified, we don't attach */
+  if( pipes ) attach = 0;
+
+  /* determine launch method */
+  if( !which_launch ){
+    which_launch = LAUNCH_DEFAULT_WHICH;
+    if( (s=getenv("LAUNCH_ROUTINE")) ){
+      /* fork_exec */
+      if( !strncasecmp(s, "f", 1) ){
+	which_launch = 1;
+	if( *s == 'F' ) which_debug = 1;
+      }
+      /* posix_spawn */
+      else if( !strncasecmp(s, "p", 1) ){
+	which_launch = 2;
+	if( *s == 'P' ) which_debug = 1;
+      }
+      /* spawnvp */
+      else if( !strncasecmp(s, "s", 1) ){
+	which_launch = 3;
+	if( *s == 'S' ) which_debug = 1;
+      }
+      else if( *s == 'V' ) {
+	which_debug = 1;
+      }
+    }
+  }
+  /* call the correct launch method */
+  switch(which_launch){
+  case 1:
+    if( which_debug ) fprintf(stderr, "launch_fork_exec: %s\n", cmdstring);
+    return launch_fork_exec(cmdstring, attach, stdfiles, pipes);
+    break;
+  case 2:
+#if HAVE_POSIX_SPAWN
+    if( which_debug ) fprintf(stderr, "launch_posix_spawn: %s\n", cmdstring);
+    return launch_posix_spawn(cmdstring, attach, stdfiles, pipes);
+#else
+    fprintf(stderr, "ERROR: posix_spawn() not available on this host\n");
+    exit(1);
 #endif
+    break;
+  case 3:
+#if HAVE_SPAWNVP
+    if( which_debug ) fprintf(stderr, "launch_spawnvp: %s\n", cmdstring);
+    return launch_spawnvp(cmdstring, attach, stdfiles, pipes);
+#else
+    fprintf(stderr, "ERROR: spawnvp() not available on this host\n");
+    exit(1);
+#endif
+    break;
+  default:
+    if( which_debug ) fprintf(stderr, "launch_fork_exec: %s\n", cmdstring);
+    return launch_fork_exec(cmdstring, attach, stdfiles, pipes);
+    break;
+  }
+  /* can't happen */
+  return -1;
+}
+
--- xpa-2.1.8.orig/launch.h	2006-01-27 16:25:08.000000000 +0000
+++ xpa-2.1.8/launch.h	2007-12-18 20:09:26.000000000 +0000
@@ -30,17 +30,54 @@
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
+#if HAVE_POSIX_SPAWN
+#include <spawn.h>
+#endif
 #include <xport.h>
 #include <word.h>
 #include <xalloc.h>
 #include <prsetup.h>
 
+#define LAUNCH_ARGS 1024
+
 #define LAUNCH_SPACE '\001'
 
+/* for fork/exec, one of these is required to specify the technique to be used
+   by the parent when determining if the child started successfully */
+#if !defined(LAUNCH_USE_PIPE) && !defined(LAUNCH_USE_WAITPID)
+#define LAUNCH_USE_PIPE 1
+#endif
+/* ... but not both */
+#if defined(LAUNCH_USE_PIPE) && defined(LAUNCH_USE_WAITPID)
+#error "LAUNCH_USE_PIPE and LAUNCH_USE_WAITPID are mutually exclusive"
+#endif
+
+#ifndef LAUNCH_WAIT_TRIES
+#define LAUNCH_WAIT_TRIES  100
+#endif
+#ifndef LAUNCH_WAIT_MSEC
+#define LAUNCH_WAIT_MSEC  5000
+#endif
+
+#if HAVE_MINGW32|HAVE_CYGWIN
+#define HAVE_SPAWNVP 1
+#endif
+
+#if HAVE_MINGW32
+/* for now, ensure that MinGW utilizes spawnvp() */
+#define LAUNCH_DEFAULT_WHICH 3
+#elif HAVE_POSIX_SPAWN
+/* use posix_spawn if possible (required for OS X 10.5) */
+#define LAUNCH_DEFAULT_WHICH 2
+#else
+/* use our home-grown version */
+#define LAUNCH_DEFAULT_WHICH 1
+#endif
+
 _PRbeg
 
-int launch _PRx((char *cmdstring, int wait, char **stdfiles));
-pid_t launchpid _PRx((void));
+int Launch _PRx((char *cmdstring, int wait, char **stdfiles, int *pipes));
+pid_t LaunchPid _PRx((void));
 
 _PRend
 
--- xpa-2.1.8.orig/xpa.c	2007-03-21 16:29:18.000000000 +0000
+++ xpa-2.1.8/xpa.c	2007-12-18 20:09:26.000000000 +0000
@@ -684,7 +684,7 @@
   if((*nscmd != '\0') && ((mtype == XPA_UNIX) || LOCALIP(xnsip)) ){
     FPRINTF((stderr, "%sLaunching: %s\n", _sp, nscmd));
 #if USE_LAUNCH
-    if( launch(nscmd, 0, NULL) != 0 )
+    if( Launch(nscmd, 0, NULL, NULL) != 0 )
       goto nons;
 #else
     if( system(nscmd) != 0 )
--- xpa-2.1.8.orig/xpap.h	2006-01-27 16:13:28.000000000 +0000
+++ xpa-2.1.8/xpap.h	2007-12-18 20:09:26.000000000 +0000
@@ -15,7 +15,9 @@
 #endif
 
 /* avoid use of system -- its not secure */
+#if USE_SPAWN == 0
 #define USE_LAUNCH 1
+#endif
 
 #if HAVE_UNISTD_H
 #include <unistd.h>
