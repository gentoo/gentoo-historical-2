--- qt-x11-free-3.1.2/src-orig/kernel/qpsprinter.cpp	Mon Feb 24 17:30:09 2003
+++ qt-x11-free-3.1.2/src/kernel/qpsprinter.cpp	Tue Apr 29 04:25:46 2003
@@ -90,9 +90,18 @@
 #endif
 #endif
 
+#undef Q_PRINTER_USE_FREETYPE2
 #ifdef Q_WS_X11
 #include "qfontdata_p.h"
 extern bool qt_has_xft;
+#ifndef QT_NO_XFTFREETYPE
+#define Q_PRINTER_USE_FREETYPE2
+#endif
+#endif
+
+#ifdef Q_PRINTER_USE_FREETYPE2
+#include <ft2build.h>
+#include FT_OUTLINE_H
 #endif
 
 static bool qt_gen_epsf = FALSE;
@@ -2016,7 +2025,8 @@
 class QPSPrinterFontTTF
   : public QPSPrinterFontPrivate {
 public:
-  QPSPrinterFontTTF(const QFont &f, QByteArray& data);
+  QPSPrinterFontTTF(const QFont &f, QByteArray& data,
+                    const QString &extra_key = QString::null);
   virtual void    download(QTextStream& s, bool global);
    //  virtual ~QPSPrinterFontTTF();
 
@@ -2088,6 +2098,21 @@
 
   int indexToLocFormat;         /* short or long offsets */
 
+  int ttc_index;
+  int ttc_offset;
+  double mxx, mxy, myx, myy;
+  bool transform;
+
+#ifdef Q_PRINTER_USE_FREETYPE2
+  FT_Library  ftLibrary;
+  FT_Face     ftFace;
+  bool        isCFF;
+
+private:
+  bool open_freetype();
+  void close_freetype();
+  bool charprocLoad_ft(int charindex, charproc_data &cd, int metrics[5]);
+#endif // Q_PRINTER_USE_FREETYPE2
 };
 
 
@@ -2173,7 +2198,8 @@
 #endif
 
 
-QPSPrinterFontTTF::QPSPrinterFontTTF(const QFont &f, QByteArray& d)
+QPSPrinterFontTTF::QPSPrinterFontTTF(const QFont &f, QByteArray& d,
+                                     const QString &extra_key)
 {
   data = d;
   defective = FALSE;
@@ -2196,11 +2222,42 @@
 #endif
   offset_table = (unsigned char*) data.data(); /* first 12 bytes */
 
+  ttc_index = 0;
+  ttc_offset = 0;
+  
+
+  if ( d[0]=='t' && d[1]=='t' && d[2]=='c' && d[3]=='f' ) {
+    if ( !extra_key.isEmpty() ) {
+      int a = extra_key.find( "-I" ) + 2;
+      if ( a >= 2 ) {
+        int b = extra_key.find( "-", a );
+        if ( b > a )
+          ttc_index = extra_key.mid( a, b - a ).toInt();
+        else
+          ttc_index = extra_key.mid( a ).toInt();
+      }
+    }
+
+    if ( ttc_index >= (int)getULONG( offset_table + 8 ) ) {
+      defective = TRUE;
+      return;
+    }
+
+    ttc_offset = getULONG( offset_table + 12 + ttc_index * 4 );
+  }
+
   /* Determine how many directory entries there are. */
-  numTables = getUSHORT( offset_table + 4 );
+  numTables = getUSHORT( offset_table + ttc_offset + 4 );
 
   /* Extract information from the "Offset" table. */
-  TTVersion = getFixed( offset_table );
+  TTVersion = getFixed( offset_table + ttc_offset );
+
+#ifdef Q_PRINTER_USE_FREETYPE2
+  Fixed flag_OTTO = getFixed( (BYTE *)"OTTO" );
+
+  isCFF = ( TTVersion.whole    == flag_OTTO.whole &&
+            TTVersion.fraction == flag_OTTO.fraction );
+#endif // Q_PRINTER_USE_FREETYPE2
 
   /* Load the "head" table and extract information from it. */
   ptr = getTable("head");
@@ -2303,6 +2360,42 @@
   }
   numGlyphs = getUSHORT( maxp + 4 );
 //  qDebug("number of glyphs is %d", numGlyphs);
+
+  double matrix[4] = { 1.0, 0.0, 0.0, 1.0 };
+
+  if ( !extra_key.isEmpty() ) {
+    int a, b;
+    a = extra_key.find( "-M[" ) + 3;
+    if ( a >= 3 ) {
+      for ( int i = 0; i < 4; i++, a = b + 1 ) {
+        if ( i < 3 )
+          b = extra_key.find( ",", a );
+        else
+          b = extra_key.find( "]", a );
+        if ( b > a )
+          matrix[i] = extra_key.mid( a, b - a ).toDouble();
+        else
+          break;
+      }
+    }
+  }
+
+  mxx = matrix[0];
+  mxy = matrix[1];
+  myx = matrix[2];
+  myy = matrix[3];
+  transform = ( mxx != 1.0 || mxy != 0.0 || myx != 0.0 || myy != 1.0 );
+
+#ifdef Q_PRINTER_USE_FREETYPE2
+  ftLibrary = 0;
+  ftFace = 0;
+#endif // Q_PRINTER_USE_FREETYPE2
+
+  if ( transform ) {
+    addPsFontNameExtension( f, psname );
+    addPsFontNameExtension( f, FullName );
+  }
+
   replacementList = makePSFontNameList( f, psname );
   uni2glyphSetup();
 }
@@ -2352,6 +2445,10 @@
 
     if( target_type == 42 )
         s << "%%Creator: Converted from TrueType to type 42 by Qt\n";
+#ifdef Q_PRINTER_USE_FREETYPE2
+    else if ( isCFF )
+        s << "%%Creator: Converted from OpenType/CFF by Qt\n";
+#endif // Q_PRINTER_USE_FREETYPE2
     else
         s << "%%Creator: Converted from TrueType by Qt\n";
 
@@ -2375,7 +2472,7 @@
         s << "/_d{bind def}bind def\n";
         s << "/_m{moveto}_d\n";
         s << "/_l{lineto}_d\n";
-        s << "/_cl{closepath eofill}_d\n";
+        s << "/_cl{closepath fill}_d\n";
         s << "/_c{curveto}_d\n";
         s << "/_sc{7 -1 roll{setcachedevice}{pop pop pop pop pop pop}ifelse}_d\n";
         s << "/_e{exec}_d\n";
@@ -2388,6 +2485,10 @@
 
     if(target_type == 42)
         s << "/FontMatrix[1 0 0 1 0 0]def\n";
+    else if ( transform )
+        s << QString( "/FontMatrix[%1 %2 %3 %4 0 0]def\n" )
+             .arg( 0.001 * mxx, 0, 'f', 6 ).arg( 0.001 * myx, 0, 'f', 6 )
+             .arg( 0.001 * mxy, 0, 'f', 6 ).arg( 0.001 * myy, 0, 'f', 6 );
     else
         s << "/FontMatrix[.001 0 0 .001 0 0]def\n";
 
@@ -2489,7 +2590,6 @@
 
     // subsetting. We turn a char subset into a glyph subset
     // and we mark as used the base glyphs of used composite glyphs.
-
     bool glyphset[65536];
     for(int c=0; c < 65536; c++)
         glyphset[c] = FALSE;
@@ -2535,6 +2635,10 @@
 
     s << "end readonly def\n";
 
+#ifdef Q_PRINTER_USE_FREETYPE2
+    close_freetype();
+#endif // Q_PRINTER_USE_FREETYPE2
+
     // === trailer ===
 
     /* If we are generating a type 3 font, we need to provide */
@@ -2666,7 +2770,7 @@
     int x;
 
     /* We must search the table directory. */
-    ptr = offset_table + 12;
+    ptr = offset_table + ttc_offset + 12;
     x=0;
     while (x != numTables) {
         if( strncmp((const char *)ptr,name,4) == 0 ) {
@@ -2775,6 +2879,9 @@
       }
     }
   }
+
+  if (!glyph2uni[0xa0] && glyph2uni[0x20])
+    glyph2uni[0xa0] = glyph2uni[0x20];
 }
 
 USHORT QPSPrinterFontTTF::unicode_for_glyph(int glyphindex)
@@ -2996,7 +3103,7 @@
   int diff;
   int count;                    /* How many `important' tables did we find? */
 
-  BYTE* ptr = offset_table + 12; // original table directory
+  BYTE* ptr = offset_table + ttc_offset + 12; // original table directory
   ULONG nextoffset=0;
   count=0;
 
@@ -3037,7 +3144,7 @@
 
   /* Generate the offset table header */
   /* Start by copying the TrueType version number. */
-  ptr = offset_table;
+  ptr = offset_table + ttc_offset;
   for(int x=0; x < 4; x++)
     sfnts_pputBYTE( *(ptr++) , s, string_len, line_len, in_string );
 
@@ -3180,7 +3287,7 @@
 }
 
 /* Emmit a PostScript "curveto" command. */
-static void PSCurveto(FWord* xcoor, FWord* ycoor,
+static void PSConicto(FWord* xcoor, FWord* ycoor, FWord x0, FWord y0,
                       FWord x, FWord y, int s, int t, QTextStream& ts)
 {
   int N, i;
@@ -3188,8 +3295,8 @@
 
   N = t-s+2;
   for(i=0; i<N-1; i++) {
-    sx[0] = i==0?xcoor[s-1]:(xcoor[i+s]+xcoor[i+s-1])/2;
-    sy[0] = i==0?ycoor[s-1]:(ycoor[i+s]+ycoor[i+s-1])/2;
+    sx[0] = i==0?x0:(xcoor[i+s]+xcoor[i+s-1])/2;
+    sy[0] = i==0?y0:(ycoor[i+s]+ycoor[i+s-1])/2;
     sx[1] = xcoor[s+i];
     sy[1] = ycoor[s+i];
     sx[2] = i==N-2?x:(xcoor[s+i]+xcoor[s+i+1])/2;
@@ -3216,6 +3323,26 @@
   }
 }
 
+static void PSCubicto(FWord* xcoor, FWord* ycoor, FWord x, FWord y,
+                      int s, QTextStream& ts)
+{
+  xcoor += s;
+  ycoor += s;
+
+  ts << (int)xcoor[0];
+  ts << " ";
+  ts << (int)ycoor[0];
+  ts << " ";
+  ts << (int)xcoor[1];
+  ts << " ";
+  ts << (int)ycoor[1];
+  ts << " ";
+  ts << (int)x;
+  ts << " ";
+  ts << (int)y;
+  ts << " _c\n";
+}
+
 /* The PostScript bounding box. */
 /* Variables to hold the character data. */
 
@@ -3226,6 +3353,7 @@
 //void PSLineto(FWord x, FWord y, QTextStream& ts);
 //void PSCurveto(FWord x, FWord y, int s, int t, QTextStream& ts);
 
+#if 0
 //double area(FWord *x, FWord *y, int n);
 //int nextinctr(int co, int ci);
 //int nextoutctr(int co);
@@ -3338,17 +3466,20 @@
 
   return k;
 } /* end of nearout() */
+#endif
 
 
 /*
 ** We call this routine to emmit the PostScript code
 ** for the character we have loaded with load_char().
 */
-static void PSConvert(QTextStream& s, charproc_data* cd)
+static void PSConvert(QTextStream& s, charproc_data* cd, bool cubic)
 {
-  int i,j,k,fst,start_offpt;
+  int i,j,k,fst,end,start_offpt;
   int end_offpt=0;
+  FWord  x0, y0, x1, y1;
 
+#if 0
   cd->area_ctr = new double[cd->num_ctr];
   memset(cd->area_ctr, 0, (cd->num_ctr*sizeof(double)));
 
@@ -3375,6 +3506,7 @@
       cd->ctrset[2*i+1]=-1;
     }
   }
+#endif
 
   /* Step thru the coutours. */
   /* I believe that a contour is a detatched */
@@ -3382,45 +3514,76 @@
   i=j=k=0;
   while (i < cd->num_ctr ) {
     fst = j = (k==0) ? 0 : (cd->epts_ctr[k-1]+1);
+    end = cd->epts_ctr[k];
+
+    if (end - fst < 2) {
+      k++; i++;
+      continue;
+    }
 
     /* Move to the first point on the contour. */
+    if (cd->tt_flags[fst]&1) {
+      x0 = cd->xcoor[fst];
+      y0 = cd->ycoor[fst];
+    } else if (cd->tt_flags[end]&1) {
+      x0 = cd->xcoor[end];
+      y0 = cd->ycoor[end];
+      end--; j--;
+    } else {
+      x0 = (cd->xcoor[fst]+cd->xcoor[end])/2;
+      y0 = (cd->ycoor[fst]+cd->ycoor[end])/2;
+      j--;
+    }
+
     stack(cd->num_pts,3,s);
-    PSMoveto(cd->xcoor[j],cd->ycoor[j],s);
-    start_offpt = 0;            /* No off curve points yet. */
+    PSMoveto(x0,y0,s);
+    start_offpt = -1;            /* No off curve points yet. */
 
+    x1 = x0; y1 = y0;
     /* Step thru the remaining points of this contour. */
-    for(j++; j <= cd->epts_ctr[k]; j++) {
+    for(j++; j <= end; j++) {
       if (!(cd->tt_flags[j]&1)) { /* Off curve */
-        if (!start_offpt)
+        if (start_offpt < 0)
           { start_offpt = end_offpt = j; }
         else
           end_offpt++;
       } else {                  /* On Curve */
-        if (start_offpt) {
+        if (start_offpt >= 0) {
           stack(cd->num_pts,7,s);
-          PSCurveto(cd->xcoor,cd->ycoor,
-                    cd->xcoor[j],cd->ycoor[j],
-                    start_offpt,end_offpt,s);
-          start_offpt = 0;
+          if ( cubic )
+            PSCubicto(cd->xcoor,cd->ycoor,
+                      cd->xcoor[j],cd->ycoor[j],start_offpt,s);
+          else
+            PSConicto(cd->xcoor,cd->ycoor,
+                      x1, y1,
+                      cd->xcoor[j],cd->ycoor[j],
+                      start_offpt,end_offpt,s);
+          start_offpt = -1;
         } else {
           stack(cd->num_pts,3,s);
           PSLineto(cd->xcoor[j], cd->ycoor[j],s);
         }
+        x1 = cd->xcoor[j];
+        y1 = cd->ycoor[j];
       }
     }
 
     /* Do the final curve or line */
     /* of this coutour. */
-    if (start_offpt) {
+    if (start_offpt >= 0) {
       stack(cd->num_pts,7,s);
-      PSCurveto(cd->xcoor,cd->ycoor,
-                cd->xcoor[fst],cd->ycoor[fst],
-                start_offpt,end_offpt,s);
+      if ( cubic )
+        PSCubicto(cd->xcoor,cd->ycoor,x0,y0,start_offpt,s);
+      else
+        PSConicto(cd->xcoor,cd->ycoor,
+                  x1,y1,x0,y0,
+                  start_offpt,end_offpt,s);
     } else {
       stack(cd->num_pts,3,s);
-      PSLineto(cd->xcoor[fst],cd->ycoor[fst],s);
+      PSLineto(x0,y0,s);
     }
 
+#if 0
     k=nextinctr(i,k,cd);
 
     if (k==NOMOREINCTR)
@@ -3428,16 +3591,21 @@
 
     if (i==NOMOREOUTCTR)
       break;
+#else
+    k++; i++;
+#endif
   }
 
   /* Now, we can fill the whole thing. */
   stack(cd->num_pts,1,s);
-  s << "_cl";           /* "closepath eofill" */
+  s << "_cl";           /* "closepath fill" */
 
+#if 0
   /* Free our work arrays. */
   delete [] cd->area_ctr;
   delete [] cd->check_ctr;
   delete [] cd->ctrset;
+#endif // Q_TTF_CONTOURS_INOUT
 }
 
 
@@ -3722,6 +3890,11 @@
 */
 BYTE* QPSPrinterFontTTF::charprocFindGlyphData(int charindex)
 {
+#ifdef Q_PRINTER_USE_FREETYPE2
+  if ( isCFF )
+    return (BYTE*)NULL;
+#endif // Q_PRINTER_USE_FREETYPE2
+
   ULONG off;
   ULONG length;
 
@@ -3744,6 +3917,122 @@
     return (BYTE*)NULL;
 }
 
+#ifdef Q_PRINTER_USE_FREETYPE2
+bool QPSPrinterFontTTF::open_freetype()
+{
+  if ( !ftLibrary )
+  {
+    ftFace = 0;
+    if ( FT_Init_FreeType( &ftLibrary ) )
+      return FALSE;
+  }
+
+  if ( !ftFace )
+  {
+    if ( FT_New_Memory_Face( ftLibrary, (FT_Byte *)data.data(),
+                             data.size(), ttc_index, &ftFace ) )
+      goto Fail;
+    if ( FT_Select_Charmap( ftFace, ft_encoding_unicode ) )
+      goto Fail;
+    if ( FT_Set_Pixel_Sizes ( ftFace, 1000, 1000 ) )
+      goto Fail;
+  }
+
+  return TRUE;
+
+ Fail:
+  close_freetype();
+  return FALSE;
+}
+
+void QPSPrinterFontTTF::close_freetype()
+{
+  if ( ftLibrary )
+    FT_Done_FreeType( ftLibrary );
+  ftLibrary = 0;
+  ftFace = 0;
+}
+
+bool QPSPrinterFontTTF::charprocLoad_ft( int charindex,
+                                         charproc_data &cd, int metrics[5] )
+{
+  if ( !open_freetype() )
+    return FALSE;
+
+  if ( FT_Load_Glyph( ftFace, charindex,
+                      FT_LOAD_NO_BITMAP | FT_LOAD_IGNORE_TRANSFORM |
+                      FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ) )
+    return FALSE;
+
+  FT_GlyphSlot slot = ftFace->glyph;
+  FT_Outline *outline = &slot->outline;
+
+  int nctrs = outline->n_contours;
+  int npts = outline->n_points;
+  float scale = (float)unitsPerEm/1000;
+
+  cd.num_ctr = nctrs;
+  cd.num_pts = npts;
+  metrics[0] = (int)(slot->advance.x * scale / 64);
+
+  if ( nctrs == 0 )
+    return TRUE;
+
+  FT_Vector *pts = outline->points;
+  char *tags = outline->tags;
+  short *ctrs = outline->contours;
+
+  cd.xcoor = new FWord[npts];
+  cd.ycoor = new FWord[npts];
+  cd.tt_flags = new BYTE[npts];
+  cd.epts_ctr = new int[nctrs];
+
+  FWord *xcoor = cd.xcoor;
+  FWord *ycoor = cd.ycoor;
+  BYTE *flags = cd.tt_flags;
+
+  int x, y, xmin, ymin, xmax, ymax;
+  int n = 0, m;
+  bool bbox_valid = FALSE;
+  bool contour_valid;
+
+  xmin = ymin = xmax = ymax = 0;
+
+  for ( int i = 0 ; i < nctrs; i++ ) {
+    m = cd.epts_ctr[i] = ctrs[i];
+
+    contour_valid = (m >= n + 2);
+
+    if ( !bbox_valid && contour_valid ) {
+      xmin = xmax = pts->x >> 6;
+      ymin = ymax = pts->y >> 6;
+      bbox_valid = TRUE;
+    }
+
+    for ( ; n <= m; n++, pts++ ) {
+      *xcoor++ = x = pts->x >> 6;
+      *ycoor++ = y = pts->y >> 6;
+      *flags++ = (*tags++) & 3;
+      if ( contour_valid ) {
+        xmin = QMIN( xmin, x );
+        xmax = QMAX( xmax, x );
+        ymin = QMIN( ymin, y );
+        ymax = QMAX( ymax, y );
+      }
+    }
+  }
+
+  if ( bbox_valid ) {
+    metrics[1] = (int)(xmin * scale);
+    metrics[2] = (int)(ymin * scale);
+    metrics[3] = (int)(xmax * scale);
+    metrics[4] = (int)(ymax * scale);
+  }
+
+  return TRUE;
+}
+#endif // Q_PRINTER_USE_FREETYPE2
+
 void QPSPrinterFontTTF::charproc(int charindex, QTextStream& s, bool *glyphSet )
 {
   int llx,lly,urx,ury;
@@ -3759,6 +4048,18 @@
   /* Get a pointer to the data. */
   BYTE* glyph = charprocFindGlyphData( charindex );
 
+#ifdef Q_PRINTER_USE_FREETYPE2
+  int metrics[5] = { 0 };
+  if (charprocLoad_ft(charindex, cd, metrics)) {
+    advance_width = metrics[0];
+    llx = metrics[1];
+    lly = metrics[2];
+    urx = metrics[3];
+    ury = metrics[4];
+    goto Output;
+  }
+#endif // Q_PRINTER_USE_FREETYPE2
+
   /* If the character is blank, it has no bounding box, */
   /* otherwise read the bounding box. */
   if( glyph == (BYTE*)NULL ) {
@@ -3791,6 +4092,9 @@
   else
     advance_width = getuFWord( hmtx_table + ((numberOfHMetrics-1) * 4) );
 
+#ifdef Q_PRINTER_USE_FREETYPE2
+ Output:
+#endif // Q_PRINTER_USE_FREETYPE2
   /* Execute setcachedevice in order to inform the font machinery */
   /* of the character bounding box and advance width. */
   stack(cd.num_pts,7,s);
@@ -3808,7 +4112,7 @@
   /* If it is a simple glyph, convert it, */
   /* otherwise, close the stack business. */
   if( cd.num_ctr > 0 ) {        // simple
-    PSConvert(s,&cd);
+    PSConvert(s,&cd,isCFF);
     delete [] cd.tt_flags;
     delete [] cd.xcoor;
     delete [] cd.ycoor;
@@ -4664,6 +4968,7 @@
 {
     QString fontfilename;
     QString fontname;
+    QString extra_key = QString::null;
 
     enum { NONE, PFB, PFA, TTF } type = NONE;
 
@@ -4687,10 +4992,19 @@
 	    XftResult res;
 	    XftPattern *f = XftFontMatch(qt_xdisplay(), 0, pattern, &res);
 	    XftPatternGetString (f, XFT_FILE, 0, &filename);
+
+	    int font_index;
+	    if ( XftPatternGetInteger (f, XFT_INDEX, 0, &font_index) == XftResultMatch )
+		extra_key += QString("-I%1").arg(font_index);
+	    XftMatrix  *mat;
+	    if (XftPatternGetMatrix (f, XFT_MATRIX, 0, &mat) == XftResultMatch)
+		extra_key += QString("-M[%1,%2,%3,%4]")
+				.arg(mat->xx).arg(mat->xy).arg(mat->yx).arg(mat->yy);
+
 	    //qDebug("filename for font is '%s'", filename);
 	    if ( filename ) {
 		fontfilename = QString::fromLatin1( filename );
-		xfontname = fontfilename;
+		xfontname = fontfilename + extra_key;
 	    }
 	    XftPatternDestroy( f );
 	    XftPatternDestroy( pattern );
@@ -4786,12 +5100,38 @@
 			if (mapping.lower().contains(searchname.lower())) {
 			    int index = mapping.find(' ',0);
 			    QString ffn = mapping.mid(0,index);
+			    // skip ttcap
+			    int length = ffn.find(':',0) + 1;
+			    while (length > 0) {
+				ffn = ffn.mid(length);
+				length = ffn.find(':',0) + 1;
+			    }
 				// remove the most common bitmap formats
 			    if( !ffn.contains( ".pcf" ) && !ffn.contains( " .bdf" ) &&
 				!ffn.contains( ".spd" ) && !ffn.contains( ".phont" ) ) {
 				fontfilename = (*it) + QString("/") + ffn;
 				if ( QFile::exists(fontfilename) ) {
 				    //qDebug("found font file %s", fontfilename.latin1());
+				    // check font index
+				    index = mapping.find("fn=",0,FALSE) + 3;
+				    if (index >= 3) {
+					length = mapping.find(':', index) - index;
+					if (length > 0) {
+					    QString ttcap_fn = mapping.mid(index, length);
+					    int font_index = ttcap_fn.toInt();
+					    extra_key += QString("-I%1").arg(font_index);
+					}
+				    }
+				    // check slant
+				    index = mapping.find("ai=",0,FALSE) + 3;
+				    if (index >= 3) {
+					length = mapping.find(':', index) - index;
+					if (length > 0) {
+					    QString ttcap_ai = mapping.mid(index, length);
+					    double xy = ttcap_ai.toDouble();
+					    extra_key += QString("-M[1.0,%1,0.0,1.0]").arg(xy);
+					}
+				    }
 				    break;
 				} else // unset fontfilename
 				    fontfilename = QString();
@@ -4829,6 +5169,12 @@
             type = PFA;
         else if (d[0]==0x00 && d[1]==0x01 && d[2]==0x00 && d[3]==0x00)
             type = TTF;
+        else if (d[0]=='t' && d[1]=='t' && d[2]=='c' && d[3]=='f')
+            type = TTF;
+#ifdef Q_PRINTER_USE_FREETYPE2
+        else if (d[0]=='O' && d[1]=='T' && d[2]=='T' && d[3]=='O')
+            type = TTF;
+#endif // Q_PRINTER_USE_FREETYPE2
         else
             type = NONE;
     } else
@@ -4837,7 +5183,7 @@
         //qWarning(xfontname);
     switch (type) {
         case TTF :
-            p = new QPSPrinterFontTTF(f, data);
+            p = new QPSPrinterFontTTF(f, data, extra_key);
             break;
         case PFB:
             p = new QPSPrinterFontPFB(f, data);
