diff -urN bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/CompilationUnit.java bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/CompilationUnit.java
--- bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/CompilationUnit.java	2002-11-12 23:28:54.000000000 -0700
+++ bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/CompilationUnit.java	2004-07-07 21:12:16.131818792 -0600
@@ -74,7 +74,7 @@
  * of script is sliced into compilation units.
  * For instance, the script text may contain a function
  * declaration and an expression to eval. The compilation
- * will result in two compilation units: the function and 
+ * will result in two compilation units: the function and
  * the expression. Each compilation unit will correspond
  * to a range of the lines of the original script compiled.
  * All line numbers are global to the document the compiled
@@ -82,89 +82,95 @@
  * It is on compilation units that breakpoints can be set
  * or removed, more exactly on the DebuggableScript attached
  * to them. See Rhino for more details.
- * 
+ *
  * @author: Olivier Gruber.
- */ 
+ */
 public class CompilationUnit {
 
-	FnOrScript m_fnOrScript;
-	int m_firstLine;
-	int m_lineCount;
-	String m_fnName;
-	DebuggableScript m_dbgScript;
-	int m_validBrkptLines[];
-
-	/**
-	 * CompilationUnit constructor comment.
-	 */
-	public CompilationUnit(FnOrScript fnOrScript, DebuggableScript dbgScript) {
-
-		int lastLine, lineno;
-
-		m_fnOrScript = fnOrScript;
-		m_dbgScript = dbgScript;
-
-		try {
-			m_validBrkptLines = dbgScript.getLineNumbers();
-			m_firstLine = 99999;
-			lastLine = 0;
-			for (int l = 0; l < m_validBrkptLines.length; l++) {
-				lineno = m_validBrkptLines[l];
-				if (m_firstLine > lineno)
-					m_firstLine = lineno;
-				if (lastLine < lineno)
-					lastLine = lineno;
-			}
-			m_lineCount = lastLine - m_firstLine + 1;
-		} catch (Throwable t) {
-			DebugLog.stderrPrintln("\nWarning: can't get valid line numbers for breakpoints.", DebugLog.BSF_LOG_L2);
-			m_validBrkptLines = null;
-		}
-
-		Scriptable scriptable = dbgScript.getScriptable();
-		if (scriptable instanceof NativeFunction) {
-			NativeFunction f = (NativeFunction) scriptable;
-			String name = f.getFunctionName();
-			if (name.length() > 0 && !name.equals("anonymous")) {
-				m_fnName = name;
-			}
-		}
-	}
-	//----------------------------------------------------------
-	boolean contains(int lineno) {
-		return (m_firstLine <= lineno && lineno < m_firstLine + m_lineCount);
-	}
-	/**
-	 * Returns true if the compilation unit contains
-	 * the breakpoint. 
-	 * Notice only breakpoint defined at a line number
-	 * are supported here.
-	 */
-	boolean contains(BreakPoint bp) {
-		try {
-			return contains(bp.getLineNo());
-		} catch (BSFException ex) {
-			return false;
-		}
-	}
-	/**
-	 * Propagates (i.e. set) this breakpoint to the underlying Rhino
-	 * engine if Rhino has provided us with the valid lines
-	 * information. Otherwise, Rhino crashes with a NullPointerException.
-	 */
-	void propagate(int lineno) {
-		if (m_validBrkptLines != null) {
-			m_dbgScript.placeBreakpoint(lineno);
-		}
-	}
-	/**
-	 * Unpropagates (i.e. unset) this breakpoint to the underlying Rhino
-	 * engine if Rhino has provided us with the valid lines
-	 * information. Otherwise, Rhino crashes with a NullPointerException.
-	 */
-	void unpropagate(int lineno) {
-		if (m_validBrkptLines != null) {
-			m_dbgScript.removeBreakpoint(lineno);
-		}
-	}
+    FnOrScript m_fnOrScript;
+    int m_firstLine;
+    int m_lineCount;
+    String m_fnName;
+    DebuggableScript m_dbgScript;
+    boolean[] m_breakpoints;
+
+    /**
+     * CompilationUnit constructor comment.
+     */
+    public CompilationUnit(FnOrScript fnOrScript, DebuggableScript dbgScript) {
+
+        m_fnOrScript = fnOrScript;
+        m_dbgScript = dbgScript;
+
+        int[] lines = dbgScript.getLineNumbers();
+        if (lines.length != 0) {
+            int lastLine;
+            m_firstLine = lines[0];
+            lastLine = m_firstLine;
+            for (int i = 1; i != lines.length; ++i) {
+                int lineno = lines[i];
+                if (m_firstLine > lineno) {
+                    m_firstLine = lineno;
+                } else if (lastLine < lineno) {
+                    lastLine = lineno;
+                }
+            }
+            m_lineCount = lastLine - m_firstLine + 1;
+            m_breakpoints = new boolean[m_lineCount];
+        }
+
+        String name = dbgScript.getFunctionName();
+        if (name != null && name.length() != 0 && !name.equals("anonymous")) {
+            m_fnName = name;
+        }
+    }
+    //----------------------------------------------------------
+    boolean contains(int lineno) {
+        return (m_firstLine <= lineno && lineno < m_firstLine + m_lineCount);
+    }
+    /**
+     * Returns true if the compilation unit contains
+     * the breakpoint.
+     * Notice only breakpoint defined at a line number
+     * are supported here.
+     */
+    boolean contains(BreakPoint bp) {
+        try {
+            return contains(bp.getLineNo());
+        } catch (BSFException ex) {
+            return false;
+        }
+    }
+    /**
+     * Set a breakpoint at the given line if Rhino has provided us with the
+     * valid lines information.
+     */
+    void propagate(int lineno) {
+        if (m_breakpoints != null) {
+            int i = lineno - m_firstLine;
+            if (0 <= i && i < m_lineCount) {
+                m_breakpoints[i] = true;
+            }
+        }
+    }
+    /**
+     * Clear a breakpoint at the given line if Rhino has provided us with the
+     * valid lines information.
+     */
+    void unpropagate(int lineno) {
+        if (m_breakpoints != null) {
+            int i = lineno - m_firstLine;
+            if (0 <= i && i < m_lineCount) {
+                m_breakpoints[i] = false;
+            }
+        }
+    }
+
+    boolean hasBreakpoint(int lineno) {
+        if (m_breakpoints != null) {
+            int i = lineno - m_firstLine;
+            return 0 <= i && i < m_lineCount && m_breakpoints[i];
+        }
+        return false;
+    }
 }
diff -urN bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/FnOrScript.java bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/FnOrScript.java
--- bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/FnOrScript.java	2002-11-12 23:28:54.000000000 -0700
+++ bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/FnOrScript.java	2004-07-07 21:12:16.132818640 -0600
@@ -71,25 +71,25 @@
  * This class represents a function or script, that is,
  * a piece of a document that is provided to the JavaScript
  * engine for evaluation, execution, or simply compilation.
- * 
+ *
  * A FnOrScript represents a range of lines or characters
- * in its document. For now, Rhino only supports ranges 
+ * in its document. For now, Rhino only supports ranges
  * of lines, really, but the code for offsets is there anyway.
  *
  * Warning: Offsets have never been quite tested yet...
- * 
+ *
  * A FnOrScript has compilation units. When Rhino compiles
  * a function or a script, even in interpreted mode where the
  * compilation is done to JavaScript bytecode, it calls back
- * its debugger with different compilation units; see 
+ * its debugger with different compilation units; see
  * Debugger::handleCompilationDone method on the RhinoEngineDebugger
  * class.
  *
  * A FnOrScript also keeps track of the known breakpoints
  * in its range of lines or characters. It makes sure
- * that they are propagated to the underlying Rhino 
+ * that they are propagated to the underlying Rhino
  * engine (i.e. set) as well as unpropagated (i.e. unset).
- *  
+ *
  * @author: Olivier Gruber
  */
 public class FnOrScript {
@@ -103,9 +103,11 @@
 
     protected StringBuffer m_text;
 
-    protected Vector m_units; // of CompilationUnit.
     protected Script m_script;
 
+    private Vector m_units; // of CompilationUnit.
+    private Hashtable m_functionToUnit;
+
     protected Hashtable m_functionMap;
 
     public FnOrScript(DocumentCell cell) {
@@ -116,8 +118,9 @@
         m_lineCount = 0;
         m_breakpoints = new Vector();
         m_text = new StringBuffer();
-	
+
         m_units = new Vector();
+        m_functionToUnit = new Hashtable();
         m_functionMap = new Hashtable();
     }
 
@@ -131,7 +134,7 @@
 
         m_breakpoints.addElement(bp);
 
-        // now, look for a unit containing it and 
+        // now, look for a unit containing it and
         // if one is found, set the breakpoint unit
         // and propagate...
         Enumeration e;
@@ -147,7 +150,7 @@
         }
         return bp;
     }
-	
+
     private BreakPoint _removeBreakpoint(int brkptId) {
         Enumeration e;
         BreakPoint bp;
@@ -173,13 +176,13 @@
             bp = (BreakPoint) e.nextElement();
             if (bpid == bp.getId()) {
                 m_breakpoints.removeElement(bp);
-                bp.unpropagate();	
+                bp.unpropagate();
                 return bp;
             }
         }
         return null;
     }
-	
+
     boolean contains(BreakPoint bp) throws BSFException {
         if (m_lineDefined) {
             int line = bp.getLineNo();
@@ -194,7 +197,7 @@
     // This protected method works as a factory
     // for language-specific breakpoints.
     // The default behavior is to use the provided
-    // generic breakpoint. 
+    // generic breakpoint.
     // See javascript for an example of language-specific
     // breakpoints.
 
@@ -360,17 +363,18 @@
 
     public void addCompilationUnit(Context cx,
                                    DebuggableScript dbgScript,
-                                   StringBuffer source) {
+                                   String source) {
 
         CompilationUnit unit;
 
         unit = new CompilationUnit(this, dbgScript);
         m_units.addElement(unit);
+        m_functionToUnit.put(dbgScript, unit);
         if (unit.m_fnName != null) {
             m_functionMap.put(unit.m_fnName, unit);
         }
 
-        // Associate breakpoints to this unit if 
+        // Associate breakpoints to this unit if
         // the unit contains them...
         Enumeration e;
         BreakPoint bp;
@@ -383,13 +387,17 @@
         propagateAll();
     }
 
+    CompilationUnit getCompilationUnit(DebuggableScript dbgScript) {
+        return (CompilationUnit)m_functionToUnit.get(dbgScript);
+    }
+
     public void compile(Context cx, Scriptable global)
         throws BSFException, IOException {
 
         Enumeration e;
         Reader reader = new StringReader(m_text.toString());
         m_script =
-            cx.compileReader(global, reader, m_cell.getName(), 
+            cx.compileReader(global, reader, m_cell.getName(),
                              m_startLine, null);
         if (m_script == null)
             throw new BSFException("Compilation of the script "
diff -urN bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/JavaScriptEngine.java bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/JavaScriptEngine.java
--- bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/JavaScriptEngine.java	2002-11-12 23:28:54.000000000 -0700
+++ bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/JavaScriptEngine.java	2004-07-07 21:12:16.133818488 -0600
@@ -104,7 +104,7 @@
     public void disconnectedDebuggerNotify() {
         m_rhinoDbg.disconnectedDebuggerNotify();
     }
-	
+
     BSFDebugManagerImpl getDebugManager() {
         return dbgmgr;
     }
@@ -114,7 +114,7 @@
         m_rhinoDbg.placeBreakpointAtLine(brkptid, docname, lineno);
     }
 
-    public void placeBreakpointAtOffset(int brkptid, String docname, 
+    public void placeBreakpointAtOffset(int brkptid, String docname,
                                         int offset) throws BSFException {
         m_rhinoDbg.placeBreakpointAtOffset(brkptid, docname, offset);
     }
@@ -140,7 +140,6 @@
     public Object call(Object object, String method, Object[] args)
         throws BSFException {
         Object theReturnValue = null;
-        DebuggableEngine engine;
         Context cx;
         try {
 
@@ -160,13 +159,12 @@
 
                 cx.setOptimizationLevel(-1);
 
-                engine = cx.getDebuggableEngine();
-                engine.setDebugger(m_rhinoDbg);
+                cx.setDebugger(m_rhinoDbg, new RhinoContextProxy(m_rhinoDbg));
 
-                theReturnValue = ScriptRuntime.call(cx, fun, global, args, 
+                theReturnValue = ScriptRuntime.call(cx, fun, global, args,
                                                     null);
 
-            } 
+            }
             else {
                 cx.setOptimizationLevel(-1);
 
@@ -175,10 +173,9 @@
 
                 cx.setOptimizationLevel(0);
 
-                engine = cx.getDebuggableEngine();
-                engine.setDebugger(null);
+                cx.setDebugger(null, null);
 
-                theReturnValue = ScriptRuntime.call(cx, fun, global, args, 
+                theReturnValue = ScriptRuntime.call(cx, fun, global, args,
                                                     null);
             }
             if (theReturnValue instanceof Wrapper) {
@@ -193,9 +190,15 @@
     }
 
     public void declareBean(BSFDeclaredBean bean) throws BSFException {
-        // Must wrap non-scriptable objects before presenting to Rhino
-        Scriptable wrapped = Context.toObject(bean.bean, global);
-        global.put(bean.name, global, wrapped);
+        if ((bean.bean instanceof Number) ||
+            (bean.bean instanceof String) ||
+            (bean.bean instanceof Boolean)) {
+            global.put(bean.name, global, bean.bean);
+        } else {
+            // Must wrap non-scriptable objects before presenting to Rhino
+            Scriptable wrapped = Context.toObject(bean.bean, global);
+            global.put(bean.name, global, wrapped);
+        }
     }
 
     /**
@@ -210,7 +213,6 @@
         DocumentCell cell;
         FnOrScript fnOrScript;
         Script script;
-        DebuggableEngine engine;
         Context cx;
 
         try {
@@ -231,13 +233,7 @@
 
                 cx.setOptimizationLevel(-1);
 
-                engine = cx.getDebuggableEngine();
-                engine.setDebugger(m_rhinoDbg);
-
-                // Muck w/ this iff someone else hasn't already got it true
-                if (!engine.getBreakNextLine()) {
-                    engine.setBreakNextLine(cell.getEntryExit());
-                }
+                cx.setDebugger(m_rhinoDbg, new RhinoContextProxy(m_rhinoDbg));
 
                 fnOrScript.compile(cx, global);
                 m_rhinoDbg.setCompilingFnOrScript(null);
@@ -245,7 +241,7 @@
 
                 if (script != null) retval = script.exec(cx, global);
                 else retval = null;
-            } 
+            }
             else {
                 cx.setOptimizationLevel(-1);
 
@@ -254,11 +250,10 @@
 
                 cx.setOptimizationLevel(0);
 
-                engine = cx.getDebuggableEngine();
-                engine.setDebugger(null);
+                cx.setDebugger(null, null);
 
                 retval = cx.evaluateString(global, scriptText,
-                                           source, lineNo, 
+                                           source, lineNo,
                                            null);
             }
 
@@ -296,14 +291,14 @@
                 // Display its stack trace as a diagnostic
                 target = (Throwable) value;
             }
-        } 
-        else if (t instanceof EvaluatorException || 
+        }
+        else if (t instanceof EvaluatorException ||
                  t instanceof SecurityException) {
             message = t.getLocalizedMessage();
-        } 
+        }
         else if (t instanceof RuntimeException) {
             message = "Internal Error: " + t.toString();
-        } 
+        }
         else if (t instanceof StackOverflowError) {
             message = "Stack Overflow";
         }
@@ -313,7 +308,7 @@
         }
 
         //REMIND: can we recover the line number here?  I think
-        // Rhino does this by looking up the stack for bytecode 
+        // Rhino does this by looking up the stack for bytecode
         // see Context.getSourcePositionFromStack()
         // but I don't think this would work in interpreted mode
 
@@ -323,7 +318,7 @@
             // corrected the situation by aborting the loop and
             // a long stacktrace would end up on the user's console
             throw (Error) t;
-        } 
+        }
         else {
             throw new BSFException(BSFException.REASON_OTHER_ERROR,
                                    "JavaScript Error: " + message,
@@ -333,7 +328,7 @@
 
     /**
      * initialize the engine. put the manager into the context -> manager
-     * map hashtable too. 
+     * map hashtable too.
      */
     public void initialize(BSFManager mgr, String lang, Vector declaredBeans)
         throws BSFException {
diff -urN bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/JsContextStub.java bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/JsContextStub.java
--- bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/JsContextStub.java	2002-11-12 23:28:54.000000000 -0700
+++ bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/JsContextStub.java	2004-07-07 21:12:16.135818184 -0600
@@ -68,235 +68,267 @@
 * @author: Administrator
 */
 
-public class JsContextStub 
+public class JsContextStub
 extends org.apache.bsf.debug.util.Skeleton
    implements JsContext {
 
-	RhinoContextProxy m_rcp;
-	RhinoEngineDebugger m_rhinoDbg;
-	DebugFrame m_frame;
-	int m_frameno;
-	boolean m_atBreakpoint;
-	boolean m_invalid;
-
-	/**
-	 * JsContextStub constructor comment.
-	 */
-	public JsContextStub(RhinoContextProxy rcp, DebugFrame frame, int frameno)
-	throws RemoteException {
-			super(org.apache.bsf.debug.util.DebugConstants.JS_CONTEXT_TID);
-		
-		m_rhinoDbg = rcp.getRhinoEngineDebugger();
-		m_rcp = rcp;
-		m_frame = frame;
-		m_frameno = frameno;
-		m_invalid = false;
-		m_atBreakpoint = true;
-	}
-	//--------------------------------------------------
-	void atBreakpoint(boolean atbrkpt) {
-		m_atBreakpoint = atbrkpt;
-	}
-	public JsObject bind(String id) throws RemoteException {
-		try {
-			Context.enter();
-			Scriptable obj = m_frame.getVariableObject();
-			Object prop;
-			while (obj != null) {
-				Scriptable m = obj;
-				do {
-					if (m.has(id, obj))
-						return m_rhinoDbg.marshallScriptable(obj);
-					m = m.getPrototype();
-				} while (m != null);
-				obj = obj.getParentScope();
-			}
-			throw new JsdiException("Name not in scope.");
-		} finally {
-			Context.exit();
-		}
-	}
-	//--------------------------------------------------
-	public JsCode getCode() {
-		if (m_invalid)
-			throw new JsdiException("This context no longer exists.");
-		if (!m_atBreakpoint)
-			throw new JsdiException("Resumed context, can't get the code.");
-
-		try {
-			Context.enter();
-			return null;
-		} finally {
-			Context.exit();
-		}
-	}
-	public int getDepth() {
-		return m_frameno;
-	}
-	//--------------------------------------------------
-	public JsEngine getEngine() {
-		RhinoEngineDebugger redbg;
-		redbg = m_rcp.getRhinoEngineDebugger();
-		return (JsEngine) redbg.getDebugInterface(); 
-		
-	}
-	//--------------------------------------------------
-	public int getLineNumber() {
-		if (m_invalid)
-			throw new JsdiException("This context no longer exists.");
-		if (!m_atBreakpoint)
-			throw new JsdiException("Resumed context, can't get line number.");
-
-		try {
-			Context.enter();
-			return m_frame.getLineNumber();
-		} finally {
-			Context.exit();
-		}
-	}
-	//------------------------------------------------------  
-	public JsObject getScope() throws RemoteException {
-
-		if (m_invalid)
-			throw new JsdiException("This context no longer exists.");
-		if (!m_atBreakpoint)
-			throw new JsdiException("Resumed context, can't get line number.");
-
-		try {
-			Context.enter();
-			Scriptable varobj = m_frame.getVariableObject();
-			JsObject scope = m_rhinoDbg.marshallScriptable(varobj);
-			return scope;
-		} finally {
-			Context.exit();
-		}
-	}
-	//------------------------------------------------------  
-	public String getSourceName() {
-		if (m_invalid)
-			throw new JsdiException("This context no longer exists.");
-		if (!m_atBreakpoint)
-			throw new JsdiException("Resumed context, can't get line number.");
-
-		try {
-			Context.enter();
-			return m_frame.getSourceName();
-		} finally {
-			Context.exit();
-		}
-	}
-	//------------------------------------------------------  
-	public JsObject getThis() throws RemoteException {
-
-		if (m_invalid)
-			throw new JsdiException("This context no longer exists.");
-		if (!m_atBreakpoint)
-			throw new JsdiException("Resumed context, can't get line number.");
-
-		try {
-			Context.enter();
-			JsObject thisobj = null;
-			Scriptable obj = null;
-			NativeCall call = null;
-			Scriptable varobj = m_frame.getVariableObject();
-			if (varobj instanceof NativeCall) {
-				call = (NativeCall) varobj;
-				obj = call.getThisObj();
-				thisobj = m_rhinoDbg.marshallScriptable(varobj);
-			}
-			return thisobj;
-		} finally {
-			Context.exit();
-		}
-	}
-	//--------------------------------------------------
-	void invalidate() {
-		m_invalid = true;
-	}
-	//------------------------------------------------------  
-	public boolean isEvalContext() {
-		if (m_invalid)
-			throw new JsdiException("This context no longer exists.");
-		if (!m_atBreakpoint)
-			throw new JsdiException("Resumed context, can't get line number.");
-
-		try {
-			Context.enter();
-			return false;
-		} finally {
-			Context.exit();
-		}
-	}
-	//------------------------------------------------------  
-	public boolean isFunctionContext() {
-		if (m_invalid)
-			throw new JsdiException("This context no longer exists.");
-		if (!m_atBreakpoint)
-			throw new JsdiException("Resumed context, can't get line number.");
-
-		try {
-			Context.enter();
-			return false;
-		} finally {
-			Context.exit();
-		}
-	}
-	//------------------------------------------------------  
-	public boolean isScriptContext() {
-		if (m_invalid)
-			throw new JsdiException("This context no longer exists.");
-		if (!m_atBreakpoint)
-			throw new JsdiException("Resumed context, can't get line number.");
-		try {
-			Context.enter();
-			return true;
-		} finally {
-			Context.exit();
-		}
-	}
-	public Object lookupName(String name) {
-
-		try {
-			Context.enter();
-			Scriptable obj = m_frame.getVariableObject();
-			Object prop;
-			while (obj != null) {
-				Scriptable m = obj;
-				do {
-					Object result = m.get(name, obj);
-					if (result != Scriptable.NOT_FOUND)
-						return result;
-					m = m.getPrototype();
-				} while (m != null);
-				obj = obj.getParentScope();
-			}
-			throw new JsdiException("Name is not in scope.");
-		} finally {
-			Context.exit();
-		}
-	}
-	/**
-	 * Looks up a name in the scope chain and returns its value.
-	 */
-	public Object lookupName(Scriptable scopeChain, String id) {
-
-		try {
-			Context.enter();
-			Scriptable obj = scopeChain;
-			Object prop;
-			while (obj != null) {
-				Scriptable m = obj;
-				do {
-					Object result = m.get(id, obj);
-					if (result != Scriptable.NOT_FOUND)
-						return result;
-					m = m.getPrototype();
-				} while (m != null);
-				obj = obj.getParentScope();
-			}
-			return null;
-		} finally {
-			Context.exit();
-		}
-	}
+    RhinoContextProxy m_rcp;
+    RhinoEngineDebugger m_rhinoDbg;
+    int m_frameno;
+    int m_lineno;
+    boolean m_atBreakpoint;
+    boolean m_invalid;
+
+    CompilationUnit m_unit;
+    Scriptable m_variableObject;
+    Scriptable m_thisObj;
+
+    /**
+     * JsContextStub constructor comment.
+     */
+    JsContextStub(RhinoContextProxy rcp, CompilationUnit unit)
+    throws RemoteException {
+        super(org.apache.bsf.debug.util.DebugConstants.JS_CONTEXT_TID);
+
+        m_rhinoDbg = rcp.getRhinoEngineDebugger();
+        m_rcp = rcp;
+        m_unit = unit;
+        m_invalid = false;
+        m_atBreakpoint = true;
+    }
+
+    DebugFrame getRhinoDebugFrame() {
+        return new RhinoDebugFrame(this);
+    }
+
+    //--------------------------------------------------
+    void atBreakpoint(boolean atbrkpt) {
+        m_atBreakpoint = atbrkpt;
+    }
+    public JsObject bind(String id) throws RemoteException {
+        try {
+            Context.enter();
+            Scriptable obj = m_variableObject;
+            Object prop;
+            while (obj != null) {
+                Scriptable m = obj;
+                do {
+                    if (m.has(id, obj))
+                        return m_rhinoDbg.marshallScriptable(obj);
+                    m = m.getPrototype();
+                } while (m != null);
+                obj = obj.getParentScope();
+            }
+            throw new JsdiException("Name not in scope.");
+        } finally {
+            Context.exit();
+        }
+    }
+    //--------------------------------------------------
+    public JsCode getCode() {
+        if (m_invalid)
+            throw new JsdiException("This context no longer exists.");
+        if (!m_atBreakpoint)
+            throw new JsdiException("Resumed context, can't get the code.");
+
+        try {
+            Context.enter();
+            return null;
+        } finally {
+            Context.exit();
+        }
+    }
+    public int getDepth() {
+        return m_frameno;
+    }
+    //--------------------------------------------------
+    public JsEngine getEngine() {
+        RhinoEngineDebugger redbg;
+        redbg = m_rcp.getRhinoEngineDebugger();
+        return (JsEngine) redbg.getDebugInterface();
+
+    }
+    //--------------------------------------------------
+    public int getLineNumber() {
+        if (m_invalid)
+            throw new JsdiException("This context no longer exists.");
+        if (!m_atBreakpoint)
+            throw new JsdiException("Resumed context, can't get line number.");
+
+        return m_lineno;
+    }
+    //------------------------------------------------------
+    public JsObject getScope() throws RemoteException {
+
+        if (m_invalid)
+            throw new JsdiException("This context no longer exists.");
+        if (!m_atBreakpoint)
+            throw new JsdiException("Resumed context, can't get line number.");
+
+        try {
+            Context.enter();
+            JsObject scope = m_rhinoDbg.marshallScriptable(m_variableObject);
+            return scope;
+        } finally {
+            Context.exit();
+        }
+    }
+    //------------------------------------------------------
+    public String getSourceName() {
+        if (m_invalid)
+            throw new JsdiException("This context no longer exists.");
+        if (!m_atBreakpoint)
+            throw new JsdiException("Resumed context, can't get line number.");
+
+        return m_unit.m_dbgScript.getSourceName();
+    }
+    //------------------------------------------------------
+    public JsObject getThis() throws RemoteException {
+
+        if (m_invalid)
+            throw new JsdiException("This context no longer exists.");
+        if (!m_atBreakpoint)
+            throw new JsdiException("Resumed context, can't get line number.");
+
+        try {
+            Context.enter();
+            JsObject thisobj = null;
+            Scriptable obj = null;
+            NativeCall call = null;
+            Scriptable varobj = m_variableObject;
+            if (varobj instanceof NativeCall) {
+                call = (NativeCall) varobj;
+                obj = call.getThisObj();
+                thisobj = m_rhinoDbg.marshallScriptable(varobj);
+            }
+            return thisobj;
+        } finally {
+            Context.exit();
+        }
+    }
+    //--------------------------------------------------
+    void invalidate() {
+        m_invalid = true;
+    }
+    //------------------------------------------------------
+    public boolean isEvalContext() {
+        if (m_invalid)
+            throw new JsdiException("This context no longer exists.");
+        if (!m_atBreakpoint)
+            throw new JsdiException("Resumed context, can't get line number.");
+
+        try {
+            Context.enter();
+            return false;
+        } finally {
+            Context.exit();
+        }
+    }
+    //------------------------------------------------------
+    public boolean isFunctionContext() {
+        if (m_invalid)
+            throw new JsdiException("This context no longer exists.");
+        if (!m_atBreakpoint)
+            throw new JsdiException("Resumed context, can't get line number.");
+
+        try {
+            Context.enter();
+            return false;
+        } finally {
+            Context.exit();
+        }
+    }
+    //------------------------------------------------------
+    public boolean isScriptContext() {
+        if (m_invalid)
+            throw new JsdiException("This context no longer exists.");
+        if (!m_atBreakpoint)
+            throw new JsdiException("Resumed context, can't get line number.");
+        try {
+            Context.enter();
+            return true;
+        } finally {
+            Context.exit();
+        }
+    }
+    public Object lookupName(String name) {
+
+        try {
+            Context.enter();
+            Scriptable obj = m_variableObject;
+            Object prop;
+            while (obj != null) {
+                Scriptable m = obj;
+                do {
+                    Object result = m.get(name, obj);
+                    if (result != Scriptable.NOT_FOUND)
+                        return result;
+                    m = m.getPrototype();
+                } while (m != null);
+                obj = obj.getParentScope();
+            }
+            throw new JsdiException("Name is not in scope.");
+        } finally {
+            Context.exit();
+        }
+    }
+    /**
+     * Looks up a name in the scope chain and returns its value.
+     */
+    public Object lookupName(Scriptable scopeChain, String id) {
+
+        try {
+            Context.enter();
+            Scriptable obj = scopeChain;
+            Object prop;
+            while (obj != null) {
+                Scriptable m = obj;
+                do {
+                    Object result = m.get(id, obj);
+                    if (result != Scriptable.NOT_FOUND)
+                        return result;
+                    m = m.getPrototype();
+                } while (m != null);
+                obj = obj.getParentScope();
+            }
+            return null;
+        } finally {
+            Context.exit();
+        }
+    }
+}
+
+class RhinoDebugFrame implements DebugFrame {
+
+    JsContextStub m_stub;
+
+    RhinoDebugFrame(JsContextStub stub) {
+        m_stub = stub;
+    }
+
+    public void onEnter(Context cx, Scriptable activation,
+                        Scriptable thisObj, Object[] args)
+    {
+        m_stub.m_variableObject = activation;
+        m_stub.m_thisObj = thisObj;
+        m_stub.m_frameno = m_stub.m_rcp.m_frameStack.size();
+        m_stub.m_rcp.m_frameStack.push(m_stub);
+    }
+
+    public void onExit(Context cx, boolean byThrow, Object resultOrException)
+    {
+        m_stub.m_rcp.m_frameStack.pop();
+        m_stub.invalidate();
+    }
+
+    public void onExceptionThrown(Context cx, Throwable ex) {
+        m_stub.m_rcp.m_reDbg.handleExceptionThrown(cx, m_stub.m_rcp, ex);
+    }
+
+    public void onLineChange(Context cx, int lineNumber) {
+        m_stub.m_lineno = lineNumber;
+        if (m_stub.m_unit.hasBreakpoint(lineNumber)) {
+            m_stub.m_rcp.m_reDbg.handleBreakpointHit(cx, m_stub.m_rcp);
+        }
+    }
 }
diff -urN bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/JsEngineStub.java bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/JsEngineStub.java
--- bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/JsEngineStub.java	2002-11-12 23:28:54.000000000 -0700
+++ bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/JsEngineStub.java	2004-07-07 21:12:16.135818184 -0600
@@ -62,38 +62,37 @@
 import org.apache.bsf.debug.jsdi.*;
 import org.mozilla.javascript.Context;
 import org.mozilla.javascript.Script;
-import org.mozilla.javascript.debug.DebuggableEngine;
 
 /**
  * Insert the type's description here.
  * Creation date: (9/6/2001 1:21:46 PM)
  * @author: Administrator
  */
-public class JsEngineStub 
+public class JsEngineStub
     extends org.apache.bsf.debug.util.Skeleton
     implements JsEngine {
 
     RhinoEngineDebugger m_rhinoDbg;
     boolean m_inCallback;
     boolean m_resumeExecution;
-    Object  m_lock;	
-	
+    Object  m_lock;
+
     /**
      * JsEngineStub constructor comment.
      */
-    public JsEngineStub(RhinoEngineDebugger rhinoDbg) 
+    public JsEngineStub(RhinoEngineDebugger rhinoDbg)
         throws RemoteException {
         super(org.apache.bsf.debug.util.DebugConstants.JS_ENGINE_TID);
         m_rhinoDbg = rhinoDbg;
         m_lock = new Object();
     }
-	
+
     public boolean isSuspended() throws RemoteException {
         return m_inCallback;
     }
-	
+
     public boolean poll() { return true; }
-	
+
     public Object eval(String docname, String exp, int lineNo)
         throws RemoteException {
 
@@ -125,7 +124,7 @@
         try {
             Context.enter();
             count = m_rhinoDbg.getContextCount();
-            DebugLog.stdoutPrintln("	count = "+count, 
+            DebugLog.stdoutPrintln("    count = "+count,
                                    DebugLog.BSF_LOG_L3);
             return count;
         } finally {
@@ -133,7 +132,7 @@
         }
 
     }
-  
+
     public String getThread() throws RemoteException {
         return m_rhinoDbg.getThread();
     }
@@ -203,7 +202,7 @@
     public void stepIn() throws RemoteException {
         try {
             Context.enter();
-            DebugLog.stdoutPrintln("Step In command on "+this, 
+            DebugLog.stdoutPrintln("Step In command on "+this,
                                    DebugLog.BSF_LOG_L3);
             m_rhinoDbg.stepIn(this);
         } catch (Exception ex) {
@@ -225,7 +224,6 @@
     }
 
     public void stepOver() throws RemoteException {
-        RhinoContextProxy rcp;
         try {
             Context.enter();
             m_rhinoDbg.stepOver(this);
diff -urN bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/RhinoContextProxy.java bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/RhinoContextProxy.java
--- bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/RhinoContextProxy.java	2002-11-12 23:28:53.000000000 -0700
+++ bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/RhinoContextProxy.java	2004-07-07 21:12:16.136818032 -0600
@@ -70,133 +70,107 @@
 
 import java.rmi.RemoteException;
 
-public class RhinoContextProxy {
+class RhinoContextProxy {
 
     RhinoEngineDebugger m_reDbg;
-    Context m_context;
-    JsContextStub m_contextStub;
 
-    DebuggableEngine m_engine;
-
-    boolean m_atBreakpoint;
-    int m_frameCount;
-    JsContextStub m_frames[];
+    ObjArray m_frameStack = new ObjArray();
 
     private static final int NO_STEP = 0, STEP_IN = 1, STEP_OVER = 2,
         STEP_OUT = 3, STOP_ENGINE = 4, RUNNING = 5;
 
     private int m_stepCmd, m_stepDepth;
 
-    RhinoContextProxy(RhinoEngineDebugger reDbg, Context cx) {
+    RhinoContextProxy(RhinoEngineDebugger reDbg) {
         m_reDbg = reDbg;
-        m_context = cx;
-        m_engine = cx.getDebuggableEngine();
     }
 
-    public void cancelStepping() {
+    static RhinoContextProxy getCurrent() {
+        Context cx = Context.getCurrentContext();
+        if (cx == null) { return null; }
+        return (RhinoContextProxy)cx.getDebuggerContextData();
+    }
+
+    void cancelStepping() {
         m_stepCmd = NO_STEP;
         m_stepDepth = -1;
-        m_engine.setBreakNextLine(false);
     }
 
-    public JsContextStub getContext(int depth) {
-        return m_frames[depth];
+    int getContextCount() {
+        return m_frameStack.size();
     }
 
-    public int getContextCount() {
-        return m_frameCount;
+    JsContextStub getContextStub(int no) {
+        if (!(0 <= no && no < m_frameStack.size())) { return null; }
+        return (JsContextStub)m_frameStack.get(no);
     }
 
-    public JsContextStub getFrame(int no) {
-        if (no < 0 || no > m_frameCount)
-            return null;
-        if (no == m_frameCount)
-            return m_contextStub;
-        else
-            return m_frames[no];
+    JsContextStub getTopContextStub() {
+        return getContextStub(m_frameStack.size() - 1);
     }
 
-    public int getLineNumber() {
-        DebugFrame frame = m_engine.getFrame(0);
-
-        return frame.getLineNumber();
+    int getLineNumber() {
+        JsContextStub stub = getTopContextStub();
+        return stub.m_lineno;
     }
 
-    public RhinoEngineDebugger getRhinoEngineDebugger() {
+    RhinoEngineDebugger getRhinoEngineDebugger() {
         return m_reDbg;
     }
 
     String getSourceName() {
-        DebugFrame frame = m_engine.getFrame(0);
-
-        return frame.getSourceName();
+        JsContextStub stub = getTopContextStub();
+        return stub.m_unit.m_dbgScript.getSourceName();
     }
 
-
     // We hit a known breakpoint.
     // We need to update the stack.
     // Also, cancel any pending stepping operation.
-    public JsContextStub hitBreakpoint() throws RemoteException {
+    JsContextStub hitBreakpoint() throws RemoteException {
         cancelStepping();
-        updateStack();
-        return m_frames[0];
+        return getTopContextStub();
     }
 
-
-    public JsContextStub exceptionThrown() throws RemoteException {
+    JsContextStub exceptionThrown() throws RemoteException {
         cancelStepping();
-        updateStack();
-        return m_frames[0];
+        return getTopContextStub();
     }
 
-    public void resumed() {
-        JsContextStub stub;
-        DebugFrame frame;
-
-        m_atBreakpoint = false;
-
-        for (int f = 0; f < m_frameCount; f++) {
-            stub = m_frames[f];
-            stub.atBreakpoint(false);
+    void resumed() {
+        for (int f = 0, N = getContextCount(); f != N; ++f) {
+            getContextStub(f).atBreakpoint(false);
         }
     }
 
-    public void run() {
-        m_engine.setBreakNextLine(false);
+    void run() {
         m_stepCmd = RUNNING;
         m_stepDepth = -1;
-
     }
 
-    public void stepIn() {
-        m_engine.setBreakNextLine(true);
+    void stepIn() {
         m_stepCmd = STEP_IN;
-        m_stepDepth = m_frameCount;
+        m_stepDepth = getContextCount();
     }
 
-    public void stepOut() {
-        m_engine.setBreakNextLine(true);
+    void stepOut() {
         m_stepCmd = STEP_OUT;
-        m_stepDepth = m_frameCount;
-
+        m_stepDepth = getContextCount();
     }
 
-    public void stepOver() {
-        m_engine.setBreakNextLine(true);
+    void stepOver() {
         m_stepCmd = STEP_OVER;
-        m_stepDepth = m_frameCount;
+        m_stepDepth = getContextCount();
     }
 
-    public JsContextStub entry_exit_mode() throws RemoteException {
+    JsContextStub entry_exit_mode() throws RemoteException {
         cancelStepping();
-        updateStack();
-        return m_frames[0];
+        return getTopContextStub();
     }
 
-    public JsContextStub stepping() {
+    JsContextStub stepping() {
         // Did we hit a known breakpoint?
 
-        int frameCount = m_engine.getFrameCount();
+        int frameCount = getContextCount();
 
         try {
             switch (m_stepCmd) {
@@ -204,39 +178,31 @@
                 cancelStepping();
                 break;
             case STOP_ENGINE :
-                updateStack();
                 cancelStepping();
-                return m_frames[0];
+                return getTopContextStub();
             case STEP_IN :
-                // OG if ((frameCount == m_stepDepth + 1) || 
+                // OG if ((frameCount == m_stepDepth + 1) ||
                 // (frameCount == m_stepDepth)) {
                 // step if we are in the same frame (nothing to step in... :-)
                 // if we are in a called frame...
                 // but also if we stepped out of the current frame...
-                if ((frameCount >= m_stepDepth) 
-                    || (frameCount < m_stepDepth)) {
-                    updateStack();
                     cancelStepping();
-                    return m_frames[0];
-                }
-                break;
+                    return getTopContextStub();
             case STEP_OVER :
                 // OG if (frameCount == m_stepDepth) {
                 // step if we are in the same frame or above...
-                // this basically avoids any children frame but 
+                // this basically avoids any children frame but
                 // covers the return of the current frame.
                 if (frameCount <= m_stepDepth) {
-                    updateStack();
                     cancelStepping();
-                    return m_frames[0];
+                    return getTopContextStub();
                 }
                 break;
             case STEP_OUT :
                 // OG if (frameCount == m_stepDepth - 1) {
                 if (frameCount < m_stepDepth) {
-                    updateStack();
                     cancelStepping();
-                    return m_frames[0];
+                    return getTopContextStub();
                 }
                 break;
             default :
@@ -249,55 +215,8 @@
         return null;
     }
 
-    public void stopEngine() {
-        m_engine.setBreakNextLine(true);
+    void stopEngine() {
         m_stepCmd = STOP_ENGINE;
         m_stepDepth = -1;
     }
-
-    public void updateStack() throws RemoteException {
-        JsContextStub frames[];
-        JsContextStub stub;
-        DebugFrame frame;
-        int nf, of, frameCount;
-
-        m_atBreakpoint = true;
-
-        frameCount = m_engine.getFrameCount();
-        frames = new JsContextStub[frameCount];
-
-        // scan the stacks from the outer frame down
-        // to the inner one of the shortest of the old
-        // and the new known stack.
-        // The goal is to recognize the DebugFrame objects
-        // that are the sames so that we can reuse the 
-        // stubs for those. 
-        // As soon as a DebugFrame object is found different,
-        // the rest of the stack is different, all the old
-        // stubs can be dropped and invalidated, new ones
-        // must be created.
-
-        for (nf = frameCount - 1, of = m_frameCount - 1;
-             nf >= 0 && of >= 0;
-             nf--, of--) {
-            frame = m_engine.getFrame(nf);
-            if (frame == m_frames[of].m_frame) {
-                frames[nf] = m_frames[of];
-            } else
-                break;
-        }
-        // now drop all old frames that diverged.
-        // Also invalidate the frame stubs so to
-        // tracked that they are no longer valid.
-        for (; of >= 0; of--) {
-            m_reDbg.dropStub(m_frames[of].m_frame);
-            m_frames[of].invalidate();
-        }
-        for (; nf >= 0; nf--) {
-            frame = m_engine.getFrame(nf);
-            frames[nf] = new JsContextStub(this, frame, nf);
-        }
-        m_frames = frames;
-        m_frameCount = frameCount;
-    }
 }
diff -urN bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/RhinoEngineDebugger.java bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/RhinoEngineDebugger.java
--- bsf-2.3.0/src/bsf/src/org/apache/bsf/engines/javascript/RhinoEngineDebugger.java	2002-11-12 23:28:55.000000000 -0700
+++ bsf-2.3.0.patched/src/bsf/src/org/apache/bsf/engines/javascript/RhinoEngineDebugger.java	2004-07-07 21:12:16.138817728 -0600
@@ -74,24 +74,23 @@
 import org.apache.bsf.debug.*;
 import org.apache.bsf.debug.jsdi.*;
 
-public class RhinoEngineDebugger implements Debugger {
+class RhinoEngineDebugger implements Debugger {
 
     /** The global script object, where all embedded functions are defined,
      * as well as the standard ECMA "core" objects.
-     */	
+     */
     private Scriptable global;
     private JsObject globalstub;
 
-    private RhinoContextProxy m_rcp;
     private Scriptable undefined;
     private JsObject undefinedStub;
 
-    /** 
+    /**
      *  Hashtable allowing to find the stub for an object in the JavaScript
      *  environment if one exists.
      *  Typically: Scriptable, Function, Script, etc.
      *  This is not used for Context and DebugFrame.
-     *  They typically contains JsObject associated to 
+     *  They typically contains JsObject associated to
      *  org.mozilla.javascript.ScriptableObject
      */
     private Hashtable stubs;
@@ -102,16 +101,13 @@
     private FnOrScript m_compilingFnOrScript;
     private JavaScriptEngine m_eng;
 
-    private Thread m_thread;
-
     private Hashtable m_documents;
 
     BSFDebugManagerImpl dbgmgr;
 
-    public RhinoEngineDebugger(JavaScriptEngine eng) 
+    RhinoEngineDebugger(JavaScriptEngine eng)
         throws RemoteException {
         super();
-        m_thread = Thread.currentThread();
         m_eng = eng;
         dbgmgr = eng.getDebugManager();
 
@@ -127,45 +123,37 @@
     /**
      * Called when our debugger has been disconnected.
      */
-    public void disconnectedDebuggerNotify() {
+    void disconnectedDebuggerNotify() {
         m_callbacks = null;
     }
 
-    void addStub(Context cx, RhinoContextProxy jscx) {
-        stubs.put(cx, jscx);
-    }
-
-    void addStub(DebugFrame frame, JsContextStub stub) {
-        stubs.put(frame, stub);
-    }
-
     void addStub(Scriptable sobj, JsObject jsobj) {
         stubs.put(sobj, jsobj);
     }
 
-    void dropStub(Object key) {
+    void dropStub(Scriptable key) {
         stubs.remove(key);
     }
 
-    public synchronized DocumentCell getDocumentCell(String name) {
+    synchronized DocumentCell getDocumentCell(String name) {
         return (DocumentCell) m_documents.get(name);
     }
 
     // Called upon creation of a BSFManager.
-    public synchronized DocumentCell loadDocumentNotify(String name) {
+    synchronized DocumentCell loadDocumentNotify(String name) {
         DocumentCell cell;
 
         cell = (DocumentCell) m_documents.get(name);
         if (cell == null) {
             cell = new DocumentCell(this, name);
             m_documents.put(name, cell);
-            if (dbgmgr!=null) 
+            if (dbgmgr!=null)
                 dbgmgr.loadDocumentNotify(m_eng, name);
         }
         return cell;
     }
 
-    public synchronized void placeBreakpointAtLine(int brkptid,
+    synchronized void placeBreakpointAtLine(int brkptid,
                                                    String docname,
                                                    int lineno) {
 
@@ -174,7 +162,7 @@
         cell.addBreakpointAtLine(brkptid, lineno);
     }
 
-    public synchronized void placeBreakpointAtOffset(int brkptid,
+    synchronized void placeBreakpointAtOffset(int brkptid,
                                                      String docname,
                                                      int offset) {
 
@@ -183,7 +171,7 @@
         cell.addBreakpointAtOffset(brkptid, offset);
     }
 
-    public void removeBreakpoint(String docname, int brkptid)
+    void removeBreakpoint(String docname, int brkptid)
         throws BSFException {
 
         DocumentCell cell;
@@ -191,7 +179,7 @@
         cell.removeBreakpoint(brkptid);
     }
 
-    public void setEntryExit(String docname, boolean on)
+    void setEntryExit(String docname, boolean on)
         throws BSFException {
 
         DocumentCell cell;
@@ -199,7 +187,7 @@
         cell.setEntryExit(on);
     }
 
-    public Object eval(String docname, String fnOrScript, int lineno)
+    Object eval(String docname, String fnOrScript, int lineno)
         throws RemoteException {
         Object retval;
         try {
@@ -210,13 +198,15 @@
         }
     }
 
-    public JsContext getContext(int depth) {
-        if (m_rcp != null) return m_rcp.getContext(depth);
+    JsContext getContext(int depth) {
+        RhinoContextProxy rcp = RhinoContextProxy.getCurrent();
+        if (rcp != null) return rcp.getContextStub(depth);
         return null;
     }
 
-    public int getContextCount() {
-        if (m_rcp != null) return m_rcp.getContextCount();
+    int getContextCount() {
+        RhinoContextProxy rcp = RhinoContextProxy.getCurrent();
+        if (rcp != null) return rcp.getContextCount();
         return -1;
     }
 
@@ -224,24 +214,20 @@
      * Return the current debugger.
      * @return the debugger, or null if none is attached.
      */
-    public JsCallbacks getDebugger() {
+    JsCallbacks getDebugger() {
         return m_callbacks;
     }
 
-    public Object getDebugInterface() {
+    Object getDebugInterface() {
         return engineStub;
     }
 
-    public JsObject getGlobalObject() {
+    JsObject getGlobalObject() {
         return globalstub;
     }
 
-    public RhinoContextProxy getRhinoContextProxy() {
-        return m_rcp;
-    }
-
     RhinoContextProxy getStub(Context cx) {
-        return (RhinoContextProxy) stubs.get(cx);
+        return (RhinoContextProxy)cx.getDebuggerContextData();
     }
 
     JsContextStub getStub(DebugFrame frame) {
@@ -252,19 +238,20 @@
         return (JsObject) stubs.get(sobj);
     }
 
-    public JsObject getUndefinedValue() {
+    JsObject getUndefinedValue() {
         return undefinedStub;
     }
 
-    public String getThread() {
+    String getThread() {
+        Context cx = Context.getCurrentContext();
         String resultstr = "";
 
-        if (m_thread != null) {
+        if (cx != null) {
             try {
                 final String resultstrf = (String)
                 AccessController.doPrivileged(new PrivilegedExceptionAction() {
                         public Object run() throws Exception {
-                            return m_thread.getName();
+                            return Thread.currentThread().getName();
                         }
                     });
             resultstr = resultstrf;
@@ -277,15 +264,17 @@
         return resultstr;
     }
 
-    public String getThreadGroup() {
+    String getThreadGroup() {
+        Context cx = Context.getCurrentContext();
         String resultstr = "";
 
-        if (m_thread != null) {
+        if (cx != null) {
             try {
                 final String resultstrf = (String)
                 AccessController.doPrivileged(new PrivilegedExceptionAction() {
                         public Object run() throws Exception {
-                            return m_thread.getThreadGroup().getName();
+                            return Thread.currentThread().getThreadGroup().
+                                        getName();
                         }
                     });
             resultstr = resultstrf;
@@ -305,7 +294,7 @@
     // to implement STEP_IN, STEP_OUT, and STEP_OVER.
     //---------------------------------------------------------
 
-    public void handleBreakpointHit(Context cx) {
+    void handleBreakpointHit(Context cx, RhinoContextProxy rcp) {
         JsCallbacks debugger;
         BreakPoint bp;
         Enumeration e;
@@ -313,48 +302,41 @@
         boolean breakpointFound=false;
         String name;
         int lineno;
-        boolean suspend=false;
-		
-        m_thread = Thread.currentThread();
-        DebugLog.stdoutPrintln("**** Handling a breakpoint hit...", 
+
+        DebugLog.stdoutPrintln("**** Handling a breakpoint hit...",
                                DebugLog.BSF_LOG_L3);
-        m_rcp = getStub(cx);
-        if (m_rcp == null) {
-            m_rcp = new RhinoContextProxy(this, cx);
-            addStub(cx, m_rcp);
-        }
-        // if we have no callbacks... then just 
+        // if we have no callbacks... then just
         // ignore the breakpoint hit, do a run
         // so that execution resumes...
         if (m_callbacks==null) {
-            DebugLog.stdoutPrintln("	No callbacks, resuming...", DebugLog.BSF_LOG_L3);
-            m_rcp.run();
+            DebugLog.stdoutPrintln("    No callbacks, resuming...", DebugLog.BSF_LOG_L3);
+            rcp.run();
 
         } else {
             // First, check that we didn't hit a known breakpoint.
             // First, search if we have breakpoints for the current documents
 
-            name = m_rcp.getSourceName();
-            lineno = m_rcp.getLineNumber();
+            name = rcp.getSourceName();
+            lineno = rcp.getLineNumber();
 
-            DebugLog.stdoutPrintln("	in "+name+" at "+lineno, DebugLog.BSF_LOG_L3);
+            DebugLog.stdoutPrintln("    in "+name+" at "+lineno, DebugLog.BSF_LOG_L3);
 
             cell = getDocumentCell(name);
-            if (cell != null) 
-                _handleBreakpointHit(cell,lineno);
-        } 
-        m_rcp = null;
+            if (cell != null)
+                _handleBreakpointHit(rcp,cell,lineno);
+        }
     }
 
-    public void _handleBreakpointHit(DocumentCell cell, int lineno) {
-
+    void _handleBreakpointHit(RhinoContextProxy rcp,
+                              DocumentCell cell, int lineno)
+    {
         JsCallbacks debugger;
         BreakPoint bp;
         Enumeration e;
         JsContext stub=null;
         boolean breakpointFound=false;
         boolean suspend=false;
-		
+
         try {
             bp = cell.findBreakpointAtLine(lineno);
         } catch (BSFException bsfex) {
@@ -363,19 +345,19 @@
         if (bp != null) {
             breakpointFound = true;
             try {
-                stub = m_rcp.hitBreakpoint();
-                DebugLog.stdoutPrintln("	breakpoint callback...", DebugLog.BSF_LOG_L3);
-             	m_callbacks.createFuture(m_rcp);
+                stub = rcp.hitBreakpoint();
+                DebugLog.stdoutPrintln("    breakpoint callback...", DebugLog.BSF_LOG_L3);
+                 m_callbacks.createFuture(rcp);
                 m_callbacks.handleBreakpointHit(stub);
                 suspend = true;
             } catch (RemoteException rex) {
-                DebugLog.stderrPrintln("	EXCEPTION OCCURED DURING BREAKPOINT CALLBACK", DebugLog.BSF_LOG_L0);				
+                DebugLog.stderrPrintln("    EXCEPTION OCCURED DURING BREAKPOINT CALLBACK", DebugLog.BSF_LOG_L0);
                 DebugLog.stderrPrintln(rex.getMessage(), DebugLog.BSF_LOG_L0);
                 rex.printStackTrace();
                 suspend = false;
             }
         } else {
-            DebugLog.stdoutPrintln("	didn't find a breakpoint...", DebugLog.BSF_LOG_L3);
+            DebugLog.stdoutPrintln("    didn't find a breakpoint...", DebugLog.BSF_LOG_L3);
             breakpointFound = false;
         }
 
@@ -384,87 +366,107 @@
             // line in the current document, we must be stepping
             // or in entry/exit mode
             try {
-                stub = m_rcp.stepping();
+                stub = rcp.stepping();
                 FnOrScript current = cell.findFnOrScriptContaining(lineno);
                 if (stub != null) {
                     cell.setLastFnOrScript(current);
-                    DebugLog.stdoutPrintln("	stepping-done callback...", 
+                    DebugLog.stdoutPrintln("    stepping-done callback...",
                                            DebugLog.BSF_LOG_L3);
-                	m_callbacks.createFuture(m_rcp);
+                    m_callbacks.createFuture(rcp);
                     m_callbacks.handleSteppingDone(stub);
                     suspend = true;
-                } 
+                }
                 else if (cell.getEntryExit() &&
                          (current != cell.getLastFnOrScript()) &&
-                         (m_rcp.getContextCount() == 0)) {
+                         (rcp.getContextCount() == 0)) {
                     cell.setLastFnOrScript(current);
-                    stub = m_rcp.entry_exit_mode();
-                    DebugLog.stdoutPrintln("    entry/exit mode...", 
+                    stub = rcp.entry_exit_mode();
+                    DebugLog.stdoutPrintln("    entry/exit mode...",
                                            DebugLog.BSF_LOG_L3);
-                	m_callbacks.createFuture(m_rcp);
+                    m_callbacks.createFuture(rcp);
                     m_callbacks.handleSteppingDone(stub);
                     suspend = true;
                 }
                 else {
-                    DebugLog.stdoutPrintln("	No reason to suspend execution.", DebugLog.BSF_LOG_L3);				
+                    DebugLog.stdoutPrintln("    No reason to suspend execution.", DebugLog.BSF_LOG_L3);
                     suspend = false;
                 }
             } catch (RemoteException rex) {
-                DebugLog.stderrPrintln("	EXCEPTION OCCURED DURING STEPPING-DONE CALLBACK", DebugLog.BSF_LOG_L0);				
+                DebugLog.stderrPrintln("    EXCEPTION OCCURED DURING STEPPING-DONE CALLBACK", DebugLog.BSF_LOG_L0);
                 DebugLog.stderrPrintln(rex.getMessage(), DebugLog.BSF_LOG_L0);
                 rex.printStackTrace();
                 suspend = false;
             }
         }
         if (suspend) {
-            // now, suspend this thread... until 
+            // now, suspend this thread... until
             // we restart.
             try {
-                m_callbacks.suspendFuture(m_rcp);
+                m_callbacks.suspendFuture(rcp);
             } catch (Exception ex) {
                 DebugLog.stdoutPrintln("Future creation failed... releasing the engine", DebugLog.BSF_LOG_L3);
-                m_rcp.run();
+                rcp.run();
             }
-        }			
+        }
     }
 
-    public void run(JsEngineStub eng) throws Exception {
+    void run(JsEngineStub eng) throws Exception {
         DebugLog.stdoutPrintln("RhinoEngineDebugger::run()...",
                                DebugLog.BSF_LOG_L3);
-        m_rcp.run(); 
-        m_callbacks.completeFuture(m_rcp);
+        RhinoContextProxy rcp = RhinoContextProxy.getCurrent();
+        rcp.run();
+        m_callbacks.completeFuture(rcp);
     }
 
-    public void stepIn(JsEngineStub eng) throws Exception {
+    void stepIn(JsEngineStub eng) throws Exception {
         DebugLog.stdoutPrintln("RhinoEngineDebugger::stepIn()...",
                                DebugLog.BSF_LOG_L3);
-        m_rcp.stepIn();
-        m_callbacks.completeFuture(m_rcp);
+        RhinoContextProxy rcp = RhinoContextProxy.getCurrent();
+        rcp.stepIn();
+        m_callbacks.completeFuture(rcp);
     }
 
-    public void stepOut(JsEngineStub eng) throws Exception {
+    void stepOut(JsEngineStub eng) throws Exception {
         DebugLog.stdoutPrintln("RhinoEngineDebugger::stepOut()...",
                                DebugLog.BSF_LOG_L3);
-        m_rcp.stepOut();
-        m_callbacks.completeFuture(m_rcp);
+        RhinoContextProxy rcp = RhinoContextProxy.getCurrent();
+        rcp.stepOut();
+        m_callbacks.completeFuture(rcp);
     }
-    public void stepOver(JsEngineStub eng) throws Exception {
+    void stepOver(JsEngineStub eng) throws Exception {
 
         DebugLog.stdoutPrintln("RhinoEngineDebugger::stepOver()...",
                                DebugLog.BSF_LOG_L3);
-        m_rcp.stepOver();
-        m_callbacks.completeFuture(m_rcp);
+        RhinoContextProxy rcp = RhinoContextProxy.getCurrent();
+        rcp.stepOver();
+        m_callbacks.completeFuture(rcp);
     }
-	
+
     public void handleCompilationDone(Context cx,
                                       DebuggableScript fnOrScript,
-                                      StringBuffer source) {
+                                      String source) {
 
-        m_thread = Thread.currentThread();
         m_compilingFnOrScript.addCompilationUnit(cx, fnOrScript, source);
     }
 
-    public void handleExceptionThrown(Context cx, Object exceptionThrown) {
+    public DebugFrame getFrame(Context cx, DebuggableScript fnOrScript) {
+        CompilationUnit unit;
+        unit = m_compilingFnOrScript.getCompilationUnit(fnOrScript);
+        RhinoContextProxy rcp = getStub(cx);
+        try {
+            JsContextStub stub = new JsContextStub(rcp, unit);
+            return stub.getRhinoDebugFrame();
+        } catch (RemoteException rex) {
+            DebugLog.stderrPrintln("    EXCEPTION OCCURED DURING FRAME INITIALIZATION", DebugLog.BSF_LOG_L0);
+            DebugLog.stderrPrintln(rex.getMessage(), DebugLog.BSF_LOG_L0);
+            rex.printStackTrace();
+            return null;
+        }
+    }
+
+    void handleExceptionThrown(Context cx, RhinoContextProxy rcp,
+                               Throwable exceptionThrown)
+    {
         JsContext stub;
         JsCallbacks debugger;
         BreakPoint bp;
@@ -473,53 +475,40 @@
         String name,msg;
         Exception ex;
         int lineno;
-        NativeError error;
-		
-        m_thread = Thread.currentThread();
-        m_rcp = getStub(cx);
-        if (m_rcp == null) {
-            m_rcp = new RhinoContextProxy(this, cx);
-            addStub(cx, m_rcp);
+
+        // if we have no callbacks... then just
+        // ignore the breakpoint hit, do a run
+        // so that execution resumes...
+        if (m_callbacks==null) {
+            rcp.run();
+            return;
         }
-        try {
-            // if we have no callbacks... then just 
-            // ignore the breakpoint hit, do a run
-            // so that execution resumes...
-            if (m_callbacks==null) {
-                m_rcp.run();
-                return;
-            }
 
-            // First, check that we didn't hit a known breakpoint.
-            // First, search if we have breakpoints for the current documents
-            name = m_rcp.getSourceName();
-            lineno = m_rcp.getLineNumber();
-            try {
-                error = (NativeError)exceptionThrown;
-                msg = error.getName() + ": " + error.getMessage();
-            } catch (ClassCastException ccex) {
-                msg = "Unknown JavaScript Exception";
-            }
-            ex = new Exception(msg);
+        // First, check that we didn't hit a known breakpoint.
+        // First, search if we have breakpoints for the current documents
+        name = rcp.getSourceName();
+        lineno = rcp.getLineNumber();
+        if (exceptionThrown instanceof EcmaError) {
+            msg = ((EcmaError)exceptionThrown).getErrorObject().toString();
+        } else {
+            msg = exceptionThrown.toString();
+        }
+        ex = new Exception(msg);
 
-            cell = getDocumentCell(name);
-            if (cell == null) return;
+        cell = getDocumentCell(name);
+        if (cell == null) return;
 
-            try {
-                stub = m_rcp.exceptionThrown();	
-                m_callbacks.createFuture(m_rcp);
-                m_callbacks.handleExceptionThrown(stub,ex);
-				
-                // now, suspend this thread... until 
-                // we restart.
-                m_callbacks.suspendFuture(m_rcp);
-				
-            } catch (Exception ex2) {
-                m_rcp.run();
-				
-            }
-        } finally {
-            m_rcp = null;
+        try {
+            stub = rcp.exceptionThrown();
+            m_callbacks.createFuture(rcp);
+            m_callbacks.handleExceptionThrown(stub,ex);
+
+            // now, suspend this thread... until
+            // we restart.
+            m_callbacks.suspendFuture(rcp);
+
+        } catch (Exception ex2) {
+            rcp.run();
         }
     }
 
@@ -568,10 +557,10 @@
      * The engine will call the attached debugger's handleBreakpointHit
      * method on the next line it executes if isLineStep is true.
      * May be used from another thread to interrupt execution.
-     * 
+     *
      * @param isLineStep if true, break next line
      */
-    public void setBreakNextLine(JsContext context, boolean isLineStep) {
+    void setBreakNextLine(JsContext context, boolean isLineStep) {
     }
 
     void setCompilingFnOrScript(FnOrScript fnOrScript) {
@@ -583,7 +572,7 @@
      * @param debugger the debugger to be used on callbacks from
      * the engine.
      */
-    public void setDebugger(JsCallbacks debugger) {
+    void setDebugger(JsCallbacks debugger) {
         m_callbacks = debugger;
     }
 }
