===================================================================
RCS file: /home/kde/kdewebdev/quanta/parsers/qtag.cpp,v
retrieving revision 1.22
retrieving revision 1.23
diff -u -r1.22 -r1.23
--- quanta/parsers/qtag.cpp	2005/01/29 13:31:13	1.22
+++ quanta/parsers/qtag.cpp	2005/03/29 22:18:35	1.23
@@ -210,7 +210,7 @@
     return (!childTags.isEmpty() && childTags.contains(tagName));
 }
 
-bool QTag::isChild(Node *node, bool trueIfNoChildsDefined)
+bool QTag::isChild(Node *node, bool trueIfNoChildsDefined, bool treatEmptyNodesAsText)
 {
   QString nodeName;
 
@@ -223,8 +223,15 @@
     else
       return(!childTags.isEmpty() && (childTags.contains("#text") || childTags.contains("#TEXT")));
   }
-  else if(node->tag->type == Tag::Empty)
-    return true;
+  else if(node->tag->type == Tag::Empty && !treatEmptyNodesAsText)
+      return true;
+  else if(node->tag->type == Tag::Empty && treatEmptyNodesAsText)
+  {
+      if(trueIfNoChildsDefined)
+          return(childTags.isEmpty() || childTags.contains("#text") || childTags.contains("#TEXT"));
+      else
+          return(!childTags.isEmpty() && (childTags.contains("#text") || childTags.contains("#TEXT")));      
+  }
   else if(node->tag->type == Tag::XmlTagEnd)
   {
     nodeName = node->tag->name;
===================================================================
RCS file: /home/kde/kdewebdev/quanta/parsers/qtag.h,v
retrieving revision 1.65
retrieving revision 1.66
diff -u -r1.65 -r1.66
--- quanta/parsers/qtag.h	2005/02/28 18:18:28	1.65
+++ quanta/parsers/qtag.h	2005/03/29 22:18:35	1.66
@@ -235,7 +235,7 @@
   there are no children defined and if trueIfNoChildsDefined is set to true. */
   bool isChild(const QString& tag, bool trueIfNoChildsDefined = true);
   //prefer using this variant, it handle Text, Empty, XmlTagEnd nodes!
-  bool isChild(Node *node, bool trueIfNoChildsDefined = true);
+  bool isChild(Node *node, bool trueIfNoChildsDefined = true, bool treatEmptyNodesAsText = false);
   /*** Returns the list of parent of this tag. */
   QPtrList<QTag> parents();
 
===================================================================
RCS file: /home/kde/kdewebdev/quanta/parts/kafka/htmlenhancer.cpp,v
retrieving revision 1.22
retrieving revision 1.22.2.1
diff -u -r1.22 -r1.22.2.1
--- quanta/parts/kafka/htmlenhancer.cpp	2005/02/09 11:41:58	1.22
+++ quanta/parts/kafka/htmlenhancer.cpp	2005/04/28 00:08:23	1.22.2.1
@@ -125,9 +125,12 @@
 			m_wkafkapart->connectDomNodeToQuantaNode(domNode2, node);
 		}
 	}
+ 
+    QTag* qTag = QuantaCommon::tagFromDTD(m_wkafkapart->getCurrentDoc()->defaultDTD(),
+                                       parentDNode.nodeName().string());
 
 	//THEN replace, if asked, scripts by a little icon.
-	if(node->tag->type == Tag::ScriptTag && m_showIconForScripts)
+    if(node->tag->type == Tag::ScriptTag && m_showIconForScripts && qTag->isChild("IMG", false))
 	{
 		script = node->tag->name.left(node->tag->name.find("block", 0, false) - 1).lower();
 #ifdef LIGHT_DEBUG
@@ -164,7 +167,7 @@
 	}
 	
 	//THEN if it is a comment, add a little icon ;o)
-	if(node->tag->type == Tag::Comment && m_showIconForScripts)
+    if(node->tag->type == Tag::Comment && m_showIconForScripts && qTag->isChild("IMG", false))
 	{
 #ifdef LIGHT_DEBUG
 		kdDebug(25001)<< "HTMLTranslator::translateNode() - Comment" << endl;
===================================================================
RCS file: /home/kde/kdewebdev/quanta/parts/kafka/kafkacommon.cpp,v
retrieving revision 1.74
retrieving revision 1.74.2.1
diff -u -r1.74 -r1.74.2.1
--- quanta/parts/kafka/kafkacommon.cpp	2005/01/05 05:02:36	1.74
+++ quanta/parts/kafka/kafkacommon.cpp	2005/04/28 00:08:23	1.74.2.1
@@ -3328,19 +3328,10 @@
     try
     {
         parent.insertBefore(node, nextSibling);
-#ifdef HEAVY_DEBUG
-
     }
-    catch(DOM::DOMException e)
+    catch(DOM::DOMException const& e)
     {
         kdDebug(25001)<< "kafkaCommon::insertDomNode() - ERROR code :" << e.code << endl;
-#else
-
-    }
-    catch(DOM::DOMException)
-    {
-#endif
-        return false;
     }
     return true;
 }
===================================================================
RCS file: /home/kde/kdewebdev/quanta/parts/kafka/wkafkapart.cpp,v
retrieving revision 1.95
retrieving revision 1.95.2.1
diff -u -r1.95 -r1.95.2.1
--- quanta/parts/kafka/wkafkapart.cpp	2005/02/22 12:46:18	1.95
+++ quanta/parts/kafka/wkafkapart.cpp	2005/04/28 00:08:23	1.95.2.1
@@ -709,29 +709,35 @@
 			node->setLeafNode(ptDomNode);
 			mainEnhancer->enhanceNode(node, parentNode, nextNode);
 
-			if(nextNode.isNull())
-			{
-				if(!kafkaCommon::insertDomNode(newNode, parentNode))
-				{
-					disconnectDomNodeFromQuantaNode(newNode);
-					if(node->rootNode())
-						delete node->rootNode();
-					node->setRootNode(0L);
-					return false;
-				}
-			}
-			else
-			{
-				if(!kafkaCommon::insertDomNode(newNode, parentNode, nextNode))
-				{
-					disconnectDomNodeFromQuantaNode(newNode);
-					if(node->rootNode())
-						delete node->rootNode();
-					node->setRootNode(0L);
-					return false;
-				}
-			}
-		}
+            QTag* qTag = QuantaCommon::tagFromDTD(getCurrentDoc()->defaultDTD(),
+                    parentNode.nodeName().string());
+
+            if(qTag->isChild(node, false))
+            {
+                if(nextNode.isNull())
+                {
+                    if(!kafkaCommon::insertDomNode(newNode, parentNode))
+                    {
+                        disconnectDomNodeFromQuantaNode(newNode);
+                        if(node->rootNode())
+                            delete node->rootNode();
+                        node->setRootNode(0L);
+                        return false;
+                    }
+                }
+                else
+                {
+                    if(!kafkaCommon::insertDomNode(newNode, parentNode, nextNode))
+                    {
+                        disconnectDomNodeFromQuantaNode(newNode);
+                        if(node->rootNode())
+                            delete node->rootNode();
+                        node->setRootNode(0L);
+                        return false;
+                    }
+                }
+            }
+        }
 		else
 		{
 			ptDomNode = new DOM::Node(newNode);
Index: quanta/parts/kafka/wkafkapart.cpp
===================================================================
RCS file: /home/kde/kdewebdev/quanta/parts/kafka/wkafkapart.cpp,v
retrieving revision 1.95.2.1
diff -U3 -r1.95.2.1 wkafkapart.cpp
--- quanta/parts/kafka/wkafkapart.cpp	28 Apr 2005 00:08:23 -0000	1.95.2.1
+++ quanta/parts/kafka/wkafkapart.cpp	2 May 2005 17:47:52 -0000
@@ -499,16 +499,24 @@
 	Node *n, *parent;
 	int i;
 
-//     This is a hack to not created DOM::Nodes from quanta empty nodes if outside body, because KHTML
-//     moves a node in that condition into the body and then the trees become desynchronized.
-    bool isInsideBody = false;
-    if(!m_currentDoc->defaultDTD()->name.contains("HTML", false))
-        isInsideBody = true;
-    else
-        isInsideBody = kafkaCommon::hasParent(node, "body");
+//     Don't create DOM::Nodes from Quanta empty nodes outside the body or inside other not allowed element, or KHTML
+//     will give us problems.
+    bool canInsertEmptyNode = false;
+    if(node->tag->type == Tag::Empty)
+    {
+        if(!m_currentDoc->defaultDTD()->name.contains("HTML", false))
+            canInsertEmptyNode = true;
+        else
+            canInsertEmptyNode = kafkaCommon::hasParent(node, "body");
+        
+        Node* parent_node = node->parent;
+        QTag* parent_node_description_tag = QuantaCommon::tagFromDTD(parent_node);
+        if(parent_node_description_tag && !parent_node_description_tag->isChild(node, false, true))
+            canInsertEmptyNode = false;
+    }
     
     if(node->tag->type == Tag::XmlTag || 
-       ((node->tag->type == Tag::Text || (node->tag->type == Tag::Empty && isInsideBody)) && !node->insideSpecial))
+       ((node->tag->type == Tag::Text || (node->tag->type == Tag::Empty && canInsertEmptyNode)) && !node->insideSpecial))
     {
 		str = node->tag->name.lower();
 
