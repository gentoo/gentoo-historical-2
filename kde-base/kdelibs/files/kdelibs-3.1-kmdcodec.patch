cvs -f log -N -r1.57 kmdcodec.cpp

RCS file: /home/kde/kdelibs/kdecore/kmdcodec.cpp,v
Working file: kmdcodec.cpp
head: 1.57
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 59;	selected revisions: 1
description:
----------------------------
revision 1.57
date: 2002/12/02 07:07:35;  author: staikos;  state: Exp;  lines: +4 -4
Hello, we like this to work on big endian too

-    //encode (bits, m_count, 8);
-    memcpy( bits, m_count, 8 );
+    encode (bits, m_count, 8);
+    //memcpy( bits, m_count, 8 );

(etc)

This is a critical fix for big endian systems.
=============================================================================
cvs -f diff -bp -u -r1.56 -r1.57 kmdcodec.cpp
Index: kmdcodec.cpp
===================================================================
RCS file: /home/kde/kdelibs/kdecore/kmdcodec.cpp,v
retrieving revision 1.56
retrieving revision 1.57
diff -b -p -u -r1.56 -r1.57
--- kdecore/kmdcodec.cpp	2002/07/31 20:57:27	1.56
+++ kdecore/kmdcodec.cpp	2002/12/02 07:07:35	1.57
@@ -845,8 +845,8 @@ void KMD5::finalize ()
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
     };
 
-    //encode (bits, m_count, 8);
-    memcpy( bits, m_count, 8 );
+    encode (bits, m_count, 8);
+    //memcpy( bits, m_count, 8 );
 
     // Pad out to 56 mod 64.
     index = static_cast<Q_UINT32>((m_count[0] >> 3) & 0x3f);
@@ -857,8 +857,8 @@ void KMD5::finalize ()
     update (reinterpret_cast<const char*>(bits), 8);
 
     // Store state in digest
-    //encode (m_digest, m_state, 16);
-    memcpy( m_digest, m_state, 16 );
+    encode (m_digest, m_state, 16);
+    //memcpy( m_digest, m_state, 16 );
 
     // Fill sensitive information with zero's
     memset ( (void *)m_buffer, 0, sizeof(*m_buffer));
