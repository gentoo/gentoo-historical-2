diff -ur kdelibs-3.3.2.orig/khtml/khtml_part.cpp kdelibs-3.3.2.new/khtml/khtml_part.cpp
--- kdelibs-3.3.2.orig/khtml/khtml_part.cpp	2004-11-28 18:30:50.000000000 +0100
+++ kdelibs-3.3.2.new/khtml/khtml_part.cpp	2004-12-28 15:30:06.000000000 +0100
@@ -517,6 +517,10 @@
   d->m_bPluginsEnabled = KHTMLFactory::defaultHTMLSettings()->isPluginsEnabled(url.host());
 
   m_url = url;
+  
+  d->m_restoreScrollPosition = true;
+  disconnect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));
+  connect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));
 
   KHTMLPageCache::self()->fetchData( d->m_cacheId, this, SLOT(slotRestoreData(const QByteArray &)));
 
@@ -602,25 +606,22 @@
         return true;
     }
   }
-
-  //jump to the anchor AFTER layouting is done, otherwise the position of the
-  //anchor is not known and we have no clue to which coordinates to jump
-  disconnect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(gotoAnchor()));
-  connect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(gotoAnchor()));
-
+  
   // Save offset of viewport when page is reloaded to be compliant
   // to every other capable browser out there.
   if (args.reload) {
     args.xOffset = d->m_view->contentsX();
     args.yOffset = d->m_view->contentsY();
     d->m_extension->setURLArgs(args);
-    disconnect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(gotoAnchor()));
-    connect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));
-  }
+  } 
 
   if (!d->m_restored)
     closeURL();
 
+  d->m_restoreScrollPosition = d->m_restored;
+  disconnect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));      
+  connect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));
+
   // initializing m_url to the new url breaks relative links when opening such a link after this call and _before_ begin() is called (when the first
   // data arrives) (Simon)
   m_url = url;
@@ -1526,15 +1527,11 @@
     if (!baseURL.isEmpty())
       d->m_doc->setBaseURL(KURL( d->m_doc->completeURL(baseURL) ));
 
-
     if ( !m_url.isLocalFile() ) {
         // Support for http last-modified
         d->m_lastModified = d->m_job->queryMetaData("modified");
     } else
         d->m_lastModified = QString::null; // done on-demand by lastModified()
-
-    // Reset contents position
-    connect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));
   }
 
   KHTMLPageCache::self()->addData(d->m_cacheId, data);
@@ -2115,12 +2112,6 @@
 
   checkEmitLoadEvent(); // if we didn't do it before
 
-  // check that the view has not been moved by the user
-
-  if ( m_url.encodedHtmlRef().isEmpty() && d->m_view->contentsY() == 0 )
-      d->m_view->setContentsPos( d->m_extension->urlArgs().xOffset,
-                                 d->m_extension->urlArgs().yOffset );
-
   bool pendingAction = false;
 
   if ( !d->m_redirectURL.isEmpty() )
@@ -2359,17 +2350,6 @@
     d->m_doc->setUserStyleSheet( styleSheet );
 }
 
-void KHTMLPart::gotoAnchor()
-{
-  if ( !d->m_doc || !d->m_doc->parsing() ) {
-    disconnect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(gotoAnchor()));
-  }
-
-  if ( m_url.hasRef() )
-    if ( !gotoAnchor(m_url.encodedHtmlRef()) )
-      gotoAnchor(m_url.htmlRef());
-}
-
 bool KHTMLPart::gotoAnchor( const QString &name )
 {
   if (!d->m_doc)
@@ -5154,8 +5137,6 @@
     args.yOffset = yOffset;
     args.docState = docState;
 
-    connect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));
-
     d->m_extension->setURLArgs( args );
     if (!KHTMLPageCache::self()->isComplete(d->m_cacheId))
     {
@@ -6604,6 +6585,14 @@
 {
   KParts::URLArgs args = d->m_extension->urlArgs();
 
+  if ( m_url.hasRef() && !d->m_restoreScrollPosition && !args.reload) {
+    if ( !d->m_doc || !d->m_doc->parsing() )
+      disconnect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));
+    if ( !gotoAnchor(m_url.encodedHtmlRef()) )
+      gotoAnchor(m_url.htmlRef());
+    return;
+  }
+  
   // Check whether the viewport has become large enough to encompass the stored
   // offsets. If the document has been fully loaded, force the new coordinates,
   // even if the canvas is too short (can happen when user resizes the window
@@ -6612,7 +6601,7 @@
       || d->m_bComplete) {
     d->m_view->setContentsPos(args.xOffset, args.yOffset);
     disconnect(d->m_view, SIGNAL(finishedLayout()), this, SLOT(restoreScrollPosition()));
-  }
+  }  
 }
 
 
diff -ur kdelibs-3.3.2.orig/khtml/khtml_part.h kdelibs-3.3.2.new/khtml/khtml_part.h
--- kdelibs-3.3.2.orig/khtml/khtml_part.h	2004-11-28 18:30:50.000000000 +0100
+++ kdelibs-3.3.2.new/khtml/khtml_part.h	2004-12-28 15:30:06.000000000 +0100
@@ -1217,11 +1217,6 @@
                         const QString& boundary = QString::null );
 
 private slots:
-  /**
-   * @internal
-   * Jump to the anchor as defined in the url. Typically connected to KHTMLView::finishedLayout().
-   */
-  void gotoAnchor();
 
   /**
    * @internal
@@ -1455,6 +1450,8 @@
 
   /**
    * @internal
+   * used to restore or reset the view's scroll position (including positioning on anchors)
+   * once a sufficient portion of the document as been laid out.
    */
   void restoreScrollPosition();
 
diff -ur kdelibs-3.3.2.orig/khtml/khtmlpart_p.h kdelibs-3.3.2.new/khtml/khtmlpart_p.h
--- kdelibs-3.3.2.orig/khtml/khtmlpart_p.h	2004-11-28 18:30:50.000000000 +0100
+++ kdelibs-3.3.2.new/khtml/khtmlpart_p.h	2004-12-28 15:30:06.000000000 +0100
@@ -217,6 +217,7 @@
     m_frameNameId = 1;
 
     m_restored = false;
+    m_restoreScrollPosition = false;
 
     m_focusNodeNumber = -1;
     m_focusNodeRestored = false;
@@ -326,6 +327,7 @@
   bool m_metaRefreshEnabled :1;
   bool m_bPluginsOverride :1;
   bool m_restored :1;
+  bool m_restoreScrollPosition :1;
   bool m_statusMessagesEnabled :1;
   bool m_bWalletOpened :1;
   int m_frameNameId;
