--- kparts/factory.cpp	2005/09/29 09:47:40	465272
+++ kparts/factory.cpp	2006/04/05 22:48:19	526923
@@ -64,7 +64,7 @@
     if ( !factory )
         return 0;
     KParts::Factory *pfactory = dynamic_cast<KParts::Factory *>( factory );
-    if ( !factory )
+    if ( !pfactory )
         return 0;
     return pfactory->partInstance();
 }
--- kdeui/kcmodule.cpp	2005/09/29 09:47:40	465272
+++ kdeui/kcmodule.cpp	2006/04/05 17:22:08	526823
@@ -79,7 +79,12 @@
 {
     init();
     d->_instance = instance;
-    KGlobal::locale()->insertCatalogue(instance->instanceName());
+
+    if (instance)
+    {
+        KGlobal::locale()->insertCatalogue(instance->instanceName());
+    }
+
     d->_hasOwnInstance = false;
     KGlobal::setActiveInstance(this->instance());
 }
--- kdeui/kcolordialog.cpp	2006/02/14 13:21:59	509356
+++ kdeui/kcolordialog.cpp	2006/04/07 13:50:45	527264
@@ -242,7 +242,7 @@
 		p = (uint *) image.scanLine( ySize - s - 1 );
 		for( h = 0; h < xSize; h++ )
 		{
-			col.setHsv( 359*h/(xSize-1), 255*s/(ySize-1), 192 );
+			col.setHsv( 359*h/(xSize-1), 255*s/((ySize == 1) ? 1 : ySize-1), 192 );
 			*p = col.rgb();
 			p++;
 		}
@@ -305,7 +305,7 @@
 
 			for( int x = 0; x < xSize; x++ )
 			{
-				col.setHsv( _hue, _sat, 255*x/(xSize-1) );
+				col.setHsv( _hue, _sat, 255*x/((xSize == 1) ? 1 : xSize-1) );
 				rgb = col.rgb();
 				*p++ = rgb;
 			}
@@ -317,7 +317,7 @@
 		for ( int v = 0; v < ySize; v++ )
 		{
 			p = (uint *) image.scanLine( ySize - v - 1 );
-			col.setHsv( _hue, _sat, 255*v/(ySize-1) );
+			col.setHsv( _hue, _sat, 255*v/((ySize == 1) ? 1 : ySize-1) );
 			rgb = col.rgb();
 			for ( int i = 0; i < xSize; i++ )
 				*p++ = rgb;
@@ -426,7 +426,7 @@
 
 void KColorCells::mouseMoveEvent( QMouseEvent *e )
 {
-    if( !(e->state() && LeftButton)) return;
+    if( !(e->state() & LeftButton)) return;
 
     if(inMouse) {
         int delay = KGlobalSettings::dndEventDelay();
@@ -530,7 +530,7 @@
 void KColorPatch::mouseMoveEvent( QMouseEvent *e )
 {
         // Drag color object
-        if( !(e->state() && LeftButton)) return;
+        if( !(e->state() & LeftButton)) return;
 	KColorDrag *d = new KColorDrag( color, this);
 	d->dragCopy();
 }
@@ -1253,30 +1253,26 @@
 void
 KColorDialog::readSettings()
 {
-  KConfig* config = KGlobal::config();
+  KConfigGroup group( KGlobal::config(), "Colors" );
 
-  QString oldgroup = config->group();
-
-  config->setGroup("Colors");
-  QString palette = config->readEntry("CurrentPalette");
+  QString palette = group.readEntry("CurrentPalette");
   d->table->setPalette(palette);
-  config->setGroup( oldgroup );
 }
 
 void
 KColorDialog::slotWriteSettings()
 {
-  KConfig* config = KGlobal::config();
-  config->setGroup("Colors");
+  KConfigGroup group( KGlobal::config(), "Colors" );
+
   QString palette = d->table->palette();
-  if (!config->hasDefault("CurrentPalette") &&
+  if (!group.hasDefault("CurrentPalette") &&
       (d->table->palette() == d->originalPalette))
   {
-     config->revertToDefault("CurrentPalette");
+     group.revertToDefault("CurrentPalette");
   }
   else
   {
-     config->writeEntry("CurrentPalette", d->table->palette());
+     group.writeEntry("CurrentPalette", d->table->palette());
   }
 }
 
--- kdeui/kdialogbase.cpp	2005/09/29 09:47:40	465272
+++ kdeui/kdialogbase.cpp	2006/04/05 16:45:10	526809
@@ -668,7 +668,7 @@
     return;
   }
 
-  if( style < 0 || style > ActionStyleMAX ) { style = ActionStyle0; }
+  if( style < 0 || style >= ActionStyleMAX ) { style = ActionStyle0; }
   d->mButton.style = style;
 
   const int *layout;
--- kdecore/kglobalaccel_x11.cpp	2005/09/29 09:47:40	465272
+++ kdecore/kglobalaccel_x11.cpp	2006/04/09 09:06:52	527729
@@ -212,7 +212,7 @@
 		if( failed ) {
 			kdDebug(125) << "grab failed!\n";
 			for( uint m = 0; m <= 0xff; m++ ) {
-				if( m & keyModMaskX == 0 )
+				if(( m & keyModMaskX ) == 0 )
 					XUngrabKey( qt_xdisplay(), keyCodeX, keyModX | m, qt_xrootwin() );
 				}
                 }
--- kdecore/network/kresolver.cpp	2006/02/26 18:55:08	513854
+++ kdecore/network/kresolver.cpp	2006/04/13 14:57:25	529483
@@ -609,7 +609,7 @@
 
 QStrList KResolver::protocolName(int protonum)
 {
-  struct protoent *pe;
+  struct protoent *pe = 0L;
 #ifndef HAVE_GETPROTOBYNAME_R
   QMutexLocker locker(&getXXbyYYmutex);
 
@@ -628,6 +628,7 @@
       if (getprotobynumber_r(protonum, &protobuf, buf, buflen, &pe) == ERANGE)
 # endif
 	{
+          pe = 0L;
 	  buflen += 1024;
 	  delete [] buf;
 	}
@@ -655,7 +656,7 @@
 
 QStrList KResolver::protocolName(const char *protoname)
 {
-  struct protoent *pe;
+  struct protoent *pe = 0L;
 #ifndef HAVE_GETPROTOBYNAME_R
   QMutexLocker locker(&getXXbyYYmutex);
 
@@ -674,6 +675,7 @@
       if (getprotobyname_r(protoname, &protobuf, buf, buflen, &pe) == ERANGE)
 # endif
 	{
+          pe = 0L;
 	  buflen += 1024;
 	  delete [] buf;
 	}
@@ -701,7 +703,7 @@
 
 int KResolver::protocolNumber(const char *protoname)
 {
-  struct protoent *pe;
+  struct protoent *pe = 0L;
 #ifndef HAVE_GETPROTOBYNAME_R
   QMutexLocker locker(&getXXbyYYmutex);
 
@@ -720,6 +722,7 @@
       if (getprotobyname_r(protoname, &protobuf, buf, buflen, &pe) == ERANGE)
 # endif
 	{
+          pe = 0L;
 	  buflen += 1024;
 	  delete [] buf;
 	}
@@ -743,7 +746,7 @@
 
 int KResolver::servicePort(const char *servname, const char *protoname)
 {
-  struct servent *se;
+  struct servent *se = 0L;
 #ifndef HAVE_GETSERVBYNAME_R
   QMutexLocker locker(&getXXbyYYmutex);
 
@@ -762,6 +765,7 @@
       if (getservbyname_r(servname, protoname, &servbuf, buf, buflen, &se) == ERANGE)
 # endif
 	{
+          se = 0L;
 	  buflen += 1024;
 	  delete [] buf;
 	}
@@ -785,7 +789,7 @@
 
 QStrList KResolver::serviceName(const char* servname, const char *protoname)
 {
-  struct servent *se;
+  struct servent *se = 0L;
 #ifndef HAVE_GETSERVBYNAME_R
   QMutexLocker locker(&getXXbyYYmutex);
 
@@ -804,6 +808,7 @@
       if (getservbyname_r(servname, protoname, &servbuf, buf, buflen, &se) == ERANGE)
 # endif
 	{
+          se = 0L;
 	  buflen += 1024;
 	  delete [] buf;
 	}
@@ -831,7 +836,7 @@
 
 QStrList KResolver::serviceName(int port, const char *protoname)
 {
-  struct servent *se;
+  struct servent *se = 0L;
 #ifndef HAVE_GETSERVBYPORT_R
   QMutexLocker locker(&getXXbyYYmutex);
 
@@ -850,6 +855,7 @@
       if (getservbyport_r(port, protoname, &servbuf, buf, buflen, &se) == ERANGE)
 # endif
 	{
+          se = 0L;
 	  buflen += 1024;
 	  delete [] buf;
 	}
--- kdecore/netsupp.cpp	2005/09/29 09:47:40	465272
+++ kdecore/netsupp.cpp	2006/04/13 14:57:25	529483
@@ -352,15 +352,9 @@
   return 0;
 
  out:
-  // Normal exit of the function
-  if (err == 0)
-    *result = res;
-  else
-    {
-      if (res->data != NULL)
-	freeaddrinfo(res->data);
-      free(res);
-    }
+  if (res->data != NULL)
+      freeaddrinfo(res->data);
+  free(res);
   return err;
 }
 
--- kdeui/kdockwidget.cpp	2005/09/29 09:47:40	465272
+++ kdeui/kdockwidget.cpp	2006/04/13 21:35:27	529609
@@ -762,9 +762,11 @@
 void KDockWidget::setEnableDocking( int pos )
 {
   eDocking = pos;
-  if( header && header->inherits( "KDockWidgetHeader" ) )
-     ( ( KDockWidgetHeader* ) header )->showUndockButton( pos & DockDesktop );
-  updateHeader();
+  if( header ) {
+     if (header->inherits( "KDockWidgetHeader" ) )
+         ( ( KDockWidgetHeader* ) header )->showUndockButton( pos & DockDesktop );
+    updateHeader();
+  }
 }
 
 void KDockWidget::updateHeader()
--- kdecore/netwm_def.h	2006/01/06 15:07:18	494899
+++ kdecore/netwm_def.h	2006/04/11 12:48:50	528573
@@ -606,6 +606,20 @@
         FromApplication,
         FromTool
     };
+    
+    /**
+     Compares two X timestamps, taking into account wrapping and 64bit architectures.
+     Return value is like with strcmp(), 0 for equal, -1 for time1 < time2, 1 for time1 > time2.
+     @since 3.5.3
+    */
+    static int timestampCompare( unsigned long time1, unsigned long time2 );
+    /**
+     Returns a difference of two X timestamps, time2 - time1, where time2 must be later than time1,
+     as returned by timestampCompare().
+     @since 3.5.3
+    */
+    static int timestampDiff( unsigned long time1_, unsigned long time2_ );
+
 };
 
 
--- kdecore/kapplication.cpp	2006/03/15 13:08:02	518842
+++ kdecore/kapplication.cpp	2006/04/11 12:48:50	528573
@@ -960,14 +960,13 @@
 static int my_system (const char *command) {
    int pid, status;
 
-   QApplication::flushX();
    pid = fork();
    if (pid == -1)
       return -1;
    if (pid == 0) {
       const char* shell = "/bin/sh";
       execl(shell, shell, "-c", command, (void *)0);
-      ::exit(127);
+      ::_exit(127);
    }
    do {
       if (waitpid(pid, &status, 0) == -1) {
@@ -1684,7 +1683,7 @@
                     && _event->xclient.data.l[ 3 ] != 0 )
                     {
                     if( qt_x_user_time == 0
-                        || ( _event->xclient.data.l[ 3 ] - qt_x_user_time ) < 100000U )
+                        || NET::timestampCompare( _event->xclient.data.l[ 3 ], qt_x_user_time ) > 0 )
                         { // and the timestamp looks reasonable
                         qt_x_user_time = _event->xclient.data.l[ 3 ]; // update our qt_x_user_time from it
                         }
@@ -1692,7 +1691,7 @@
                 else // normal DND, only needed until Qt updates qt_x_user_time from XdndDrop
                     {
                     if( qt_x_user_time == 0
-                        || ( _event->xclient.data.l[ 2 ] - qt_x_user_time ) < 100000U )
+                        || NET::timestampCompare( _event->xclient.data.l[ 2 ], qt_x_user_time ) > 0 )
                         { // the timestamp looks reasonable
                         qt_x_user_time = _event->xclient.data.l[ 2 ]; // update our qt_x_user_time from it
                         }
@@ -1812,7 +1811,7 @@
         XDestroyWindow( qt_xdisplay(), w );
     }
     if( qt_x_user_time == 0
-        || time - qt_x_user_time < 1000000000U ) // check time > qt_x_user_time, handle wrapping
+        || NET::timestampCompare( time, qt_x_user_time ) > 0 ) // check time > qt_x_user_time
         qt_x_user_time = time;
 #endif
 }
--- kdecore/kprocess.cpp	2006/01/29 09:42:40	503447
+++ kdecore/kprocess.cpp	2006/03/30 22:04:03	524676
@@ -355,8 +355,6 @@
   if (pipe(fd))
      fd[0] = fd[1] = -1; // Pipe failed.. continue
 
-  QApplication::flushX();
-
   // we don't use vfork() because
   // - it has unclear semantics and is not standardized
   // - we do way too much magic in the child
@@ -768,7 +766,7 @@
     d->shell = shell;
   else
 // #ifdef NON_FREE // ... as they ship non-POSIX /bin/sh
-#if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__GNU__)
+#if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__GNU__) && !defined(__DragonFly__)
   // Solaris POSIX ...
   if (!access( "/usr/xpg4/bin/sh", X_OK ))
     d->shell = "/usr/xpg4/bin/sh";
--- kdecore/kxerrorhandler.cpp	2005/07/26 18:54:59	438982
+++ kdecore/kxerrorhandler.cpp	2006/04/11 13:28:02	528591
@@ -28,6 +28,7 @@
 #include "kxerrorhandler.h"
 #include <assert.h>
 #include <stdlib.h>
+#include <netwm_def.h>
 
 KXErrorHandler** KXErrorHandler::handlers = NULL;
 int KXErrorHandler::pos = 0;
@@ -101,13 +102,14 @@
 int KXErrorHandler::handle( Display* dpy, XErrorEvent* e )
     {
     if( dpy == display
-        && e->serial - first_request < 1000000000 ) // e->serial > first_request, with wrapping
+        // e->serial >= first_request , compare like X timestamps to handle wrapping
+        && NET::timestampCompare( e->serial, first_request ) >= 0 )
         { // it's for us
         //qDebug( "Handling: %p", static_cast< void* >( this ));
-        if( user_handler1 != NULL )
-            was_error |= user_handler1( e->request_code, e->error_code, e->resourceid );
-        else if( user_handler2 != NULL )
-            was_error |= ( user_handler2( dpy, e ) != 0 );
+        if( user_handler1 != NULL && user_handler1( e->request_code, e->error_code, e->resourceid ))
+            was_error = true;
+        if( user_handler2 != NULL && user_handler2( dpy, e ) != 0 )
+            was_error = true;
         else // no handler set, simply set that there was an error
             was_error = true;
         return 0;
--- kdecore/netwm.cpp	2005/07/26 18:54:59	438982
+++ kdecore/netwm.cpp	2006/04/11 12:48:50	528573
@@ -4401,4 +4401,38 @@
 void NETWinInfo::virtual_hook( int, void* )
 { /*BASE::virtual_hook( id, data );*/ }
 
+// Functions for X timestamp comparing. For Time being 32bit they're fairly simple
+// (the #if 0 part), but on 64bit architectures Time is 64bit unsigned long,
+// so there special care needs to be taken to always use only the lower 32bits.
+#if 0
+int NET::timestampCompare( Time time1, Time time2 ) // like strcmp()
+    {
+    if( time1 == time2 )
+        return 0;
+    return ( time1 - time2 ) < 0x7fffffffU ? 1 : -1; // time1 > time2 -> 1, handle wrapping
+    }
+
+Time NET::timestampDiff( Time time1, Time time2 ) // returns time2 - time1
+    { // no need to handle wrapping?
+    return time2 - time1;
+    }
+#else
+int NET::timestampCompare( unsigned long time1_, unsigned long time2_ ) // like strcmp()
+    {
+    Q_UINT32 time1 = time1_;
+    Q_UINT32 time2 = time2_;
+    if( time1 == time2 )
+        return 0;
+    return Q_UINT32( time1 - time2 ) < 0x7fffffffU ? 1 : -1; // time1 > time2 -> 1, handle wrapping
+    }
+
+int NET::timestampDiff( unsigned long time1_, unsigned long time2_ ) // returns time2 - time1
+    { // no need to handle wrapping?
+    Q_UINT32 time1 = time1_;
+    Q_UINT32 time2 = time2_;
+    return Q_UINT32( time2 - time1 );
+    }
+#endif
+
+
 #endif
--- kdeprint/kpgeneralpage.cpp	2005/10/13 02:22:24	470046
+++ kdeprint/kpgeneralpage.cpp	2006/04/19 09:45:52	531417
@@ -523,7 +523,7 @@
 			if (ch) setComboItem(m_papertype, ch->get("text"));
 		}
 		value = opts["InputSlot"];
-		if (m_inputslot->isEnabled() && !value.isEmpty())
+		if (m_inputslot && m_inputslot->isEnabled() && !value.isEmpty())
 		{
 			DrBase	*ch = ((DrListOption*)driver()->findOption("InputSlot"))->findChoice(value);
 			if (ch) setComboItem(m_inputslot, ch->get("text"));
--- khtml/khtml_part.cpp	2006/03/30 17:08:27	524563
+++ khtml/khtml_part.cpp	2006/05/04 16:37:34	537375
@@ -3160,7 +3160,8 @@
         else if ( renderLineText )
         {
           khtml::RenderLineEdit *parentLine= static_cast<khtml::RenderLineEdit *>(obj);
-          s = parentLine->widget()->text();
+          if (parentLine->widget()->echoMode() == QLineEdit::Normal)
+            s = parentLine->widget()->text();
           s = s.replace(0xa0, ' ');
         }
         else if ( obj->isText() )
@@ -3470,7 +3471,8 @@
 	    text += static_cast<HTMLTextAreaElementImpl*>(n.handle())->value().string();
 	    break;
 	  case ID_INPUT:
-	    text += static_cast<HTMLInputElementImpl*>(n.handle())->value().string();
+            if (static_cast<HTMLInputElementImpl*>(n.handle())->inputType() != HTMLInputElementImpl::PASSWORD)
+  	      text += static_cast<HTMLInputElementImpl*>(n.handle())->value().string();
 	    break;
 	  case ID_SELECT:
 	    text += static_cast<HTMLSelectElementImpl*>(n.handle())->value().string();
@@ -4477,7 +4479,7 @@
     }
 
     child->m_serviceType = mimetype;
-    if ( child->m_frame )
+    if ( child->m_frame  && part->widget() )
       child->m_frame->setWidget( part->widget() );
 
     if ( child->m_type != khtml::ChildFrame::Object )
--- kdeui/ksconfig.cpp	2006/02/01 19:32:55	504677
+++ kdeui/ksconfig.cpp	2006/05/06 15:07:51	538032
@@ -23,6 +23,7 @@
 #include <qcombobox.h>
 #include <qlabel.h>
 #include <qlayout.h>
+#include <qtimer.h>
 
 #include <kapplication.h>
 #include <kconfig.h>
@@ -238,7 +239,7 @@
       dictcombo->clear();
       dictcombo->insertItem( i18n("Turkish") );
       sChangeEncoding( KS_E_UTF8 );
-    } 
+    }
     else
       getAvailDictsAspell();
   }
@@ -505,7 +506,7 @@
   dictcombo->insertItem (i18n("ASpell Default"));
 
   // Aspell now have /usr/lib/aspell as
-  // ASPELL_DATADIR default. 
+  // ASPELL_DATADIR default.
   QFileInfo dir ( ASPELL_DATADIR );
   if (!dir.exists() || !dir.isDir())
     dir.setFile ("/usr/lib/aspell-0.60");
@@ -908,7 +909,7 @@
 {
   setDictionary (langfnames[i]);
   setDictFromList (true);
-  emit configChanged();
+  QTimer::singleShot( 0, this, SIGNAL( configChanged() ) );
 }
 
 void
--- kabc/lock.cpp	2005/09/29 09:47:40	465272
+++ kabc/lock.cpp	2006/05/09 12:09:31	538959
@@ -55,9 +55,9 @@
 {
   QFile file( filename );
   if ( !file.open( IO_ReadOnly ) ) return false;
-  
+
   QTextStream t( &file );
-  t >> pid >> ws >> app;
+  t >> pid >> endl >> app;
 
   return true;
 }
@@ -102,8 +102,8 @@
       QString identifier( mIdentifier );
       identifier.replace( '_', '/' );
 
-      mError = i18n("The resource '%1' is locked by application '%2'.")
-               .arg( identifier ).arg( app );
+      mError = i18n("The address book '%1' is locked by application '%2'.\nIf you believe this is incorrect, just remove the lock file from '%3'")
+               .arg( identifier ).arg( app ).arg( locateLocal( "data", "kabc/lock/*.lock" ) );
       return false;
     }
   }
--- kdeui/ktextedit.cpp	2005/09/29 09:47:40	465272
+++ kdeui/ktextedit.cpp	2006/05/09 15:06:47	539040
@@ -295,7 +295,7 @@
 
 void KTextEdit::focusInEvent( QFocusEvent *e )
 {
-    if ( d->checkSpellingEnabled && !d->highlighter )
+    if ( d->checkSpellingEnabled && !isReadOnly() && !d->highlighter )
         d->highlighter = new KDictSpellingHighlighter( this );
 
     QTextEdit::focusInEvent( e );
@@ -308,11 +308,17 @@
 
 void KTextEdit::setReadOnly(bool readOnly)
 {
+    if ( !readOnly && hasFocus() && d->checkSpellingEnabled && !d->highlighter )
+        d->highlighter = new KDictSpellingHighlighter( this );
+	
     if ( readOnly == isReadOnly() )
         return;
 
     if (readOnly)
     {
+	delete d->highlighter;
+	d->highlighter = 0;
+	    
         bool custom = ownPalette();
         QPalette p = palette();
         QColor color = p.color(QPalette::Disabled, QColorGroup::Background);
--- kdeui/ktextedit.h	2005/09/29 09:47:40	465272
+++ kdeui/ktextedit.h	2006/05/09 15:06:47	539040
@@ -74,15 +74,20 @@
     virtual void setPalette( const QPalette& palette );
 
     /**
-     * Turns spell checking for this text edit on or off.
+     * Turns spell checking for this text edit on or off. Note that spell
+     * checking is only available in read-writable KTextEdits.
      *
      * @see checkSpellingEnabled()
+     * @see isReadOnly()
+     * @see setReadOnly()
      * @since 3.2
      */
     void setCheckSpellingEnabled( bool check );
 
     /**
      * Returns true if spell checking is enabled for this text edit.
+     * Note that it even returns true if this is a read-only KTextEdit,
+     * where spell checking is actually disabled.
      *
      @ see setCheckSpellingEnabled()
      * @since 3.2
--- kdeui/tests/ktextedittest.cpp	2005/09/29 09:47:40	465272
+++ kdeui/tests/ktextedittest.cpp	2006/05/09 15:06:47	539040
@@ -26,6 +26,8 @@
 {
     KApplication app( argc, argv, "ktextedittest" );
     KTextEdit *edit = new KTextEdit();
+    edit->setReadOnly( true );
+    edit->setCheckSpellingEnabled( true );
 
     QFile file( "ktextedittest.cpp" );
     if ( file.open( IO_ReadOnly ) )
@@ -36,5 +38,6 @@
 
     edit->resize( 600, 600 );
     edit->show();
+    edit->setReadOnly( false ); // also enables spell checking
     return app.exec();
 }
--- kabc/plugins/file/resourcefile.cpp	2006/03/07 18:29:10	516587
+++ kabc/plugins/file/resourcefile.cpp	2006/05/09 11:56:04	538954
@@ -2,6 +2,7 @@
     This file is part of libkabc.
 
     Copyright (c) 2001,2003 Cornelius Schumacher <schumacher@kde.org>
+    Copyright (c) 2006 Tom Abers <tomalbers@kde.nl>
 
     This library is free software; you can redistribute it and/or
     modify it under the terms of the GNU Library General Public
@@ -26,7 +27,6 @@
 
 #include <qfile.h>
 #include <qfileinfo.h>
-#include <qregexp.h>
 #include <qtimer.h>
 
 #include <kapplication.h>
@@ -36,7 +36,9 @@
 #include <klocale.h>
 #include <ksavefile.h>
 #include <kstandarddirs.h>
-#include <ktempfile.h>
+#include <kurl.h>
+#include <jobclasses.h>
+#include <kio/netaccess.h>
 
 #include "formatfactory.h"
 #include "resourcefileconfig.h"
@@ -47,19 +49,9 @@
 
 using namespace KABC;
 
-class ResourceFile::ResourceFilePrivate
-{
-  public:
-    KIO::Job *mLoadJob;
-    bool mIsLoading;
-
-    KIO::Job *mSaveJob;
-    bool mIsSaving;
-};
-
 ResourceFile::ResourceFile( const KConfig *config )
-  : Resource( config ), mFormat( 0 ), mTempFile( 0 ),
-    mAsynchronous( false ), d( new ResourceFilePrivate )
+  : Resource( config ), mFormat( 0 ),
+    mAsynchronous( false )
 {
   QString fileName, formatName;
 
@@ -76,19 +68,14 @@
 
 ResourceFile::ResourceFile( const QString &fileName,
                             const QString &formatName )
-  : Resource( 0 ), mFormat( 0 ), mTempFile( 0 ),
-    mAsynchronous( false ), d( new ResourceFilePrivate )
+  : Resource( 0 ), mFormat( 0 ),
+    mAsynchronous( false )
 {
   init( fileName, formatName );
 }
 
 void ResourceFile::init( const QString &fileName, const QString &formatName )
 {
-  d->mLoadJob = 0;
-  d->mIsLoading = false;
-  d->mSaveJob = 0;
-  d->mIsSaving = false;
-
   mFormatName = formatName;
 
   FormatFactory *factory = FormatFactory::self();
@@ -110,17 +97,8 @@
 
 ResourceFile::~ResourceFile()
 {
-  if ( d->mIsLoading )
-    d->mLoadJob->kill();
-  if ( d->mIsSaving )
-    d->mSaveJob->kill();
-
-  delete d;
-  d = 0;
   delete mFormat;
   mFormat = 0;
-
-  deleteLocalTempFile();
 }
 
 void ResourceFile::writeConfig( KConfig *config )
@@ -189,9 +167,31 @@
 
     if ( file.size() == 0 ) {
       file.close();
+      kdDebug() << "File size is zero. Evaluating backups" << endl;
+      for (int i=0; i!=20; i++)
+      {
+        QFile backup( mFileName + "__" + QString::number(i) );
+        kdDebug() << "Evaluating" << backup.name() << " size: " << backup.size() << endl;
+        if ( backup.size() != 0 )
+        {
+          kdDebug() << "Restoring backup " << i << endl;
+          KURL src, dest;
+          src.setPath( mFileName + "__" + QString::number(i) );
+          dest.setPath( mFileName );
+
+          KIO::DeleteJob* job = KIO::del( dest, false, false ); 
+          KIO::NetAccess::synchronousRun( job, 0);
+
+          KIO::CopyJob* job2 = KIO::copy( src, dest, false ); 
+          KIO::NetAccess::synchronousRun( job2, 0);
+
+          backup.close();
+          return true; 
+        }
+        backup.close();
+      }
       return true;
     }
-
     bool ok = mFormat->checkFormat( &file );
     file.close();
 
@@ -207,10 +207,6 @@
 {
   kdDebug(5700) << "ResourceFile::load(): '" << mFileName << "'" << endl;
 
-  if ( d->mIsLoading ) {
-    abortAsyncLoading();
-  }
-
   mAsynchronous = false;
 
   QFile file( mFileName );
@@ -219,96 +215,53 @@
     return false;
   }
 
-  if ( !clearAndLoad( &file ) ) {
-      addressBook()->error( i18n( "Problems during parsing file '%1'." ).arg( mFileName ) );
-    return false;
-  }
-
-  return true;
-}
-
-bool ResourceFile::clearAndLoad( QFile *file )
-{
   clear();
-  return mFormat->loadAll( addressBook(), this, file );
+
+  return mFormat->loadAll( addressBook(), this, &file );
 }
 
 bool ResourceFile::asyncLoad()
 {
-  if ( d->mIsLoading ) {
-    abortAsyncLoading();
-  }
-
-  if (d->mIsSaving) {
-    kdWarning(5700) << "Aborted asyncSave() because we're still asyncSave()ing!" << endl;
-    return false;
-  }
+  kdDebug(5700) << "ResourceFile::asyncLoad()" << endl;
 
   mAsynchronous = true;
 
-  bool ok = createLocalTempFile();
-  if ( ok )
-    ok = mTempFile->close(); // we only need the filename
-
-  if ( !ok ) {
-    emit loadingError( this, i18n( "Unable to open file '%1'." ).arg( mTempFile->name() ) );
-    deleteLocalTempFile();
-    return false;
-  }
+  bool ok = load();
 
-  KURL dest, src;
-  dest.setPath( mTempFile->name() );
-  src.setPath( mFileName );
-
-  KIO::Scheduler::checkSlaveOnHold( true );
-  d->mLoadJob = KIO::file_copy( src, dest, -1, true, false, false );
-  d->mIsLoading = true;
-  connect( d->mLoadJob, SIGNAL( result( KIO::Job* ) ),
-           this, SLOT( downloadFinished( KIO::Job* ) ) );
+  if ( !ok )
+    emitLoadingError();
+  else
+    emitLoadingFinished();
 
   return true;
 }
 
-void ResourceFile::abortAsyncLoading()
-{
-  kdDebug(5700) << "ResourceFile::abortAsyncLoading()" << endl;
-
-  if ( d->mLoadJob ) {
-    d->mLoadJob->kill(); // result not emitted
-    d->mLoadJob = 0;
-  }
-
-  deleteLocalTempFile();
-  d->mIsLoading = false;
-}
-
-void ResourceFile::abortAsyncSaving()
-{
-  kdDebug(5700) << "ResourceFile::abortAsyncSaving()" << endl;
-
-  if ( d->mSaveJob ) {
-    d->mSaveJob->kill(); // result not emitted
-    d->mSaveJob = 0;
-  }
-
-  deleteLocalTempFile();
-  d->mIsSaving = false;
-}
-
 bool ResourceFile::save( Ticket * )
 {
   kdDebug(5700) << "ResourceFile::save()" << endl;
 
-  if (d->mIsSaving) {
-    abortAsyncSaving();
-  }
-  if ( d->mIsLoading ) {
-    kdWarning(5700) << "Aborted save() because we're still asyncLoad()ing!" << endl;
-    return false;
-  }
+  // Only do the logrotate dance when the __0 file is not 0 bytes.
+  QFile file( mFileName + "__0" );
+  if ( file.size() != 0 ) {
+    KURL last;
+    last.setPath( mFileName + "__20" );
+    kdDebug() << "deleting " << last << endl;
+    KIO::DeleteJob* job = KIO::del( last, false, false ); 
+    KIO::NetAccess::synchronousRun( job, 0);
+
+    for (int i=19; i>=0; i--)
+    {
+      KURL src, dest;
+      src.setPath( mFileName + "__" + QString::number(i) );
+      dest.setPath( mFileName + "__" + QString::number(i+1) );
+      kdDebug() << "moving " << src << " -> " << dest << endl;
+      KIO::SimpleJob* job = KIO::rename( src, dest, false ); 
+      KIO::NetAccess::synchronousRun( job, 0);
+    }
+  } else
+    kdDebug() << "Not starting logrotate __0 is 0 bytes." << endl;
 
-  // create backup file
-  QString extension = "_" + QString::number( QDate::currentDate().dayOfWeek() );
+  QString extension = "__0";
   (void) KSaveFile::backupFile( mFileName, QString::null /*directory*/,
                                 extension );
 
@@ -318,7 +271,7 @@
   bool ok = false;
 
   if ( saveFile.status() == 0 && saveFile.file() ) {
-    saveToFile( saveFile.file() );
+    mFormat->saveAll( addressBook(), this, saveFile.file() );
     ok = saveFile.close();
   }
 
@@ -332,70 +285,18 @@
   return ok;
 }
 
-bool ResourceFile::asyncSave( Ticket * )
+bool ResourceFile::asyncSave( Ticket *ticket )
 {
   kdDebug(5700) << "ResourceFile::asyncSave()" << endl;
 
-  if (d->mIsSaving) {
-    abortAsyncSaving();
-  }
+  bool ok = save( ticket );
 
-  if (d->mIsLoading) {
-    kdWarning(5700) << "Aborted asyncSave() because we're still asyncLoad()ing!" << endl;
-    return false;
-  }
-
-  bool ok = createLocalTempFile();
-  if ( ok ) {
-    saveToFile( mTempFile->file() );
-    ok = mTempFile->close();
-  }
-
-  if ( !ok ) {
-    emit savingError( this, i18n( "Unable to save file '%1'." ).arg( mTempFile->name() ) );
-    deleteLocalTempFile();
-    return false;
-  }
-
-  KURL src, dest;
-  src.setPath( mTempFile->name() );
-  dest.setPath( mFileName );
-
-  KIO::Scheduler::checkSlaveOnHold( true );
-  d->mIsSaving = true;
-  mDirWatch.stopScan(); // restarted in uploadFinished()
-  d->mSaveJob = KIO::file_copy( src, dest, -1, true, false, false );
-  connect( d->mSaveJob, SIGNAL( result( KIO::Job* ) ),
-           this, SLOT( uploadFinished( KIO::Job* ) ) );
-
-  return true;
-}
-
-bool ResourceFile::createLocalTempFile()
-{
-  deleteStaleTempFile();
-  mTempFile = new KTempFile();
-  mTempFile->setAutoDelete( true );
-  return mTempFile->status() == 0;
-}
-
-void ResourceFile::deleteStaleTempFile()
-{
-  if ( hasTempFile() ) {
-    kdDebug(5700) << "stale temp file detected " << mTempFile->name() << endl;
-    deleteLocalTempFile();
-  }
-}
-
-void ResourceFile::deleteLocalTempFile()
-{
-  delete mTempFile;
-  mTempFile = 0;
-}
+  if ( !ok )
+    QTimer::singleShot( 0, this, SLOT( emitSavingError() ) );
+  else
+    QTimer::singleShot( 0, this, SLOT( emitSavingFinished() ) );
 
-void ResourceFile::saveToFile( QFile *file )
-{
-  mFormat->saveAll( addressBook(), this, file );
+  return ok;
 }
 
 void ResourceFile::setFileName( const QString &fileName )
@@ -436,7 +337,6 @@
   if ( !addressBook() )
     return;
 
-//  clear(); // moved to clearAndLoad()
   if ( mAsynchronous )
     asyncLoad();
   else {
@@ -455,44 +355,24 @@
   mAddrMap.erase( addr.uid() );
 }
 
-void ResourceFile::downloadFinished( KIO::Job* )
+void ResourceFile::emitSavingFinished()
 {
-  kdDebug(5700) << "ResourceFile::downloadFinished()" << endl;
-
-  d->mIsLoading = false;
-
-  if ( !hasTempFile() || mTempFile->status() != 0 ) {
-    emit loadingError( this, i18n( "Download failed in some way!" ) );
-    return;
-  }
-
-  QFile file( mTempFile->name() );
-  if ( file.open( IO_ReadOnly ) ) {
-    if ( clearAndLoad( &file ) )
-      emit loadingFinished( this );
-    else
-      emit loadingError( this, i18n( "Problems during parsing file '%1'." ).arg( mTempFile->name() ) );
-  }
-  else {
-    emit loadingError( this, i18n( "Unable to open file '%1'." ).arg( mTempFile->name() ) );
-  }
-
-  deleteLocalTempFile();
+  emit savingFinished( this );
 }
 
-void ResourceFile::uploadFinished( KIO::Job *job )
+void ResourceFile::emitSavingError()
 {
-  kdDebug(5700) << "ResourceFile::uploadFinished()" << endl;
-
-  d->mIsSaving = false;
+  emit savingError( this, i18n( "Unable to save file '%1'." ).arg( mFileName ) );
+}
 
-  if ( job->error() )
-    emit savingError( this, job->errorString() );
-  else
-    emit savingFinished( this );
+void ResourceFile::emitLoadingFinished()
+{
+  emit loadingFinished( this );
+}
 
-  deleteLocalTempFile();
-  mDirWatch.startScan();
+void ResourceFile::emitLoadingError()
+{
+  emit loadingError( this, i18n( "Problems during parsing file '%1'." ).arg( mFileName ) );
 }
 
 #include "resourcefile.moc"
--- kabc/plugins/file/resourcefile.h	2006/02/22 11:43:12	512375
+++ kabc/plugins/file/resourcefile.h	2006/05/09 11:56:04	538954
@@ -28,14 +28,6 @@
 
 #include <kabc/resource.h>
 
-class QFile;
-class QTimer;
-class KTempFile;
-
-namespace KIO {
-class Job;
-}
-
 namespace KABC {
 
 class FormatPlugin;
@@ -135,8 +127,10 @@
     virtual void removeAddressee( const Addressee& addr );
 
   private slots:
-    void downloadFinished( KIO::Job* );
-    void uploadFinished( KIO::Job* );
+    void emitLoadingFinished();
+    void emitLoadingError();
+    void emitSavingFinished();
+    void emitSavingError();
 
   protected slots:
     void fileChanged();
@@ -148,15 +142,6 @@
     void unlock( const QString &fileName );
 
   private:
-    bool clearAndLoad( QFile *file );
-    void saveToFile( QFile *file );
-    void abortAsyncLoading();
-    void abortAsyncSaving();
-    bool createLocalTempFile();
-    void deleteLocalTempFile();
-    void deleteStaleTempFile();
-    bool hasTempFile() const { return mTempFile != 0; }
-
     QString mFileName;
     QString mFormatName;
 
@@ -166,8 +151,6 @@
 
     KDirWatch mDirWatch;
 
-    KTempFile *mTempFile;
-
     bool mAsynchronous;
 
     class ResourceFilePrivate;
--- kdecore/kiconloader.cpp	2006/01/30 14:52:12	503832
+++ kdecore/kiconloader.cpp	2006/05/09 19:15:18	539123
@@ -435,16 +435,25 @@
 
     if ( extensionLength > 0 )
     {
-#ifndef NDEBUG
-	kdDebug(264) << "Application " << KGlobal::instance()->instanceName()
-                     << " loads icon " << name << " with extension." << endl;
-#endif
-
 	return name.left(name.length() - extensionLength);
     }
     return name;
 }
 
+QString KIconLoader::removeIconExtensionInternal(const QString &name) const
+{
+    QString name_noext = removeIconExtension(name);
+
+#ifndef NDEBUG
+    if (name != name_noext)
+    {
+	kdDebug(264) << "Application " << KGlobal::instance()->instanceName()
+		     << " loads icon " << name << " with extension." << endl;
+    }
+#endif
+
+    return name_noext;
+}
 
 KIcon KIconLoader::findMatchingIcon(const QString& name, int size) const
 {
@@ -529,7 +538,7 @@
     if (!QDir::isRelativePath(_name))
 	return _name;
 
-    QString name = removeIconExtension( _name );
+    QString name = removeIconExtensionInternal( _name );
 
     QString path;
     if (group_or_size == KIcon::User)
@@ -673,7 +682,7 @@
         if (!canReturnNull && name.isEmpty())
             name = str_unknown;
         else
-	    name = removeIconExtension(name);
+	    name = removeIconExtensionInternal(name);
     }
 
     // If size == 0, use default size for the specified group.
@@ -810,12 +819,16 @@
 	    ((ovl = loadOverlay(theme->shareOverlay(), size)) != 0L))
 	  KIconEffect::overlay(*img, *ovl);
         if (overlay & KIcon::HiddenOverlay)
+        {
+	    if (img->depth() != 32)
+	        *img = img->convertDepth(32);
             for (int y = 0; y < img->height(); y++)
             {
-		Q_UINT32 *line = reinterpret_cast<Q_UINT32 *>(img->scanLine(y));
+		QRgb *line = reinterpret_cast<QRgb *>(img->scanLine(y));
                 for (int x = 0; x < img->width();  x++)
                     line[x] = (line[x] & 0x00ffffff) | (QMIN(0x80, qAlpha(line[x])) << 24);
 	    }
+	}
     }
 
     // Scale the icon and apply effects if necessary
--- kdecore/kiconloader.h	2005/09/28 09:27:53	464793
+++ kdecore/kiconloader.h	2006/05/07 05:30:53	538154
@@ -401,11 +401,32 @@
     /**
      * Checks if name ends in one of the supported icon formats (i.e. .png)
      * and returns the name without the extension if it does.
+     *
+     * Otherwise name is returned unchanged.
+     *
+     * Currently supported:
+     *   - png
+     *   - xpm
+     *   - svg  (if libart is being used)
+     *   - svgz (if libart is being used)
+     *
+     * TODO: KDE 4 make public & static
      * @since 3.1
      */
     QString removeIconExtension(const QString &name) const;
 
     /**
+     * Same as removeIconExtension except it prints a debug message
+     * if an extension is removed to help catch programming errors.
+     *
+     * @see findMatchingIcon()
+     * @see iconPath()
+     *
+     * TODO: KDE 4 make static
+     */
+    QString removeIconExtensionInternal(const QString &name) const;
+
+    /**
      * Loads all the different sizes for an iconset.
      */
     QIconSet loadIconSetNonDelayed( const QString& name, KIcon::Group group,
