commit d1254968eac95f4d9d8c47552e27f0cc40e6aed9
Author: Peter Penz <peter.penz19@gmail.com>
Date:   Sun Feb 27 20:01:19 2011 +0100

    KFileMetaDataProvider: Don't crash if a Strigi analyzer crashes
    
    Some Strigi analyzers are still unstable and crash under certain circumstances. This patch moves the reading of the meta-data into a custom process instead of doing it in a thread, which assures that a crashing Strigi analyzer does not result in crashing Dolphin or Konqueror when hovering some items.
    
    FIXED-IN: 4.7.0
    BUG: 257964
    BUG: 258715
    BUG: 262299
    BUG: 263468
    BUG: 263502
    BUG: 264254
    BUG: 234799
    BUG: 251462
    BUG: 251701
    BUG: 258918
    BUG: 192377
    BUG: 195564
    BUG: 199368
    BUG: 210841
    BUG: 245376
    BUG: 246461
    BUG: 246901
    BUG: 249150
    BUG: 261952
    BUG: 249876
    BUG: 179376
    BUG: 179417
    BUG: 179420
    BUG: 181591
    BUG: 183269
    BUG: 183722
    BUG: 185667
    BUG: 188596
    BUG: 191864
    BUG: 193112
    BUG: 205813
    BUG: 244621
    BUG: 245451
    BUG: 248214
    BUG: 249655
    BUG: 249876
    BUG: 265549
    BUG: 267079

diff --git a/kio/CMakeLists.txt b/kio/CMakeLists.txt
index 0802150..72386f8 100644
--- a/kio/CMakeLists.txt
+++ b/kio/CMakeLists.txt
@@ -257,7 +257,6 @@ if(NOT KIO_NO_NEPOMUK)
   set(kfile_STAT_SRCS
     ${kfile_STAT_SRCS}
     kfile/kcommentwidget.cpp
-    kfile/kloadfilemetadatathread.cpp
     )
 endif(NOT KIO_NO_NEPOMUK)
 
@@ -307,6 +306,12 @@ set(kio_LIB_PRIVATE_SRCS
     kio/slaveinterface_p.h
 )
 
+if(NOT KIO_NO_NEPOMUK)
+    set(kfilemetadatareader_SRCS
+        kfile/kfilemetadatareader.cpp
+    )
+endif(NOT KIO_NO_NEPOMUK)
+
 kde4_add_ui_files(kio_LIB_SRCS
    kfile/kpropertiesdesktopadvbase.ui
    kfile/kpropertiesdesktopbase.ui
@@ -323,6 +328,8 @@ install(FILES kssl/ksslcertificatemanager.upd
 kde4_add_library(kio ${LIBRARY_TYPE} ${kio_LIB_SRCS})
 
 if(NOT KIO_NO_NEPOMUK)
+  kde4_add_executable(kfilemetadatareader ${kfilemetadatareader_SRCS})
+  target_link_libraries(kfilemetadatareader ${KDE4_KIO_LIBS} ${KDE4_NEPOMUK_LIBRARY} nepomukutils)
   target_link_libraries(kio ${KDE4_NEPOMUK_LIBRARY} nepomukquery nepomukutils)
 endif(NOT KIO_NO_NEPOMUK)
 target_link_libraries(kio ${KDE4_KDEUI_LIBS} ${ZLIB_LIBRARY} ${QT_QTNETWORK_LIBRARY} ${QT_QTXML_LIBRARY} ${QT_QTSVG_LIBRARY} ${X11_LIBRARIES} ${KIO_EXTRA_LIBS})
@@ -343,6 +350,9 @@ set_target_properties(kio PROPERTIES VERSION ${KDE_NON_GENERIC_LIB_VERSION}
 
 ########### install files ###############
 install(TARGETS kio EXPORT kdelibsLibraryTargets ${INSTALL_TARGETS_DEFAULT_ARGS})
+if(NOT KIO_NO_NEPOMUK)
+    install(TARGETS kfilemetadatareader ${INSTALL_TARGETS_DEFAULT_ARGS})
+endif(NOT KIO_NO_NEPOMUK)
 
 install( PROGRAMS useragent.pl proxytype.pl  DESTINATION ${KCONF_UPDATE_INSTALL_DIR} )
 
diff --git a/kio/kfile/kfilemetadataprovider.cpp b/kio/kfile/kfilemetadataprovider.cpp
index 09ce4b2..d6e4d0d 100644
--- a/kio/kfile/kfilemetadataprovider.cpp
+++ b/kio/kfile/kfilemetadataprovider.cpp
@@ -22,18 +22,20 @@
 #include <kfileitem.h>
 #include "knfotranslator_p.h"
 #include <klocale.h>
+#include <kprocess.h>
+#include <kstandarddirs.h>
 #include <kurl.h>
 
 #ifndef KIO_NO_NEPOMUK
     #define DISABLE_NEPOMUK_LEGACY
     #include "nepomukmassupdatejob.h"
     #include "tagwidget.h"
+    #include "tag.h"
     #include "kratingwidget.h"
     #include "resource.h"
     #include "resourcemanager.h"
 
     #include "kcommentwidget_p.h"
-    #include "kloadfilemetadatathread_p.h"
 #else
     namespace Nepomuk
     {
@@ -103,7 +105,7 @@ public:
     Private(KFileMetaDataProvider* parent);
     ~Private();
 
-    void slotLoadingFinished(QThread* finishedThread);
+    void slotLoadingFinished(int exitCode, QProcess::ExitStatus exitStatus);
 
     void slotRatingChanged(unsigned int rating);
     void slotTagsChanged(const QList<Nepomuk::Tag>& tags);
@@ -135,8 +137,8 @@ public:
 #ifndef KIO_NO_NEPOMUK
     QHash<KUrl, Nepomuk::Variant> m_data;
 
-    QList<KLoadFileMetaDataThread*> m_metaDataThreads;
-    KLoadFileMetaDataThread* m_latestMetaDataThread;
+    QList<KProcess*> m_metaDataProcesses;
+    KProcess* m_latestMetaDataProcess;
 
     QWeakPointer<KRatingWidget> m_ratingWidget;
     QWeakPointer<Nepomuk::TagWidget> m_tagWidget;
@@ -153,8 +155,8 @@ KFileMetaDataProvider::Private::Private(KFileMetaDataProvider* parent) :
     m_fileItems(),
 #ifndef KIO_NO_NEPOMUK
     m_data(),
-    m_metaDataThreads(),
-    m_latestMetaDataThread(0),
+    m_metaDataProcesses(),
+    m_latestMetaDataProcess(0),
     m_ratingWidget(),
     m_tagWidget(),
     m_commentWidget(),
@@ -169,35 +171,57 @@ KFileMetaDataProvider::Private::Private(KFileMetaDataProvider* parent) :
 KFileMetaDataProvider::Private::~Private()
 {
 #ifndef KIO_NO_NEPOMUK
-    foreach (KLoadFileMetaDataThread* thread, m_metaDataThreads) {
-        disconnect(thread, SIGNAL(finished(QThread*)),
-                   q, SLOT(slotLoadingFinished(QThread*)));
-        thread->wait();
-    }
+    qDeleteAll(m_metaDataProcesses);
 #endif
 }
 
-void KFileMetaDataProvider::Private::slotLoadingFinished(QThread* finishedThread)
+void KFileMetaDataProvider::Private::slotLoadingFinished(int exitCode, QProcess::ExitStatus exitStatus)
 {
+    Q_UNUSED(exitCode);
+    Q_UNUSED(exitStatus);
+
 #ifndef KIO_NO_NEPOMUK
-    // The thread that has emitted the finished() signal
-    // will get deleted and removed from m_metaDataThreads.
-    const int threadsCount = m_metaDataThreads.count();
-    for (int i = 0; i < threadsCount; ++i) {
-        KLoadFileMetaDataThread* thread = m_metaDataThreads[i];
-        if (thread == finishedThread) {
-            m_metaDataThreads.removeAt(i);
-            if (thread != m_latestMetaDataThread) {
-                // Ignore data of older threads, as the data got
-                // obsolete by m_latestMetaDataThread.
-                thread->deleteLater();
+    KProcess* finishedProcess = qobject_cast<KProcess*>(q->sender());
+    // The process that has emitted the finished() signal
+    // will get deleted and removed from m_metaDataProcesses.
+    for (int i = 0; i < m_metaDataProcesses.count(); ++i) {
+        KProcess* process = m_metaDataProcesses[i];
+        if (process == finishedProcess) {
+            m_metaDataProcesses.removeAt(i);
+            if (process != m_latestMetaDataProcess) {
+                // Ignore data of older processs, as the data got
+                // obsolete by m_latestMetaDataProcess.
+                process->deleteLater();
                 return;
             }
         }
     }
 
-    m_data = m_latestMetaDataThread->data();
-    m_latestMetaDataThread->deleteLater();
+    m_data.clear();
+    while (m_latestMetaDataProcess->canReadLine()) {
+        // Read key
+        QString key = QString::fromLocal8Bit(m_latestMetaDataProcess->readLine());
+        key.remove(QChar::Other_Control);
+
+        // Read variant-type
+        if (!m_latestMetaDataProcess->canReadLine()) {
+            break;
+        }
+        QString valueTypeString(QString::fromLocal8Bit(m_latestMetaDataProcess->readLine()));
+        valueTypeString.remove(QChar::Other_Control);
+        const int valueType = valueTypeString.toInt();
+        if (!m_latestMetaDataProcess->canReadLine()) {
+            break;
+        }
+
+        // Read variant-value
+        QString value(QString::fromLocal8Bit(m_latestMetaDataProcess->readLine()));
+        value.remove(QChar::Other_Control);
+        // TODO: Handle value-types like QVariantList
+        Q_UNUSED(valueType);
+        m_data.insert(KUrl(key), value);
+    }
+    m_latestMetaDataProcess->deleteLater();
 
     if (m_fileItems.count() == 1) {
         // TODO: Handle case if remote URLs are used properly. isDir() does
@@ -219,14 +243,11 @@ void KFileMetaDataProvider::Private::slotLoadingFinished(QThread* finishedThread
         }
         m_data.insert(KUrl("kfileitem#totalSize"), KIO::convertSize(totalSize));
     }
-#else
-    Q_UNUSED(finishedThread)
 #endif
 
     emit q->loadingFinished();
 }
 
-
 void KFileMetaDataProvider::Private::slotRatingChanged(unsigned int rating)
 {
 #ifndef KIO_NO_NEPOMUK
@@ -386,18 +407,27 @@ void KFileMetaDataProvider::setItems(const KFileItemList& items)
         }
     }
 
-    // Cancel all threads that have not emitted a finished() signal.
-    // The deleting of those threads is done in slotLoadingFinished().
-    foreach (KLoadFileMetaDataThread* thread, d->m_metaDataThreads) {
-        thread->cancel();
+    // Create a new process that will provide the meta data for the items
+    d->m_latestMetaDataProcess = new KProcess();
+
+    const QString fileMetaDataReaderExe = KStandardDirs::findExe(QLatin1String("kfilemetadatareader"));
+    (*d->m_latestMetaDataProcess) << fileMetaDataReaderExe;
+
+    foreach (const KUrl& url, urls) {
+        (*d->m_latestMetaDataProcess) << url.url();
     }
 
-    // Create a new thread that will provide the meta data for the items
-    d->m_latestMetaDataThread = new KLoadFileMetaDataThread();
-    connect(d->m_latestMetaDataThread, SIGNAL(finished(QThread*)),
-            this, SLOT(slotLoadingFinished(QThread*)));
-    d->m_latestMetaDataThread->load(urls);
-    d->m_metaDataThreads.append(d->m_latestMetaDataThread);
+    d->m_latestMetaDataProcess->setOutputChannelMode(KProcess::OnlyStdoutChannel);
+    d->m_latestMetaDataProcess->setNextOpenMode(QIODevice::ReadOnly | QIODevice::Text);
+    d->m_latestMetaDataProcess->start();
+    if (d->m_latestMetaDataProcess->waitForStarted()) {
+        connect(d->m_latestMetaDataProcess, SIGNAL(finished(int, QProcess::ExitStatus)),
+                this, SLOT(slotLoadingFinished(int, QProcess::ExitStatus)));
+        d->m_metaDataProcesses.append(d->m_latestMetaDataProcess);
+    } else {
+        delete d->m_latestMetaDataProcess;
+        d->m_latestMetaDataProcess = 0;
+    }
 #endif
 }
 
diff --git a/kio/kfile/kfilemetadataprovider_p.h b/kio/kfile/kfilemetadataprovider_p.h
index 05ae848..ce6e259 100644
--- a/kio/kfile/kfilemetadataprovider_p.h
+++ b/kio/kfile/kfilemetadataprovider_p.h
@@ -33,6 +33,7 @@
 #endif
 
 class KFileItemList;
+class KProcess;
 class KUrl;
 class QWidget;
 
@@ -131,7 +132,7 @@ private:
     class Private;
     Private* const d;
 
-    Q_PRIVATE_SLOT(d, void slotLoadingFinished(QThread* finishedThread))
+    Q_PRIVATE_SLOT(d, void slotLoadingFinished(int exitCode, QProcess::ExitStatus exitStatus))
     Q_PRIVATE_SLOT(d, void slotRatingChanged(unsigned int rating))
     Q_PRIVATE_SLOT(d, void slotTagsChanged(const QList<Nepomuk::Tag>& tags))
     Q_PRIVATE_SLOT(d, void slotCommentChanged(const QString& comment))
diff --git a/kio/kfile/kfilemetadatareader.cpp b/kio/kfile/kfilemetadatareader.cpp
new file mode 100644
index 0000000..0609235
--- /dev/null
+++ b/kio/kfile/kfilemetadatareader.cpp
@@ -0,0 +1,174 @@
+/*****************************************************************************
+ * Copyright (C) 2011 by Peter Penz <peter.penz@gmx.at>                      *
+ *                                                                           *
+ * This library is free software; you can redistribute it and/or             *
+ * modify it under the terms of the GNU Library General Public               *
+ * License as published by the Free Software Foundation; either              *
+ * version 2 of the License, or (at your option) any later version.          *
+ *                                                                           *
+ * This library is distributed in the hope that it will be useful,           *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
+ * Library General Public License for more details.                          *
+ *                                                                           *
+ * You should have received a copy of the GNU Library General Public License *
+ * along with this library; see the file COPYING.LIB.  If not, write to      *
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,      *
+ * Boston, MA 02110-1301, USA.                                               *
+ *****************************************************************************/
+
+#include <iostream>
+
+#include <kaboutdata.h>
+#include <kcmdlineargs.h>
+#include <kfilemetainfo.h>
+#include <klocale.h>
+
+#include <QtCore/QHash>
+#include <QtCore/QString>
+
+#define DISABLE_NEPOMUK_LEGACY
+#include "config-nepomuk.h"
+
+#include <nepomuk/query/filequery.h>
+#include <nepomuk/query/comparisonterm.h>
+#include <nepomuk/query/andterm.h>
+#include <nepomuk/query/resourceterm.h>
+#include <nepomuk/query/resourcetypeterm.h>
+#include <nepomuk/query/optionalterm.h>
+#include <nepomuk/utils/utils.h>
+#include <nepomuk/property.h>
+#include <nepomuk/tag.h>
+#include <nepomuk/variant.h>
+#include <nepomuk/resourcemanager.h>
+
+using namespace std;
+
+static void sendMetaData(const QHash<KUrl, Nepomuk::Variant>& data)
+{
+    // Write the meta-data as sequence of the following properties:
+    // 1. Metadata key
+    // 2. Variant type
+    // 3. Variant value
+    QHashIterator<KUrl, Nepomuk::Variant> it(data);
+    while (it.hasNext()) {
+        it.next();
+        const QString key = it.key().url();
+        const Nepomuk::Variant& variant = it.value();
+
+        const QString variantType = QString::number(variant.type());
+        // TODO: serialize valuetypes like variant lists
+        QString variantValue = variant.toString();
+        // QChar::Other_Control acts as separator between the output-values.
+        // Assure that this character is not already part of a value:
+        variantValue.remove(QChar::Other_Control);
+
+        cout << key.toLocal8Bit().data() << endl;
+        cout << variantType.toLocal8Bit().data() << endl;
+        cout << variantValue.toLocal8Bit().data() << endl;
+    }
+}
+
+static int readMetaData(const KCmdLineArgs* args)
+{
+    KUrl::List urls;
+    const int argsCount = args->count();
+    for (int i = 0; i < argsCount; ++i) {
+        urls.append(KUrl(args->arg(i)));
+    }
+
+    unsigned int rating = 0;
+    QString comment;
+    QList<Nepomuk::Tag> tags;
+    QHash<KUrl, Nepomuk::Variant> data;
+
+    bool first = true;
+    foreach (const KUrl& url, urls) {
+        Nepomuk::Resource file(url);
+        if (!file.isValid()) {
+            continue;
+        }
+
+        if (!first && (rating != file.rating())) {
+            rating = 0; // Reset rating
+        } else if (first) {
+            rating = file.rating();
+        }
+
+        if (!first && (comment != file.description())) {
+            comment.clear(); // Reset comment
+        } else if (first) {
+            comment = file.description();
+        }
+
+        if (!first && (tags != file.tags())) {
+            tags.clear(); // Reset tags
+        } else if (first) {
+            tags = file.tags();
+        }
+
+        if (first && (urls.count() == 1)) {
+            // Get cached meta data by checking the indexed files
+            QHash<QUrl, Nepomuk::Variant> variants = file.properties();
+            QHash<QUrl, Nepomuk::Variant>::const_iterator it = variants.constBegin();
+            while (it != variants.constEnd()) {
+                Nepomuk::Types::Property prop(it.key());
+                data.insert(prop.uri(), Nepomuk::Utils::formatPropertyValue(prop, it.value(),
+                                                                            QList<Nepomuk::Resource>() << file,
+                                                                            Nepomuk::Utils::WithKioLinks));
+                ++it;
+            }
+
+            if (variants.isEmpty()) {
+                // The file has not been indexed, query the meta data
+                // directly from the file.
+                const QString path = urls.first().toLocalFile();
+                KFileMetaInfo metaInfo(path, QString(), KFileMetaInfo::Fastest);
+                const QHash<QString, KFileMetaInfoItem> metaInfoItems = metaInfo.items();
+                foreach (const KFileMetaInfoItem& metaInfoItem, metaInfoItems) {
+                    const QString uriString = metaInfoItem.name();
+                    const Nepomuk::Variant value(metaInfoItem.value());
+                    data.insert(uriString,
+                                Nepomuk::Utils::formatPropertyValue(Nepomuk::Types::Property(), value));
+                }
+            }
+        }
+
+        first = false;
+    }
+
+    if (Nepomuk::ResourceManager::instance()->initialized()) {
+        data.insert(KUrl("kfileitem#rating"), rating);
+        data.insert(KUrl("kfileitem#comment"), comment);
+
+        QList<Nepomuk::Variant> tagVariants;
+        foreach (const Nepomuk::Tag& tag, tags) {
+            tagVariants.append(Nepomuk::Variant(tag));
+        }
+        data.insert(KUrl("kfileitem#tags"), tagVariants);
+    }
+
+    sendMetaData(data);
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    KAboutData aboutData("kfilemetadatareader", 0, ki18n("KFileMetaDataReader"),
+                         "1.0",
+                         ki18n("KFileMetaDataReader can be used to read metadata from a file"),
+                         KAboutData::License_GPL,
+                         ki18n("(C) 2011, Peter Penz"));
+    aboutData.addAuthor(ki18n("Peter Penz"), ki18n("Current maintainer"), "peter.penz19@gmail.com");
+    
+    KCmdLineArgs::init(argc, argv, &aboutData);
+    
+    KCmdLineOptions options;
+    options.add("+[arg]", ki18n("List of URLs where the meta-data should be read from"));
+
+    KCmdLineArgs::addCmdLineOptions(options);
+    const KCmdLineArgs *args = KCmdLineArgs::parsedArgs();
+
+    return readMetaData(args);
+}
+
diff --git a/kio/kfile/kfilemetadatawidget.cpp b/kio/kfile/kfilemetadatawidget.cpp
index dca3a12..532d884 100644
--- a/kio/kfile/kfilemetadatawidget.cpp
+++ b/kio/kfile/kfilemetadatawidget.cpp
@@ -41,9 +41,7 @@
     #include <property.h>
     #include <tag.h>
 
-    #include <QMutex>
     #include <QSpacerItem>
-    #include <QThread>
 #endif
 
 class KFileMetaDataWidget::Private
diff --git a/kio/kfile/kloadfilemetadatathread.cpp b/kio/kfile/kloadfilemetadatathread.cpp
deleted file mode 100644
index 55d2c37..0000000
--- a/kio/kfile/kloadfilemetadatathread.cpp
+++ /dev/null
@@ -1,178 +0,0 @@
-/*****************************************************************************
- * Copyright (C) 2009-2010 by Peter Penz <peter.penz@gmx.at>                 *
- * Copyright (C) 2009-2010 by Sebastian Trueg <trueg@kde.org>                *
- *                                                                           *
- * This library is free software; you can redistribute it and/or             *
- * modify it under the terms of the GNU Library General Public               *
- * License as published by the Free Software Foundation; either              *
- * version 2 of the License, or (at your option) any later version.          *
- *                                                                           *
- * This library is distributed in the hope that it will be useful,           *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
- * Library General Public License for more details.                          *
- *                                                                           *
- * You should have received a copy of the GNU Library General Public License *
- * along with this library; see the file COPYING.LIB.  If not, write to      *
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,      *
- * Boston, MA 02110-1301, USA.                                               *
- *****************************************************************************/
-
-#include "kloadfilemetadatathread_p.h"
-
-#include <kfilemetainfo.h>
-#include <kfilemetainfoitem.h>
-#include <kglobal.h>
-#include <klocale.h>
-#include "kfilemetadataprovider_p.h"
-#include <kprotocolinfo.h>
-
-#include "resource.h"
-#include "thing.h"
-#include "variant.h"
-#include "resourcemanager.h"
-
-#include "config-nepomuk.h"
-
-#include "query/filequery.h"
-#include "query/comparisonterm.h"
-#include "query/andterm.h"
-#include "query/resourceterm.h"
-#include "query/resourcetypeterm.h"
-#include "query/optionalterm.h"
-#include "utils/utils.h"
-
-#include <Soprano/Model>
-#include <Soprano/QueryResultIterator>
-#include <Soprano/NodeIterator>
-
-#include <QMutexLocker>
-
-KLoadFileMetaDataThread::KLoadFileMetaDataThread()
-    : m_canceled(false)
-{
-    connect(this, SIGNAL(finished()), this, SLOT(slotLoadingFinished()));
-}
-
-KLoadFileMetaDataThread::~KLoadFileMetaDataThread()
-{
-}
-
-void KLoadFileMetaDataThread::load(const KUrl::List& urls)
-{
-    QMutexLocker locker(&m_mutex);
-    m_urls = urls;
-    m_canceled = false;
-    start();
-}
-
-QHash<KUrl, Nepomuk::Variant> KLoadFileMetaDataThread::data() const
-{
-    QMutexLocker locker(&m_mutex);
-    return m_data;
-}
-
-void KLoadFileMetaDataThread::cancel()
-{
-    // Setting m_canceled to true will cancel KLoadFileMetaDataThread::run()
-    // as soon as run() gets the chance to check m_cancel.
-    m_canceled = true;
-}
-
-void KLoadFileMetaDataThread::run()
-{
-    QMutexLocker locker(&m_mutex);
-    const KUrl::List urls = m_urls;
-    locker.unlock(); // no shared member is accessed until locker.relock()
-
-    unsigned int rating = 0;
-    QString comment;
-    QList<Nepomuk::Tag> tags;
-    QHash<KUrl, Nepomuk::Variant> data;
-
-    bool first = true;
-    foreach (const KUrl& url, urls) {
-        if (m_canceled) {
-            return;
-        }
-
-        Nepomuk::Resource file(url);
-        if (!file.isValid()) {
-            continue;
-        }
-
-        if (!first && (rating != file.rating())) {
-            rating = 0; // reset rating
-        } else if (first) {
-            rating = file.rating();
-        }
-
-        if (!first && (comment != file.description())) {
-            comment.clear(); // reset comment
-        } else if (first) {
-            comment = file.description();
-        }
-
-        if (!first && (tags != file.tags())) {
-            tags.clear(); // reset tags
-        } else if (first) {
-            tags = file.tags();
-        }
-
-        if (first && (urls.count() == 1)) {
-            // get cached meta data by checking the indexed files
-            QHash<QUrl, Nepomuk::Variant> variants = file.properties();
-            QHash<QUrl, Nepomuk::Variant>::const_iterator it = variants.constBegin();
-            while (it != variants.constEnd()) {
-                Nepomuk::Types::Property prop(it.key());
-                data.insert(prop.uri(), Nepomuk::Utils::formatPropertyValue(prop, it.value(), QList<Nepomuk::Resource>() << file, Nepomuk::Utils::WithKioLinks));
-                ++it;
-            }
-
-            if (variants.isEmpty()) {
-                // The file has not been indexed, query the meta data
-                // directly from the file
-
-                // TODO: Some Strigi analyzers (used in KFileMetaInfo) are not reentrant.
-                // As workaround the access is protected by a mutex here. To reproduce
-                // the issue run kfilemetainfotest with helgrind.
-                static QMutex metaInfoMutex;
-                metaInfoMutex.lock();
-
-                const QString path = urls.first().toLocalFile();
-                KFileMetaInfo metaInfo(path, QString(), KFileMetaInfo::Fastest);
-                const QHash<QString, KFileMetaInfoItem> metaInfoItems = metaInfo.items();
-                foreach (const KFileMetaInfoItem& metaInfoItem, metaInfoItems) {
-                    const QString uriString = metaInfoItem.name();
-                    const Nepomuk::Variant value(metaInfoItem.value());
-                    data.insert(uriString, Nepomuk::Utils::formatPropertyValue(Nepomuk::Types::Property(), value));
-                }
-
-                metaInfoMutex.unlock();
-            }
-        }
-
-        first = false;
-    }
-
-    if (Nepomuk::ResourceManager::instance()->initialized()) {
-        data.insert(KUrl("kfileitem#rating"), rating);
-        data.insert(KUrl("kfileitem#comment"), comment);
-
-        QList<Nepomuk::Variant> tagVariants;
-        foreach (const Nepomuk::Tag& tag, tags) {
-            tagVariants.append(Nepomuk::Variant(tag));
-        }
-        data.insert(KUrl("kfileitem#tags"), tagVariants);
-    }
-
-    locker.relock();
-    m_data = data;
-}
-
-void KLoadFileMetaDataThread::slotLoadingFinished()
-{
-    emit finished(this);
-}
-
-#include "kloadfilemetadatathread_p.moc"
diff --git a/kio/kfile/kloadfilemetadatathread_p.h b/kio/kfile/kloadfilemetadatathread_p.h
deleted file mode 100644
index 006e3a0..0000000
--- a/kio/kfile/kloadfilemetadatathread_p.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*****************************************************************************
- * Copyright (C) 2009-2010 by Peter Penz <peter.penz@gmx.at>                 *
- *                                                                           *
- * This library is free software; you can redistribute it and/or             *
- * modify it under the terms of the GNU Library General Public               *
- * License as published by the Free Software Foundation; either              *
- * version 2 of the License, or (at your option) any later version.          *
- *                                                                           *
- * This library is distributed in the hope that it will be useful,           *
- * but WITHOUT ANY WARRANTY; without even the implied warranty of            *
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
- * Library General Public License for more details.                          *
- *                                                                           *
- * You should have received a copy of the GNU Library General Public License *
- * along with this library; see the file COPYING.LIB.  If not, write to      *
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,      *
- * Boston, MA 02110-1301, USA.                                               *
- *****************************************************************************/
-
-#ifndef KLOADFILEMETADATATHREAD_H
-#define KLOADFILEMETADATATHREAD_H
-
-#define DISABLE_NEPOMUK_LEGACY
-#include <property.h>
-#include <tag.h>
-#include <variant.h>
-
-#include <kurl.h>
-#include <QList>
-#include <QMutex>
-#include <QThread>
-
-/**
- * Loads the meta data of files that are
- * required by the widget KMetaDataWidget.
- *
- * Is used in KMetaDataModel.
- */
-class KLoadFileMetaDataThread : public QThread
-{
-    Q_OBJECT
-
-public:
-    KLoadFileMetaDataThread();
-    virtual ~KLoadFileMetaDataThread();
-
-    /**
-     * Starts the thread and loads the meta data for
-     * the files given by \p urls. After receiving
-     * the signal finished(), the method KLoadFileMetaDataThread::data()
-     * provides the loaded meta data.
-     */
-    void load(const KUrl::List& urls);
-
-    /**
-     * Returns the meta data for the URLs given
-     * by KLoadFileMetaDataThread::load(). The method only provides
-     * valid results after the signal finished() has been
-     * emitted.
-     */
-    QHash<KUrl, Nepomuk::Variant> data() const;
-
-    /**
-     * Tells the thread that it should cancel as soon
-     * as possible. It is undefined when the thread
-     * gets cancelled. The signal finished() will emitted
-     * after the cancelling has been done.mergedIt
-     */
-    void cancel();
-
-    /** @see QThread::run() */
-    virtual void run();
-
-Q_SIGNALS:
-    /**
-     * Is emitted if the thread has finished the loading. KMetaDataModel
-     * requires the information which thread has been finished, hence
-     * the thread is passed as parameter (using QObject::sender() would
-     * be an alternative, but it is less understandable).
-     */
-    void finished(QThread* thread);
-
-private slots:
-    /**
-     * Emits the signal finished() including the thread as parameter.
-     */
-    void slotLoadingFinished();
-
-private:
-    mutable QMutex m_mutex;
-    QHash<KUrl, Nepomuk::Variant> m_data;
-    KUrl::List m_urls;
-
-    volatile bool m_canceled;
-};
-#endif
