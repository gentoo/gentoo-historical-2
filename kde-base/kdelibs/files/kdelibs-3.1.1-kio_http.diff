cvs -f log -N -r1.551.2.9 http.cc

RCS file: /home/kde/kdelibs/kioslave/http/http.cc,v
Working file: http.cc
head: 1.565
branch:
locks: strict
access list:
keyword substitution: kv
total revisions: 632;	selected revisions: 1
description:
----------------------------
revision 1.551.2.9
date: 2003/03/17 14:20:31;  author: waba;  state: Exp;  lines: +112 -112
CCMAIL: 55571-done@bugs.kde.org
Fix Bug 55571: https authentication through proxy fails

(This patch basically reverts r1.546 and r1.544)
m_bNeedTunnel was incorrectly used to check whether we were busy connecting
to a proxy or sending the actual request. Moved some code around so that it
only gets executed when sending the actual request so that it isn't necassery
any more to abuse m_bNeedTunnel for this.

The resetting of m_bNeedTunnel caused bug 55571, it isn't necassery to reset
it, the resetting was a poor attempt to let m_bNeedTunnel serve as a status
indicator for something it wasn't intended to indicate.
=============================================================================
cvs -f diff -kk -bp -u -r1.551.2.8 -r1.551.2.9 http.cc
Index: http.cc
===================================================================
RCS file: /home/kde/kdelibs/kioslave/http/http.cc,v
retrieving revision 1.551.2.8
retrieving revision 1.551.2.9
diff -b -p -u -r1.551.2.8 -r1.551.2.9
--- kioslave/http/http.cc	14 Feb 2003 19:50:53 -0000	1.551.2.8
+++ kioslave/http/http.cc	17 Mar 2003 14:20:31 -0000	1.551.2.9
@@ -438,7 +438,6 @@ bool HTTPProtocol::retrieveHeader( bool 
           kdDebug(7113) << "(" << m_pid << ") Unset tunneling flag!" << endl;
           setEnableSSLTunnel( false );
           m_bIsTunneled = true;
-          m_bNeedTunnel = false;
           // Reset the CONNECT response code...
           m_responseCode = m_prevResponseCode;
           continue;
@@ -1936,7 +1935,42 @@ bool HTTPProtocol::httpOpen()
   // Check the validity of the current connection, if one exists.
   httpCheckConnection();  
 
-  // Determine if this is a POST or GET method
+
+  if ( !m_bIsTunneled && m_bNeedTunnel )
+  {
+    setEnableSSLTunnel( true );
+    // We send a HTTP 1.0 header since some proxies refuse HTTP 1.1 and we don't
+    // need any HTTP 1.1 capabilities for CONNECT - Waba
+    header = QString("CONNECT %1:%2 HTTP/1.0"
+                     "\r\n").arg( m_request.hostname).arg(m_request.port);
+
+    // Identify who you are to the proxy server!
+    if (!m_request.userAgent.isEmpty())
+        header += "User-Agent: " + m_request.userAgent + "\r\n";
+
+    /* Add hostname information */
+    header += "Host: ";
+    if (m_state.hostname.find(':') != -1)
+    {
+      // This is an IPv6 (not hostname)
+      header += '[';
+      header += m_state.hostname;
+      header += ']';
+    }
+    else
+    {
+      header += m_state.hostname;
+    }
+
+    if (m_state.port != m_iDefaultPort)
+      header += QString(":%1").arg(m_state.port);
+    header += "\r\n";
+
+    header += proxyAuthenticationHeader();
+  }
+  else
+  {
+    // Determine the kind of method we are handling...
   switch (m_request.method)
   {
   case HTTP_GET:
@@ -1944,12 +1978,12 @@ bool HTTPProtocol::httpOpen()
       break;
   case HTTP_PUT:
       header = "PUT ";
-      moreData = !m_bNeedTunnel;
+        moreData = true;
       m_request.bCachedWrite = false; // Do not put any result in the cache
       break;
   case HTTP_POST:
       header = "POST ";
-      moreData = !m_bNeedTunnel;
+        moreData = true;
       m_request.bCachedWrite = false; // Do not put any result in the cache
       break;
   case HTTP_HEAD:
@@ -2033,40 +2067,6 @@ bool HTTPProtocol::httpOpen()
       return false;
   }
 
-  if ( !m_bIsTunneled && m_bNeedTunnel )
-  {
-    setEnableSSLTunnel( true );
-    // We send a HTTP 1.0 header since some proxies refuse HTTP 1.1 and we don't
-    // need any HTTP 1.1 capabilities for CONNECT - Waba
-    header = QString("CONNECT %1:%2 HTTP/1.0"
-                     "\r\n").arg( m_request.hostname).arg(m_request.port);
-
-    // Identify who you are to the proxy server!
-    if (!m_request.userAgent.isEmpty())
-        header += "User-Agent: " + m_request.userAgent + "\r\n";
-
-    /* Add hostname information */
-    header += "Host: ";
-    if (m_state.hostname.find(':') != -1)
-    {
-      // This is an IPv6 (not hostname)
-      header += '[';
-      header += m_state.hostname;
-      header += ']';
-    }
-    else
-    {
-      header += m_state.hostname;
-    }
-
-    if (m_state.port != m_iDefaultPort)
-      header += QString(":%1").arg(m_state.port);
-    header += "\r\n";
-
-    header += proxyAuthenticationHeader();
-  }
-  else
-  {
     // format the URI
     if (m_state.doProxy && !m_bIsTunneled)
     {
@@ -2271,7 +2271,6 @@ bool HTTPProtocol::httpOpen()
     // Do we need to authorize to the proxy server ?
     if ( m_state.doProxy && !m_bIsTunneled )
       header += proxyAuthenticationHeader();
-  }
 
   if ( m_protocol == "webdav" || m_protocol == "webdavs" )
   {
@@ -2289,6 +2288,7 @@ bool HTTPProtocol::httpOpen()
     // add extra header elements for WebDAV
     if ( !davHeader.isNull() )
       header += davHeader;
+    }
   }
 
   kdDebug(7103) << "(" << m_pid << ") ============ Sending Header:" << endl;
