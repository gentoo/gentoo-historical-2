Index: kpdf/part.cpp
===================================================================
--- kpdf/part.cpp	(revision 485446)
+++ kpdf/part.cpp	(revision 485447)
@@ -274,6 +274,8 @@
 	connect( m_watcher, SIGNAL( dirty( const QString& ) ), this, SLOT( slotFileDirty( const QString& ) ) );
 	m_dirtyHandler = new QTimer( this );
 	connect( m_dirtyHandler, SIGNAL( timeout() ),this, SLOT( slotDoFileDirty() ) );
+	m_saveSplitterSizeTimer = new QTimer( this );
+	connect( m_saveSplitterSizeTimer, SIGNAL( timeout() ),this, SLOT( saveSplitterSize() ) );
 
 	slotNewConfig();
 
@@ -478,7 +480,7 @@
 {
     // if pageView has been resized, save splitter sizes
     if ( watched == m_pageView && e->type() == QEvent::Resize )
-        saveSplitterSize();
+        m_saveSplitterSizeTimer->start(500, true);
 
     // only intercept events, don't block them
     return false;
Index: kpdf/part.h
===================================================================
--- kpdf/part.h	(revision 485446)
+++ kpdf/part.h	(revision 485447)
@@ -146,6 +146,11 @@
 	// static instances counter
 	static unsigned int m_count;
 
+	// this is a hack because we can not use writeConfig on part destructor
+	// and we don't want to writeconfig every time someone moves the splitter
+	// so we use a QTimer each 500 ms
+	QTimer *m_saveSplitterSizeTimer;
+
 	KDirWatch *m_watcher;
 	QTimer *m_dirtyHandler;
 	DocumentViewport m_viewportDirty;
