--- kdebase-3.4.1/kioslave/media/configure.in.in	2005-05-23 12:14:18.000000000 +0000
+++ kdebase-3.4.1/kioslave/media/configure.in.in	2005-06-26 09:44:24.000000000 +0000
@@ -12,100 +12,100 @@
 AC_ARG_WITH(hal,AC_HELP_STRING([--with-hal],[Enable HAL support  [default=check]]),[hal_test="$withval"],[hal_test="yes"])
 
 if test "x$hal_test" = "xyes" ; then
-  
-########### Check for the HAL, version 0.4.x
-  
-  AC_MSG_CHECKING(for the HAL 0.4)
-  
+
+########### Check for the HAL
+
+  AC_MSG_CHECKING(for the HAL)
+
   hal_inc=NOTFOUND
   hal_lib=NOTFOUND
   hal=NOTFOUND
-  
-  search_incs="$kde_includes /usr/include /usr/local/include /usr/include/hal /usr/local/include/hal"
+
+  search_incs="$kde_includes /usr/include /usr/include/hal /usr/local/include /usr/local/include/hal"
   AC_FIND_FILE(libhal.h libhal-storage.h, $search_incs, hal_incdir)
-  
+
   if [test -r $hal_incdir/libhal.h] && [test -r $hal_incdir/libhal-storage.h] ; then
     HAL_INCS="-I$hal_incdir"
     hal_inc=FOUND
   fi
-  
+
+  if test -r $hal_incdir/libhal-storage.h ; then
+    hal_storage_version=4
+    grep LibHalVolume $hal_incdir/libhal-storage.h \
+    > /dev/null 2>&1 && hal_storage_version=5
+    if test $hal_storage_version = 4 ; then
+      AC_DEFINE(HAL_0_4, , [HAL API version 0.4])
+    fi
+  fi
+
   search_libs="$kde_libraries /usr/lib /usr/local/lib"
   AC_FIND_FILE(libhal.so libhal-storage.so, $search_libs, hal_libdir)
-  
+
   if [test -r $hal_libdir/libhal.so] && [test -r $hal_libdir/libhal-storage.so] ; then
     HAL_LIBS="-L$hal_libdir -lhal -lhal-storage"
     hal_lib=FOUND
   fi
-  
-  if test -r $hal_incdir/libhal.h ; then
-    hal_version=5
-    grep LibHalFunctions $hal_incdir/libhal.h \
-    > /dev/null 2>&1 && hal_version=4
-    if test $hal_version = 5 ; then
-      hal_lib=NOT_FOUND
-    fi
-  fi
-				
-  
+
+
   if [test $hal_inc = FOUND] && [test $hal_lib = FOUND] ; then
       AC_MSG_RESULT(headers $hal_incdir  libraries $hal_libdir)
   	hal=FOUND
   else
       AC_MSG_RESULT(searched but not found)
   fi
-  
+
   AC_SUBST(HAL_INCS)
   AC_SUBST(HAL_LIBS)
-  
-  
+
+
 ########### Check for DBus
-  
+
   AC_MSG_CHECKING(for DBus)
-  
+
   dbus_inc=NOTFOUND
   dbus_lib=NOTFOUND
   dbus=NOTFOUND
-  
-  search_incs="$kde_includes /usr/include /usr/local/include /usr/include/dbus-1.0 /usr/local/include/dbus-1.0"
+
+  search_incs="$kde_includes /usr/include /usr/include/dbus-1.0 /usr/local/include /usr/local/include/dbus-1.0"
   AC_FIND_FILE(dbus/dbus.h, $search_incs, dbus_incdir)
-  
+
   search_incs_arch_deps="$kde_includes /usr/lib/dbus-1.0/include /usr/local/lib/dbus-1.0/include"
   AC_FIND_FILE(dbus/dbus-arch-deps.h, $search_incs_arch_deps, dbus_incdir_arch_deps)
-  
+
   if [test -r $dbus_incdir/dbus/dbus.h] && [test -r $dbus_incdir_arch_deps/dbus/dbus-arch-deps.h] ; then
     DBUS_INCS="-I$dbus_incdir -I$dbus_incdir_arch_deps"
     dbus_inc=FOUND
   fi
-  
+
   search_libs="$kde_libraries /usr/lib /usr/local/lib"
   AC_FIND_FILE(libdbus-1.so, $search_libs, dbus_libdir)
-  
+
   if test -r $dbus_libdir/libdbus-1.so ; then
     DBUS_LIBS="-L$dbus_libdir -ldbus-1"
     dbus_lib=FOUND
   fi
-  
+
   if [test $dbus_inc = FOUND] && [test $dbus_lib = FOUND] ; then
     AC_MSG_RESULT(headers $dbus_incdir $dbus_incdir_arch_deps  libraries $dbus_libdir)
     dbus=FOUND
   else
     AC_MSG_RESULT(searched but not found)
   fi
-  
+
   AC_SUBST(DBUS_INCS)
   AC_SUBST(DBUS_LIBS)
-  
+
 ########### Check for DBus-Qt bindings
-  
+
   AC_MSG_CHECKING(for DBus-Qt bindings)
-  
+
   dbusqt_inc=NOTFOUND
   dbusqt_lib=NOTFOUND
   dbusqt=NOTFOUND
-  
-  search_incs="$kde_includes /usr/include /usr/local/include /usr/include/dbus-1.0 /usr/local/include/dbus-1.0"
+
+  search_incs="$kde_includes /usr/include /usr/include/dbus-1.0 /usr/local/include /usr/local/include/dbus-1.0"
   AC_FIND_FILE(dbus/connection.h, $search_incs, dbusqt_incdir)
-  
+
   if test -r $dbusqt_incdir/dbus/connection.h ; then
     have_qt_patch=0
     grep dbus_connection_setup_with_qt_main $dbusqt_incdir/dbus/connection.h \
@@ -115,15 +115,15 @@
       dbusqt_inc=FOUND
     fi
   fi
-  
+
   search_libs="$kde_libraries /usr/lib /usr/local/lib"
   AC_FIND_FILE(libdbus-qt-1.so, $search_libs, dbusqt_libdir)
-  
+
   if test -r $dbusqt_libdir/libdbus-qt-1.so ; then
     DBUSQT_LIBS="-L$dbusqt_libdir -ldbus-qt-1"
     dbusqt_lib=FOUND
   fi
-  
+
   if [test $dbusqt_inc = FOUND] && [test $dbusqt_lib = FOUND] ; then
     AC_MSG_RESULT(headers $dbusqt_incdir libraries $dbusqt_libdir)
     dbusqt=FOUND
--- kdebase-3.4.1/kioslave/media/kdedmodule/Makefile.am	2005-05-23 12:14:18.000000000 +0000
+++ kdebase-3.4.1/kioslave/media/kdedmodule/Makefile.am	2005-06-30 08:14:14.000000000 +0000
@@ -22,7 +22,7 @@
 
 noinst_LTLIBRARIES = $(LINUXCDPOLLING_LIB) $(HALBACKEND_LIB)
 
-kded_mediamanager_la_SOURCES = mediamanager.cpp mediamanager.skel medialist.cpp backendbase.cpp fstabbackend.cpp removablebackend.cpp mediadirnotify.cpp mediadirnotify.skel
+kded_mediamanager_la_SOURCES = mediamanager.cpp mediamanager.skel medialist.cpp backendbase.cpp fstabbackend.cpp haladdition.cpp removablebackend.cpp mediadirnotify.cpp mediadirnotify.skel
 kded_mediamanager_la_LDFLAGS = $(all_libraries) -module -avoid-version
 kded_mediamanager_la_LIBADD = $(LIB_KSYCOCA) ../libmediacommon/libmediacommon.la $(HALBACKEND_LIB) $(LINUXCDPOLLING_LIB)
 
--- kdebase-3.4.1/kioslave/media/kdedmodule/mediamanager.cpp	2005-05-23 12:14:18.000000000 +0000
+++ kdebase-3.4.1/kioslave/media/kdedmodule/mediamanager.cpp	2005-06-30 08:14:33.000000000 +0000
@@ -31,6 +31,7 @@
 
 #ifdef COMPILE_HALBACKEND
 #include "halbackend.h"
+#include "haladdition.h"
 #endif //COMPILE_HALBACKEND
 
 #ifdef COMPILE_LINUXCDPOLLING
@@ -60,8 +61,10 @@
 
 #ifdef COMPILE_HALBACKEND
 	HALBackend* halBackend = new HALBackend(m_mediaList, this);
-	if (halBackend->InitHal())
+	if (halBackend->InitHal()) {
 		m_backends.append( halBackend );
+		m_backends.append( new HalAddition(m_mediaList) );
+	}
 	else
 	{
 		delete halBackend;
--- /dev/null	2005-06-16 20:07:09.000000000 +0000
+++ kdebase-3.4.1/kioslave/media/kdedmodule/haladdition.h	2005-07-03 20:29:20.000000000 +0000
@@ -0,0 +1,49 @@
+/* This file is part of the KDE Project
+   Copyright (c) 2004 Kévin Ottens <ervin ipsquad net>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef _HALADDITION_H_
+#define _HALADDITION_H_
+
+#include "backendbase.h"
+
+#include <qobject.h>
+#include <qstringlist.h>
+#include <kmountpoint.h>
+
+class HalAddition : public QObject, public BackendBase
+{
+Q_OBJECT
+
+public:
+	HalAddition(MediaList &list);
+	virtual ~HalAddition() {};
+
+	static void guess(const QString &devNode, const QString &mountPoint,
+                          const QString &fsType, bool mounted,
+                          QString &mimeType, QString &iconName,
+	                  QString &label);
+private slots:
+	void slotDirty(const QString &path);
+
+private:
+	void handleMtabChange();
+        QStringList m_mtabIds;
+		
+};
+
+#endif
--- /dev/null	2005-06-16 20:07:09.000000000 +0000
+++ kdebase-3.4.1/kioslave/media/kdedmodule/haladdition.cpp	2005-07-03 21:08:11.000000000 +0000
@@ -0,0 +1,155 @@
+/* This file is part of the KDE Project
+   Copyright (c) 2004 Kévin Ottens <ervin ipsquad net>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#include "haladdition.h"
+
+#include <klocale.h>
+#include <kdirwatch.h>
+#include <kurl.h>
+#include <kstandarddirs.h>
+
+#ifdef _OS_SOLARIS_
+#define MTAB "/etc/mnttab"
+#else
+#define MTAB "/etc/mtab"
+#endif
+
+
+HalAddition::HalAddition(MediaList &list)
+	: QObject(), BackendBase(list)
+{
+	KDirWatch::self()->addFile(MTAB);
+
+	connect( KDirWatch::self(), SIGNAL( dirty(const QString&) ),
+	         this, SLOT( slotDirty(const QString&) ) );
+
+	handleMtabChange();
+
+	KDirWatch::self()->startScan();
+}
+
+void HalAddition::slotDirty(const QString &path)
+{
+	if (path==MTAB)
+	{
+		handleMtabChange();
+	}
+}
+
+void HalAddition::handleMtabChange()
+{
+	QStringList new_mtabIds;
+	KMountPoint::List mtab = KMountPoint::currentMountPoints();
+
+	KMountPoint::List::iterator it = mtab.begin();
+	KMountPoint::List::iterator end = mtab.end();
+
+	for (; it!=end; ++it)
+	{
+		QString dev = (*it)->mountedFrom();
+		QString mp = (*it)->mountPoint();
+		QString fs = (*it)->mountType();
+
+		if ( mp == "/"
+		  || mp.find("/media/floppy") != -1
+	          || mp.find("/media/zip") != -1
+		  || mp.find("/media/jaz") != -1
+		   ) 
+		{
+			QString device;
+			const Medium *medium;
+		     	
+			device = dev;
+			device.replace("/dev/", "");
+
+			if (medium = m_mediaList.findByName(device))
+			{
+				QString mime, icon, label;
+				guess(dev, mp, fs, true, mime, icon, label);
+				m_mediaList.changeMediumState(medium->id(), dev, mp, fs, true, mime, icon, medium->label());
+				new_mtabIds += device;
+			}
+		}
+	}
+        
+	QStringList::iterator it2 = m_mtabIds.begin();
+	QStringList::iterator end2 = m_mtabIds.end();
+
+	for (; it2!=end2; ++it2)
+	{
+		if ( !new_mtabIds.contains(*it2) )
+		{
+			const Medium *medium;
+
+			if (medium = m_mediaList.findByName(*it2))
+			{
+				QString dev = medium->deviceNode();
+				QString mp = medium->mountPoint();
+				QString fs = medium->fsType();
+				QString mime, icon, label;
+				
+		  		guess(dev, mp, fs, false, mime, icon, label);
+				m_mediaList.changeMediumState(medium->id(), false, mime, icon, medium->label());
+			}
+		}
+	}
+	m_mtabIds = new_mtabIds;
+}
+
+void HalAddition::guess(const QString &devNode, const QString &mountPoint,
+                         const QString &fsType, bool mounted,
+                         QString &mimeType, QString &iconName, QString &label)
+{
+	if ( devNode.find("fd")!=-1 )
+	{
+		if ( devNode.find("360")!=-1 || devNode.find("1200")!=-1 )
+		{
+			mimeType = "media/floppy5";
+		}
+		else
+		{
+			mimeType = "media/floppy";
+		}
+		label = i18n("Floppy");
+	}
+	else if ( mountPoint.find("zip")!=-1
+	       || mountPoint.find("jaz")!=-1
+	       // FREEBSD SPECIFIC
+	       || devNode.find("/afd")!=-1
+	        )
+	{
+		mimeType = "media/zip";
+		label = i18n("Zip Disk");
+	}
+	else
+	{
+		mimeType = "media/hdd";
+		label = i18n("Harddisk");
+	}
+
+	QString tmp = devNode;
+	if ( tmp.startsWith("/dev/") )
+	{
+		tmp = tmp.mid(5);
+	}
+	label+= " (" + tmp + ")";
+	mimeType+= (mounted ? "_mounted" : "_unmounted");
+	iconName = QString::null;
+}
+
+#include "haladdition.moc"
--- kdebase-3.4.1/kioslave/media/kdedmodule/halbackend.cpp	2005-05-23 12:14:18.000000000 +0000
+++ kdebase-3.4.1/kioslave/media/kdedmodule/halbackend.cpp	2005-07-03 20:23:51.000000000 +0000
@@ -1,5 +1,5 @@
 /* This file is part of the KDE Project
-   Copyright (c) 2004 Jérôme Lodewyck <lodewyck@clipper.ens.fr>
+   Copyright (c) 2004 - 2005 JÃ©rÃ´me Lodewyck <lodewyck@clipper.ens.fr>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -19,11 +19,13 @@
 #include "halbackend.h"
 #include "linuxcdpolling.h"
 
+#include <stdlib.h>
+
 #include <klocale.h>
 #include <kurl.h>
 #include <kdebug.h>
 
-#define MOUNT_SUFFIX	(hal_volume_is_mounted(halVolume) ? QString("_mounted") : QString("_unmounted"))
+#define MOUNT_SUFFIX	(libhal_volume_is_mounted(halVolume) ? QString("_mounted") : QString("_unmounted"))
 
 /* Static instance of this class, for static HAL callbacks */
 static HALBackend* s_HALBackend;
@@ -33,9 +35,9 @@
 {
 	char*   _ppt_string;
 	QString _ppt_QString;
-	_ppt_string = hal_device_get_property_string(ctx, udi, key);
+	_ppt_string = libhal_device_get_property_string(ctx, udi, key, NULL);
 	_ppt_QString = QString(_ppt_string ? _ppt_string : "");
-	hal_free_string(_ppt_string);
+	libhal_free_string(_ppt_string);
 	return _ppt_QString;
 }
 
@@ -55,14 +57,24 @@
 {
 	/* Close HAL connection */
 	if (m_halContext)
+	{
+		#ifdef HAL_0_4
 		hal_shutdown(m_halContext);
+		#else
+		libhal_ctx_shutdown(m_halContext, NULL);
+		libhal_ctx_free(m_halContext);
+		#endif
+	}
 	if (m_halStoragePolicy)
-		hal_storage_policy_free(m_halStoragePolicy);
+		libhal_storage_policy_free(m_halStoragePolicy);
+
+	/** @todo empty media list ? */
 }
 
 /* Connect to the HAL */
 bool HALBackend::InitHal()
 {
+#ifdef HAL_0_4 /* HAL API 0.4 */
 	/* libhal initialization */
 	m_halFunctions.main_loop_integration	= HALBackend::hal_main_loop_integration;
 	m_halFunctions.device_added				= HALBackend::hal_device_added;
@@ -75,19 +87,72 @@
 	m_halContext = hal_initialize(&m_halFunctions, FALSE);
 	if (!m_halContext)
 	{
-		kdDebug()<<"Failed to initialize HAL!"<<endl;
+		kdDebug() << "Failed to initialize HAL!" << endl;
 		return false;
 	}
 
 	/** @todo customize watch policy */
-	if (hal_device_property_watch_all(m_halContext))
+	kdDebug() << "Watch properties" << endl;
+	if (libhal_device_property_watch_all(m_halContext, NULL))
+	{
+		kdDebug() << "Failed to watch HAL properties!" << endl;
+		return false;
+	}
+#else /* HAL API >= 0.5 */
+	kdDebug() << "Context new" << endl;
+	m_halContext = libhal_ctx_new();
+	if (!m_halContext)
 	{
-		kdDebug()<<"Failed to watch HAL properties!"<<endl;
+		kdDebug() << "Failed to initialize HAL!" << endl;
+		return false;
+	}
+
+	// Main loop integration
+	kdDebug() << "Main loop integration" << endl;
+	DBusError error;
+	dbus_error_init(&error);
+	DBusConnection *dbus_connection = dbus_bus_get(DBUS_BUS_SYSTEM, &error);
+	if (dbus_error_is_set(&error)) {
+		dbus_error_free(&error);
+		libhal_ctx_free(m_halContext);
+		m_halContext = NULL;
 		return false;
 	}
+	MainLoopIntegration(dbus_connection);
+	libhal_ctx_set_dbus_connection(m_halContext, dbus_connection);
+
+	// HAL callback functions
+	kdDebug() << "Callback functions" << endl;
+	libhal_ctx_set_device_added(m_halContext, HALBackend::hal_device_added);
+	libhal_ctx_set_device_removed(m_halContext, HALBackend::hal_device_removed);
+	libhal_ctx_set_device_new_capability (m_halContext, NULL);
+	libhal_ctx_set_device_lost_capability (m_halContext, NULL);
+	libhal_ctx_set_device_property_modified (m_halContext, HALBackend::hal_device_property_modified);
+	libhal_ctx_set_device_condition(m_halContext, HALBackend::hal_device_condition);
+
+	kdDebug() << "Context Init" << endl;
+	if (!libhal_ctx_init(m_halContext, &error))
+	{
+		if (dbus_error_is_set(&error))
+			dbus_error_free(&error);
+		libhal_ctx_free(m_halContext);
+		m_halContext = NULL;
+		kdDebug() << "Failed to init HAL context!" << endl;
+		return false;
+	}
+
+	/** @todo customize watch policy */
+	kdDebug() << "Watch properties" << endl;
+	if (!libhal_device_property_watch_all(m_halContext, &error))
+	{
+		kdDebug() << "Failed to watch HAL properties!" << endl;
+		return false;
+	}
+#endif
 
 	/* libhal-storage initialization */
-	m_halStoragePolicy = hal_storage_policy_new();
+	kdDebug() << "Storage Policy" << endl;
+	m_halStoragePolicy = libhal_storage_policy_new();
 	/** @todo define libhal-storage icon policy */
 
 	/* List devices at startup */
@@ -97,8 +162,10 @@
 /* List devices (at startup)*/
 bool HALBackend::ListDevices()
 {
+	kdDebug() << "ListDevices" << endl;
+
 	int numDevices;
-	char** halDeviceList = hal_get_all_devices(m_halContext, &numDevices);
+	char** halDeviceList = libhal_get_all_devices(m_halContext, &numDevices, NULL);
 
 	if (!halDeviceList)
 		return false;
@@ -116,7 +183,7 @@
 {
 	/* We don't deal with devices that do not expose their capabilities.
 	If we don't check this, we will get a lot of warning messages from libhal */
-	if (!hal_device_property_exists(m_halContext, udi, "info.capabilities"))
+	if (!libhal_device_property_exists(m_halContext, udi, "info.capabilities", NULL))
 		return;
 
 	/* If the device is already listed, do not process.
@@ -126,17 +193,18 @@
 		return;
 
 	/* Add volume block devices */
-	if (hal_device_query_capability(m_halContext, udi, "volume"))
+	if (libhal_device_query_capability(m_halContext, udi, "volume", NULL))
 	{
 		/* We only list volume that have a filesystem or volume that have an audio track*/
 		if ( (hal_device_get_property_QString(m_halContext, udi, "volume.fsusage") != "filesystem") &&
-		     (!hal_device_get_property_bool(m_halContext, udi, "volume.disc.has_audio")) )
+		     (!libhal_device_get_property_bool(m_halContext, udi, "volume.disc.has_audio", NULL)) )
 			return;
 		/* Query drive udi */
 		QString driveUdi = hal_device_get_property_QString(m_halContext, udi, "block.storage_device");
 		/* We don't list floppy volumes because we list floppy drives */
 		if ((hal_device_get_property_QString(m_halContext, driveUdi.ascii(), "storage.drive_type") == "floppy") ||
-		    (hal_device_get_property_QString(m_halContext, driveUdi.ascii(), "storage.drive_type") == "zip"))
+		    (hal_device_get_property_QString(m_halContext, driveUdi.ascii(), "storage.drive_type") == "zip") ||
+		    (hal_device_get_property_QString(m_halContext, driveUdi.ascii(), "storage.drive_type") == "jaz"))
 			return;
 
 		/** @todo check exclusion list **/
@@ -148,11 +216,12 @@
 
 		return;
 	}
-
+	
 	/* Floppy & zip drives */
-	if (hal_device_query_capability(m_halContext, udi, "storage"))
+	if (libhal_device_query_capability(m_halContext, udi, "storage", NULL))
 		if ((hal_device_get_property_QString(m_halContext, udi, "storage.drive_type") == "floppy") ||
-		    (hal_device_get_property_QString(m_halContext, udi, "storage.drive_type") == "zip"))
+		    (hal_device_get_property_QString(m_halContext, udi, "storage.drive_type") == "zip") ||
+		    (hal_device_get_property_QString(m_halContext, udi, "storage.drive_type") == "jaz"))
 		{
 			/* Create medium */
 			Medium* medium = new Medium(udi, "");
@@ -162,7 +231,7 @@
 		}
 
 	/* Camera handled by gphoto2*/
-	if (hal_device_query_capability(m_halContext, udi, "camera"))
+	if (libhal_device_query_capability(m_halContext, udi, "camera", NULL))
 
 		{
 			/* Create medium */
@@ -180,9 +249,14 @@
 
 void HALBackend::ModifyDevice(const char *udi, const char* key)
 {
-	Q_UNUSED(udi);
+	const char* mediumUdi = findMediumUdiFromUdi(udi);
+	if (!mediumUdi)
+		return;
+	ResetProperties(mediumUdi); 
+
 	Q_UNUSED(key);
 /*
+	Q_UNUSED(udi);
 	TODO: enable this when the watch policy is written
 */
 }
@@ -229,8 +303,8 @@
 		return medium->id().ascii();
 
 	/* Hard part : this is a volume whose drive is registered */
-	if (hal_device_property_exists(m_halContext, udi, "info.capabilities"))
-		if (hal_device_query_capability(m_halContext, udi, "volume"))
+	if (libhal_device_property_exists(m_halContext, udi, "info.capabilities", NULL))
+		if (libhal_device_query_capability(m_halContext, udi, "volume", NULL))
 		{
 			QString driveUdi = hal_device_get_property_QString(m_halContext, udi, "block.storage_device");
 			return findMediumUdiFromUdi(driveUdi.ascii());
@@ -244,11 +318,11 @@
 	kdDebug() << "HALBackend::setProperties" << endl;
 
 	Medium* m = new Medium(mediumUdi, "");
-	if (hal_device_query_capability(m_halContext, mediumUdi, "volume"))
+	if (libhal_device_query_capability(m_halContext, mediumUdi, "volume", NULL))
 		setVolumeProperties(m);
-	if (hal_device_query_capability(m_halContext, mediumUdi, "storage"))
+	if (libhal_device_query_capability(m_halContext, mediumUdi, "storage", NULL))
 		setFloppyProperties(m);
-	if (hal_device_query_capability(m_halContext, mediumUdi, "camera"))
+	if (libhal_device_query_capability(m_halContext, mediumUdi, "camera", NULL))
 		setCameraProperties(m);
 
 	m_mediaList.changeMediumState(*m);
@@ -262,34 +336,35 @@
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
-	if (!hal_device_exists(m_halContext, udi))
+	if (!libhal_device_exists(m_halContext, udi, NULL))
 			return;
 
 	/* Get device information from libhal-storage */
-	HalVolume* halVolume = hal_volume_from_udi(m_halContext, udi);
+	LibHalVolume* halVolume = libhal_volume_from_udi(m_halContext, udi);
 	if (!halVolume)
 		return;
-
-	QString driveUdi = hal_volume_get_storage_device_udi(halVolume);
-	HalDrive*  halDrive  = hal_drive_from_udi(m_halContext, driveUdi.ascii());
+	QString driveUdi = libhal_volume_get_storage_device_udi(halVolume);
+	LibHalDrive*  halDrive  = libhal_drive_from_udi(m_halContext, driveUdi.ascii());
 
 	medium->setName(
-		generateName(hal_volume_get_device_file(halVolume)) );
+		generateName(libhal_volume_get_device_file(halVolume)) );
 
 	medium->mountableState(
-		hal_volume_get_device_file(halVolume),		/* Device node */
-		hal_volume_get_mount_point(halVolume),		/* Mount point */
-		hal_volume_get_fstype(halVolume),			/* Filesystem type */
-		hal_volume_is_mounted(halVolume) );			/* Mounted ? */
+		libhal_volume_get_device_file(halVolume),		/* Device node */
+		libhal_volume_get_mount_point(halVolume),		/* Mount point */
+		libhal_volume_get_fstype(halVolume),			/* Filesystem type */
+		libhal_volume_is_mounted(halVolume) );			/* Mounted ? */
 
 	QString mimeType;
-	if (hal_volume_is_disc(halVolume))
+	if (libhal_volume_is_disc(halVolume))
 	{
 		mimeType = "media/cdrom" + MOUNT_SUFFIX;
 
-		HalVolumeDiscType discType = hal_volume_get_disc_type(halVolume);
-		if ((discType == HAL_VOLUME_DISC_TYPE_CDR) || (discType == HAL_VOLUME_DISC_TYPE_CDRW))
-			if (hal_volume_disc_is_blank(halVolume))
+		LibHalVolumeDiscType discType = libhal_volume_get_disc_type(halVolume);
+		if ((discType == LIBHAL_VOLUME_DISC_TYPE_CDROM) ||
+		    (discType == LIBHAL_VOLUME_DISC_TYPE_CDR) ||
+			(discType == LIBHAL_VOLUME_DISC_TYPE_CDRW))
+			if (libhal_volume_disc_is_blank(halVolume))
 			{
 				mimeType = "media/blankcd";
 				medium->unmountableState("");
@@ -297,10 +372,10 @@
 			else
 				mimeType = "media/cdwriter" + MOUNT_SUFFIX;
 
-		if ((discType == HAL_VOLUME_DISC_TYPE_DVDROM) || (discType == HAL_VOLUME_DISC_TYPE_DVDRAM) ||
-			(discType == HAL_VOLUME_DISC_TYPE_DVDR) || (discType == HAL_VOLUME_DISC_TYPE_DVDRW) ||
-			(discType == HAL_VOLUME_DISC_TYPE_DVDPLUSR) || (discType == HAL_VOLUME_DISC_TYPE_DVDPLUSRW) )
-			if (hal_volume_disc_is_blank(halVolume))
+		if ((discType == LIBHAL_VOLUME_DISC_TYPE_DVDROM) || (discType == LIBHAL_VOLUME_DISC_TYPE_DVDRAM) ||
+			(discType == LIBHAL_VOLUME_DISC_TYPE_DVDR) || (discType == LIBHAL_VOLUME_DISC_TYPE_DVDRW) ||
+			(discType == LIBHAL_VOLUME_DISC_TYPE_DVDPLUSR) || (discType == LIBHAL_VOLUME_DISC_TYPE_DVDPLUSRW) )
+			if (libhal_volume_disc_is_blank(halVolume))
 			{
 				mimeType = "media/blankdvd";
 				medium->unmountableState("");
@@ -308,16 +383,16 @@
 			else
 				mimeType = "media/dvd" + MOUNT_SUFFIX;
 
-		if (hal_volume_disc_has_audio(halVolume) && !hal_volume_disc_has_data(halVolume))
+		if (libhal_volume_disc_has_audio(halVolume) && !libhal_volume_disc_has_data(halVolume))
 		{
 			mimeType = "media/audiocd";
-			medium->unmountableState( "audiocd:/?device=" + QString(hal_volume_get_device_file(halVolume)) );
+			medium->unmountableState( "audiocd:/?device=" + QString(libhal_volume_get_device_file(halVolume)) );
 		}
 
 		medium->setIconName(QString::null);
-		
+
 		/* check if the disc id a vcd or a video dvd */
-		DiscType type = LinuxCDPolling::identifyDiscType(hal_volume_get_device_file(halVolume));
+		DiscType type = LinuxCDPolling::identifyDiscType(libhal_volume_get_device_file(halVolume));
 		switch (type)
 		{
 		  case DiscType::VCD:
@@ -334,44 +409,48 @@
 	else
 	{
 		mimeType = "media/hdd" + MOUNT_SUFFIX;
-		if (hal_drive_is_hotpluggable(halDrive))
-		{		
+		if (libhal_drive_is_hotpluggable(halDrive))
+		{
 			mimeType = "media/removable" + MOUNT_SUFFIX;
 			medium->needMounting();
-			switch (hal_drive_get_type(halDrive)) {
-			case HAL_DRIVE_TYPE_COMPACT_FLASH:
+			switch (libhal_drive_get_type(halDrive)) {
+			case LIBHAL_DRIVE_TYPE_COMPACT_FLASH:
 				medium->setIconName("compact_flash" + MOUNT_SUFFIX);
 				break;
-			case HAL_DRIVE_TYPE_MEMORY_STICK:
+			case LIBHAL_DRIVE_TYPE_MEMORY_STICK:
 				medium->setIconName("memory_stick" + MOUNT_SUFFIX);
 				break;
-			case HAL_DRIVE_TYPE_SMART_MEDIA:
+			case LIBHAL_DRIVE_TYPE_SMART_MEDIA:
 				medium->setIconName("smart_media" + MOUNT_SUFFIX);
 				break;
-			case HAL_DRIVE_TYPE_SD_MMC:
+			case LIBHAL_DRIVE_TYPE_SD_MMC:
 				medium->setIconName("sd_mmc" + MOUNT_SUFFIX);
 				break;
-			case HAL_DRIVE_TYPE_PORTABLE_AUDIO_PLAYER:
+			case LIBHAL_DRIVE_TYPE_PORTABLE_AUDIO_PLAYER:
 				medium->setIconName(QString::null); //FIXME need icon
 				break;
-			case HAL_DRIVE_TYPE_CAMERA:
+			case LIBHAL_DRIVE_TYPE_CAMERA:
 				medium->setIconName("camera" + MOUNT_SUFFIX);
-				break;			
-			case HAL_DRIVE_TYPE_TAPE:
+				break;
+			case LIBHAL_DRIVE_TYPE_TAPE:
 				medium->setIconName(QString::null); //FIXME need icon
-				break;			
-			default:	
+				break;
+			default:
 				medium->setIconName(QString::null);
 			};
 		};
 	}
 	medium->setMimeType(mimeType);
 
-	medium->setLabel(QString::fromUtf8( hal_volume_policy_compute_display_name(halDrive,
-		halVolume, m_halStoragePolicy) ) );
+	char* name = libhal_volume_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy);
+	//char* name = libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy);
+	QString volume_name = QString::fromUtf8(name);
+	QString media_name = volume_name;
+	medium->setLabel(media_name);
+	free(name);
 
-	hal_drive_free(halDrive);
-	hal_volume_free(halVolume);
+	libhal_drive_free(halDrive);
+	libhal_volume_free(halVolume);
 }
 
 // Handle floppies and zip drives
@@ -381,34 +460,34 @@
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
-	if (!hal_device_exists(m_halContext, udi))
+	if (!libhal_device_exists(m_halContext, udi, NULL))
 		return;
 
-	HalDrive*  halDrive  = hal_drive_from_udi(m_halContext, udi);
+	LibHalDrive*  halDrive  = libhal_drive_from_udi(m_halContext, udi);
 	if (!halDrive)
 		return;
 	int numVolumes;
-	char** volumes = hal_drive_find_all_volumes(m_halContext, halDrive, &numVolumes);
-	HalVolume* halVolume = NULL;
+	char** volumes = libhal_drive_find_all_volumes(m_halContext, halDrive, &numVolumes);
+	LibHalVolume* halVolume = NULL;
 	kdDebug() << " found " << numVolumes << " volumes" << endl;
 	if (numVolumes)
-		halVolume = hal_volume_from_udi(m_halContext, volumes[0]);
+		halVolume = libhal_volume_from_udi(m_halContext, volumes[0]);
 
 	medium->setName(
-		generateName(hal_drive_get_device_file(halDrive)) );
+		generateName(libhal_drive_get_device_file(halDrive)) );
 
 	if (halVolume)
 	{
 		medium->mountableState(
-			hal_volume_get_device_file(halVolume),		/* Device node */
-			hal_volume_get_mount_point(halVolume),		/* Mount point */
-			hal_volume_get_fstype(halVolume),			/* Filesystem type */
-			hal_volume_is_mounted(halVolume) );			/* Mounted ? */
+			libhal_volume_get_device_file(halVolume),		/* Device node */
+			libhal_volume_get_mount_point(halVolume),		/* Mount point */
+			libhal_volume_get_fstype(halVolume),			/* Filesystem type */
+			libhal_volume_is_mounted(halVolume) );			/* Mounted ? */
 	}
 	else
 	{
 		medium->mountableState(
-			hal_drive_get_device_file(halDrive),		/* Device node */
+			libhal_drive_get_device_file(halDrive),		/* Device node */
 			"",											/* Mount point */
 			"",											/* Filesystem type */
 			false );									/* Mounted ? */
@@ -421,7 +500,7 @@
 		else
 			medium->setMimeType("media/floppy_unmounted");
 	}
-	
+
 	if (hal_device_get_property_QString(m_halContext, udi, "storage.drive_type") == "zip")
 	{
 		if (halVolume)
@@ -429,14 +508,29 @@
 		else
 			medium->setMimeType("media/zip_unmounted");
 	}
-	
+
 	medium->setIconName(QString::null);
 
-	medium->setLabel(QString::fromUtf8( hal_drive_policy_compute_display_name(halDrive,
-		halVolume, m_halStoragePolicy) ) );
+	QString media_name;
+	if (halVolume)
+	{
+		char* name = libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy);
+		QString volume_name = QString::fromUtf8(name);
+		media_name = volume_name;
+		free(name);
+	}
+	else
+	{
+		char* name = libhal_drive_policy_compute_display_name(halDrive, halVolume, m_halStoragePolicy);
+		QString drive_name =  QString::fromUtf8(name);
+		media_name = drive_name;
+		free(name);
+	}
+	medium->setLabel(media_name);
 
-	hal_drive_free(halDrive);
-	hal_volume_free(halVolume);
+	free(volumes);
+	libhal_drive_free(halDrive);
+	libhal_volume_free(halVolume);
 }
 
 void HALBackend::setCameraProperties(Medium* medium)
@@ -445,7 +539,7 @@
 
 	const char* udi = medium->id().ascii();
 	/* Check if the device still exists */
-	if (!hal_device_exists(m_halContext, udi))
+	if (!libhal_device_exists(m_halContext, udi, NULL))
 		return;
 
 	/** @todo find name */
@@ -467,6 +561,7 @@
 ** HAL CALL-BACKS                        **
 ******************************************/
 
+#ifdef HAL_0_4
 void HALBackend::hal_main_loop_integration(LibHalContext *ctx,
 			DBusConnection *dbus_connection)
 {
@@ -474,6 +569,7 @@
 	Q_UNUSED(ctx);
 	s_HALBackend->MainLoopIntegration(dbus_connection);
 }
+#endif
 
 void HALBackend::hal_device_added(LibHalContext *ctx, const char *udi)
 {
@@ -498,8 +594,15 @@
 	Q_UNUSED(is_added);
 	s_HALBackend->ModifyDevice(udi, key);
 }
+
 void HALBackend::hal_device_condition(LibHalContext *ctx, const char *udi,
-			const char *condition_name, DBusMessage *message)
+			const char *condition_name,
+			#ifdef HAL_0_4
+			DBusMessage *message
+			#else
+			const char* message
+			#endif
+			)
 {
 	kdDebug() << "HALBackend::hal_device_condition " << udi << " -- " << condition_name << endl;
 	Q_UNUSED(ctx);
--- kdebase-3.4.1/kioslave/media/kdedmodule/halbackend.h	2005-05-23 12:14:18.000000000 +0000
+++ kdebase-3.4.1/kioslave/media/kdedmodule/halbackend.h	2005-06-30 08:20:11.000000000 +0000
@@ -35,6 +35,8 @@
 #include <qstringlist.h>
 #include <qstring.h>
 
+#include <config.h>
+
 /* We acknowledge the the dbus API is unstable */
 #define DBUS_API_SUBJECT_TO_CHANGE
 /* DBus-Qt bindings */
@@ -43,6 +45,65 @@
 #include <libhal.h>
 #include <libhal-storage.h>
 
+/* The HAL API changed between 0.4 and 0.5 series.
+These defines enable backward compatibility */
+#ifdef HAL_0_4
+	// libhal-storage 0.4 API
+	#define LibHalStoragePolicy				HalStoragePolicy
+	#define LibHalDrive						HalDrive
+	#define LibHalVolume					HalVolume
+	#define LibHalVolumeDiscType			HalVolumeDiscType
+	#define libhal_storage_policy_free		hal_storage_policy_free
+	#define libhal_storage_policy_new		hal_storage_policy_new
+	#define libhal_drive_from_udi			hal_drive_from_udi
+	#define libhal_drive_find_all_volumes	hal_drive_find_all_volumes
+	#define libhal_drive_get_type			hal_drive_get_type
+	#define libhal_drive_get_device_file	hal_drive_get_device_file
+	#define libhal_drive_free				hal_drive_free
+	#define libhal_drive_policy_compute_display_name	hal_drive_policy_compute_display_name
+	#define libhal_drive_is_hotpluggable	hal_drive_is_hotpluggable
+	#define libhal_volume_from_udi			hal_volume_from_udi
+	#define libhal_volume_get_device_file	hal_volume_get_device_file
+	#define libhal_volume_get_mount_point	hal_volume_get_mount_point
+	#define libhal_volume_get_fstype		hal_volume_get_fstype
+	#define libhal_volume_is_mounted		hal_volume_is_mounted
+	#define libhal_volume_get_disc_type		hal_volume_get_disc_type
+	#define libhal_volume_free				hal_volume_free
+	#define libhal_volume_policy_compute_display_name	hal_volume_policy_compute_display_name
+	#define libhal_volume_disc_has_data		hal_volume_disc_has_data
+	#define libhal_volume_disc_has_audio	hal_volume_disc_has_audio
+	#define libhal_volume_disc_is_blank		hal_volume_disc_is_blank
+	#define libhal_volume_is_disc			hal_volume_is_disc
+	#define libhal_volume_get_storage_device_udi	hal_volume_get_storage_device_udi
+	#define LIBHAL_VOLUME_DISC_TYPE_CDROM		HAL_VOLUME_DISC_TYPE_CDROM
+	#define LIBHAL_VOLUME_DISC_TYPE_CDR			HAL_VOLUME_DISC_TYPE_CDR
+	#define LIBHAL_VOLUME_DISC_TYPE_CDRW		HAL_VOLUME_DISC_TYPE_CDRW
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDROM		HAL_VOLUME_DISC_TYPE_DVDROM
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDRAM		HAL_VOLUME_DISC_TYPE_DVDRAM
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDR		HAL_VOLUME_DISC_TYPE_DVDR
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDRW		HAL_VOLUME_DISC_TYPE_DVDRW
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDPLUSR	HAL_VOLUME_DISC_TYPE_DVDPLUSR
+	#define LIBHAL_VOLUME_DISC_TYPE_DVDPLUSRW	HAL_VOLUME_DISC_TYPE_DVDPLUSRW
+	#define LIBHAL_DRIVE_TYPE_COMPACT_FLASH			HAL_DRIVE_TYPE_COMPACT_FLASH
+	#define LIBHAL_DRIVE_TYPE_MEMORY_STICK			HAL_DRIVE_TYPE_MEMORY_STICK
+	#define LIBHAL_DRIVE_TYPE_SMART_MEDIA 			HAL_DRIVE_TYPE_SMART_MEDIA
+	#define LIBHAL_DRIVE_TYPE_SD_MMC				HAL_DRIVE_TYPE_SD_MMC
+	#define LIBHAL_DRIVE_TYPE_PORTABLE_AUDIO_PLAYER	HAL_DRIVE_TYPE_PORTABLE_AUDIO_PLAYER
+	#define LIBHAL_DRIVE_TYPE_CAMERA				HAL_DRIVE_TYPE_CAMERA
+	#define LIBHAL_DRIVE_TYPE_TAPE					HAL_DRIVE_TYPE_TAPE
+
+	// libhal 0.4 API
+	#define libhal_free_string hal_free_string
+	#define libhal_device_exists(ctx, udi, error) hal_device_exists(ctx, udi)
+	#define libhal_device_property_watch_all(ctx, error) hal_device_property_watch_all(ctx)
+	#define libhal_get_all_devices(ctx, num_devices, error) hal_get_all_devices(ctx, num_devices)
+	#define libhal_device_property_exists(ctx, udi, key, error) hal_device_property_exists(ctx, udi, key)
+	#define libhal_device_get_property_bool(ctx, udi, key, error) hal_device_get_property_bool(ctx, udi, key)
+	#define libhal_device_get_property_string(ctx, udi, key, error) hal_device_get_property_string(ctx, udi, key)
+	#define libhal_device_query_capability(ctx, udi, capability, error) hal_device_query_capability(ctx, udi, capability)
+#endif
+
+
 /**
 * A handy function to query a hal string
 *
@@ -137,12 +198,14 @@
 
 /* Hal call-backs -- from gvm*/
 public:
+#ifdef HAL_0_4
 	/** Invoked by libhal for integration with our mainloop.
 	*
 	*  @param  ctx                 LibHal context
 	*  @param  dbus_connection     D-BUS connection to integrate
 	*/
 	static void hal_main_loop_integration(LibHalContext *ctx, DBusConnection *dbus_connection);
+#endif
 
 	/** Invoked when a device is added to the Global Device List.
 	*
@@ -175,7 +238,13 @@
 	*  @param  message             D-BUS message with variable parameters depending on condition
 	*/
 	static void hal_device_condition(LibHalContext *ctx, const char *udi,
-				const char *condition_name, DBusMessage *message);
+				const char *condition_name,
+				#ifdef HAL_0_4
+				DBusMessage *message
+				#else
+				const char* message
+				#endif
+				);
 
 /* HAL and DBus structures */
 private:
@@ -184,15 +253,17 @@
 	*/
 	LibHalContext*		m_halContext;
 
+#ifdef HAL_0_4
 	/**
 	* Structure defining the hal callback function for devices events
 	*/
 	LibHalFunctions 	m_halFunctions;
+#endif
 
 	/**
 	* libhal-storage HAL policy, e.g. for icon names
 	*/
-	HalStoragePolicy*	m_halStoragePolicy;
+	LibHalStoragePolicy*	m_halStoragePolicy;
 
 	/**
 	* The DBus-Qt bindings connection for mainloop integration
