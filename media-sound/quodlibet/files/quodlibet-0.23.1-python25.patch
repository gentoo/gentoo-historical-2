Index: parse/_pattern.py
===================================================================
--- parse/_pattern.py	(revision 3816)
+++ parse/_pattern.py	(revision 3817)
@@ -15,7 +15,7 @@
 # every time. The Song proxy might also get in the way.
 
 import os
-import sre
+import re
 
 import util
 
@@ -43,16 +43,16 @@
                 str(self._reverse[self.type]) +
                 "), lexeme=" + repr(self.lexeme) + ">")
 
-class PatternLexer(sre.Scanner):
+class PatternLexer(re.Scanner):
     def __init__(self, s):
         self.string = s.strip()
-        sre.Scanner.__init__(self,
+        re.Scanner.__init__(self,
                              [(r"([^<>|\\]|\\.)+", self.text),
                               (r"[<>|]", self.table),
                               ])
 
     def text(self, scanner, string):
-        return PatternLexeme(TEXT, sre.sub(r"\\(.)", r"\1", string))
+        return PatternLexeme(TEXT, re.sub(r"\\(.)", r"\1", string))
     def table(self, scanner, string):
         return PatternLexeme(
             {"|": COND, "<": OPEN, ">": CLOSE}[string], string)
Index: parse/_query.py
===================================================================
--- parse/_query.py	(revision 3816)
+++ parse/_query.py	(revision 3817)
@@ -10,7 +10,7 @@
 # but it could use some cleaning up. It builds the requisite match.*
 # objects as it goes, which is where the interesting stuff will happen.
 
-import sre
+import re
 
 import parse._match as match
 
@@ -22,10 +22,10 @@
 class ParseError(error): pass
 class LexerError(error): pass
 
-class QueryLexer(sre.Scanner):
+class QueryLexer(re.Scanner):
     def __init__(self, s):
         self.string = s.strip()
-        sre.Scanner.__init__(self,
+        re.Scanner.__init__(self,
                              [(r"/([^/\\]|\\.)*/", self.regexp),
                               (r'"([^"\\]|\\.)*"', self.str_to_re),
                               (r"'([^'\\]|\\.)*'", self.str_to_re),
@@ -42,7 +42,7 @@
         if isinstance(string, unicode): string = string.encode('utf-8')
         string = string[1:-1].decode('string_escape')
         string = string.decode('utf-8')
-        return QueryLexeme(RE, "^%s$" % sre.escape(string))
+        return QueryLexeme(RE, "^%s$" % re.escape(string))
 
     def tag(self, scanner, string):
         return QueryLexeme(TAG, string.strip())
@@ -190,24 +190,24 @@
     def MatchTag(self):
         tag = self.lookahead.lexeme
         self.match(TAG)
-        try: return sre.compile(sre.escape(tag), sre.IGNORECASE | sre.UNICODE)
-        except sre.error:
+        try: return re.compile(re.escape(tag), re.IGNORECASE | re.UNICODE)
+        except re.error:
             raise ParseError("The regular expression was invalid")
 
     def Regexp(self):
-        re = self.lookahead.lexeme
+        regex = self.lookahead.lexeme
         self.match(RE)
-        mods = sre.MULTILINE | sre.UNICODE | sre.IGNORECASE
+        mods = re.MULTILINE | re.UNICODE | re.IGNORECASE
         if self.lookahead.type == TAG:
             s = self.lookahead.lexeme.lower()
-            if "c" in s: mods &= ~sre.IGNORECASE
-            if "i" in s: mods |= sre.IGNORECASE
-            if "s" in s: mods |= sre.DOTALL
-            if "l" in s: mods = (mods & ~sre.UNICODE) | sre.LOCALE
+            if "c" in s: mods &= ~re.IGNORECASE
+            if "i" in s: mods |= re.IGNORECASE
+            if "s" in s: mods |= re.DOTALL
+            if "l" in s: mods = (mods & ~re.UNICODE) | re.LOCALE
             self.match(TAG)
-        try: return sre.compile(re, mods)
-        except sre.error:
-            raise ParseError("The regular expression /%s/ is invalid." % re)
+        try: return re.compile(regex, mods)
+        except re.error:
+            raise ParseError("The regular expression /%s/ is invalid." % regex)
 
     def match(self, *tokens):
         if tokens == [EOF] and self.lookahead.type == EOF:
@@ -227,7 +227,7 @@
     if not isinstance(string, unicode): string = string.decode('utf-8')
     if string == "": return match.Inter([])
     elif not set("#=").intersection(string):
-        parts = ["%s = /%s/" % (", ".join(star), sre.escape(p))
+        parts = ["%s = /%s/" % (", ".join(star), re.escape(p))
                  for p in string.split()]
         string = "&(" + ",".join(parts) + ")"
     return QueryParser(QueryLexer(string)).StartQuery()
Index: qltk/remote.py
===================================================================
--- qltk/remote.py	(revision 3816)
+++ qltk/remote.py	(revision 3817)
@@ -9,7 +9,7 @@
 
 import os
 import random
-import sre
+import re
 
 import gobject
 import gtk
@@ -162,7 +162,7 @@
         for added in library.scan([filename]): pass
         if window.browser.can_filter(None):
             window.browser.set_text(
-                "filename = /^%s/c" % sre.escape(filename))
+                "filename = /^%s/c" % re.escape(filename))
             window.browser.activate()
         else:
             basepath = filename + "/"
Index: qltk/cbes.py
===================================================================
--- qltk/cbes.py	(revision 3816)
+++ qltk/cbes.py	(revision 3817)
@@ -241,8 +241,8 @@
                 if not os.path.isdir(os.path.dirname(filename)):
                     os.makedirs(os.path.dirname(filename))
 
-            saved = file(filename + ".saved", "wU")
-            memory = file(filename, "wU")
+            saved = file(filename + ".saved", "w")
+            memory = file(filename, "w")
             target = saved
             for row in self.get_model():
                 if row[0] is None: target = memory
Index: qltk/renamefiles.py
===================================================================
--- qltk/renamefiles.py	(revision 3816)
+++ qltk/renamefiles.py	(revision 3817)
@@ -8,7 +8,7 @@
 # $Id: quodlibet-0.23.1-python25.patch,v 1.1 2006/09/25 02:05:35 tcort Exp $
 
 import os
-import sre
+import re
 import unicodedata
 
 import gtk
@@ -38,7 +38,7 @@
         new = u"".join(map(lambda s: (s in self.BAD and "_") or s, filename))
         parts = new.split(os.sep)
         def fix_end(string):
-            return sre.sub(r'[\. ]$', "_", string)
+            return re.sub(r'[\. ]$', "_", string)
         return unicode(os.sep).join(map(fix_end, parts))
 
 class StripDiacriticals(FilterCheckButton):
Index: qltk/tagsfrompath.py
===================================================================
--- qltk/tagsfrompath.py	(revision 3816)
+++ qltk/tagsfrompath.py	(revision 3817)
@@ -8,7 +8,7 @@
 # $Id: quodlibet-0.23.1-python25.patch,v 1.1 2006/09/25 02:05:35 tcort Exp $
 
 import os
-import sre
+import re
 
 import gtk
 
@@ -29,7 +29,7 @@
         self.slashes = len(pattern) - len(pattern.replace(os.path.sep,'')) + 1
         self.pattern = None
         # patterns look like <tagname> non regexy stuff <tagname> ...
-        pieces = sre.split(r'(<[A-Za-z0-9_]+>)', pattern)
+        pieces = re.split(r'(<[A-Za-z0-9_]+>)', pattern)
         override = { '<tracknumber>': r'\d\d?', '<discnumber>': r'\d\d??' }
         for i, piece in enumerate(pieces):
             if not piece: continue
@@ -38,7 +38,7 @@
                 pieces[i] = '(?P%s%s)' % (piece, override.get(piece, '.+?'))
                 self.headers.append(piece[1:-1].encode("ascii", "replace"))
             else:
-                pieces[i] = sre.escape(piece)
+                pieces[i] = re.escape(piece)
 
         # some slight magic to anchor searches "nicely"
         # nicely means if it starts with a <tag>, anchor with a /
@@ -52,7 +52,7 @@
                 and not pattern.endswith('<discnumber>'):
             pieces.append(r'(?:\.\w+)$')
 
-        self.pattern = sre.compile(''.join(pieces))
+        self.pattern = re.compile(''.join(pieces))
 
     def match(self, song):
         if isinstance(song, dict):
@@ -125,7 +125,7 @@
         if songs: pattern_text = self.combo.child.get_text().decode("utf-8")
         else: pattern_text = ""
         try: pattern = TagsFromPattern(pattern_text)
-        except sre.error:
+        except re.error:
             qltk.ErrorMessage(
                 self, _("Invalid pattern"),
                 _("The pattern\n\t<b>%s</b>\nis invalid. "
Index: util/__init__.py
===================================================================
--- util/__init__.py	(revision 3816)
+++ util/__init__.py	(revision 3817)
@@ -9,7 +9,7 @@
 import gettext
 import locale
 import os
-import sre
+import re
 import sys
 
 from const import FSCODING as fscoding, ENCODING
@@ -26,7 +26,13 @@
     t.install()
 
 def python_init():
-    sre.escape = re_esc
+    re.escape = re_esc
+    # Python 2.4 has sre.Scanner but not re.Scanner. Python 2.5 has
+    # deprecated sre and moved Scanner to re.
+    try: re.Scanner
+    except AttributeError:
+        from sre import Scanner
+        re.Scanner = Scanner
 
 def re_esc(str, BAD="/.^$*+?{,\\[]|()<>#=!:"):
     needs_escape = lambda c: (c in BAD and "\\" + c) or c
@@ -237,7 +243,7 @@
     """Unescape a string in a manner suitable for XML/Pango."""
     return str.replace("&lt;", "<").replace("&gt;", ">").replace("&amp;", "&")
 
-def parse_time(timestr, err=(ValueError, sre.error)):
+def parse_time(timestr, err=(ValueError, re.error)):
     """Parse a time string in hh:mm:ss, mm:ss, or ss format."""
     if timestr[0:1] == "-":
         m = -1
@@ -246,7 +252,7 @@
 
     try:
         return m * reduce(lambda s, a: s * 60 + int(a),
-                          sre.split(r":|\.", timestr), 0)
+                          re.split(r":|\.", timestr), 0)
     except err: return 0
 
 RATING_PRECISION = 0.25
@@ -362,7 +368,7 @@
     if not splitters: return [s.strip()]
     values = s.split("\n")
     for spl in splitters:
-        spl = sre.compile(r"\b\s*%s\s*\b" % sre.escape(spl), sre.UNICODE)
+        spl = re.compile(r"\b\s*%s\s*\b" % re.escape(spl), re.UNICODE)
         new_values = []
         for v in values:
             new_values.extend([st.strip() for st in spl.split(v)])
Index: util/massagers.py
===================================================================
--- util/massagers.py	(revision 3816)
+++ util/massagers.py	(revision 3817)
@@ -8,7 +8,7 @@
 # $Id: quodlibet-0.23.1-python25.patch,v 1.1 2006/09/25 02:05:35 tcort Exp $
 
 import locale
-import sre
+import re
 
 class Massager(object):
     """Massage a tag value from various 'okay' formats to the
@@ -23,7 +23,7 @@
     tags = ["date"]
     error = _("The date must be entered in 'YYYY', 'YYYY-MM-DD' or "
               "'YYYY-MM-DD HH:MM:SS' format.")
-    __match = sre.compile(r"^\d{4}([-.]\d{2}([-.]\d{2}([T ]\d{2}"
+    __match = re.compile(r"^\d{4}([-.]\d{2}([-.]\d{2}([T ]\d{2}"
                           "([:.]\d{2}([:.]\d{2})?)?)?)?)?$").match
     def validate(self, value):
         value = value.strip().replace(".", "-").replace("/", "-")
@@ -32,7 +32,7 @@
 class GainMassager(Massager):
     tags = ["replaygain_album_gain", "replaygain_track_gain"]
     error = _("Replay Gain gains must be entered in 'x.yy dB' format.")
-    __match = sre.compile(r"^[+-]\d+\.?\d+?\s+dB$").match
+    __match = re.compile(r"^[+-]\d+\.?\d+?\s+dB$").match
 
     def validate(self, value):
         if self.__match(value): return value
