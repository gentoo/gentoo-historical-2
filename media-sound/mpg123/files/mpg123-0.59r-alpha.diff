diff -urN mpg123-0.59r/Makefile mpg123-0.59r.alpha/Makefile
--- mpg123-0.59r/Makefile	1999-06-15 16:39:06.000000000 -0400
+++ mpg123-0.59r.alpha/Makefile	2002-11-22 17:57:45.000000000 -0500
@@ -173,7 +173,7 @@
 		mpg123-make
 
 linux-alpha:
-	$(MAKE) CC=gcc LDFLAGS= OBJECTS='decode.o dct64.o audio_oss.o' \
+	$(MAKE) CC=gcc LDFLAGS= OBJECTS='decode_alpha.o dct64_alpha.o audio_oss.o' \
 		CFLAGS='-DLINUX -DOSS -Wall -O2 \
 			-fomit-frame-pointer -funroll-all-loops \
 			-finline-functions -ffast-math \
@@ -184,7 +184,7 @@
 linux-alpha-esd:
 	$(MAKE) CC=gcc LDFLAGS= \
 		AUDIO_LIB='-lesd -laudiofile' \
-		OBJECTS='decode.o dct64.o audio_esd.o' \
+		OBJECTS='decode_alpha.o dct64_alpha.o audio_esd.o' \
 		CFLAGS='-DLINUX -DOSS -Wall -O2 \
 			-fomit-frame-pointer -funroll-all-loops \
 			-finline-functions -ffast-math \
diff -urN mpg123-0.59r/dct64_alpha.c mpg123-0.59r.alpha/dct64_alpha.c
--- mpg123-0.59r/dct64_alpha.c	1969-12-31 19:00:00.000000000 -0500
+++ mpg123-0.59r.alpha/dct64_alpha.c	2002-11-22 17:52:59.000000000 -0500
@@ -0,0 +1,411 @@
+
+/*
+ * Discrete Cosine Tansform (DCT) for subband synthesis
+ * optimized for machines with no auto-increment. 
+ */
+
+/*
+ * 1999-03-17 Ivan Kokshaysky
+ * Optimized for Alpha
+ */
+
+#include "mpg123.h"
+
+void dct64(real *out0,real *out1,real *samples)
+{
+
+  register real *costab = pnts[1];
+  register real cos0,cos1,tmp;
+  register real b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,bA,bB,bC,bD,bE,bF;
+
+/* --1 */
+  b0 = samples[0x00] + samples[0x1F];
+  b1 = samples[0x01] + samples[0x1E];
+  b2 = samples[0x02] + samples[0x1D];
+  b3 = samples[0x03] + samples[0x1C];
+  b4 = samples[0x04] + samples[0x1B];
+  b5 = samples[0x05] + samples[0x1A];
+  b6 = samples[0x06] + samples[0x19];
+  b7 = samples[0x07] + samples[0x18];
+  b8 = samples[0x08] + samples[0x17];
+  b9 = samples[0x09] + samples[0x16];
+  bA = samples[0x0A] + samples[0x15];
+  bB = samples[0x0B] + samples[0x14];
+  bC = samples[0x0C] + samples[0x13];
+  bD = samples[0x0D] + samples[0x12];
+  bE = samples[0x0E] + samples[0x11];
+  bF = samples[0x0F] + samples[0x10];
+
+  tmp = b0 + bF;
+  bF = b0 - bF;
+  b0 = tmp;
+  bF *= costab[0];
+  tmp = b1 + bE; 
+  bE = b1 - bE;
+  b1 = tmp; 
+  bE *= costab[1];
+  tmp = b2 + bD; 
+  bD = b2 - bD;
+  b2 = tmp; 
+  bD *= costab[2];
+  tmp = b3 + bC; 
+  bC = b3 - bC;
+  b3 = tmp; 
+  bC *= costab[3];
+  tmp = b4 + bB; 
+  bB = b4 - bB;
+  b4 = tmp; 
+  bB *= costab[4];
+  tmp = b5 + bA; 
+  bA = b5 - bA;
+  b5 = tmp; 
+  bA *= costab[5];
+  tmp = b6 + b9; 
+  b9 = b6 - b9;
+  b6 = tmp; 
+  b9 *= costab[6];
+  tmp = b7 + b8; 
+  b8 = b7 - b8;
+  b7 = tmp; 
+  b8 *= costab[7];
+
+  costab = pnts[2];
+
+  tmp = b0 + b7;
+  b7 = b0 - b7;
+  b0 = tmp;
+  b7 *= costab[0];
+  tmp = b1 + b6;
+  b6 = b1 - b6;
+  b1 = tmp;
+  b6 *= costab[1];
+  tmp = b2 + b5;
+  b5 = b2 - b5;
+  b2 = tmp;
+  b5 *= costab[2];
+  tmp = b3 + b4;
+  b4 = b3 - b4;
+  b3 = tmp;
+  b4 *= costab[3];
+  tmp = b8 + bF;
+  bF = bF - b8;
+  b8 = tmp;
+  bF *= costab[0];
+  tmp = b9 + bE;
+  bE = bE - b9;
+  b9 = tmp;
+  bE *= costab[1];
+  tmp = bA + bD;
+  bD = bD - bA;
+  bA = tmp;
+  bD *= costab[2];
+  tmp = bB + bC;
+  bC = bC - bB;
+  bB = tmp;
+  bC *= costab[3];
+
+  cos0 = pnts[3][0];
+  cos1 = pnts[3][1];
+
+  tmp = b0 + b3;
+  b3 = b0 - b3;
+  b0 = tmp;
+  b3 *= cos0;
+  tmp = b1 + b2;
+  b2 = b1 - b2;
+  b1 = tmp;
+  b2 *= cos1;
+  tmp = b4 + b7;
+  b7 = b7 - b4;
+  b4 = tmp;
+  b7 *= cos0;
+  tmp = b5 + b6;
+  b6 = b6 - b5;
+  b5 = tmp;
+  b6 *= cos1;
+  tmp = b8 + bB;
+  bB = b8 - bB;
+  b8 = tmp;
+  bB *= cos0;
+  tmp = b9 + bA;
+  bA = b9 - bA;
+  b9 = tmp;
+  bA *= cos1;
+  tmp = bC + bF;
+  bF = bF - bC;
+  bC = tmp;
+  bF *= cos0;
+  tmp = bD + bE;
+  bE = bE - bD;
+  bD = tmp;
+  bE *= cos1;
+
+  cos0 = pnts[4][0];
+
+  tmp = b0 + b1;
+  b1 = b0 - b1;
+  b0 = tmp;
+  b1 *= cos0;
+  tmp = b2 + b3;
+  b3 = b3 - b2;
+  b2 = tmp;
+  b3 *= cos0;
+  tmp = b4 + b5;
+  b5 = b4 - b5;
+  b2 += b3;
+  b4 = tmp;
+  b5 *= cos0;
+  tmp = b6 + b7;
+  b7 = b7 - b6;
+  b6 = tmp;
+  b7 *= cos0;
+  tmp = b8 + b9;
+  b6 += b7;
+  b9 = b8 - b9;
+  b4 += b6;
+  b8 = tmp;
+  b6 += b5;
+  b9 *= cos0;
+  b5 += b7;
+
+  tmp = bA + bB;
+  bB = bB - bA;
+  bA = tmp;
+  bB *= cos0;
+  tmp = bC + bD;
+  bA += bB;
+  bD = bC - bD;
+  bC = tmp;
+  bD *= cos0;
+  tmp = bE + bF;
+  bF = bF - bE;
+  bE = tmp;
+  bF *= cos0;
+  out0[0x10*16] = b0;
+  bE += bF;
+  out0[0x10*12] = b4;
+  bC += bE;
+  out0[0x10* 8] = b2;
+  bE += bD;
+  out0[0x10* 4] = b6;
+  bD += bF;
+
+  out0[0x10* 0] = b1;
+  b8 += bC;
+  out1[0x10* 0] = b1;
+  out0[0x10*14] = b8;
+  bC += bA;
+  out1[0x10* 4] = b5;
+  out0[0x10*10] = bC;
+  bA += bE;
+  out1[0x10* 8] = b3;
+  out0[0x10* 6] = bA;
+  bE += b9;
+  out1[0x10*12] = b7;
+  out0[0x10* 2] = bE;
+  b9 += bD;
+  out1[0x10* 2] = b9;
+  bD += bB;
+  out1[0x10* 6] = bD;
+  bB += bF;
+  out1[0x10*10] = bB;
+  out1[0x10*14] = bF;
+
+/* --2 */
+  costab = pnts[0];
+
+  bF = (samples[0x00] - samples[0x1F]) * costab[0x0];
+  bE = (samples[0x01] - samples[0x1E]) * costab[0x1];
+  bD = (samples[0x02] - samples[0x1D]) * costab[0x2];
+  bC = (samples[0x03] - samples[0x1C]) * costab[0x3];
+  bB = (samples[0x04] - samples[0x1B]) * costab[0x4];
+  bA = (samples[0x05] - samples[0x1A]) * costab[0x5];
+  b9 = (samples[0x06] - samples[0x19]) * costab[0x6];
+  b8 = (samples[0x07] - samples[0x18]) * costab[0x7];
+  b7 = (samples[0x08] - samples[0x17]) * costab[0x8];
+  b6 = (samples[0x09] - samples[0x16]) * costab[0x9];
+  b5 = (samples[0x0A] - samples[0x15]) * costab[0xA];
+  b4 = (samples[0x0B] - samples[0x14]) * costab[0xB];
+  b3 = (samples[0x0C] - samples[0x13]) * costab[0xC];
+  b2 = (samples[0x0D] - samples[0x12]) * costab[0xD];
+  b1 = (samples[0x0E] - samples[0x11]) * costab[0xE];
+  b0 = (samples[0x0F] - samples[0x10]) * costab[0xF];
+
+  costab = pnts[1];
+
+  tmp = b0 + bF;
+  bF = bF - b0;
+  b0 = tmp;
+  bF *= costab[0];
+  tmp = b1 + bE;
+  bE = bE - b1;
+  b1 = tmp;
+  bE *= costab[1];
+  tmp = b2 + bD;
+  bD = bD - b2;
+  b2 = tmp;
+  bD *= costab[2];
+  tmp = b3 + bC;
+  bC = bC - b3;
+  b3 = tmp;
+  bC *= costab[3];
+  tmp = b4 + bB;
+  bB = bB - b4;
+  b4 = tmp;
+  bB *= costab[4];
+  tmp = b5 + bA;
+  bA = bA - b5;
+  b5 = tmp;
+  bA *= costab[5];
+  tmp = b6 + b9;
+  b9 = b9 - b6;
+  b6 = tmp;
+  b9 *= costab[6];
+  tmp = b7 + b8;
+  b8 = b8 - b7;
+  b7 = tmp;
+  b8 *= costab[7];
+
+  costab = pnts[2];
+
+  tmp = b0 + b7;
+  b7 = b0 - b7;
+  b0 = tmp;
+  b7 *= costab[0];
+  tmp = b1 + b6;
+  b6 = b1 - b6;
+  b1 = tmp;
+  b6 *= costab[1];
+  tmp = b2 + b5;
+  b5 = b2 - b5;
+  b2 = tmp;
+  b5 *= costab[2];
+  tmp = b3 + b4;
+  b4 = b3 - b4;
+  b3 = tmp;
+  b4 *= costab[3];
+  tmp = b8 + bF;
+  bF = bF - b8;
+  b8 = tmp;
+  bF *= costab[0];
+  tmp = b9 + bE;
+  bE = bE - b9;
+  b9 = tmp;
+  bE *= costab[1];
+  tmp = bA + bD;
+  bD = bD - bA;
+  bA = tmp;
+  bD *= costab[2];
+  tmp = bB + bC;
+  bC = bC - bB;
+  bB = tmp;
+  bC *= costab[3];
+
+  cos0 = pnts[3][0];
+  cos1 = pnts[3][1];
+
+  tmp = b0 + b3;
+  b3 = b0 - b3;
+  b0 = tmp;
+  b3 *= cos0;
+  tmp = b1 + b2;
+  b2 = b1 - b2;
+  b1 = tmp;
+  b2 *= cos1;
+  tmp = b4 + b7;
+  b7 = b7 - b4;
+  b4 = tmp;
+  b7 *= cos0;
+  tmp = b5 + b6;
+  b6 = b6 - b5;
+  b5 = tmp;
+  b6 *= cos1;
+  tmp = b8 + bB;
+  bB = b8 - bB;
+  b8 = tmp;
+  bB *= cos0;
+  tmp = b9 + bA;
+  bA = b9 - bA;
+  b9 = tmp;
+  bA *= cos1;
+  tmp = bC + bF;
+  bF = bF - bC;
+  bC = tmp;
+  bF *= cos0;
+  tmp = bD + bE;
+  bE = bE - bD;
+  bD = tmp;
+  bE *= cos1;
+
+  cos0 = pnts[4][0];
+
+  tmp = b0 + b1;
+  b1 = b0 - b1;
+  b0 = tmp;
+  b1 *= cos0;
+  tmp = b2 + b3;
+  b3 = b3 - b2;
+  b2 = tmp;
+  b3 *= cos0;
+
+  tmp = b4 + b5;
+  b2 += b3;
+  b5 = b4 - b5;
+  b4 = tmp;
+  b5 *= cos0;
+  tmp = b6 + b7;
+  b7 = b7 - b6;
+  b6 = tmp;
+  b7 *= cos0;
+  tmp = b8 + b9;
+  b6 += b7;
+  b9 = b8 - b9;
+  b4 += b6;
+  b8 = tmp;
+  b6 += b5;
+  b9 *= cos0;
+  b5 += b7;
+
+  tmp = bA + bB;
+  bB = bB - bA;
+  bA = tmp;
+  bB *= cos0;
+
+  tmp = bC + bD;
+  bA += bB;
+  bD = bC - bD;
+  bC = tmp;
+  bD *= cos0;
+  tmp = bE + bF;
+  bF = bF - bE;
+  bE = tmp;
+  bF *= cos0;
+  bE += bF;
+  bC += bE;
+  bE += bD;
+  bD += bF;
+
+  b8 += bC;
+  out0[0x10*15] = b0 + b8;
+  out0[0x10*13] = b8 + b4;
+  bC += bA;
+  out0[0x10*11] = b4 + bC;
+  out0[0x10* 9] = bC + b2;
+  bA += bE;
+  out0[0x10* 7] = b2 + bA;
+  out0[0x10* 5] = bA + b6;
+  bE += b9;
+  out0[0x10* 3] = b6 + bE;
+  out0[0x10* 1] = bE + b1;
+  b9 += bD;
+  out1[0x10* 1] = b1 + b9;
+  out1[0x10* 3] = b9 + b5;
+  bD += bB;
+  out1[0x10* 5] = b5 + bD;
+  out1[0x10* 7] = bD + b3;
+  bB += bF;
+  out1[0x10* 9] = b3 + bB;
+  out1[0x10*11] = bB + b7;
+  out1[0x10*13] = b7 + bF;
+  out1[0x10*15] = bF;
+}
diff -urN mpg123-0.59r/decode_alpha.c mpg123-0.59r.alpha/decode_alpha.c
--- mpg123-0.59r/decode_alpha.c	1969-12-31 19:00:00.000000000 -0500
+++ mpg123-0.59r.alpha/decode_alpha.c	2002-11-22 17:52:59.000000000 -0500
@@ -0,0 +1,239 @@
+/* 
+ * Mpeg Layer-1,2,3 audio decoder 
+ * ------------------------------
+ * copyright (c) 1995,1996,1997 by Michael Hipp, All rights reserved.
+ * See also 'README'
+ *
+ * Actually it's slightly modified decode_i386.c, but it gives
+ * a noticable speed increase on Alpha :) -ink
+ */
+
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+
+#include "mpg123.h"
+
+#if 0
+ /* old WRITE_SAMPLE */
+#define WRITE_SAMPLE(samples,sum,clip) \
+  if( (sum) > 32767.0) { *(samples) = 0x7fff; (clip)++; } \
+  else if( (sum) < -32768.0) { *(samples) = -0x8000; (clip)++; } \
+  else { *(samples) = sum; }
+#else
+ /* new WRITE_SAMPLE */
+#define WRITE_SAMPLE(samples,sum,clip) { \
+  double dtemp; int v; /* sizeof(int) == 4 */ \
+  dtemp = ((((65536.0 * 65536.0 * 16)+(65536.0 * 0.5))* 65536.0)) + (sum);  \
+  v = ((*(int *)&dtemp) - 0x80000000); \
+  if( v > 32767) { *(samples) = 0x7fff; (clip)++; } \
+  else if( v < -32768) { *(samples) = -0x8000; (clip)++; } \
+  else { *(samples) = v; }  \
+}
+#endif
+
+
+int synth_1to1_8bit(real *bandPtr,int channel,unsigned char *samples,int *pnt)
+{
+  short samples_tmp[64];
+  short *tmp1 = samples_tmp + channel;
+  int i,ret;
+  int pnt1 = 0;
+
+  ret = synth_1to1(bandPtr,channel,(unsigned char *)samples_tmp,&pnt1);
+  samples += channel + *pnt;
+
+  for(i=0;i<32;i++) {
+    *samples = conv16to8[*tmp1>>AUSHIFT];
+    samples += 2;
+    tmp1 += 2;
+  }
+  *pnt += 64;
+
+  return ret;
+}
+
+int synth_1to1_8bit_mono(real *bandPtr,unsigned char *samples,int *pnt) 
+{
+  short samples_tmp[64];
+  short *tmp1 = samples_tmp;
+  int i,ret;
+  int pnt1 = 0;
+
+  ret = synth_1to1(bandPtr,0,(unsigned char *)samples_tmp,&pnt1);
+  samples += *pnt;
+
+  for(i=0;i<32;i++) {
+    *samples++ = conv16to8[*tmp1>>AUSHIFT];
+    tmp1+=2;
+  }
+  *pnt += 32;
+
+  return ret;
+}
+
+int synth_1to1_8bit_mono2stereo(real *bandPtr,unsigned char *samples,int *pnt)
+{
+  short samples_tmp[64];
+  short *tmp1 = samples_tmp;
+  int i,ret;
+  int pnt1 = 0;
+
+  ret = synth_1to1(bandPtr,0,(unsigned char *)samples_tmp,&pnt1);
+  samples += *pnt;
+
+  for(i=0;i<32;i++) {
+    *samples++ = conv16to8[*tmp1>>AUSHIFT];
+    *samples++ = conv16to8[*tmp1>>AUSHIFT];
+    tmp1 += 2;
+  }
+  *pnt += 64;
+
+  return ret;
+}
+
+int synth_1to1_mono(real *bandPtr,unsigned char *samples,int *pnt)
+{
+  short samples_tmp[64];
+  short *tmp1 = samples_tmp;
+  int i,ret;
+  int pnt1 = 0;
+
+  ret = synth_1to1(bandPtr,0,(unsigned char *) samples_tmp,&pnt1);
+  samples += *pnt;
+
+  for(i=0;i<32;i++) {
+    *( (short *) samples) = *tmp1;
+    samples += 2;
+    tmp1 += 2;
+  }
+  *pnt += 64;
+
+  return ret;
+}
+
+
+int synth_1to1_mono2stereo(real *bandPtr,unsigned char *samples,int *pnt)
+{
+  int i,ret;
+
+  ret = synth_1to1(bandPtr,0,samples,pnt);
+  samples = samples + *pnt - 128;
+
+  for(i=0;i<32;i++) {
+    ((short *)samples)[1] = ((short *)samples)[0];
+    samples+=4;
+  }
+
+  return ret;
+}
+
+int synth_1to1(real *bandPtr,int channel,unsigned char *out,int *pnt)
+{
+  static real buffs[2][2][0x110];
+  static const int step = 2;
+  static int bo = 1;
+  short *samples = (short *) (out + *pnt);
+
+  real *b0,(*buf)[0x110];
+  int clip = 0; 
+  int bo1;
+
+  if(equalfile)
+	do_equalizer(bandPtr,channel);
+
+  if(!channel) {
+    bo--;
+    bo &= 0xf;
+    buf = buffs[0];
+  }
+  else {
+    samples++;
+    buf = buffs[1];
+  }
+
+  if(bo & 0x1) {
+    b0 = buf[0];
+    bo1 = bo;
+    dct64(buf[1]+((bo+1)&0xf),buf[0]+bo,bandPtr);
+  }
+  else {
+    b0 = buf[1];
+    bo1 = bo+1;
+    dct64(buf[0]+bo,buf[1]+bo+1,bandPtr);
+  }
+
+  {
+    register int j;
+    real *window = decwin + 16 - bo1;
+
+/* sum1 added to prevent pipeline stalls on an alphas.
+   Ivan Kokshaysky, 1999 */
+
+    for (j=16;j;j--,b0+=0x10,window+=0x20,samples+=step)
+    {
+      real sum,sum1;
+      sum  = window[0x0] * b0[0x0];
+      sum1 = window[0x1] * b0[0x1];
+      sum += window[0x2] * b0[0x2];
+      sum1 += window[0x3] * b0[0x3];
+      sum += window[0x4] * b0[0x4];
+      sum1 += window[0x5] * b0[0x5];
+      sum += window[0x6] * b0[0x6];
+      sum1 += window[0x7] * b0[0x7];
+      sum += window[0x8] * b0[0x8];
+      sum1 += window[0x9] * b0[0x9];
+      sum += window[0xA] * b0[0xA];
+      sum1 += window[0xB] * b0[0xB];
+      sum += window[0xC] * b0[0xC];
+      sum1 += window[0xD] * b0[0xD];
+      sum += window[0xE] * b0[0xE];
+      sum1 += window[0xF] * b0[0xF];
+      sum -= sum1;
+      WRITE_SAMPLE(samples,sum,clip);
+    }
+
+    {
+      real sum,sum1;
+      sum  = window[0x0] * b0[0x0];
+      sum1 = window[0x2] * b0[0x2];
+      sum += window[0x4] * b0[0x4];
+      sum1 += window[0x6] * b0[0x6];
+      sum += window[0x8] * b0[0x8];
+      sum1 += window[0xA] * b0[0xA];
+      sum += window[0xC] * b0[0xC];
+      sum1 += window[0xE] * b0[0xE];
+      sum += sum1;
+      WRITE_SAMPLE(samples,sum,clip);
+      b0-=0x10,window-=0x20,samples+=step;
+    }
+    window += bo1<<1;
+
+    for (j=15;j;j--,b0-=0x10,window-=0x20,samples+=step)
+    {
+      real sum,sum1;
+      sum = window[-0x1] * b0[0x0];
+      sum1 = window[-0x2] * b0[0x1];
+      sum += window[-0x3] * b0[0x2];
+      sum1 += window[-0x4] * b0[0x3];
+      sum += window[-0x5] * b0[0x4];
+      sum1 += window[-0x6] * b0[0x5];
+      sum += window[-0x7] * b0[0x6];
+      sum1 += window[-0x8] * b0[0x7];
+      sum += window[-0x9] * b0[0x8];
+      sum1 += window[-0xA] * b0[0x9];
+      sum += window[-0xB] * b0[0xA];
+      sum1 += window[-0xC] * b0[0xB];
+      sum += window[-0xD] * b0[0xC];
+      sum1 += window[-0xE] * b0[0xD];
+      sum += window[-0xF] * b0[0xE];
+      sum1 += window[-0x0] * b0[0xF];
+      sum = -sum - sum1;
+
+      WRITE_SAMPLE(samples,sum,clip);
+    }
+  }
+  *pnt += 128;
+
+  return clip;
+}
diff -urN mpg123-0.59r/getlopt.c mpg123-0.59r.alpha/getlopt.c
--- mpg123-0.59r/getlopt.c	1998-12-08 04:41:11.000000000 -0500
+++ mpg123-0.59r.alpha/getlopt.c	2002-11-22 17:52:59.000000000 -0500
@@ -48,7 +48,7 @@
 			if (opt->flags & 2) /* var is *char */
 				*((char *) opt->var) = (char) opt->value;
 			else
-				*((long *) opt->var) = opt->value;
+				*((int *) opt->var) = opt->value;
 		}
 		else
 			result = opt->value ? opt->value : opt->sname;
@@ -62,7 +62,7 @@
 			if (opt->flags & 2) /* var is *char */
 				*((char **) opt->var) = strdup(loptarg);
 			else
-				*((long *) opt->var) = atoi(loptarg);
+				*((int *) opt->var) = atoi(loptarg);
 		}
 		else
 			result = opt->value ? opt->value : opt->sname;
diff -urN mpg123-0.59r/layer3.c mpg123-0.59r.alpha/layer3.c
--- mpg123-0.59r/layer3.c	1999-04-21 11:25:18.000000000 -0400
+++ mpg123-0.59r.alpha/layer3.c	2002-11-22 17:52:59.000000000 -0500
@@ -608,7 +608,7 @@
  * Dequantize samples (includes huffman decoding)
  */
 /* 24 is enough because tab13 has max. a 19 bit huffvector */
-#define BITSHIFT ((sizeof(long)-1)*8)
+#define BITSHIFT ((sizeof(int)-1)*8)
 #define REFRESH_MASK \
   while(num < BITSHIFT) { \
     mask |= getbyte()<<(BITSHIFT-num); \
@@ -625,7 +625,7 @@
   int *me;
 
   int num=getbitoffset();
-  long mask = (long) getbits(num)<<(BITSHIFT+8-num);
+  int mask = (int) getbits(num)<<(BITSHIFT+8-num);
   part2remain -= num;
 
   {
@@ -709,7 +709,7 @@
         if(x == 15 && h->linbits) {
           max[lwin] = cb;
           REFRESH_MASK;
-          x += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          x += ((unsigned int) mask) >> (BITSHIFT+8-h->linbits);
           num -= h->linbits+1;
           mask <<= h->linbits;
           if(mask < 0)
@@ -733,7 +733,7 @@
         if(y == 15 && h->linbits) {
           max[lwin] = cb;
           REFRESH_MASK;
-          y += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          y += ((unsigned int) mask) >> (BITSHIFT+8-h->linbits);
           num -= h->linbits+1;
           mask <<= h->linbits;
           if(mask < 0)
@@ -883,7 +883,7 @@
         if (x == 15 && h->linbits) {
           max = cb;
 	  REFRESH_MASK;
-          x += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          x += ((unsigned int) mask) >> (BITSHIFT+8-h->linbits);
           num -= h->linbits+1;
           mask <<= h->linbits;
           if(mask < 0)
@@ -907,7 +907,7 @@
         if (y == 15 && h->linbits) {
           max = cb;
 	  REFRESH_MASK;
-          y += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          y += ((unsigned int) mask) >> (BITSHIFT+8-h->linbits);
           num -= h->linbits+1;
           mask <<= h->linbits;
           if(mask < 0)
