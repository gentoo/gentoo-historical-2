diff -ruN mpg123.old/Makefile mpg123/Makefile
--- mpg123.old/Makefile	2001-01-23 13:00:46.000000000 -0500
+++ mpg123/Makefile	2003-10-06 00:19:31.356137840 -0400
@@ -318,6 +318,29 @@
 			$(RPM_OPT_FLAGS)' \
 		mpg123-make
 
+linux-x86_64:
+	$(MAKE) LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_oss.o' \
+		CFLAGS='-O2 -Wall -DLINUX -DOSS -DUSE_MMAP \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
+linux-x86_64-esd:
+	$(MAKE) LDFLAGS= \
+		AUDIO_LIB='-lesd -laudiofile' \
+		OBJECTS='decode.o dct64.o audio_esd.o' \
+		CFLAGS='-O2 -Wall -DLINUX -DOSS -DUSE_MMAP \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
+linux-x86_64-alsa:
+	$(MAKE) LDFLAGS= \
+		AUDIO_LIB='-lasound' \
+		OBJECTS='decode.o dct64.o audio_alsa.o' \
+		CFLAGS='-O2 -Wall -DLINUX -DOSS -DUSE_MMAP \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
 #linux-ppc:
 #	$(MAKE) CC=gcc  LDFLAGS= \
 #		OBJECTS='decode.o dct64.o audio_oss.o' \
diff -ruN mpg123.old/Makefile.orig mpg123/Makefile.orig
--- mpg123.old/Makefile.orig	1969-12-31 19:00:00.000000000 -0500
+++ mpg123/Makefile.orig	2001-01-23 13:00:46.000000000 -0500
@@ -0,0 +1,851 @@
+###
+###   mpg123  Makefile
+###
+
+# Where to install binary and manpage on "make install":
+
+PREFIX=/usr/local
+BINDIR=$(PREFIX)/bin
+MANDIR=$(PREFIX)/man
+SECTION=1
+
+########################################################
+# Enable the below line If your plathome support IPv6
+########################################################
+
+#CFLAGS+= -DINET6
+# Additional LIBDIR and libraries if exist
+IPV6LIBDIR=
+IPV6LIB=
+
+### KAME stack
+#IPV6LIBDIR=-L/usr/local/v6/lib
+#IPV6LIB=-linet6
+### BSD/OS 4.0 (NRL) stack
+#IPV6LIBDIR=
+#IPV6LIB=
+### Linux stack
+#IPV6LIBDIR= #/usr/inet6/lib
+#IPV6LIB= #-linet6
+
+###################################################
+######                                       ######
+######   End of user-configurable settings   ######
+######                                       ######
+###################################################
+
+nothing-specified:
+	@echo ""
+	@echo "You must specify the system which you want to compile for:"
+	@echo ""
+	@echo "make linux-help     Linux          more help"
+	@echo "make freebsd-help   FreeBSD        more help"
+	@echo "make bsdos-help     BSDOS          more help"
+	@echo "make aix-help       AIX            more help"
+	@echo "make hpux-help      HPUX           more help"
+	@echo "make solaris-help   Solaris 2.x    more help" 
+	@echo "make dec-help       DEC OSF/True64 more help"
+	@echo ""
+	@echo "make sunos          SunOS 4.x (tested: 4.1.4)"
+	@echo "make sgi            SGI running IRIX"
+	@echo "make sgi-gcc        SGI running IRIX using GCC cc"
+	@echo "make ultrix         DEC Ultrix (tested: 4.4)"
+	@echo "make os2            IBM OS/2"
+	@echo "make netbsd         NetBSD"
+	@echo "make openbsd        OpenBSD"
+	@echo "make mint           MiNT on Atari"
+	@echo "make generic        try this one if your system isn't listed above"
+	@echo ""
+	@echo "Please read the file INSTALL for additional information."
+	@echo ""
+
+solaris-help:
+	@echo "make solaris        Solaris 2.x (tested: 2.5 and 2.5.1) using SparcWorks cc"
+	@echo "make solaris-gcc    Solaris 2.x using GNU cc (somewhat slower)"
+	@echo "make solaris-gcc-esd  Solaris 2.x using gnu cc and Esound as audio output"
+	@echo "make solaris-x86-gcc-oss Solaris with (commercial) OSS"
+	@echo "make solaris-gcc-nas Solaris with gcc and NAS"
+	@echo ""
+	@echo "Please read the file INSTALL for additional information."
+	@echo ""
+
+dec-help:
+	@echo "make dec            DEC/Tru64 UNIX (tested: 3.2 and 4.0), OSF/1"
+	@echo "make dec-nas        DEC/Tru64 UNIX, OSF/1 with NAS"
+	@echo "make dec-esd        DEC/Tru64 UNIX, OSF/1 using EsounD as audio output"
+	@echo ""
+	@echo "'dec' and 'dec-nas' versions tested using DEC UNIX 3.2 and 4.0"
+	@echo "'dec' and 'dec-esd' versions tested using Tru64 UNIX 5.0A"
+	@echo ""
+	@echo "Please read the file INSTALL for additional information."
+	@echo ""
+
+bsdos-help:
+	@echo "make bsdos          BSDI BSD/OS"
+	@echo "make bsdos4         BSDI BSD/OS 4.0"
+	@echo "make bsdos-nas      BSDI BSD/OS with NAS support"
+	@echo ""
+	@echo "Please read the file INSTALL for additional information."
+	@echo ""	
+
+aix-help:
+	@echo "make aix-gcc        IBM AIX using gcc (tested: 4.2)"
+	@echo "make aix-xlc        IBM AIX using xlc (tested: 4.3)"
+	@echo "make aix-ums        IBM AIX using Ultimedia library"
+	@echo "make aix-tk3play    IBM AIX"
+	@echo ""
+	@echo "Please read the file INSTALL for additional information."
+	@echo ""	
+
+hpux-help:
+	@echo "make hpux           HP/UX 9/10, /7xx"
+	@echo "make hpux-gcc       HP/UX 9/10, /7xx using GCC cc"
+	@echo "make hpux-alib      HP/UX with ALIB audio"
+	@echo ""
+	@echo "Please read the file INSTALL for additional information."
+	@echo ""	
+
+linux-help:
+	@echo ""
+	@echo "There are several Linux flavours. Choose one:"
+	@echo ""
+	@echo "make linux            Linux (i386, Pentium or unlisted platform)"
+	@echo "make linux-i486       Linux (optimized for i486 ONLY)"
+	@echo "make linux-pentium    Linux with -mpentium"
+	@echo "make linux-mmx        Linux with MMX optimized code"
+	@echo "make linux-3dnow      Linux with 3DNow! optimized code"
+	@echo "make linux-alsa       Linux with ALSA sound driver"
+	@echo "make linux-esd        Linux with output to EsounD"
+	@echo "make linux-3dnow-alsa Linux 3dnow optimzed with ALSA audio"
+	@echo "make linux-3dnow-esd  Linux 3dnow optimzed with output to EsoundD"
+	@echo "make linux-nas        Linux with output to Network Audio System"
+	@echo "make linux-sajber     Linux, backend for Sajber Jukebox frontend"
+	@echo "make linux-alpha      Linux/Alpha (minor changes)"
+	@echo "make linux-alpha-alsa Linux/Alpha with ALSA audio"
+	@echo "make linux-alpha-esd  Linux/Alpha output to EsounD audio"
+	@echo "make linux-ppc        Linux/PPC or MkLinux for the PowerPC"
+	@echo "make linux-ppc-esd    Linux/PPC output to EsounD audio"
+	@echo "make linux-m68k       Linux/m68k (Amiga, Atari) using OSS"
+	@echo "make linux-arm      Linux on the StrongArm"
+	@echo "make linux-sparc      Linux/Sparc"
+	@echo "make linux-mips-alsa  Linux/MIPS with ALSA sound driver"
+	@echo "NOTE: - esd flavours require libaudiofile, available from: "
+	@echo "        http://www.68k.org/~michael/audiofile/"
+	@echo "      - 3DNow requires 'as' from binutils-2.9.1.0.15 or later"
+	@echo "Please read the file INSTALL for additional information."
+	@echo ""
+
+freebsd-help:
+	@echo ""
+	@echo "There are several FreeBSD flavours. Choose one:"
+	@echo ""
+	@echo "make freebsd         FreeBSD"
+	@echo "make freebsd-sajber  FreeBSD, build binary for Sajber Jukebox frontend"
+	@echo "make freebsd-tk3play FreeBSD, build binary for tk3play frontend"
+	@echo "make freebsd-esd     FreeBSD, output to EsounD"
+	@echo "make freebsd-nas     FreeBSD, output to NAS"
+	@echo "make freebsd-i486    FreeBSD, optimized for i486"
+	@echo ""
+	@echo "Please read the file INSTALL for additional information."
+	@echo ""
+
+linux-devel:
+	$(MAKE) OBJECTS='decode_i386.o dct64_i386.o audio_oss.o' \
+        CC=gcc LDFLAGS= \
+        CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DLINUX -Wall -g -m486 \
+		-DOSS -funroll-all-loops \
+		-finline-functions -ffast-math' \
+        mpg123-make
+
+linux-profile:
+	$(MAKE) OBJECTS='decode_i386.o dct64_i386.o audio_oss.o' \
+        CC=gcc LDFLAGS='-pg' \
+        CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DLINUX -Wall -pg -m486 \
+		-DOSS -funroll-all-loops \
+		-finline-functions -ffast-math' \
+        mpg123-make
+
+linux:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o decode_i586.o \
+			audio_oss.o term.o' \
+		CFLAGS='$(CFLAGS) -DI386_ASSEM -DPENTIUM_OPT -DREAL_IS_FLOAT -DLINUX \
+			-DOSS -DTERM_CONTROL\
+			-Wall -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-pentium:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o decode_i586.o \
+			audio_oss.o term.o' \
+		CFLAGS='$(CFLAGS) -DI386_ASSEM -DPENTIUM_OPT -DREAL_IS_FLOAT -DLINUX \
+			-DOSS -DTERM_CONTROL\
+			-Wall -O2 -mpentium \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-mmx:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_MMX.o tabinit_MMX.o decode_MMX.o \
+			audio_oss.o term.o' \
+		CFLAGS='-DUSE_MMX -DI386_ASSEM -DPENTIUM_OPT -DREAL_IS_FLOAT \
+			-DLINUX -DOSS -DTERM_CONTROL\
+			-Wall -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-3dnow:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode_i386.o decode_3dnow.o dct64_3dnow.o \
+			dct64_i386.o dct36_3dnow.o getcpuflags.o \
+			equalizer_3dnow.o decode_i586.o audio_oss.o term.o' \
+		CFLAGS='$(CFLAGS) -DI386_ASSEM -DREAL_IS_FLOAT -DPENTIUM_OPT -DLINUX \
+			-DUSE_3DNOW -DOSS -DTERM_CONTROL\
+			-Wall -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+
+linux-i486:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o decode_i586.o \
+			decode_i486.o audio_oss.o term.o \
+			dct64_i486-a.o dct64_i486-b.o ' \
+		CFLAGS='$(CFLAGS) -DI386_ASSEM -DREAL_IS_FLOAT -DI486_OPT -DLINUX \
+			-DOSS -DTERM_CONTROL\
+			-Wall -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-esd:
+	$(MAKE) CC=gcc LDFLAGS= \
+		AUDIO_LIB='-lesd -laudiofile' \
+		OBJECTS='decode_i386.o dct64_i386.o decode_i586.o \
+			audio_esd.o' \
+		CFLAGS='$(CFLAGS) -DI386_ASSEM -DREAL_IS_FLOAT -DPENTIUM_OPT -DLINUX \
+			-DOSS -DUSE_ESD \
+			-Wall  -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
+linux-alsa:
+	$(MAKE) CC=gcc LDFLAGS= \
+		AUDIO_LIB='-lasound' \
+		OBJECTS='decode_i386.o dct64_i386.o decode_i586.o \
+			audio_alsa.o term.o' \
+		CFLAGS='$(CFLAGS) -DI386_ASSEM -DREAL_IS_FLOAT -DPENTIUM_OPT -DLINUX \
+			-DALSA -DTERM_CONTROL\
+			-Wall  -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
+linux-3dnow-alsa:
+	$(MAKE) CC=gcc LDFLAGS= \
+		AUDIO_LIB='-lasound' \
+		OBJECTS='decode_i386.o decode_3dnow.o dct64_3dnow.o \
+			dct64_i386.o dct36_3dnow.o getcpuflags.o \
+			equalizer_3dnow.o decode_i586.o audio_alsa.o term.o' \
+		CFLAGS='-DI386_ASSEM -DREAL_IS_FLOAT -DPENTIUM_OPT -DLINUX \
+			-DUSE_3DNOW -DALSA -DTERM_CONTROL\
+			-Wall -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-3dnow-esd:
+	$(MAKE) CC=gcc LDFLAGS= \
+		AUDIO_LIB='-lesd -laudiofile' \
+		OBJECTS='decode_i386.o decode_3dnow.o dct64_3dnow.o \
+			dct64_i386.o dct36_3dnow.o getcpuflags.o \
+			equalizer_3dnow.o decode_i586.o audio_esd.o' \
+		CFLAGS='-DI386_ASSEM -DREAL_IS_FLOAT -DPENTIUM_OPT -DLINUX \
+			-DUSE_3DNOW -DUSE_ESD \
+			-Wall -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-mips-alsa:
+	$(MAKE) CC=gcc LDFLAGS= \
+		AUDIO_LIB='-lasound' \
+		OBJECTS='decode.o dct64.o audio_alsa.o term.o' \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DLINUX -DALSA \
+			-DTERM_CONTROL -Wall  -O2 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
+linux-alpha:
+	$(MAKE) CC=gcc LDFLAGS= OBJECTS='decode.o dct64.o audio_oss.o' \
+		CFLAGS='$(CFLAGS) -DLINUX -DOSS -Wall -O2 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math \
+			-Wall -O6 -DUSE_MMAP \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
+linux-alpha-alsa:
+	$(MAKE) CC=gcc LDFLAGS= \
+		AUDIO_LIB='-lasound' \
+		OBJECTS='decode.o dct64.o audio_alsa.o term.o' \
+		CFLAGS='-DLINUX \
+			-DALSA -DTERM_CONTROL\
+			-DUSE_MMAP  -O6 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
+linux-alpha-esd:
+	$(MAKE) CC=gcc LDFLAGS= \
+		AUDIO_LIB='-lesd -laudiofile' \
+		OBJECTS='decode.o dct64.o audio_esd.o' \
+		CFLAGS='$(CFLAGS) -DLINUX -DOSS -DUSE_ESD -Wall -O2 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math \
+			-Wall -O6 -DUSE_MMAP \
+			$(RPM_OPT_FLAGS)' \
+		mpg123-make
+
+#linux-ppc:
+#	$(MAKE) CC=gcc  LDFLAGS= \
+#		OBJECTS='decode.o dct64.o audio_oss.o' \
+#		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DLINUX -Wall -O2 -mcpu=ppc \
+#			-DOSS -DPPC_ENDIAN \
+#			-fomit-frame-pointer -funroll-all-loops \
+#			-finline-functions -ffast-math' \
+#		mpg123-make
+
+#linux-ppc-esd:
+#	$(MAKE) CC=gcc  LDFLAGS= \
+#		AUDIO_LIB='-lesd -laudiofile' \
+#		OBJECTS='decode.o dct64.o audio_esd.o' \
+#		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DLINUX -Wall -O2 -mcpu=ppc \
+#			-DOSS -DPPC_ENDIAN \
+#			-fomit-frame-pointer -funroll-all-loops \
+#			-finline-functions -ffast-math' \
+#		mpg123-make
+
+linux-ppc:
+	$(MAKE) CC=gcc  LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_oss.o' \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DLINUX -Wall -O2 -mcpu=ppc \
+			-DOSS \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-ppc-esd:
+	$(MAKE) CC=gcc  LDFLAGS= \
+		AUDIO_LIB='-lesd -laudiofile' \
+		OBJECTS='decode.o dct64.o audio_esd.o' \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DLINUX -Wall -O2 -mcpu=ppc \
+			-DOSS -DUSE_ESD \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-sparc:
+	$(MAKE) CC=gcc  LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_sun.o' \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DUSE_MMAP -DSPARCLINUX -Wall -O2 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-sparc-esd:
+	$(MAKE) CC=gcc  LDFLAGS= \
+		AUDIO_LIB='-lesd -laudiofile' \
+		OBJECTS='decode.o dct64.o audio_esd.o' \
+		CFLAGS='-DREAL_IS_FLOAT -DUSE_MMAP -DOSS -DUSE_ESD -DSPARCLINUX -Wall -O2 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math \
+		mpg123-make
+
+
+linux-armv4l:
+	$(MAKE) CC=gcc LDFLAGS= OBJECTS='decode.o dct64.o audio_oss.o' \
+		CFLAGS='-DLINUX -DOSS -Wall -O2 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math \
+			-Wall -O6 -DUSE_MMAP \
+                mpg123-make
+
+linux-arm:
+	$(MAKE) CC=gcc LDFLAGS= OBJECTS='decode.o dct64.o audio_oss.o' \
+		CFLAGS='-DREAL_IS_FIXED -DLINUX \
+			-DOSS -Wall -O6 -march=armv4 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+ 
+
+linux-m68k:
+	$(MAKE) CC=gcc LDFLAGS= OBJECTS='decode.o dct64.o audio_oss.o' \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DLINUX \
+			-DOSS -DOSS_BIG_ENDIAN -Wall -O2 -m68040 \
+			-fomit-frame-pointer -funroll-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+linux-sajber:
+	@ $(MAKE) FRONTEND=sajberplay-make linux-frontend
+
+linux-tk3play:
+	@ $(MAKE) FRONTEND=mpg123m-make linux-frontend
+
+freebsd-sajber:
+	@ $(MAKE) FRONTEND=sajberplay-make freebsd-frontend
+
+freebsd-tk3play:
+	@ $(MAKE) FRONTEND=mpg123m-make freebsd-frontend
+
+linux-frontend:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o decode_i586.o \
+			control_sajber.o control_tk3play.o audio_oss.o' \
+		CFLAGS='$(CFLAGS) -DFRONTEND -DOSS -DI386_ASSEM -DREAL_IS_FLOAT \
+			-DPENTIUM_OPT -DLINUX -Wall -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		$(FRONTEND)
+
+linux-nas:
+	$(MAKE) CC=gcc LDFLAGS='-L/usr/X11R6/lib' \
+		AUDIO_LIB='-laudio -lXau' \
+		OBJECTS='decode_i386.o dct64_i386.o audio_nas.o' \
+		CFLAGS='$(CFLAGS) -I/usr/X11R6/include \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DLINUX -DNAS \
+			-Wall -O2 -m486 \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+#### the following defines are for experimental use ... 
+#
+#CFLAGS='$(CFLAGS) -pg -DI386_ASSEM -DREAL_IS_FLOAT -DLINUX -Wall -O2 -m486 -funroll-all-loops -finline-functions -ffast-math' mpg123
+#CFLAGS='$(CFLAGS) -DI386_ASSEM -O2 -DREAL_IS_FLOAT -DLINUX -Wall -g'
+#CFLAGS='$(CFLAGS) -DI386_ASSEM -DREAL_IS_FLOAT -DLINUX -Wall -O2 -m486 -fomit-frame-pointer -funroll-all-loops -finline-functions -ffast-math -malign-loops=2 -malign-jumps=2 -malign-functions=2'
+
+freebsd:
+	$(MAKE) CC=cc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o audio_oss.o' \
+		CFLAGS='$(CFLAGS) -Wall -ansi -pedantic -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DOSS' \
+		mpg123-make
+
+freebsd-i486:
+	$(MAKE) CC=cc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o \
+			decode_i486.o dct64_i486.o audio_oss.o' \
+		CFLAGS='$(CFLAGS) -Wall -ansi -pedantic -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DOPT_ARCH=i486 \
+			-march=i486 -finline-functions \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DOSS' \
+		mpg123-make
+
+freebsd-esd:
+	$(MAKE) CC=cc LDFLAGS= \
+		AUDIO_LIB='-lesd -laudiofile' \
+		OBJECTS='decode_i386.o dct64_i386.o $(GETBITS) audio_esd.o' \
+		CFLAGS='$(CFLAGS) -Wall -ansi -pedantic -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DOSS -DUSE_ESD \
+			-I/usr/local/include -L/usr/local/lib 
+		mpg123-make
+
+freebsd-nas:
+	$(MAKE) CC=cc LDFLAGS= \
+		AUDIO_LIB='-L/usr/X11R6/lib -laudio -lXau' \
+		OBJECTS='decode_i386.o dct64_i386.o audio_nas.o' \
+		CFLAGS='-Wall -ansi -pedantic -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DREAD_MMAP \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DNAS \
+			-I/usr/X11R6/include -L/usr/X11R6/lib' \
+		mpg123-make
+
+freebsd-frontend:
+	$(MAKE) CC=cc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o audio_oss.o \
+			control_sajber.o control_tk3play.o' \
+		CFLAGS='$(CFLAGS) -Wall -ansi -pedantic -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DFRONTEND \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DOSS' \
+		$(FRONTEND)
+
+openbsd:
+	$(MAKE) CC=cc LDFLAGS='-L/usr/lib' \
+		AUDIO_LIB='-lossaudio' \
+		OBJECTS='decode_i386.o dct64_i386.o audio_oss.o' \
+		CFLAGS='-Wall -ansi -pedantic -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DREAD_MMAP \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DOSS' \
+		mpg123-make
+
+# -mno-epilogue
+# -mflat -mv8 -mcpu=ultrasparc
+
+# these are MY EXPERIMENTAL compile entries
+solaris-pure:
+	$(MAKE) CC='purify -cache-dir=/tmp cc' \
+		LDFLAGS='-lsocket -lnsl' \
+		OBJECTS='decode.o dct64.o audio_sun.o term.o' \
+		CFLAGS='$(CFLAGS) -fast -native -xO4 -DSOLARIS -DTERM_CONTROL \
+			-DUSE_MMAP ' \
+		mpg123-make
+
+solaris-ccscc:
+	$(MAKE) CC=/usr/ccs/bin/ucbcc LDFLAGS='-lsocket -lnsl' \
+		OBJECTS='decode.o dct64.o audio_sun.o term.o' \
+		CFLAGS='$(CFLAGS) -fast -native -xO4 -DSOLARIS \
+			-DUSE_MMAP ' \
+		mpg123-make
+
+# common solaris compile entries
+solaris:
+	$(MAKE) CC=cc LDFLAGS='-lsocket -lnsl' \
+		OBJECTS='decode.o dct64.o audio_sun.o term.o' \
+		CFLAGS='$(CFLAGS) -fast -native -xO4 -DSOLARIS \
+			-DUSE_MMAP -DTERM_CONTROL' \
+		mpg123-make
+
+solaris-gcc-profile:
+	$(MAKE) CC='gcc' \
+		LDFLAGS='-lsocket -lnsl -pg' \
+		OBJECTS='decode.o dct64.o audio_sun.o' \
+		CFLAGS='$(CFLAGS) -g -pg -O2 -Wall -DSOLARIS -DREAL_IS_FLOAT -DUSE_MMAP \
+			-funroll-all-loops -finline-functions' \
+		mpg123-make
+
+#	-DREAL_IS_FLOAT 
+
+solaris-gcc:
+	$(MAKE) CC=gcc \
+		LDFLAGS='-lsocket -lnsl' \
+		OBJECTS='decode.o dct64.o audio_sun.o term.o' \
+		CFLAGS='$(CFLAGS) -O2 -Wall -pedantic -DSOLARIS \
+			-DUSE_MMAP -g \
+			-DTERM_CONTROL \
+			-funroll-all-loops  -finline-functions' \
+		mpg123-make
+
+solaris-gcc-esd:
+	$(MAKE) CC=gcc LDFLAGS='-lsocket -lnsl' \
+		AUDIO_LIB='-lesd -lresolv' \
+		OBJECTS='decode.o dct64.o audio_esd.o' \
+		CFLAGS='$(CFLAGS) -O2 -Wall -DSOLARIS -DREAL_IS_FLOAT -DUSE_MMAP \
+			-DUSE_ESD -funroll-all-loops -finline-functions' \
+		mpg123-make
+
+solaris-x86-gcc-oss:
+	$(MAKE) CC=gcc LDFLAGS='-lsocket -lnsl' \
+		OBJECTS='decode_i386.o dct64_i386.o decode_i586.o \
+			audio_oss.o' \
+		CFLAGS='$(CFLAGS) -DI386_ASSEM -DREAL_IS_FLOAT -DPENTIUM_OPT -DUSE_MMAP \
+			-DOSS \
+			-Wall -O2 -m486 \
+			-funroll-all-loops -finline-functions' \
+		mpg123-make
+
+solaris-gcc-nas:
+	$(MAKE) CC=gcc LDFLAGS='-lsocket -lnsl' \
+		AUDIO_LIB='-L/usr/openwin/lib -laudio -lXau'\
+		OBJECTS='decode.o dct64.o audio_nas.o' \
+		CFLAGS='$(CFLAGS) -O2 -I/usr/openwin/include -Wall \
+			-DSOLARIS -DREAL_IS_FLOAT -DUSE_MMAP \
+			-DNAS \
+			-funroll-all-loops -finline-functions' \
+		mpg123-make
+
+sunos:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_sun.o' \
+		CFLAGS='$(CFLAGS) -O2 -DSUNOS -DREAL_IS_FLOAT -DUSE_MMAP \
+			-funroll-loops' \
+		mpg123-make
+
+#		CFLAGS='-DREAL_IS_FLOAT -Aa +O3 -D_HPUX_SOURCE -DHPUX'
+hpux:
+	$(MAKE) CC=cc LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_hp.o' \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -Ae +O3 -D_HPUX_SOURCE -DHPUX' \
+		mpg123-make
+
+hpux-alib:
+	$(MAKE) CC=cc LDFLAGS='-L/opt/audio/lib' \
+		OBJECTS='decode.o dct64.o audio_alib.o' \
+		AUDIO_LIB=-lAlib \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -Ae +O3 -D_HPUX_SOURCE -DHPUX \
+			-I/opt/audio/include' \
+		mpg123-make
+
+hpux-gcc:
+	$(MAKE) CC=gcc LDFLAGS= OBJECTS='decode.o dct64.o audio_hp.o' \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -O3 -D_HPUX_SOURCE -DHPUX' \
+		mpg123-make
+sgi:
+	$(MAKE) CC=cc LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_sgi.o' AUDIO_LIB=-laudio \
+		CFLAGS='$(CFLAGS) -O2 -DSGI -DTERM_CONTROL \
+		-DREAL_IS_FLOAT -DUSE_MMAP' \
+		mpg123-make
+
+sgi-gcc:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_sgi.o' AUDIO_LIB=-laudio \
+		CFLAGS='$(CFLAGS) -O2 -DSGI -DTERM_CONTROL \
+		-DREAL_IS_FLOAT -DUSE_MMAP' \
+		mpg123-make
+
+dec:
+	$(MAKE) CC=cc LDFLAGS= OBJECTS='decode.o dct64.o audio_dec.o' \
+		AUDIO_LIB=-lmme \
+		CFLAGS='$(CFLAGS) -std1 -warnprotos -O4 -DUSE_MMAP \
+			-I/usr/include/mme' \
+		mpg123-make
+
+dec-esd:
+	$(MAKE) CC=cc LDFLAGS= OBJECTS='decode.o dct64.o audio_esd.o' \
+		AUDIO_LIB='-lesd -laudiofile' \
+		CFLAGS='$(CFLAGS) -std1 -warnprotos -O4 -DUSE_MMAP \
+			-I/usr/include/mme `esd-config --cflags`' \
+		mpg123-make
+
+dec-nas:
+	$(MAKE) CC=cc LDFLAGS='-L/usr/X11R6/lib' \
+		AUDIO_LIB='-laudio -lXau -ldnet_stub'\
+		OBJECTS='decode.o dct64.o  audio_nas.o' \
+		CFLAGS='$(CFLAGS) -I/usr/X11R6/include -std1 -warnprotos -O4 -DUSE_MMAP' \
+		mpg123-make
+
+ultrix:
+	$(MAKE) CC=cc LDFLAGS= OBJECTS='decode.o dct64.o audio_dummy.o' \
+		CFLAGS='$(CFLAGS) -std1 -O2 -DULTRIX' \
+		mpg123-make
+
+aix-gcc:
+	$(MAKE) CC=gcc LDFLAGS= OBJECTS='decode.o dct64.o audio_aix.o' \
+		CFLAGS='$(CFLAGS) -DAIX -Wall -O6 -DUSE_MMAP -DREAL_IS_FLOAT \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		mpg123-make
+
+aix-xlc:
+	$(MAKE) LDFLAGS= OBJECTS='decode.o dct64.o audio_aix.o' \
+		CFLAGS="$(CFLAGS) -O3 -qstrict -qcpluscmt -DAIX -DUSE_MMAP \
+		mpg123-make
+
+
+aix-ums:
+	$(MAKE) LDFLAGS='-L/usr/lpp/som/lib -lUMSobj' \
+		OBJECTS='decode.o dct64.o audio_aixums.o term.o' \
+		CFLAGS="$(CFLAGS) -O3 -qstrict -qcpluscmt -DAIX -DAIX_UMS \
+			-DUSE_MMAP -DTERM_CONTROL \
+			-DREAD_MMAP -I/usr/lpp/UMS/include \
+			-I/usr/lpp/som/include" \
+		mpg123-make
+
+
+aix-tk3play:
+	@ $(MAKE) FRONTEND=mpg123m-make aix-frontend
+
+aix-frontend:
+	$(MAKE) LDFLAGS= OBJECTS='decode.o dct64.o audio_aix.o \
+			control_sajber.o control_tk3play.o' \
+		CFLAGS='$(CFLAGS) -DAIX -Wall -O6 -DUSE_MMAP -DFRONTEND \
+			-fomit-frame-pointer -funroll-all-loops \
+			-finline-functions -ffast-math' \
+		$(FRONTEND)
+
+os2:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o audio_os2.o' \
+		CFLAGS='$(CFLAGS) -DREAL_IS_FLOAT -DNOXFERMEM -DOS2 -Wall -O2 -m486 \
+		-fomit-frame-pointer -funroll-all-loops \
+		-finline-functions -ffast-math' \
+		LIBS='-los2me -lsocket' \
+		mpg123.exe
+
+netbsd:
+	$(MAKE) CC=cc LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_sun.o' \
+		CFLAGS='$(CFLAGS) -Wall -ansi -pedantic -O3 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math \
+			-DREAL_IS_FLOAT -DUSE_MMAP -DNETBSD' \
+		mpg123-make
+
+netbsd-i386:
+	$(MAKE) CC=cc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o audio_sun.o' \
+		CFLAGS='$(CFLAGS) -Wall -ansi -pedantic -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DNETBSD' \
+		mpg123-make
+
+bsdos:
+	$(MAKE) CC=shlicc2 LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o \
+			 audio_oss.o' \
+		CFLAGS='$(CFLAGS) -Wall -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DOSS \
+			-DDONT_CATCH_SIGNALS' \
+		mpg123-make
+
+bsdos4:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode_i386.o dct64_i386.o audio_oss.o' \
+		CFLAGS='$(CFLAGS) -Wall -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DOSS \
+			-DDONT_CATCH_SIGNALS' \
+		mpg123-make
+
+bsdos-nas:
+	$(MAKE) CC=shlicc2 LDFLAGS= \
+		AUDIO_LIB='-laudio -lXau -L/usr/X11R6/lib' \
+		OBJECTS='decode_i386.o dct64_i386.o \
+			audio_nas.o' \
+		CFLAGS='$(CFLAGS) -Wall -O4 -m486 -fomit-frame-pointer \
+			-funroll-all-loops -ffast-math -DROT_I386 \
+			-DI386_ASSEM -DREAL_IS_FLOAT -DUSE_MMAP -DOSS \
+			-DDONT_CATCH_SIGNALS -DNAS' \
+		mpg123-make
+
+mint:
+	$(MAKE) CC=gcc LDFLAGS= \
+		OBJECTS='decode.o dct64.o audio_mint.o' \
+		CFLAGS='$(CFLAGS) -Wall -O2 -m68020-40 -m68881 \
+		-fomit-frame-pointer -funroll-all-loops \
+		-finline-functions -ffast-math \
+		-DREAL_IS_FLOAT -DMINT -DNOXFERMEM' \
+		AUDIO_LIB='-lsocket' \
+		mpg123-make
+
+# maybe you need the additonal options LDFLAGS='-lnsl -lsocket' when linking (see solaris:)
+generic:
+	$(MAKE) LDFLAGS= OBJECTS='decode.o dct64.o audio_dummy.o' \
+		CFLAGS='$(CFLAGS) -O -DGENERIC -DNOXFERMEM' \
+		mpg123-make
+
+###########################################################################
+###########################################################################
+###########################################################################
+
+sajberplay-make:
+	@ $(MAKE) CFLAGS='$(CFLAGS)' BINNAME=sajberplay mpg123
+
+mpg123m-make:
+	@ $(MAKE) CFLAGS='$(CFLAGS)' BINNAME=mpg123m mpg123
+
+mpg123-make:
+	@ $(MAKE) CFLAGS='$(CFLAGS)' BINNAME=mpg123 mpg123
+
+mpg123: mpg123.o common.o $(OBJECTS) decode_2to1.o decode_4to1.o \
+		tabinit.o audio.o layer1.o layer2.o layer3.o buffer.o \
+		getlopt.o httpget.o xfermem.o equalizer.o \
+		decode_ntom.o Makefile wav.o readers.o \
+		control_generic.o vbrhead.o playlist.o getbits.o
+	$(CC) $(CFLAGS) $(LDFLAGS)  mpg123.o tabinit.o common.o layer1.o \
+		layer2.o layer3.o audio.o buffer.o decode_2to1.o equalizer.o \
+		decode_4to1.o getlopt.o httpget.o xfermem.o decode_ntom.o \
+		wav.o readers.o control_generic.o vbrhead.o playlist.o getbits.o \
+		$(OBJECTS) -o $(BINNAME) -lm $(AUDIO_LIB) $(IPV6LIBDIR) $(IPV6LIB)
+
+mpg123.exe: mpg123.o common.o $(OBJECTS) decode_2to1.o decode_4to1.o \
+		tabinit.o audio.o layer1.o layer2.o layer3.o buffer.o \
+		getlopt.o httpget.o Makefile wav.o readers.o 
+	$(CC) $(CFLAGS) $(LDFLAGS) $^ -o mpg123.exe -lm $(LIBS)
+
+###########################################################################
+###########################################################################
+###########################################################################
+
+layer1.o:	mpg123.h getbits.h
+layer2.o:	mpg123.h l2tables.h getbits.h
+layer3.o:	mpg123.h huffman.h common.h getbits.h
+decode.o:	mpg123.h
+decode_2to1.o:	mpg123.h
+decode_4to1.o:	mpg123.h
+decode_ntom.o:	mpg123.h
+decode_i386.o:	mpg123.h
+common.o:	mpg123.h common.h
+mpg123.o:	mpg123.c mpg123.h getlopt.h xfermem.h version.h buffer.h term.h
+mpg123.h:	audio.h
+audio.o:	mpg123.h
+audio_oss.o:	mpg123.h
+audio_sun.o:	mpg123.h
+audio_sgi.o:	mpg123.h
+audio_hp.o:	mpg123.h
+audio_nas.o:	mpg123.h
+audio_os2.o:	mpg123.h
+audio_dummy.o:	mpg123.h
+buffer.o:	mpg123.h xfermem.h buffer.h
+getbits.o:	common.h mpg123.h
+tabinit.o:	mpg123.h audio.h
+getlopt.o:	getlopt.h
+httpget.o:	mpg123.h
+dct64.o:	mpg123.h
+dct64_i386.o:	mpg123.h
+xfermem.o:	xfermem.h
+equalizer.o:	mpg123.h
+control_sajber.o:	jukebox/controldata.h mpg123.h
+wav.o:		mpg123.h
+readers.o:	mpg123.h buffer.h common.h
+term.o:		mpg123.h buffer.h term.h common.h
+vbrhead.o:	mpg123.h
+playlist.o:	playlist.h mpg123.h
+
+###########################################################################
+###########################################################################
+###########################################################################
+
+clean:
+	rm -f *.o *core *~ mpg123 gmon.out sajberplay system mpg123m
+
+prepared-for-install:
+	@if [ ! -x mpg123 ]; then \
+		echo '###' ; \
+		echo '###  Before doing "make install", you have to compile the software.' ; \
+		echo '### Type "make" for more information.' ; \
+		echo '###' ; \
+		exit 1 ; \
+	fi
+
+system: mpg123.h system.c
+	$(CC) -o $@ -Wall -O2 system.c
+
+install:	prepared-for-install
+	strip mpg123
+	if [ -x /usr/ccs/bin/mcs ]; then /usr/ccs/bin/mcs -d mpg123; fi
+	mkdir -p $(BINDIR)
+	mkdir -p $(MANDIR)/man$(SECTION)
+	cp -f mpg123 $(BINDIR)
+	chmod 755 $(BINDIR)/mpg123
+	cp -f mpg123.1 $(MANDIR)/man$(SECTION)
+	chmod 644 $(MANDIR)/man$(SECTION)/mpg123.1
+
+dist:	clean
+	DISTNAME="`basename \`pwd\``" ; \
+	sed '/prgDate/s_".*"_"'`date +%Y/%m/%d`'"_' version.h > version.new; \
+	mv -f version.new version.h; \
+	cd .. ; \
+	rm -f "$$DISTNAME".tar.gz "$$DISTNAME".tar ; \
+	tar cvf "$$DISTNAME".tar "$$DISTNAME" ; \
+	gzip -9 "$$DISTNAME".tar
diff -ruN mpg123.old/getlopt.c.orig mpg123/getlopt.c.orig
--- mpg123.old/getlopt.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ mpg123/getlopt.c.orig	2000-10-30 12:45:12.000000000 -0500
@@ -0,0 +1,140 @@
+/*
+ *   getlopt.c
+ *
+ *   Oliver Fromme  <oliver.fromme@heim3.tu-clausthal.de>
+ *   Tue Apr  8 07:15:13 MET DST 1997
+ */
+
+#include "getlopt.h"
+#include <stdio.h>
+
+int loptind = 1;	/* index in argv[] */
+int loptchr = 0;	/* index in argv[loptind] */
+char *loptarg;		/* points to argument if present, else to option */
+
+#if defined(ultrix) || defined(ULTRIX)
+char *strdup (char *src)
+{
+	char *dest;
+
+	if (!(dest = (char *) malloc(strlen(src)+1)))
+		return (NULL);
+	return (strcpy(dest, src));
+}
+#endif
+
+topt *findopt (int islong, char *opt, topt *opts)
+{
+	if (!opts)
+		return (0);
+	while (opts->lname) {
+		if (islong) {
+			if (!strcmp(opts->lname, opt))
+				return (opts);
+		}
+		else
+			if (opts->sname == *opt)
+				return (opts);
+		opts++;
+	}
+	return (0);
+}
+
+int performoption (int argc, char *argv[], topt *opt)
+{
+	int result = GLO_CONTINUE;
+
+	if (!(opt->flags & GLO_ARG)) { /* doesn't take argument */
+		if (opt->var) {
+			if (opt->flags & GLO_CHAR) /* var is *char */
+				*((char *) opt->var) = (char) opt->value;
+			else if (opt->flags & GLO_LONG)
+				*((long *) opt->var) = opt->value;
+			else if (opt->flags & GLO_FLOAT)
+				*((double *) opt->var) = (double) atof(loptarg);
+			else
+			        *((int *) opt->var) = opt->value;
+		}
+		/* else
+			result = opt->value ? opt->value : opt->sname; */
+	}
+	else { /* requires argument */
+		if (loptind >= argc)
+			return (GLO_NOARG);
+		loptarg = argv[loptind++]+loptchr;
+		loptchr = 0;
+		if (opt->var) {
+			if (opt->flags & GLO_CHAR) /* var is *char */
+				*((char **) opt->var) = strdup(loptarg);
+			else if (opt->flags & GLO_LONG)
+				*((long *) opt->var) = atoi(loptarg);
+			else if (opt->flags & GLO_FLOAT)
+				*((double *) opt->var) = (double) atof(loptarg);
+			else {
+                           fprintf(stderr,"Error in param cfg.\n");
+                           exit(1);
+                        }
+		}
+/*
+		else {
+fprintf(stderr,"%d %d",opt->value , opt->sname);
+			result = opt->value ? opt->value : opt->sname;
+                }
+*/
+	}
+	if (opt->func)
+		opt->func(loptarg);
+	return (result);
+}
+
+int getsingleopt (int argc, char *argv[], topt *opts)
+{
+	char *thisopt;
+	topt *opt;
+	static char shortopt[2] = {0, 0};
+
+	if (loptind >= argc)
+		return (GLO_END);
+	thisopt = argv[loptind];
+	if (!loptchr) { /* start new option string */
+		if (thisopt[0] != '-' || !thisopt[1]) /* no more options */
+			return (GLO_END);
+		if (thisopt[1] == '-') { /* "--" */
+			if (thisopt[2]) { /* long option */
+				loptarg = thisopt+2;
+				loptind++;
+				if (!(opt = findopt(1, thisopt+2, opts)))
+					return (GLO_UNKNOWN);
+				else
+					return (performoption(argc, argv, opt));
+			}
+			else { /* "--" == end of options */
+				loptind++;
+				return (GLO_END);
+			}
+		}
+		else /* start short option(s) */
+			loptchr = 1;
+	}
+	shortopt[0] = thisopt[loptchr];
+	loptarg = shortopt;
+	opt = findopt(0, thisopt+(loptchr++), opts);
+	if (!thisopt[loptchr]) {
+		loptind++;
+		loptchr = 0;
+	}
+	if (!opt)
+		return (GLO_UNKNOWN);
+	else
+		return (performoption(argc, argv, opt));
+}
+
+int getlopt (int argc, char *argv[], topt *opts)
+{
+	int result;
+	
+	while ((result = getsingleopt(argc, argv, opts)) == GLO_CONTINUE);
+	return (result);
+}
+
+/* EOF */
diff -ruN mpg123.old/layer3.c mpg123/layer3.c
--- mpg123.old/layer3.c	2001-01-23 10:10:02.000000000 -0500
+++ mpg123/layer3.c	2003-10-06 00:19:31.357137688 -0400
@@ -609,7 +609,7 @@
  * Dequantize samples (includes huffman decoding)
  */
 /* 24 is enough because tab13 has max. a 19 bit huffvector */
-#define BITSHIFT ((sizeof(long)-1)*8)
+#define BITSHIFT ((sizeof(int)-1)*8)
 #define REFRESH_MASK \
   while(num < BITSHIFT) { \
     mask |= ((unsigned long)getbyte(&bsi))<<(BITSHIFT-num); \
@@ -713,7 +713,7 @@
         if(x == 15 && h->linbits) {
           max[lwin] = cb;
           REFRESH_MASK;
-          x += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          x += ((unsigned int) mask) >> (BITSHIFT+8-h->linbits);
           num -= h->linbits+1;
           mask <<= h->linbits;
           if(mask < 0)
@@ -737,7 +737,7 @@
         if(y == 15 && h->linbits) {
           max[lwin] = cb;
           REFRESH_MASK;
-          y += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          y += ((unsigned int) mask) >> (BITSHIFT+8-h->linbits);
           num -= h->linbits+1;
           mask <<= h->linbits;
           if(mask < 0)
@@ -891,7 +891,7 @@
         if (x == 15 && h->linbits) {
           max = cb;
 	  REFRESH_MASK;
-          x += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          x += ((unsigned int) mask) >> (BITSHIFT+8-h->linbits);
           num -= h->linbits+1;
           mask <<= h->linbits;
           if(mask < 0)
@@ -915,7 +915,7 @@
         if (y == 15 && h->linbits) {
           max = cb;
 	  REFRESH_MASK;
-          y += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          y += ((unsigned int) mask) >> (BITSHIFT+8-h->linbits);
           num -= h->linbits+1;
           mask <<= h->linbits;
           if(mask < 0)
diff -ruN mpg123.old/layer3.c.orig mpg123/layer3.c.orig
--- mpg123.old/layer3.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ mpg123/layer3.c.orig	2001-01-23 10:10:02.000000000 -0500
@@ -0,0 +1,1880 @@
+/* 
+ * Mpeg Layer-3 audio decoder 
+ * --------------------------
+ * copyright (c) 1995-1999 by Michael Hipp.
+ * All rights reserved. See also 'README'
+ *
+ * Optimize-TODO: put short bands into the band-field without the stride 
+ *                of 3 reals
+ * Length-optimze: unify long and short band code where it is possible
+ */ 
+
+#if 0
+#define L3_DEBUG 1
+#endif
+
+#if 0
+#define CUT_HF
+#endif
+
+#include <stdlib.h>
+#include "mpg123.h"
+#include "huffman.h"
+
+#include "common.h"
+
+#include "getbits.h"
+
+static real ispow[8207];
+static real aa_ca[8],aa_cs[8];
+static real COS1[12][6];
+static real win[4][36];
+static real win1[4][36];
+static real gainpow2[256+118+4];
+
+/* non static for external 3dnow functions */
+real   COS9[9];
+static real COS6_1,COS6_2;
+real   tfcos36[9];
+
+static real tfcos12[3];
+#define NEW_DCT9
+#ifdef NEW_DCT9
+static real cos9[3],cos18[3];
+#endif
+
+struct bandInfoStruct {
+  int longIdx[23];
+  int longDiff[22];
+  int shortIdx[14];
+  int shortDiff[13];
+};
+
+int longLimit[9][23];
+int shortLimit[9][14];
+
+struct bandInfoStruct bandInfo[9] = { 
+
+/* MPEG 1.0 */
+ { {0,4,8,12,16,20,24,30,36,44,52,62,74, 90,110,134,162,196,238,288,342,418,576},
+   {4,4,4,4,4,4,6,6,8, 8,10,12,16,20,24,28,34,42,50,54, 76,158},
+   {0,4*3,8*3,12*3,16*3,22*3,30*3,40*3,52*3,66*3, 84*3,106*3,136*3,192*3},
+   {4,4,4,4,6,8,10,12,14,18,22,30,56} } ,
+
+ { {0,4,8,12,16,20,24,30,36,42,50,60,72, 88,106,128,156,190,230,276,330,384,576},
+   {4,4,4,4,4,4,6,6,6, 8,10,12,16,18,22,28,34,40,46,54, 54,192},
+   {0,4*3,8*3,12*3,16*3,22*3,28*3,38*3,50*3,64*3, 80*3,100*3,126*3,192*3},
+   {4,4,4,4,6,6,10,12,14,16,20,26,66} } ,
+
+ { {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576} ,
+   {4,4,4,4,4,4,6,6,8,10,12,16,20,24,30,38,46,56,68,84,102, 26} ,
+   {0,4*3,8*3,12*3,16*3,22*3,30*3,42*3,58*3,78*3,104*3,138*3,180*3,192*3} ,
+   {4,4,4,4,6,8,12,16,20,26,34,42,12} }  ,
+
+/* MPEG 2.0 */
+ { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 } ,
+   {0,4*3,8*3,12*3,18*3,24*3,32*3,42*3,56*3,74*3,100*3,132*3,174*3,192*3} ,
+   {4,4,4,6,6,8,10,14,18,26,32,42,18 } } ,
+/*
+ { {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
+   {6,6,6,6,6,6,8,10,12,14,16,18,22,26,32,38,46,52,64,70,76,36 } ,
+*/
+/* changed 19th value fropm 330 to 332 */
+ { {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,332,394,464,540,576},
+   {6,6,6,6,6,6,8,10,12,14,16,18,22,26,32,38,46,54,62,70,76,36 } ,
+   {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,136*3,180*3,192*3} ,
+   {4,4,4,6,8,10,12,14,18,24,32,44,12 } } ,
+
+ { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 },
+   {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,134*3,174*3,192*3},
+   {4,4,4,6,8,10,12,14,18,24,30,40,18 } } ,
+/* MPEG 2.5 */
+ { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+   {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+   {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+ { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+   {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+   {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+   {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+ { {0,12,24,36,48,60,72,88,108,132,160,192,232,280,336,400,476,566,568,570,572,574,576},
+   {12,12,12,12,12,12,16,20,24,28,32,40,48,56,64,76,90,2,2,2,2,2},
+   {0, 24, 48, 72,108,156,216,288,372,480,486,492,498,576},
+   {8,8,8,12,16,20,24,28,36,2,2,2,26} } ,
+};
+
+static int mapbuf0[9][152];
+static int mapbuf1[9][156];
+static int mapbuf2[9][44];
+static int *map[9][3];
+static int *mapend[9][3];
+
+static unsigned int n_slen2[512]; /* MPEG 2.0 slen for 'normal' mode */
+static unsigned int i_slen2[256]; /* MPEG 2.0 slen for intensity stereo */
+
+static real tan1_1[16],tan2_1[16],tan1_2[16],tan2_2[16];
+static real pow1_1[2][16],pow2_1[2][16],pow1_2[2][16],pow2_2[2][16];
+
+/* 
+ * init tables for layer-3 
+ */
+void init_layer3(int down_sample_sblimit)
+{
+  int i,j,k,l;
+
+#ifdef REAL_IS_FIXED
+  double tmparray[8207];
+  double twotothequarter = pow((double)2.0, (double)0.25);
+  double current = pow((double)2.0, (double)(0.25 * 47));
+#endif
+
+  for(i=-256;i<118+4;i++) {
+#ifdef REAL_IS_FIXED
+  /* Possibly a few too many multiplies - single bit errors will
+   * propagate. It may change the gradient of the (log) power curve
+   * slighty */
+   current = current / twotothequarter;
+   gainpow2[i+256] = DOUBLE_TO_REAL(current);
+#else
+# ifdef USE_MMX
+    if(!param.down_sample)
+      gainpow2[i+256] = 16384.0 * pow((double)2.0,-0.25 * (double) (i+210) );
+    else
+# endif
+    gainpow2[i+256] = DOUBLE_TO_REAL(pow((double)2.0,-0.25 * (double) (i+210) ));
+#endif
+  }
+
+#ifdef REAL_IS_FIXED
+  for(i=0;i<8207;i++)
+     tmparray[i] = 0.0;
+  tmparray[1] = 1.0;
+  for(i=2;i<8207;i++) {
+     if(!tmparray[i]) {
+      tmparray[i] = pow((double)i,(double)(4.0/3.0));
+      for(j = 2; (j <= i) && ((i * j) < 8207); j++) {
+         /* Degradation due to lots of multiplies: A double has
+          * 52 bits of mantissa. A long has 32 bits (on the IPaq).
+          * Hence we can create 20 bits of error without fussing.
+          * Assuming that a 1 bit error multiplies to 2 bits, then 4,
+          * then 8, and noting that 2^13 is 8196 (we go up to 8207),
+          * we may have a problem. Resolve this by limiting to 4
+          * multiplies before recalculating. */
+         for(k = i, l = 0; (k * j) <= 8207 && (l < 4); k *= j, l++) {
+            tmparray[k * j] = tmparray[k] * tmparray[j];
+         }
+      }
+     }
+     ispow[i] = DOUBLE_TO_REAL(tmparray[i]);
+  }
+#else
+  for(i=0;i<8207;i++)
+    ispow[i] = DOUBLE_TO_REAL(pow((double)i,(double)4.0/3.0));
+#endif
+
+  for (i=0;i<8;i++) {
+    static double Ci[8]={-0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142,-0.0037};
+    double sq=sqrt(1.0+Ci[i]*Ci[i]);
+    aa_cs[i] = DOUBLE_TO_REAL(1.0/sq);
+    aa_ca[i] = DOUBLE_TO_REAL(Ci[i]/sq);
+  }
+
+  for(i=0;i<18;i++) {
+    win[0][i]    = win[1][i]    = 
+	DOUBLE_TO_REAL(0.5 * sin( M_PI / 72.0 * (double) (2*(i+0) +1) ) / cos ( M_PI * (double) (2*(i+0) +19) / 72.0 ));
+    win[0][i+18] = win[3][i+18] = 
+	DOUBLE_TO_REAL(0.5 * sin( M_PI / 72.0 * (double) (2*(i+18)+1) ) / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 ));
+  }
+  for(i=0;i<6;i++) {
+    win[1][i+18] = DOUBLE_TO_REAL(0.5 / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 ));
+    win[3][i+12] = DOUBLE_TO_REAL(0.5 / cos ( M_PI * (double) (2*(i+12)+19) / 72.0 ));
+    win[1][i+24] = DOUBLE_TO_REAL(0.5 * sin( M_PI / 24.0 * (double) (2*i+13) ) / cos ( M_PI * (double) (2*(i+24)+19) / 72.0 ));
+    win[1][i+30] = win[3][i] = DOUBLE_TO_REAL(0.0);
+    win[3][i+6 ] = DOUBLE_TO_REAL(0.5 * sin( M_PI / 24.0 * (double) (2*i+1) )  / cos ( M_PI * (double) (2*(i+6 )+19) / 72.0 ));
+  }
+
+  for(i=0;i<9;i++)
+    COS9[i] = DOUBLE_TO_REAL(cos( M_PI / 18.0 * (double) i));
+
+  for(i=0;i<9;i++)
+    tfcos36[i] = DOUBLE_TO_REAL(0.5 / cos ( M_PI * (double) (i*2+1) / 36.0 ));
+  for(i=0;i<3;i++)
+    tfcos12[i] = DOUBLE_TO_REAL(0.5 / cos ( M_PI * (double) (i*2+1) / 12.0 ));
+
+  COS6_1 = DOUBLE_TO_REAL(cos( M_PI / 6.0 * (double) 1));
+  COS6_2 = DOUBLE_TO_REAL(cos( M_PI / 6.0 * (double) 2));
+
+#ifdef NEW_DCT9
+  cos9[0]  = DOUBLE_TO_REAL(cos(1.0*M_PI/9.0));
+  cos9[1]  = DOUBLE_TO_REAL(cos(5.0*M_PI/9.0));
+  cos9[2]  = DOUBLE_TO_REAL(cos(7.0*M_PI/9.0));
+  cos18[0] = DOUBLE_TO_REAL(cos(1.0*M_PI/18.0));
+  cos18[1] = DOUBLE_TO_REAL(cos(11.0*M_PI/18.0));
+  cos18[2] = DOUBLE_TO_REAL(cos(13.0*M_PI/18.0));
+#endif
+
+  for(i=0;i<12;i++) {
+    win[2][i]  = DOUBLE_TO_REAL(0.5 * sin( M_PI / 24.0 * (double) (2*i+1) ) / cos ( M_PI * (double) (2*i+7) / 24.0 ));
+    for(j=0;j<6;j++)
+      COS1[i][j] = DOUBLE_TO_REAL(cos( M_PI / 24.0 * (double) ((2*i+7)*(2*j+1)) ));
+  }
+
+  for(j=0;j<4;j++) {
+    static int len[4] = { 36,36,12,36 };
+    for(i=0;i<len[j];i+=2)
+      win1[j][i] = + win[j][i];
+    for(i=1;i<len[j];i+=2)
+      win1[j][i] = - win[j][i];
+  }
+
+  for(i=0;i<16;i++) {
+    double t = tan( (double) i * M_PI / 12.0 );
+    tan1_1[i] = DOUBLE_TO_REAL(t / (1.0+t));
+    tan2_1[i] = DOUBLE_TO_REAL(1.0 / (1.0 + t));
+    tan1_2[i] = DOUBLE_TO_REAL(M_SQRT2 * t / (1.0+t));
+    tan2_2[i] = DOUBLE_TO_REAL(M_SQRT2 / (1.0 + t));
+
+    for(j=0;j<2;j++) {
+      double base = pow(2.0,-0.25*(j+1.0));
+      double p1=1.0,p2=1.0;
+      if(i > 0) {
+        if( i & 1 )
+          p1 = pow(base,(i+1.0)*0.5);
+        else
+          p2 = pow(base,i*0.5);
+      }
+      pow1_1[j][i] = DOUBLE_TO_REAL(p1);
+      pow2_1[j][i] = DOUBLE_TO_REAL(p2);
+      pow1_2[j][i] = DOUBLE_TO_REAL(M_SQRT2 * p1);
+      pow2_2[j][i] = DOUBLE_TO_REAL(M_SQRT2 * p2);
+    }
+  }
+
+  for(j=0;j<9;j++) {
+   struct bandInfoStruct *bi = &bandInfo[j];
+   int *mp;
+   int cb,lwin;
+   int *bdf;
+
+   mp = map[j][0] = mapbuf0[j];
+   bdf = bi->longDiff;
+   for(i=0,cb = 0; cb < 8 ; cb++,i+=*bdf++) {
+     *mp++ = (*bdf) >> 1;
+     *mp++ = i;
+     *mp++ = 3;
+     *mp++ = cb;
+   }
+   bdf = bi->shortDiff+3;
+   for(cb=3;cb<13;cb++) {
+     int l = (*bdf++) >> 1;
+     for(lwin=0;lwin<3;lwin++) {
+       *mp++ = l;
+       *mp++ = i + lwin;
+       *mp++ = lwin;
+       *mp++ = cb;
+     }
+     i += 6*l;
+   }
+   mapend[j][0] = mp;
+
+   mp = map[j][1] = mapbuf1[j];
+   bdf = bi->shortDiff+0;
+   for(i=0,cb=0;cb<13;cb++) {
+     int l = (*bdf++) >> 1;
+     for(lwin=0;lwin<3;lwin++) {
+       *mp++ = l;
+       *mp++ = i + lwin;
+       *mp++ = lwin;
+       *mp++ = cb;
+     }
+     i += 6*l;
+   }
+   mapend[j][1] = mp;
+
+   mp = map[j][2] = mapbuf2[j];
+   bdf = bi->longDiff;
+   for(cb = 0; cb < 22 ; cb++) {
+     *mp++ = (*bdf++) >> 1;
+     *mp++ = cb;
+   }
+   mapend[j][2] = mp;
+
+  }
+
+  for(j=0;j<9;j++) {
+    for(i=0;i<23;i++) {
+      longLimit[j][i] = (bandInfo[j].longIdx[i] - 1 + 8) / 18 + 1;
+      if(longLimit[j][i] > (down_sample_sblimit) )
+        longLimit[j][i] = down_sample_sblimit;
+    }
+    for(i=0;i<14;i++) {
+      shortLimit[j][i] = (bandInfo[j].shortIdx[i] - 1) / 18 + 1;
+      if(shortLimit[j][i] > (down_sample_sblimit) )
+        shortLimit[j][i] = down_sample_sblimit;
+    }
+  }
+
+  for(i=0;i<5;i++) {
+    for(j=0;j<6;j++) {
+      for(k=0;k<6;k++) {
+        int n = k + j * 6 + i * 36;
+        i_slen2[n] = i|(j<<3)|(k<<6)|(3<<12);
+      }
+    }
+  }
+  for(i=0;i<4;i++) {
+    for(j=0;j<4;j++) {
+      for(k=0;k<4;k++) {
+        int n = k + j * 4 + i * 16;
+        i_slen2[n+180] = i|(j<<3)|(k<<6)|(4<<12);
+      }
+    }
+  }
+  for(i=0;i<4;i++) {
+    for(j=0;j<3;j++) {
+      int n = j + i * 3;
+      i_slen2[n+244] = i|(j<<3) | (5<<12);
+      n_slen2[n+500] = i|(j<<3) | (2<<12) | (1<<15);
+    }
+  }
+
+  for(i=0;i<5;i++) {
+    for(j=0;j<5;j++) {
+      for(k=0;k<4;k++) {
+        for(l=0;l<4;l++) {
+          int n = l + k * 4 + j * 16 + i * 80;
+          n_slen2[n] = i|(j<<3)|(k<<6)|(l<<9)|(0<<12);
+        }
+      }
+    }
+  }
+  for(i=0;i<5;i++) {
+    for(j=0;j<5;j++) {
+      for(k=0;k<4;k++) {
+        int n = k + j * 4 + i * 20;
+        n_slen2[n+400] = i|(j<<3)|(k<<6)|(1<<12);
+      }
+    }
+  }
+}
+
+/*
+ * read additional side information (for MPEG 1 and MPEG 2)
+ */
+static int III_get_side_info(struct III_sideinfo *si,int stereo,
+ int ms_stereo,long sfreq,int single,int lsf)
+{
+   int ch, gr;
+   int powdiff = (single == 3) ? 4 : 0;
+
+   static const int tabs[2][5] = { { 2,9,5,3,4 } , { 1,8,1,2,9 } };
+   const int *tab = tabs[lsf];
+   
+   si->main_data_begin = getbits(&bsi,tab[1]);
+   if (stereo == 1)
+     si->private_bits = getbits_fast(&bsi,tab[2]);
+   else 
+     si->private_bits = getbits_fast(&bsi,tab[3]);
+
+   if(!lsf) {
+     for (ch=0; ch<stereo; ch++) {
+         si->ch[ch].gr[0].scfsi = -1;
+         si->ch[ch].gr[1].scfsi = getbits_fast(&bsi,4);
+     }
+   }
+
+   for (gr=0; gr<tab[0]; gr++) {
+     for (ch=0; ch<stereo; ch++) {
+       register struct gr_info_s *gr_info = &(si->ch[ch].gr[gr]);
+
+       gr_info->part2_3_length = getbits(&bsi,12);
+       gr_info->big_values = getbits(&bsi,9);
+       if(gr_info->big_values > 288) {
+          if(param.verbose)
+            fprintf(stderr,"big_values too large!\n");
+          gr_info->big_values = 288;
+       }
+       gr_info->pow2gain = gainpow2+256 - getbits_fast(&bsi,8) + powdiff;
+       if(ms_stereo)
+         gr_info->pow2gain += 2;
+       gr_info->scalefac_compress = getbits(&bsi,tab[4]);
+
+       if(get1bit(&bsi)) { /* window switch flag  */
+         int i;
+#ifdef L3_DEBUG
+if(2*gr_info->big_values > bandInfo[sfreq].shortIdx[12])
+  fprintf(stderr,"L3: BigValues too large, doesn't make sense %d %d\n",2*gr_info->big_values,bandInfo[sfreq].shortIdx[12]);
+#endif
+
+         gr_info->block_type       = getbits_fast(&bsi,2);
+         gr_info->mixed_block_flag = get1bit(&bsi);
+         gr_info->table_select[0]  = getbits_fast(&bsi,5);
+         gr_info->table_select[1]  = getbits_fast(&bsi,5);
+         /*
+          * table_select[2] not needed, because there is no region2,
+          * but to satisfy some verifications tools we set it either.
+          */
+         gr_info->table_select[2] = 0;
+         for(i=0;i<3;i++)
+           gr_info->full_gain[i] = gr_info->pow2gain + (getbits_fast(&bsi,3)<<3);
+
+         if(gr_info->block_type == 0) {
+           if(param.verbose) 
+             fprintf(stderr,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+           return 0;
+         }
+      
+         /* region_count/start parameters are implicit in this case. */       
+         if(!lsf || gr_info->block_type == 2)
+           gr_info->region1start = 36>>1;
+         else {
+/* check this again for 2.5 and sfreq=8 */
+           if(sfreq == 8)
+             gr_info->region1start = 108>>1;
+           else
+             gr_info->region1start = 54>>1;
+         }
+         gr_info->region2start = 576>>1;
+       }
+       else {
+         int i,r0c,r1c;
+#ifdef L3_DEBUG
+if(2*gr_info->big_values > bandInfo[sfreq].longIdx[21])
+  fprintf(stderr,"L3: BigValues too large, doesn't make sense %d %d\n",2*gr_info->big_values,bandInfo[sfreq].longIdx[21]);
+#endif
+         for (i=0; i<3; i++)
+           gr_info->table_select[i] = getbits_fast(&bsi,5);
+         r0c = getbits_fast(&bsi,4);
+         r1c = getbits_fast(&bsi,3);
+         gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+         if(r0c + r1c + 2 > 22)
+           gr_info->region2start = 576>>1;
+         else
+           gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+         gr_info->block_type = 0;
+         gr_info->mixed_block_flag = 0;
+       }
+       if(!lsf)
+         gr_info->preflag = get1bit(&bsi);
+       gr_info->scalefac_scale = get1bit(&bsi);
+       gr_info->count1table_select = get1bit(&bsi);
+     }
+   }
+
+   return !0;
+}
+
+/*
+ * read scalefactors
+ */
+static int III_get_scale_factors_1(int *scf,struct gr_info_s *gr_info)
+{
+   static const unsigned char slen[2][16] = {
+     {0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
+     {0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}
+   };
+   int numbits;
+   int num0 = slen[0][gr_info->scalefac_compress];
+   int num1 = slen[1][gr_info->scalefac_compress];
+
+    if (gr_info->block_type == 2) {
+      int i=18;
+      numbits = (num0 + num1) * 18;
+
+      if (gr_info->mixed_block_flag) {
+         for (i=8;i;i--)
+           *scf++ = getbits_fast(&bsi,num0);
+         i = 9;
+         numbits -= num0; /* num0 * 17 + num1 * 18 */
+      }
+
+      for (;i;i--)
+        *scf++ = getbits_fast(&bsi,num0);
+      for (i = 18; i; i--)
+        *scf++ = getbits_fast(&bsi,num1);
+      *scf++ = 0; *scf++ = 0; *scf++ = 0; /* short[13][0..2] = 0 */
+    }
+    else {
+      int i;
+      int scfsi = gr_info->scfsi;
+
+      if(scfsi < 0) { /* scfsi < 0 => granule == 0 */
+         for(i=11;i;i--)
+           *scf++ = getbits_fast(&bsi,num0);
+         for(i=10;i;i--)
+           *scf++ = getbits_fast(&bsi,num1);
+         numbits = (num0 + num1) * 10 + num0;
+         *scf++ = 0;
+      }
+      else {
+        numbits = 0;
+        if(!(scfsi & 0x8)) {
+          for (i=0;i<6;i++)
+            *scf++ = getbits_fast(&bsi,num0);
+          numbits += num0 * 6;
+        }
+        else {
+          scf += 6; 
+        }
+
+        if(!(scfsi & 0x4)) {
+          for (i=0;i<5;i++)
+            *scf++ = getbits_fast(&bsi,num0);
+          numbits += num0 * 5;
+        }
+        else {
+          scf += 5;
+        }
+
+        if(!(scfsi & 0x2)) {
+          for(i=0;i<5;i++)
+            *scf++ = getbits_fast(&bsi,num1);
+          numbits += num1 * 5;
+        }
+        else {
+          scf += 5; 
+        }
+
+        if(!(scfsi & 0x1)) {
+          for (i=0;i<5;i++)
+            *scf++ = getbits_fast(&bsi,num1);
+          numbits += num1 * 5;
+        }
+        else {
+           scf += 5;
+        }
+        *scf++ = 0;  /* no l[21] in original sources */
+      }
+    }
+    return numbits;
+}
+
+static int III_get_scale_factors_2(int *scf,struct gr_info_s *gr_info,int i_stereo)
+{
+  unsigned char *pnt;
+  int i,j,n=0,numbits=0;
+  unsigned int slen;
+
+  static unsigned char stab[3][6][4] = {
+   { { 6, 5, 5,5 } , { 6, 5, 7,3 } , { 11,10,0,0} ,
+     { 7, 7, 7,0 } , { 6, 6, 6,3 } , {  8, 8,5,0} } ,
+   { { 9, 9, 9,9 } , { 9, 9,12,6 } , { 18,18,0,0} ,
+     {12,12,12,0 } , {12, 9, 9,6 } , { 15,12,9,0} } ,
+   { { 6, 9, 9,9 } , { 6, 9,12,6 } , { 15,18,0,0} ,
+     { 6,15,12,0 } , { 6,12, 9,6 } , {  6,18,9,0} } }; 
+
+  if(i_stereo) /* i_stereo AND second channel -> do_layer3() checks this */
+    slen = i_slen2[gr_info->scalefac_compress>>1];
+  else
+    slen = n_slen2[gr_info->scalefac_compress];
+
+  gr_info->preflag = (slen>>15) & 0x1;
+
+  n = 0;  
+  if( gr_info->block_type == 2 ) {
+    n++;
+    if(gr_info->mixed_block_flag)
+      n++;
+  }
+
+  pnt = stab[n][(slen>>12)&0x7];
+
+  for(i=0;i<4;i++) {
+    int num = slen & 0x7;
+    slen >>= 3;
+    if(num) {
+      for(j=0;j<(int)(pnt[i]);j++)
+        *scf++ = getbits_fast(&bsi,num);
+      numbits += pnt[i] * num;
+    }
+    else {
+      for(j=0;j<(int)(pnt[i]);j++)
+        *scf++ = 0;
+    }
+  }
+  
+  n = (n << 1) + 1;
+  for(i=0;i<n;i++)
+    *scf++ = 0;
+
+  return numbits;
+}
+
+static int pretab1[22] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0};
+static int pretab2[22] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+
+/*
+ * Dequantize samples (includes huffman decoding)
+ */
+/* 24 is enough because tab13 has max. a 19 bit huffvector */
+#define BITSHIFT ((sizeof(long)-1)*8)
+#define REFRESH_MASK \
+  while(num < BITSHIFT) { \
+    mask |= ((unsigned long)getbyte(&bsi))<<(BITSHIFT-num); \
+    num += 8; \
+    part2remain -= 8; }
+
+static int III_dequantize_sample(real xr[SBLIMIT][SSLIMIT],int *scf,
+   struct gr_info_s *gr_info,int sfreq,int part2bits)
+{
+  int shift = 1 + gr_info->scalefac_scale;
+  real *xrpnt = (real *) xr;
+  int l[3],l3;
+  int part2remain = gr_info->part2_3_length - part2bits;
+  int *me;
+
+  int num=getbitoffset(&bsi);
+  long mask;
+  /* we must split this, because for num==0 the shift is undefined if you do it in one step */
+  mask  = ((unsigned long) getbits(&bsi,num))<<BITSHIFT;
+  mask <<= 8-num;
+  part2remain -= num;
+
+  {
+    int bv       = gr_info->big_values;
+    int region1  = gr_info->region1start;
+    int region2  = gr_info->region2start;
+
+    l3 = ((576>>1)-bv)>>1;   
+/*
+ * we may lose the 'odd' bit here !! 
+ * check this later again 
+ */
+    if(bv <= region1) {
+      l[0] = bv; l[1] = l[2] = 0;
+    }
+    else {
+      l[0] = region1;
+      if(bv <= region2) {
+        l[1] = bv - l[0];  l[2] = 0;
+      }
+      else {
+        l[1] = region2 - l[0]; l[2] = bv - region2;
+      }
+    }
+  }
+ 
+  if(gr_info->block_type == 2) {
+    /*
+     * decoding with short or mixed mode BandIndex table 
+     */
+    int i,max[4];
+    int step=0,lwin=3,cb=0;
+    register real v = 0.0;
+    register int *m,mc;
+
+    if(gr_info->mixed_block_flag) {
+      max[3] = -1;
+      max[0] = max[1] = max[2] = 2;
+      m = map[sfreq][0];
+      me = mapend[sfreq][0];
+    }
+    else {
+      max[0] = max[1] = max[2] = max[3] = -1;
+      /* max[3] not really needed in this case */
+      m = map[sfreq][1];
+      me = mapend[sfreq][1];
+    }
+
+    mc = 0;
+    for(i=0;i<2;i++) {
+      int lp = l[i];
+      struct newhuff *h = ht+gr_info->table_select[i];
+      for(;lp;lp--,mc--) {
+        register int x,y;
+        if( (!mc) ) {
+          mc    = *m++;
+          xrpnt = ((real *) xr) + (*m++);
+          lwin  = *m++;
+          cb    = *m++;
+          if(lwin == 3) {
+            v = gr_info->pow2gain[(*scf++) << shift];
+            step = 1;
+          }
+          else {
+            v = gr_info->full_gain[lwin][(*scf++) << shift];
+            step = 3;
+          }
+        }
+        {
+          register short *val = h->table;
+          REFRESH_MASK;
+          while((y=*val++)<0) {
+            if (mask < 0)
+              val -= y;
+            num--;
+            mask <<= 1;
+          }
+          x = y >> 4;
+          y &= 0xf;
+        }
+        if(x == 15 && h->linbits) {
+          max[lwin] = cb;
+          REFRESH_MASK;
+          x += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          num -= h->linbits+1;
+          mask <<= h->linbits;
+          if(mask < 0)
+            *xrpnt = REAL_MUL(-ispow[x], v);
+          else
+            *xrpnt = REAL_MUL(ispow[x], v);
+          mask <<= 1;
+        }
+        else if(x) {
+          max[lwin] = cb;
+          if(mask < 0)
+            *xrpnt = REAL_MUL(-ispow[x], v);
+          else
+            *xrpnt = REAL_MUL(ispow[x], v);
+          num--;
+          mask <<= 1;
+        }
+        else
+          *xrpnt = DOUBLE_TO_REAL(0.0);
+        xrpnt += step;
+        if(y == 15 && h->linbits) {
+          max[lwin] = cb;
+          REFRESH_MASK;
+          y += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          num -= h->linbits+1;
+          mask <<= h->linbits;
+          if(mask < 0)
+            *xrpnt = REAL_MUL(-ispow[y], v);
+          else
+            *xrpnt = REAL_MUL(ispow[y], v);
+          mask <<= 1;
+        }
+        else if(y) {
+          max[lwin] = cb;
+          if(mask < 0)
+            *xrpnt = REAL_MUL(-ispow[y], v);
+          else
+            *xrpnt = REAL_MUL(ispow[y], v);
+          num--;
+          mask <<= 1;
+        }
+        else
+          *xrpnt = DOUBLE_TO_REAL(0.0);
+        xrpnt += step;
+      }
+    }
+
+    for(;l3 && (part2remain+num > 0);l3--) {
+      struct newhuff *h = htc+gr_info->count1table_select;
+      register short *val = h->table,a;
+
+      REFRESH_MASK;
+      while((a=*val++)<0) {
+        if (mask < 0)
+          val -= a;
+        num--;
+        mask <<= 1;
+      }
+      if(part2remain+num <= 0) {
+	num -= part2remain+num;
+	break;
+      }
+
+      for(i=0;i<4;i++) {
+        if(!(i & 1)) {
+          if(!mc) {
+            mc = *m++;
+            xrpnt = ((real *) xr) + (*m++);
+            lwin = *m++;
+            cb = *m++;
+            if(lwin == 3) {
+              v = gr_info->pow2gain[(*scf++) << shift];
+              step = 1;
+            }
+            else {
+              v = gr_info->full_gain[lwin][(*scf++) << shift];
+              step = 3;
+            }
+          }
+          mc--;
+        }
+        if( (a & (0x8>>i)) ) {
+          max[lwin] = cb;
+          if(part2remain+num <= 0) {
+            break;
+          }
+          if(mask < 0) 
+            *xrpnt = -v;
+          else
+            *xrpnt = v;
+          num--;
+          mask <<= 1;
+        }
+        else
+          *xrpnt = DOUBLE_TO_REAL(0.0);
+        xrpnt += step;
+      }
+    }
+
+    if(lwin < 3) { /* short band? */
+      while(1) {
+        for(;mc > 0;mc--) {
+          *xrpnt = DOUBLE_TO_REAL(0.0); xrpnt += 3; /* short band -> step=3 */
+          *xrpnt = DOUBLE_TO_REAL(0.0); xrpnt += 3;
+        }
+        if(m >= me)
+          break;
+        mc    = *m++;
+        xrpnt = ((real *) xr) + *m++;
+        if(*m++ == 0)
+          break; /* optimize: field will be set to zero at the end of the function */
+        m++; /* cb */
+      }
+    }
+
+    gr_info->maxband[0] = max[0]+1;
+    gr_info->maxband[1] = max[1]+1;
+    gr_info->maxband[2] = max[2]+1;
+    gr_info->maxbandl = max[3]+1;
+
+    {
+      int rmax = max[0] > max[1] ? max[0] : max[1];
+      rmax = (rmax > max[2] ? rmax : max[2]) + 1;
+      gr_info->maxb = rmax ? shortLimit[sfreq][rmax] : longLimit[sfreq][max[3]+1];
+    }
+
+  }
+  else {
+    /*
+     * decoding with 'long' BandIndex table (block_type != 2)
+     */
+    int *pretab = gr_info->preflag ? pretab1 : pretab2;
+    int i,max = -1;
+    int cb = 0;
+    int *m = map[sfreq][2];
+    register real v = 0.0;
+    int mc = 0;
+
+    /*
+     * long hash table values
+     */
+    for(i=0;i<3;i++) {
+      int lp = l[i];
+      struct newhuff *h = ht+gr_info->table_select[i];
+
+      for(;lp;lp--,mc--) {
+        int x,y;
+
+        if(!mc) {
+          mc = *m++;
+          cb = *m++;
+#ifdef CUT_HF
+          if(cb == 21) {
+            fprintf(stderr,"c");
+            v = 0.0;
+          }
+          else
+#endif
+            v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+
+        }
+        {
+          register short *val = h->table;
+          REFRESH_MASK;
+          while((y=*val++)<0) {
+            if (mask < 0)
+              val -= y;
+            num--;
+            mask <<= 1;
+          }
+          x = y >> 4;
+          y &= 0xf;
+        }
+
+        if (x == 15 && h->linbits) {
+          max = cb;
+	  REFRESH_MASK;
+          x += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          num -= h->linbits+1;
+          mask <<= h->linbits;
+          if(mask < 0)
+            *xrpnt++ = REAL_MUL(-ispow[x], v);
+          else
+            *xrpnt++ = REAL_MUL(ispow[x], v);
+          mask <<= 1;
+        }
+        else if(x) {
+          max = cb;
+          if(mask < 0)
+            *xrpnt++ = REAL_MUL(-ispow[x], v);
+          else
+            *xrpnt++ = REAL_MUL(ispow[x], v);
+          num--;
+          mask <<= 1;
+        }
+        else
+          *xrpnt++ = DOUBLE_TO_REAL(0.0);
+
+        if (y == 15 && h->linbits) {
+          max = cb;
+	  REFRESH_MASK;
+          y += ((unsigned long) mask) >> (BITSHIFT+8-h->linbits);
+          num -= h->linbits+1;
+          mask <<= h->linbits;
+          if(mask < 0)
+            *xrpnt++ = REAL_MUL(-ispow[y], v);
+          else
+            *xrpnt++ = REAL_MUL(ispow[y], v);
+          mask <<= 1;
+        }
+        else if(y) {
+          max = cb;
+          if(mask < 0)
+            *xrpnt++ = REAL_MUL(-ispow[y], v);
+          else
+            *xrpnt++ = REAL_MUL(ispow[y], v);
+          num--;
+          mask <<= 1;
+        }
+        else
+          *xrpnt++ = DOUBLE_TO_REAL(0.0);
+      }
+    }
+
+    /*
+     * short (count1table) values
+     */
+    for(;l3 && (part2remain+num > 0);l3--) {
+      struct newhuff *h = htc+gr_info->count1table_select;
+      register short *val = h->table,a;
+
+      REFRESH_MASK;
+      while((a=*val++)<0) {
+        if (mask < 0)
+          val -= a;
+        num--;
+        mask <<= 1;
+      }
+      if(part2remain+num <= 0) {
+	num -= part2remain+num;
+        break;
+      }
+
+      for(i=0;i<4;i++) {
+        if(!(i & 1)) {
+          if(!mc) {
+            mc = *m++;
+            cb = *m++;
+#ifdef CUT_HF
+            if(cb == 21) { 
+              fprintf(stderr,"c");
+              v = 0.0;
+            }
+            else
+#endif
+              v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+          }
+          mc--;
+        }
+        if ( (a & (0x8>>i)) ) {
+          max = cb;
+          if(part2remain+num <= 0) {
+            break;
+          }
+          if(mask < 0)
+            *xrpnt++ = -v;
+          else
+            *xrpnt++ = v;
+          num--;
+          mask <<= 1;
+        }
+        else
+          *xrpnt++ = DOUBLE_TO_REAL(0.0);
+      }
+    }
+
+    gr_info->maxbandl = max+1;
+    gr_info->maxb = longLimit[sfreq][gr_info->maxbandl];
+  }
+
+  part2remain += num;
+  backbits(&bsi,num);
+  num = 0;
+
+  while(xrpnt < &xr[SBLIMIT][0]) 
+    *xrpnt++ = DOUBLE_TO_REAL(0.0);
+
+  while( part2remain > 16 ) {
+    getbits(&bsi,16); /* Dismiss stuffing Bits */
+    part2remain -= 16;
+  }
+  if(part2remain > 0)
+    getbits(&bsi,part2remain);
+  else if(part2remain < 0) {
+    if(param.verbose)
+      fprintf(stderr,"mpg123: Can't rewind stream by %d bits!\n",-part2remain);
+    return 1; /* -> error */
+  }
+  return 0;
+}
+
+/* 
+ * III_stereo: calculate real channel values for Joint-I-Stereo-mode
+ */
+static void III_i_stereo(real xr_buf[2][SBLIMIT][SSLIMIT],int *scalefac,
+   struct gr_info_s *gr_info,int sfreq,int ms_stereo,int lsf)
+{
+      real (*xr)[SBLIMIT*SSLIMIT] = (real (*)[SBLIMIT*SSLIMIT] ) xr_buf;
+      struct bandInfoStruct *bi = &bandInfo[sfreq];
+
+      const real *tab1,*tab2;
+
+      int tab;
+      static const real *tabs[3][2][2] = { 
+         { { tan1_1,tan2_1 }     , { tan1_2,tan2_2 } },
+         { { pow1_1[0],pow2_1[0] } , { pow1_2[0],pow2_2[0] } } ,
+         { { pow1_1[1],pow2_1[1] } , { pow1_2[1],pow2_2[1] } } 
+      };
+
+      tab = lsf + (gr_info->scalefac_compress & lsf);
+      tab1 = tabs[tab][ms_stereo][0];
+      tab2 = tabs[tab][ms_stereo][1];
+#if 0
+      if(lsf) {
+        int p = gr_info->scalefac_compress & 0x1;
+	if(ms_stereo) {
+          tab1 = pow1_2[p]; tab2 = pow2_2[p];
+        }
+        else {
+          tab1 = pow1_1[p]; tab2 = pow2_1[p];
+        }
+      }
+      else {
+        if(ms_stereo) {
+          tab1 = tan1_2; tab2 = tan2_2;
+        }
+        else {
+          tab1 = tan1_1; tab2 = tan2_1;
+        }
+      }
+#endif
+
+      if (gr_info->block_type == 2) {
+         int lwin,do_l = 0;
+         if( gr_info->mixed_block_flag )
+           do_l = 1;
+
+         for (lwin=0;lwin<3;lwin++) { /* process each window */
+             /* get first band with zero values */
+           int is_p,sb,idx,sfb = gr_info->maxband[lwin];  /* sfb is minimal 3 for mixed mode */
+           if(sfb > 3)
+             do_l = 0;
+
+           for(;sfb<12;sfb++) {
+             is_p = scalefac[sfb*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */ 
+             if(is_p != 7) {
+               real t1,t2;
+               sb  = bi->shortDiff[sfb];
+               idx = bi->shortIdx[sfb] + lwin;
+               t1  = tab1[is_p]; t2 = tab2[is_p];
+               for (; sb > 0; sb--,idx+=3) {
+                 real v = xr[0][idx];
+                 xr[0][idx] = REAL_MUL(v, t1);
+                 xr[1][idx] = REAL_MUL(v, t2);
+               }
+             }
+           }
+
+#if 1
+/* in the original: copy 10 to 11 , here: copy 11 to 12 
+maybe still wrong??? (copy 12 to 13?) */
+           is_p = scalefac[11*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+           sb   = bi->shortDiff[12];
+           idx  = bi->shortIdx[12] + lwin;
+#else
+           is_p = scalefac[10*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+           sb   = bi->shortDiff[11];
+           idx  = bi->shortIdx[11] + lwin;
+#endif
+           if(is_p != 7) {
+             real t1,t2;
+             t1 = tab1[is_p]; t2 = tab2[is_p];
+             for ( ; sb > 0; sb--,idx+=3 ) {  
+               real v = xr[0][idx];
+               xr[0][idx] = REAL_MUL(v, t1);
+               xr[1][idx] = REAL_MUL(v, t2);
+             }
+           }
+         } /* end for(lwin; .. ; . ) */
+
+/* also check l-part, if ALL bands in the three windows are 'empty'
+ * and mode = mixed_mode 
+ */
+         if (do_l) {
+           int sfb = gr_info->maxbandl;
+           int idx = bi->longIdx[sfb];
+
+           for ( ; sfb<8; sfb++ ) {
+             int sb = bi->longDiff[sfb];
+             int is_p = scalefac[sfb]; /* scale: 0-15 */
+             if(is_p != 7) {
+               real t1,t2;
+               t1 = tab1[is_p]; t2 = tab2[is_p];
+               for ( ; sb > 0; sb--,idx++) {
+                 real v = xr[0][idx];
+                 xr[0][idx] = REAL_MUL(v, t1);
+                 xr[1][idx] = REAL_MUL(v, t2);
+               }
+             }
+             else 
+               idx += sb;
+           }
+         }     
+      } 
+      else { /* ((gr_info->block_type != 2)) */
+       int sfb = gr_info->maxbandl;
+       int is_p,idx = bi->longIdx[sfb];
+
+/* hmm ... maybe the maxbandl stuff for i-stereo is buggy? */
+       if(sfb <= 21) { 
+        for ( ; sfb<21; sfb++) {
+          int sb = bi->longDiff[sfb];
+          is_p = scalefac[sfb]; /* scale: 0-15 */
+          if(is_p != 7) {
+            real t1,t2;
+            t1 = tab1[is_p]; t2 = tab2[is_p];
+            for ( ; sb > 0; sb--,idx++) {
+               real v = xr[0][idx];
+               xr[0][idx] = REAL_MUL(v, t1);
+               xr[1][idx] = REAL_MUL(v, t2);
+            }
+          }
+          else
+            idx += sb;
+        }
+
+        is_p = scalefac[20];
+        if(is_p != 7) {  /* copy l-band 20 to l-band 21 */
+          int sb;
+          real t1 = tab1[is_p],t2 = tab2[is_p]; 
+
+          for ( sb = bi->longDiff[21]; sb > 0; sb--,idx++ ) {
+            real v = xr[0][idx];
+            xr[0][idx] = REAL_MUL(v, t1);
+            xr[1][idx] = REAL_MUL(v, t2);
+          }
+        }
+       }        /* end: if(sfb <= 21) */
+      } /* ... */
+}
+
+static void III_antialias(real xr[SBLIMIT][SSLIMIT],struct gr_info_s *gr_info) {
+   int sblim;
+
+   if(gr_info->block_type == 2) {
+      if(!gr_info->mixed_block_flag) 
+        return;
+      sblim = 1; 
+   }
+   else {
+     sblim = gr_info->maxb-1;
+   }
+
+   /* 31 alias-reduction operations between each pair of sub-bands */
+   /* with 8 butterflies between each pair                         */
+
+   {
+     int sb;
+     real *xr1=(real *) xr[1];
+
+     for(sb=sblim;sb;sb--,xr1+=10) {
+       int ss;
+       real *cs=aa_cs,*ca=aa_ca;
+       real *xr2 = xr1;
+
+       for(ss=7;ss>=0;ss--)
+       {       /* upper and lower butterfly inputs */
+         register real bu = *--xr2,bd = *xr1;
+	 *xr2   = REAL_MUL(bu, *cs) - REAL_MUL(bd, *ca);
+	 *xr1++ = REAL_MUL(bd, *cs++) + REAL_MUL(bu, *ca++);
+       }
+     }
+  }
+}
+
+/* 
+ This is an optimized DCT from Jeff Tsay's maplay 1.2+ package.
+ Saved one multiplication by doing the 'twiddle factor' stuff
+ together with the window mul. (MH)
+
+ This uses Byeong Gi Lee's Fast Cosine Transform algorithm, but the
+ 9 point IDCT needs to be reduced further. Unfortunately, I don't
+ know how to do that, because 9 is not an even number. - Jeff.
+
+ ****************************************************************
+
+ 9 Point Inverse Discrete Cosine Transform
+
+ This piece of code is Copyright 1997 Mikko Tommila and is freely usable
+ by anybody. The algorithm itself is of course in the public domain.
+
+ Again derived heuristically from the 9-point WFTA.
+
+ The algorithm is optimized (?) for speed, not for small rounding errors or
+ good readability.
+
+ 36 additions, 11 multiplications
+
+ Again this is very likely sub-optimal.
+
+ The code is optimized to use a minimum number of temporary variables,
+ so it should compile quite well even on 8-register Intel x86 processors.
+ This makes the code quite obfuscated and very difficult to understand.
+
+ References:
+ [1] S. Winograd: "On Computing the Discrete Fourier Transform",
+     Mathematics of Computation, Volume 32, Number 141, January 1978,
+     Pages 175-199
+*/
+
+/*------------------------------------------------------------------*/
+/*                                                                  */
+/*    Function: Calculation of the inverse MDCT                     */
+/*                                                                  */
+/*------------------------------------------------------------------*/
+
+void dct36(real *inbuf,real *o1,real *o2,real *wintab,real *tsbuf)
+{
+#ifdef NEW_DCT9
+  real tmp[18];
+#endif
+
+  {
+    register real *in = inbuf;
+
+    in[17]+=in[16]; in[16]+=in[15]; in[15]+=in[14];
+    in[14]+=in[13]; in[13]+=in[12]; in[12]+=in[11];
+    in[11]+=in[10]; in[10]+=in[9];  in[9] +=in[8];
+    in[8] +=in[7];  in[7] +=in[6];  in[6] +=in[5];
+    in[5] +=in[4];  in[4] +=in[3];  in[3] +=in[2];
+    in[2] +=in[1];  in[1] +=in[0];
+
+    in[17]+=in[15]; in[15]+=in[13]; in[13]+=in[11]; in[11]+=in[9];
+    in[9] +=in[7];  in[7] +=in[5];  in[5] +=in[3];  in[3] +=in[1];
+
+
+#ifdef NEW_DCT9
+#if 1
+    {
+     real t3;
+     { 
+      real t0, t1, t2;
+
+      t0 = REAL_MUL(COS6_2, (in[8] + in[16] - in[4]));
+      t1 = REAL_MUL(COS6_2, in[12]);
+
+      t3 = in[0];
+      t2 = t3 - t1 - t1;
+      tmp[1] = tmp[7] = t2 - t0;
+      tmp[4]          = t2 + t0 + t0;
+      t3 += t1;
+
+      t2 = REAL_MUL(COS6_1, (in[10] + in[14] - in[2]));
+      tmp[1] -= t2;
+      tmp[7] += t2;
+     }
+     {
+      real t0, t1, t2;
+
+      t0 = REAL_MUL(cos9[0], (in[4] + in[8] ));
+      t1 = REAL_MUL(cos9[1], (in[8] - in[16]));
+      t2 = REAL_MUL(cos9[2], (in[4] + in[16]));
+
+      tmp[2] = tmp[6] = t3 - t0      - t2;
+      tmp[0] = tmp[8] = t3 + t0 + t1;
+      tmp[3] = tmp[5] = t3      - t1 + t2;
+     }
+    }
+    {
+      real t1, t2, t3;
+
+      t1 = REAL_MUL(cos18[0], (in[2]  + in[10]));
+      t2 = REAL_MUL(cos18[1], (in[10] - in[14]));
+      t3 = REAL_MUL(COS6_1,    in[6]);
+
+      {
+        real t0 = t1 + t2 + t3;
+        tmp[0] += t0;
+        tmp[8] -= t0;
+      }
+
+      t2 -= t3;
+      t1 -= t3;
+
+      t3 = REAL_MUL(cos18[2], (in[2] + in[14]));
+
+      t1 += t3;
+      tmp[3] += t1;
+      tmp[5] -= t1;
+
+      t2 -= t3;
+      tmp[2] += t2;
+      tmp[6] -= t2;
+    }
+
+#else
+    {
+      real t0, t1, t2, t3, t4, t5, t6, t7;
+
+      t1 = REAL_MUL(COS6_2, in[12]);
+      t2 = REAL_MUL(COS6_2, (in[8] + in[16] - in[4]));
+
+      t3 = in[0] + t1;
+      t4 = in[0] - t1 - t1;
+      t5     = t4 - t2;
+      tmp[4] = t4 + t2 + t2;
+
+      t0 = REAL_MUL(cos9[0], (in[4] + in[8]));
+      t1 = REAL_MUL(cos9[1], (in[8] - in[16]));
+
+      t2 = REAL_MUL(cos9[2], (in[4] + in[16]));
+
+      t6 = t3 - t0 - t2;
+      t0 += t3 + t1;
+      t3 += t2 - t1;
+
+      t2 = REAL_MUL(cos18[0], (in[2]  + in[10]));
+      t4 = REAL_MUL(cos18[1], (in[10] - in[14]));
+      t7 = REAL_MUL(COS6_1, in[6]);
+
+      t1 = t2 + t4 + t7;
+      tmp[0] = t0 + t1;
+      tmp[8] = t0 - t1;
+      t1 = REAL_MUL(cos18[2], (in[2] + in[14]));
+      t2 += t1 - t7;
+
+      tmp[3] = t3 + t2;
+      t0 = REAL_MUL(COS6_1, (in[10] + in[14] - in[2]));
+      tmp[5] = t3 - t2;
+
+      t4 -= t1 + t7;
+
+      tmp[1] = t5 - t0;
+      tmp[7] = t5 + t0;
+      tmp[2] = t6 + t4;
+      tmp[6] = t6 - t4;
+    }
+#endif
+
+    {
+      real t0, t1, t2, t3, t4, t5, t6, t7;
+
+      t1 = REAL_MUL(COS6_2, in[13]);
+      t2 = REAL_MUL(COS6_2, (in[9] + in[17] - in[5]));
+
+      t3 = in[1] + t1;
+      t4 = in[1] - t1 - t1;
+      t5 = t4 - t2;
+
+      t0 = REAL_MUL(cos9[0], (in[5] + in[9]));
+      t1 = REAL_MUL(cos9[1], (in[9] - in[17]));
+
+      tmp[13] = REAL_MUL((t4 + t2 + t2), tfcos36[17-13]);
+      t2 = REAL_MUL(cos9[2], (in[5] + in[17]));
+
+      t6 = t3 - t0 - t2;
+      t0 += t3 + t1;
+      t3 += t2 - t1;
+
+      t2 = REAL_MUL(cos18[0], (in[3]  + in[11]));
+      t4 = REAL_MUL(cos18[1], (in[11] - in[15]));
+      t7 = REAL_MUL(COS6_1, in[7]);
+
+      t1 = t2 + t4 + t7;
+      tmp[17] = REAL_MUL((t0 + t1), tfcos36[17-17]);
+      tmp[9]  = REAL_MUL((t0 - t1), tfcos36[17-9]);
+      t1 = REAL_MUL(cos18[2], (in[3] + in[15]));
+      t2 += t1 - t7;
+
+      tmp[14] = REAL_MUL((t3 + t2), tfcos36[17-14]);
+      t0 = REAL_MUL(COS6_1, (in[11] + in[15] - in[3]));
+      tmp[12] = REAL_MUL((t3 - t2), tfcos36[17-12]);
+
+      t4 -= t1 + t7;
+
+      tmp[16] = REAL_MUL((t5 - t0), tfcos36[17-16]);
+      tmp[10] = REAL_MUL((t5 + t0), tfcos36[17-10]);
+      tmp[15] = REAL_MUL((t6 + t4), tfcos36[17-15]);
+      tmp[11] = REAL_MUL((t6 - t4), tfcos36[17-11]);
+   }
+
+#define MACRO(v) { \
+    real tmpval; \
+    tmpval = tmp[(v)] + tmp[17-(v)]; \
+    out2[9+(v)] = REAL_MUL(tmpval, w[27+(v)]); \
+    out2[8-(v)] = REAL_MUL(tmpval, w[26-(v)]); \
+    tmpval = tmp[(v)] - tmp[17-(v)]; \
+    ts[SBLIMIT*(8-(v))] = out1[8-(v)] + REAL_MUL(tmpval, w[8-(v)]); \
+    ts[SBLIMIT*(9+(v))] = out1[9+(v)] + REAL_MUL(tmpval, w[9+(v)]); }
+
+{
+   register real *out2 = o2;
+   register real *w = wintab;
+   register real *out1 = o1;
+   register real *ts = tsbuf;
+
+   MACRO(0);
+   MACRO(1);
+   MACRO(2);
+   MACRO(3);
+   MACRO(4);
+   MACRO(5);
+   MACRO(6);
+   MACRO(7);
+   MACRO(8);
+}
+
+#else
+
+  {
+
+#define MACRO0(v) { \
+    real tmp; \
+    out2[9+(v)] = REAL_MUL((tmp = sum0 + sum1), w[27+(v)]); \
+    out2[8-(v)] = REAL_MUL(tmp, w[26-(v)]);   } \
+    sum0 -= sum1; \
+    ts[SBLIMIT*(8-(v))] = out1[8-(v)] + REAL_MUL(sum0, w[8-(v)]); \
+    ts[SBLIMIT*(9+(v))] = out1[9+(v)] + REAL_MUL(sum0, w[9+(v)]);
+#define MACRO1(v) { \
+	real sum0,sum1; \
+    sum0 = tmp1a + tmp2a; \
+	sum1 = REAL_MUL((tmp1b + tmp2b), tfcos36[(v)]); \
+	MACRO0(v); }
+#define MACRO2(v) { \
+    real sum0,sum1; \
+    sum0 = tmp2a - tmp1a; \
+    sum1 = REAL_MUL((tmp2b - tmp1b), tfcos36[(v)]); \
+	MACRO0(v); }
+
+    register const real *c = COS9;
+    register real *out2 = o2;
+	register real *w = wintab;
+	register real *out1 = o1;
+	register real *ts = tsbuf;
+
+    real ta33,ta66,tb33,tb66;
+
+    ta33 = REAL_MUL(in[2*3+0], c[3]);
+    ta66 = REAL_MUL(in[2*6+0], c[6]);
+    tb33 = REAL_MUL(in[2*3+1], c[3]);
+    tb66 = REAL_MUL(in[2*6+1], c[6]);
+
+    { 
+      real tmp1a,tmp2a,tmp1b,tmp2b;
+      tmp1a = REAL_MUL(in[2*1+0], c[1]) + ta33 + REAL_MUL(in[2*5+0], c[5]) + REAL_MUL(in[2*7+0], c[7]);
+      tmp1b = REAL_MUL(in[2*1+1], c[1]) + tb33 + REAL_MUL(in[2*5+1], c[5]) + REAL_MUL(in[2*7+1], c[7]);
+      tmp2a = REAL_MUL(in[2*2+0], c[2]) + REAL_MUL(in[2*4+0], c[4]) + ta66 + REAL_MUL(in[2*8+0], c[8]);
+      tmp2b = REAL_MUL(in[2*2+1], c[2]) + REAL_MUL(in[2*4+1], c[4]) + tb66 + REAL_MUL(in[2*8+1], c[8]);
+
+      MACRO1(0);
+      MACRO2(8);
+    }
+
+    {
+      real tmp1a,tmp2a,tmp1b,tmp2b;
+      tmp1a = REAL_MUL(( in[2*1+0] - in[2*5+0] - in[2*7+0] ), c[3]);
+      tmp1b = REAL_MUL(( in[2*1+1] - in[2*5+1] - in[2*7+1] ), c[3]);
+      tmp2a = REAL_MUL(( in[2*2+0] - in[2*4+0] - in[2*8+0] ), c[6]) - in[2*6+0] + in[2*0+0];
+      tmp2b = REAL_MUL(( in[2*2+1] - in[2*4+1] - in[2*8+1] ), c[6]) - in[2*6+1] + in[2*0+1];
+
+      MACRO1(1);
+      MACRO2(7);
+    }
+
+    {
+      real tmp1a,tmp2a,tmp1b,tmp2b;
+      tmp1a =   REAL_MUL(in[2*1+0], c[5]) - ta33 - REAL_MUL(in[2*5+0], c[7]) + REAL_MUL(in[2*7+0], c[1]);
+      tmp1b =   REAL_MUL(in[2*1+1], c[5]) - tb33 - REAL_MUL(in[2*5+1], c[7]) + REAL_MUL(in[2*7+1], c[1]);
+      tmp2a = - REAL_MUL(in[2*2+0], c[8]) - REAL_MUL(in[2*4+0], c[2]) + ta66 + REAL_MUL(in[2*8+0], c[4]);
+      tmp2b = - REAL_MUL(in[2*2+1], c[8]) - REAL_MUL(in[2*4+1], c[2]) + tb66 + REAL_MUL(in[2*8+1], c[4]);
+
+      MACRO1(2);
+      MACRO2(6);
+    }
+
+    {
+      real tmp1a,tmp2a,tmp1b,tmp2b;
+      tmp1a =   REAL_MUL(in[2*1+0], c[7]) - ta33 + REAL_MUL(in[2*5+0], c[1]) - REAL_MUL(in[2*7+0], c[5]);
+      tmp1b =   REAL_MUL(in[2*1+1], c[7]) - tb33 + REAL_MUL(in[2*5+1], c[1]) - REAL_MUL(in[2*7+1], c[5]);
+      tmp2a = - REAL_MUL(in[2*2+0], c[4]) + REAL_MUL(in[2*4+0], c[8]) + ta66 - REAL_MUL(in[2*8+0], c[2]);
+      tmp2b = - REAL_MUL(in[2*2+1], c[4]) + REAL_MUL(in[2*4+1], c[8]) + tb66 - REAL_MUL(in[2*8+1], c[2]);
+
+      MACRO1(3);
+      MACRO2(5);
+    }
+
+	{
+		real sum0,sum1;
+    	sum0 =  in[2*0+0] - in[2*2+0] + in[2*4+0] - in[2*6+0] + in[2*8+0];
+    	sum1 = REAL_MUL((in[2*0+1] - in[2*2+1] + in[2*4+1] - in[2*6+1] + in[2*8+1] ), tfcos36[4]);
+		MACRO0(4);
+	}
+  }
+#endif
+
+  }
+}
+
+/*
+ * new DCT12
+ */
+static void dct12(real *in,real *rawout1,real *rawout2,register real *wi,register real *ts)
+{
+#define DCT12_PART1 \
+             in5 = in[5*3];  \
+     in5 += (in4 = in[4*3]); \
+     in4 += (in3 = in[3*3]); \
+     in3 += (in2 = in[2*3]); \
+     in2 += (in1 = in[1*3]); \
+     in1 += (in0 = in[0*3]); \
+                             \
+     in5 += in3; in3 += in1; \
+                             \
+     in2 = REAL_MUL(in2, COS6_1); \
+     in3 = REAL_MUL(in3, COS6_1); \
+
+#define DCT12_PART2 \
+     in0 += REAL_MUL(in4, COS6_2); \
+                          \
+     in4 = in0 + in2;     \
+     in0 -= in2;          \
+                          \
+     in1 += REAL_MUL(in5, COS6_2); \
+                          \
+     in5 = REAL_MUL((in1 + in3), tfcos12[0]); \
+     in1 = REAL_MUL((in1 - in3), tfcos12[2]); \
+                         \
+     in3 = in4 + in5;    \
+     in4 -= in5;         \
+                         \
+     in2 = in0 + in1;    \
+     in0 -= in1;
+
+
+   {
+     real in0,in1,in2,in3,in4,in5;
+     register real *out1 = rawout1;
+     ts[SBLIMIT*0] = out1[0]; ts[SBLIMIT*1] = out1[1]; ts[SBLIMIT*2] = out1[2];
+     ts[SBLIMIT*3] = out1[3]; ts[SBLIMIT*4] = out1[4]; ts[SBLIMIT*5] = out1[5];
+ 
+     DCT12_PART1
+
+     {
+       real tmp0,tmp1 = (in0 - in4);
+       {
+         real tmp2 = REAL_MUL((in1 - in5), tfcos12[1]);
+         tmp0 = tmp1 + tmp2;
+         tmp1 -= tmp2;
+       }
+       ts[(17-1)*SBLIMIT] = out1[17-1] + REAL_MUL(tmp0, wi[11-1]);
+       ts[(12+1)*SBLIMIT] = out1[12+1] + REAL_MUL(tmp0, wi[6+1]);
+       ts[(6 +1)*SBLIMIT] = out1[6 +1] + REAL_MUL(tmp1, wi[1]);
+       ts[(11-1)*SBLIMIT] = out1[11-1] + REAL_MUL(tmp1, wi[5-1]);
+     }
+
+     DCT12_PART2
+
+     ts[(17-0)*SBLIMIT] = out1[17-0] + REAL_MUL(in2, wi[11-0]);
+     ts[(12+0)*SBLIMIT] = out1[12+0] + REAL_MUL(in2, wi[6+0]);
+     ts[(12+2)*SBLIMIT] = out1[12+2] + REAL_MUL(in3, wi[6+2]);
+     ts[(17-2)*SBLIMIT] = out1[17-2] + REAL_MUL(in3, wi[11-2]);
+
+     ts[(6 +0)*SBLIMIT]  = out1[6+0] + REAL_MUL(in0, wi[0]);
+     ts[(11-0)*SBLIMIT] = out1[11-0] + REAL_MUL(in0, wi[5-0]);
+     ts[(6 +2)*SBLIMIT]  = out1[6+2] + REAL_MUL(in4, wi[2]);
+     ts[(11-2)*SBLIMIT] = out1[11-2] + REAL_MUL(in4, wi[5-2]);
+  }
+
+  in++;
+
+  {
+     real in0,in1,in2,in3,in4,in5;
+     register real *out2 = rawout2;
+ 
+     DCT12_PART1
+
+     {
+       real tmp0,tmp1 = (in0 - in4);
+       {
+         real tmp2 = REAL_MUL((in1 - in5), tfcos12[1]);
+         tmp0 = tmp1 + tmp2;
+         tmp1 -= tmp2;
+       }
+       out2[5-1] = REAL_MUL(tmp0, wi[11-1]);
+       out2[0+1] = REAL_MUL(tmp0, wi[6+1]);
+       ts[(12+1)*SBLIMIT] += REAL_MUL(tmp1, wi[1]);
+       ts[(17-1)*SBLIMIT] += REAL_MUL(tmp1, wi[5-1]);
+     }
+
+     DCT12_PART2
+
+     out2[5-0] = REAL_MUL(in2, wi[11-0]);
+     out2[0+0] = REAL_MUL(in2, wi[6+0]);
+     out2[0+2] = REAL_MUL(in3, wi[6+2]);
+     out2[5-2] = REAL_MUL(in3, wi[11-2]);
+
+     ts[(12+0)*SBLIMIT] += REAL_MUL(in0, wi[0]);
+     ts[(17-0)*SBLIMIT] += REAL_MUL(in0, wi[5-0]);
+     ts[(12+2)*SBLIMIT] += REAL_MUL(in4, wi[2]);
+     ts[(17-2)*SBLIMIT] += REAL_MUL(in4, wi[5-2]);
+  }
+
+  in++; 
+
+  {
+     real in0,in1,in2,in3,in4,in5;
+     register real *out2 = rawout2;
+     out2[12]=out2[13]=out2[14]=out2[15]=out2[16]=out2[17]=0.0;
+
+     DCT12_PART1
+
+     {
+       real tmp0,tmp1 = (in0 - in4);
+       {
+         real tmp2 = REAL_MUL((in1 - in5), tfcos12[1]);
+         tmp0 = tmp1 + tmp2;
+         tmp1 -= tmp2;
+       }
+       out2[11-1] = REAL_MUL(tmp0, wi[11-1]);
+       out2[6 +1] = REAL_MUL(tmp0, wi[6+1]);
+       out2[0+1] += REAL_MUL(tmp1, wi[1]);
+       out2[5-1] += REAL_MUL(tmp1, wi[5-1]);
+     }
+
+     DCT12_PART2
+
+     out2[11-0] = REAL_MUL(in2, wi[11-0]);
+     out2[6 +0] = REAL_MUL(in2, wi[6+0]);
+     out2[6 +2] = REAL_MUL(in3, wi[6+2]);
+     out2[11-2] = REAL_MUL(in3, wi[11-2]);
+
+     out2[0+0] += REAL_MUL(in0, wi[0]);
+     out2[5-0] += REAL_MUL(in0, wi[5-0]);
+     out2[0+2] += REAL_MUL(in4, wi[2]);
+     out2[5-2] += REAL_MUL(in4, wi[5-2]);
+  }
+}
+
+/*
+ * III_hybrid
+ */
+static void III_hybrid(struct mpstr *mp,real fsIn[SBLIMIT][SSLIMIT],real tsOut[SSLIMIT][SBLIMIT],
+   int ch,struct gr_info_s *gr_info,struct frame *fr)
+{
+/*
+   static real block[2][2][SBLIMIT*SSLIMIT] = { { { 0, } } };
+   static int blc[2]={0,0};
+ */
+
+   real *tspnt = (real *) tsOut;
+   real *rawout1,*rawout2;
+   int bt,sb = 0;
+
+   {
+     int b = mp->hybrid_blc[ch];
+     rawout1=mp->hybrid_block[b][ch];
+     b=-b+1;
+     rawout2=mp->hybrid_block[b][ch];
+     mp->hybrid_blc[ch] = b;
+   }
+  
+   if(gr_info->mixed_block_flag) {
+     sb = 2;
+#ifdef USE_3DNOW
+     (fr->dct36)(fsIn[0],rawout1,rawout2,win[0],tspnt);
+     (fr->dct36)(fsIn[1],rawout1+18,rawout2+18,win1[0],tspnt+1);
+#else
+     dct36(fsIn[0],rawout1,rawout2,win[0],tspnt);
+     dct36(fsIn[1],rawout1+18,rawout2+18,win1[0],tspnt+1);
+#endif
+     rawout1 += 36; rawout2 += 36; tspnt += 2;
+   }
+ 
+   bt = gr_info->block_type;
+   if(bt == 2) {
+     for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+       dct12(fsIn[sb]  ,rawout1   ,rawout2   ,win[2] ,tspnt);
+       dct12(fsIn[sb+1],rawout1+18,rawout2+18,win1[2],tspnt+1);
+     }
+   }
+   else {
+     for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+#ifdef USE_3DNOW
+       (fr->dct36)(fsIn[sb],rawout1,rawout2,win[bt],tspnt);
+       (fr->dct36)(fsIn[sb+1],rawout1+18,rawout2+18,win1[bt],tspnt+1);
+#else
+       dct36(fsIn[sb],rawout1,rawout2,win[bt],tspnt);
+       dct36(fsIn[sb+1],rawout1+18,rawout2+18,win1[bt],tspnt+1);
+#endif
+     }
+   }
+
+   for(;sb<SBLIMIT;sb++,tspnt++) {
+     int i;
+     for(i=0;i<SSLIMIT;i++) {
+       tspnt[i*SBLIMIT] = *rawout1++;
+       *rawout2++ = DOUBLE_TO_REAL(0.0);
+     }
+   }
+}
+
+
+
+/*
+ * main layer3 handler
+ */
+int do_layer3(struct mpstr *mp,struct frame *fr,int outmode,struct audio_info_struct *ai)
+{
+  int gr, ch, ss,clip=0;
+  int scalefacs[2][39]; /* max 39 for short[13][3] mode, mixed: 38, long: 22 */
+  struct III_sideinfo sideinfo;
+  int stereo = fr->stereo;
+  int single = fr->single;
+  int ms_stereo,i_stereo;
+  int sfreq = fr->sampling_frequency;
+  int stereo1,granules;
+
+  if(stereo == 1) { /* stream is mono */
+    stereo1 = 1;
+    single = 0;
+  }
+  else if(single >= 0) /* stream is stereo, but force to mono */
+    stereo1 = 1;
+  else
+    stereo1 = 2;
+
+  if(fr->mode == MPG_MD_JOINT_STEREO) {
+    ms_stereo = (fr->mode_ext & 0x2)>>1;
+    i_stereo  = fr->mode_ext & 0x1;
+  }
+  else
+    ms_stereo = i_stereo = 0;
+
+  granules = fr->lsf ? 1 : 2;
+  if(!III_get_side_info(&sideinfo,stereo,ms_stereo,sfreq,single,fr->lsf))
+    return -1;
+
+  set_pointer(fr->sideInfoSize,sideinfo.main_data_begin);
+
+  for (gr=0;gr<granules;gr++) {
+    real hybridIn [2][SBLIMIT][SSLIMIT];
+    real hybridOut[2][SSLIMIT][SBLIMIT];
+
+    {
+      struct gr_info_s *gr_info = &(sideinfo.ch[0].gr[gr]);
+      long part2bits;
+      if(fr->lsf)
+        part2bits = III_get_scale_factors_2(scalefacs[0],gr_info,0);
+      else
+        part2bits = III_get_scale_factors_1(scalefacs[0],gr_info);
+
+      if(III_dequantize_sample(hybridIn[0], scalefacs[0],gr_info,sfreq,part2bits))
+        return clip;
+    }
+
+    if(stereo == 2) {
+      struct gr_info_s *gr_info = &(sideinfo.ch[1].gr[gr]);
+      long part2bits;
+      if(fr->lsf) 
+        part2bits = III_get_scale_factors_2(scalefacs[1],gr_info,i_stereo);
+      else
+        part2bits = III_get_scale_factors_1(scalefacs[1],gr_info);
+
+      if(III_dequantize_sample(hybridIn[1],scalefacs[1],gr_info,sfreq,part2bits))
+          return clip;
+
+      if(ms_stereo) {
+        int i;
+        int maxb = sideinfo.ch[0].gr[gr].maxb;
+        if(sideinfo.ch[1].gr[gr].maxb > maxb)
+            maxb = sideinfo.ch[1].gr[gr].maxb;
+        for(i=0;i<SSLIMIT*maxb;i++) {
+          real tmp0 = ((real *)hybridIn[0])[i];
+          real tmp1 = ((real *)hybridIn[1])[i];
+          ((real *)hybridIn[0])[i] = tmp0 + tmp1;
+          ((real *)hybridIn[1])[i] = tmp0 - tmp1;
+        }
+      }
+
+      if(i_stereo)
+        III_i_stereo(hybridIn,scalefacs[1],gr_info,sfreq,ms_stereo,fr->lsf);
+
+      if(ms_stereo || i_stereo || (single == 3) ) {
+        if(gr_info->maxb > sideinfo.ch[0].gr[gr].maxb) 
+          sideinfo.ch[0].gr[gr].maxb = gr_info->maxb;
+        else
+          gr_info->maxb = sideinfo.ch[0].gr[gr].maxb;
+      }
+
+      switch(single) {
+        case 3:
+          {
+            register int i;
+            register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+            for(i=0;i<SSLIMIT*gr_info->maxb;i++,in0++)
+              *in0 = (*in0 + *in1++); /* *0.5 done by pow-scale */ 
+          }
+          break;
+        case 1:
+          {
+            register int i;
+            register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+            for(i=0;i<SSLIMIT*gr_info->maxb;i++)
+              *in0++ = *in1++;
+          }
+          break;
+      }
+    }
+
+    for(ch=0;ch<stereo1;ch++) {
+      struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+      III_antialias(hybridIn[ch],gr_info);
+      III_hybrid(mp,hybridIn[ch], hybridOut[ch], ch,gr_info,fr);
+    }
+
+#ifdef I486_OPT
+    if (fr->synth != synth_1to1 || single >= 0) {
+#endif
+    for(ss=0;ss<SSLIMIT;ss++) {
+      if(single >= 0) {
+        clip += (fr->synth_mono)(hybridOut[0][ss],pcm_sample,&pcm_point);
+      }
+      else {
+        int p1 = pcm_point;
+        clip += (fr->synth)(hybridOut[0][ss],0,pcm_sample,&p1);
+        clip += (fr->synth)(hybridOut[1][ss],1,pcm_sample,&pcm_point);
+      }
+
+      if(pcm_point >= audiobufsize)
+        audio_flush(outmode,ai);
+    }
+#ifdef I486_OPT
+    } else {
+      /* Only stereo, 16 bits benefit from the 486 optimization. */
+      ss=0;
+      while (ss < SSLIMIT) {
+        int n;
+        n=(audiobufsize - pcm_point) / (2*2*32);
+        if (n > (SSLIMIT-ss)) n=SSLIMIT-ss;
+        
+        synth_1to1_486(hybridOut[0][ss],0,pcm_sample+pcm_point,n);
+        synth_1to1_486(hybridOut[1][ss],1,pcm_sample+pcm_point,n);
+        ss+=n;
+        pcm_point+=(2*2*32)*n;
+        
+        if(pcm_point >= audiobufsize)
+          audio_flush(outmode,ai);
+      }
+    }
+#endif
+  }
+  
+  return clip;
+}
