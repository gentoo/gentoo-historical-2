diff -ruNd cheesetracker-0.9.9.orig/common/components/data/dds_packer.cpp cheesetracker-0.9.9/common/components/data/dds_packer.cpp
--- cheesetracker-0.9.9.orig/common/components/data/dds_packer.cpp	2004-05-29 18:43:34.000000000 +0200
+++ cheesetracker-0.9.9/common/components/data/dds_packer.cpp	2004-05-29 18:59:21.000000000 +0200
@@ -63,8 +63,11 @@
 		}; break;
 
 		case DDS::T_POINTER: {
-			// warning
-			aux_int = (Uint32*)&p_I->second.data_ptr;
+			p_data.resize(p_data.size() + sizeof(void *));
+			store_ptr(p_data, data_index, p_I->second.data_ptr);
+			data_index += sizeof(void *);
+
+			return (data_index - p_index);
 		}; break;
 
 		case DDS::T_INT_ARRAY: {
@@ -234,6 +237,13 @@
 
 };
 
+void DDSPacker::store_ptr(data& p_data, Uint32 p_index, void * p_ptr)
+{
+	for (int i = 0; i < sizeof(void *); ++i) {
+		p_data[p_index + i] = ((Uint8 *) &p_ptr)[i];
+	}
+}
+
 void DDSPacker::store_dword(data& p_data, Uint32 data_index, Uint32 p_dword) {
 
 	//p_data.resize(p_data.size() + 4);
@@ -312,8 +322,8 @@
 
 		case DDS::T_POINTER: {
 			// warning
-			void* aux_pointer = (void*)get_dword(p_data, data_index);
-			data_index += 4;
+			void* aux_pointer = get_ptr(p_data, data_index);
+			data_index += sizeof(void *);
 			p_struct->set_pointer_var(name, aux_pointer);
 		}; break;
 
@@ -451,6 +461,17 @@
 
 };
 
+void * DDSPacker::get_ptr(const Uint8* p_data, Uint32 p_index)
+{
+	void * result = NULL;
+
+	for (int i = 0; i < sizeof(void *); ++i) {
+		((Uint8 *) &result)[i] = p_data[p_index + i];
+	}
+
+	return result;
+}
+
 Uint32 DDSPacker::get_dword(const Uint8* p_data, Uint32 p_index) {
 
 	Uint32 aux_value = 0;
diff -ruNd cheesetracker-0.9.9.orig/common/components/data/dds_packer.h cheesetracker-0.9.9/common/components/data/dds_packer.h
--- cheesetracker-0.9.9.orig/common/components/data/dds_packer.h	2004-05-29 18:43:34.000000000 +0200
+++ cheesetracker-0.9.9/common/components/data/dds_packer.h	2004-05-29 18:56:21.000000000 +0200
@@ -29,8 +29,10 @@
 
 public:
 	static void store_data(data& p_data, Uint32 p_index, const Uint8* p_data_ptr, Uint32 p_size);
+	static void store_ptr(data& p_data, Uint32 p_index, void * p_ptr);
 	static void store_dword(data& p_data, Uint32 data_index, Uint32 p_dword);
 	static Uint32 get_dword(const Uint8* p_data, Uint32 p_index);
+	static void * get_ptr(const Uint8* p_data, Uint32 p_index);
 	static Sint32 get_string(const Uint8* p_data, Uint32 p_data_size, Uint32 p_index, string &p_str);
 
 	static void pack(DDS* p_struct, data& p_vector, Uint32 p_offset = 0);
diff -ruNd cheesetracker-0.9.9.orig/common/plugins/resamplers/resampler_cosine.cpp 
cheesetracker-0.9.9/common/plugins/resamplers/resampler_cosine.cpp
--- cheesetracker-0.9.9.orig/common/plugins/resamplers/resampler_cosine.cpp	2004-05-29 18:43:34.000000000 +0200
+++ cheesetracker-0.9.9/common/plugins/resamplers/resampler_cosine.cpp	2004-05-30 11:05:31.417363920 +0200
@@ -26,7 +26,14 @@
 static void mix_cosine(Resampler::Mix_Data *mixdata,Sint32 *p_table) {
 
 	HELPER_INITIALIZE
-	Uint32 real_index;
+	/* 64bit: real_index was of type unsigned. If the index was in reality
+	 * representing a negative values (let's say -1 or 0xffffffff), there
+	 * was no problem on 32bit systems, because it was only used as an index
+	 * into a byte-array, where adding 0xffffffff or subtracting -1 is equivalent.
+	 * On a 64 bit system this is no longer the case, because no overflow occurs,
+	 * so that real_index is now signed.
+	 */
+	Sint32 real_index;
 	Sint32 last_sample=mixdata->sample->get_size()-1;
 	Uint32 fractional_mask=(1L<<fractional_size)-1L;
 	//sample_t next_index;
diff -ruNd cheesetracker-0.9.9.orig/common/plugins/resamplers/resampler_linear.cpp 
cheesetracker-0.9.9/common/plugins/resamplers/resampler_linear.cpp
--- cheesetracker-0.9.9.orig/common/plugins/resamplers/resampler_linear.cpp	2004-05-29 18:43:34.000000000 +0200
+++ cheesetracker-0.9.9/common/plugins/resamplers/resampler_linear.cpp	2004-05-30 11:10:57.120849464 +0200
@@ -21,7 +21,14 @@
 static void mix_linear(Resampler::Mix_Data *mixdata) {
 
 	HELPER_INITIALIZE
-	Uint32 real_index;
+	/* 64bit: real_index was of type unsigned. If the index was in reality
+	 * representing a negative values (let's say -1 or 0xffffffff), there
+	 * was no problem on 32bit systems, because it was only used as an index
+	 * into a byte-array, where adding 0xffffffff or subtracting -1 is equivalent.
+	 * On a 64 bit system this is no longer the case, because no overflow occurs,
+	 * so that real_index is now signed.
+	 */
+	Sint32 real_index;
 //	Sint32 last_sample=mixdata->sample->get_size()-1;
 	Uint32 fractional_mask=(1L<<fractional_size)-1L;
 	//sample_t next_index;
