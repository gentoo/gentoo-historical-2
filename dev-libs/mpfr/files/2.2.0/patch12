diff -Naurd mpfr-2.2.0-p11/get_f.c mpfr-2.2.0-p12/get_f.c
--- mpfr-2.2.0-p11/get_f.c	2006-01-13 15:04:34.000000000 +0000
+++ mpfr-2.2.0-p12/get_f.c	2006-05-26 21:10:14.000000000 +0000
@@ -29,6 +29,7 @@
 {
   mp_size_t sx, sy;
   mp_prec_t precx, precy;
+  mp_limb_t *xp;
   int sh;
 
   if (MPFR_UNLIKELY(MPFR_IS_SINGULAR(y)))
@@ -48,6 +49,8 @@
   precx = (mp_prec_t) sx * BITS_PER_MP_LIMB;
   sy = MPFR_LIMB_SIZE (y);
 
+  xp = PTR (x);
+
   /* since mpf numbers are represented in base 2^BITS_PER_MP_LIMB,
      we loose -EXP(y) % BITS_PER_MP_LIMB bits in the most significant limb */
   sh = MPFR_GET_EXP(y) % BITS_PER_MP_LIMB;
@@ -55,20 +58,31 @@
   MPFR_ASSERTD (sh >= 0);
   if (precy + sh <= precx) /* we can copy directly */
     {
+      mp_size_t ds;
+
       MPFR_ASSERTN (sx >= sy);
+      ds = sx - sy;
+
       if (sh != 0)
-        mpn_rshift (PTR(x) + sx - sy, MPFR_MANT(y), sy, sh);
+        {
+          mp_limb_t out;
+          out = mpn_rshift (xp + ds, MPFR_MANT(y), sy, sh);
+          MPFR_ASSERTN (ds > 0 || out == 0);
+          if (ds > 0)
+            xp[--ds] = out;
+        }
       else
-        MPN_COPY (PTR(x) + sx - sy, MPFR_MANT(y), sy);
-      if (sx > sy)
-        MPN_ZERO (PTR(x), sx - sy);
+        MPN_COPY (xp + ds, MPFR_MANT (y), sy);
+      if (ds > 0)
+        MPN_ZERO (xp, ds);
       EXP(x) = (MPFR_GET_EXP(y) + sh) / BITS_PER_MP_LIMB;
     }
   else /* we have to round to precx - sh bits */
     {
       mpfr_t z;
-      mp_size_t sz;
+      mp_size_t sz, ds;
 
+      /* Recall that precx = (mp_prec_t) sx * BITS_PER_MP_LIMB */
       mpfr_init2 (z, precx - sh);
       sz = MPFR_LIMB_SIZE (z);
       mpfr_set (z, y, rnd_mode);
@@ -76,13 +90,21 @@
          thus we can safely ignore its last bit which is 0 */
       sh = MPFR_GET_EXP(z) % BITS_PER_MP_LIMB;
       sh = sh <= 0 ? - sh : BITS_PER_MP_LIMB - sh;
-      MPFR_ASSERTD (sh >= 0);
+      MPFR_ASSERTD (sx >= sz);
+      ds = sx - sz;
+      MPFR_ASSERTD (sh >= 0 && ds <= 1);
       if (sh != 0)
-        mpn_rshift (PTR(x) + sx - sz, MPFR_MANT(z), sz, sh);
+        {
+          mp_limb_t out;
+          out = mpn_rshift (xp + ds, MPFR_MANT(z), sz, sh);
+          /* If sh hasn't changed, it is the number of the non-significant
+             bits in the lowest limb of z. Therefore out == 0. */
+          MPFR_ASSERTD (out == 0);
+        }
       else
-        MPN_COPY (PTR(x) + sx - sz, MPFR_MANT(z), sz);
-      if (sx > sz)
-        MPN_ZERO (PTR(x), sx - sz);
+        MPN_COPY (xp + ds, MPFR_MANT(z), sz);
+      if (ds != 0)
+        xp[0] = 0;
       EXP(x) = (MPFR_GET_EXP(z) + sh) / BITS_PER_MP_LIMB;
       mpfr_clear (z);
     }
diff -Naurd mpfr-2.2.0-p11/tests/tget_f.c mpfr-2.2.0-p12/tests/tget_f.c
--- mpfr-2.2.0-p11/tests/tget_f.c	2006-01-13 15:05:14.000000000 +0000
+++ mpfr-2.2.0-p12/tests/tget_f.c	2006-05-26 21:10:14.000000000 +0000
@@ -26,18 +26,84 @@
 
 #include "mpfr-test.h"
 
+/* Test that there is no lost of accuracy when converting a mpfr_t number
+   into a mpf_t number (test with various precisions and exponents). */
+static void
+prec_test (void)
+{
+  int px, py;
+
+  for (py = 3; py <= 136; py++)
+    {
+      mpfr_t y1, y2, y3;
+
+      mpfr_init2 (y1, py);
+      mpfr_init2 (y2, py);
+      mpfr_init2 (y3, py);
+
+      for (px = 32; px <= 160; px += 32)
+        {
+          mpf_t x1, x2, x3;
+          int e;
+
+          mpf_init (x1);
+          mpf_init (x2);
+          mpf_init (x3);
+          mpfr_set_ui_2exp (y1, 1, py - 1, GMP_RNDN);
+          mpfr_get_f (x1, y1, GMP_RNDN);  /* exact (power of 2) */
+          mpf_set (x2, x1);
+          mpfr_set (y2, y1, GMP_RNDN);
+
+          for (e = py - 2; e >= 0; e--)
+            {
+              int inex;
+              mpf_div_2exp (x2, x2, 1);
+              mpf_add (x1, x1, x2);
+              mpfr_div_2exp (y2, y2, 1, GMP_RNDN);
+              inex = mpfr_add (y1, y1, y2, GMP_RNDN);
+              MPFR_ASSERTN (inex == 0);
+              mpfr_set_f (y3, x1, GMP_RNDN);
+              if (! mpfr_equal_p (y1, y3))
+                break;
+              mpfr_get_f (x3, y3, GMP_RNDN);
+              if (mpf_cmp (x1, x3) != 0)
+                {
+                  printf ("Error in prec_test (px = %d, py = %d, e = %d)\n",
+                          px, py, e);
+                  printf ("x1 = ");
+                  mpf_out_str (stdout, 16, 0, x1);
+                  printf ("\nx2 = ");
+                  mpf_out_str (stdout, 16, 0, x1);
+                  printf ("\n");
+                  exit (1);
+                }
+            }
+
+          mpf_clear (x1);
+          mpf_clear (x2);
+          mpf_clear (x3);
+        }
+
+      mpfr_clear (y1);
+      mpfr_clear (y2);
+      mpfr_clear (y3);
+    }
+}
+
 int
 main (void)
 {
   mpf_t x;
-  mpfr_t y;
+  mpfr_t y, z;
   unsigned long i;
   mp_exp_t e;
+  int inex;
 
   MPFR_TEST_USE_RANDS ();
   tests_start_mpfr ();
 
   mpfr_init (y);
+  mpfr_init (z);
   mpf_init (x);
 
   mpfr_set_nan (y);
@@ -154,9 +220,28 @@
         }
     }
 
+  /* Bug reported by Yury Lukach on 2006-04-05 */
+  mpfr_set_prec (y, 32);
+  mpfr_set_prec (z, 32);
+  mpf_set_prec (x, 32);
+  mpfr_set_ui_2exp (y, 0xc1234567, -30, GMP_RNDN);
+  mpfr_get_f (x, y, GMP_RNDN);
+  inex = mpfr_set_f (z, x, GMP_RNDN);
+  if (inex || ! mpfr_equal_p (y, z))
+    {
+      printf ("Error in mpfr_get_f:\n  inex = %d, y = ", inex);
+      mpfr_dump (z);
+      printf ("Expected:\n  inex = 0, y = ");
+      mpfr_dump (y);
+      exit (1);
+    }
+
   mpfr_clear (y);
+  mpfr_clear (z);
   mpf_clear (x);
 
+  prec_test ();
+
   tests_end_mpfr ();
   return 0;
 }
