diff -ruNp 9140-freeze-fses-in-reverse-mount-order.patch-old/kernel/power/process.c 9140-freeze-fses-in-reverse-mount-order.patch-new/kernel/power/process.c
--- 9140-freeze-fses-in-reverse-mount-order.patch-old/kernel/power/process.c	2005-12-05 10:00:42.000000000 +1000
+++ 9140-freeze-fses-in-reverse-mount-order.patch-new/kernel/power/process.c	2005-12-05 09:53:03.000000000 +1000
@@ -66,25 +66,26 @@ static atomic_t nr_kernelspace_frozen;
 
 struct frozen_fs
 {
+	struct list_head fsb_list;
 	struct super_block *sb;
-	struct frozen_fs *next;
-} *frozen_fs_list;
+};
+
+LIST_HEAD(frozen_fs_list);
 
 void freezer_make_fses_rw(void)
 {
-	while (frozen_fs_list) {
-		struct frozen_fs *this;
-		char b[255];
+	struct frozen_fs *fs, *next_fs;
 
-		this = frozen_fs_list;
-		frozen_fs_list = frozen_fs_list->next;
-
-		bdevname(this->sb->s_bdev, b);
+	list_for_each_entry_safe(fs, next_fs, &frozen_fs_list, fsb_list) {
+		char b[255];
+		
+		bdevname(fs->sb->s_bdev, b);
 
 		printk("Thawing %s.\n", b);
-		thaw_bdev(this->sb->s_bdev, this->sb);
+		thaw_bdev(fs->sb->s_bdev, fs->sb);
 
-		kfree(this);
+		list_del(&fs->fsb_list);
+		kfree(fs);
 	}
 }
 
@@ -94,31 +95,33 @@ void freezer_make_fses_rw(void)
  */
 int freezer_make_fses_ro(void)
 {
-	struct frozen_fs *new;
+	struct frozen_fs *fs;
 	struct super_block *sb;
 
+	/* Generate the list */
 	list_for_each_entry(sb, &super_blocks, s_list) {
-		if (!sb->s_root || !sb->s_bdev)
-			continue;
+		char b[255];
 
-		if (sb->s_frozen == SB_FREEZE_TRANS)
+		if (!sb->s_root || !sb->s_bdev ||
+		    (sb->s_frozen == SB_FREEZE_TRANS) ||
+		    (sb->s_flags & MS_RDONLY))
 			continue;
 
-		if (!(sb->s_flags & MS_RDONLY)) {
-			char b[255];
-
-			new = kmalloc(sizeof(struct frozen_fs), GFP_ATOMIC);
-			new->sb = sb;
-			new->next = frozen_fs_list;
-
-			bdevname(sb->s_bdev, b);
-
-			printk("Attemting to freeze %s.\n", b);
-
-			freeze_bdev(sb->s_bdev);
-
-			frozen_fs_list = new;
-		}
+		bdevname(sb->s_bdev, b);
+		printk("Adding %s to freeze list.\n", b);
+		fs = kmalloc(sizeof(struct frozen_fs), GFP_ATOMIC);
+		fs->sb = sb;
+		list_add_tail(&fs->fsb_list, &frozen_fs_list);
+	};
+
+	/* Do the freezing in reverse order so filesystems dependant
+	 * upon others are frozen in the right order. (Eg loopback
+	 * on ext3). */
+	list_for_each_entry_reverse(fs, &frozen_fs_list, fsb_list) {
+		char b[255];
+		bdevname(fs->sb->s_bdev, b);
+		printk("Attempting to freeze %s.\n", b);
+		freeze_bdev(fs->sb->s_bdev);
 	}
 
 	return 0;
