 process.c |   69 ++++++++++++++++++++++++--------------------------------------
 1 files changed, 27 insertions(+), 42 deletions(-)
diff -ruNp 9500-freeze_sbs.patch-old/kernel/power/process.c 9500-freeze_sbs.patch-new/kernel/power/process.c
--- 9500-freeze_sbs.patch-old/kernel/power/process.c	2005-11-23 14:07:24.000000000 +1100
+++ 9500-freeze_sbs.patch-new/kernel/power/process.c	2005-11-23 14:07:50.000000000 +1100
@@ -65,76 +65,61 @@ DECLARE_COMPLETION(userspace_thaw);
 static atomic_t nr_userspace_frozen;
 static atomic_t nr_kernelspace_frozen;
 
-struct remounted_fs
+struct frozen_fs
 {
 	struct super_block *sb;
-	struct remounted_fs *next;
-} *remounted_fs_list;
+	struct frozen_fs *next;
+} *frozen_fs_list;
 
 void freezer_make_fses_rw(void)
 {
-	int retval;
+	while (frozen_fs_list) {
+		struct frozen_fs *this;
+		char b[255];
 
-	while (remounted_fs_list) {
-		struct remounted_fs *this;
+		this = frozen_fs_list;
+		frozen_fs_list = frozen_fs_list->next;
 
-		this = remounted_fs_list;
-		remounted_fs_list = remounted_fs_list->next;
+		bdevname(this->sb->s_bdev, b);
 
-		lock_kernel();
-		retval = do_remount_sb(this->sb, 0, NULL, 2);
-		unlock_kernel();
-
-		if (retval) {
-			printk("Failed to remount %s as writable. Sorry.\n",
-					this->sb->s_id);
-		}
+		printk("Thawing %s.\n", b);
+		thaw_bdev(this->sb->s_bdev, this->sb);
 
 		kfree(this);
 	}
 }
 
+/* 
+ * Done after userspace is frozen, so there should be no danger of
+ * fses being unmounted while we're in here.
+ */
 int freezer_make_fses_ro(void)
 {
-	struct remounted_fs *new;
+	struct frozen_fs *new;
 	struct super_block *sb;
-	int retval, tries;
 
 	list_for_each_entry(sb, &super_blocks, s_list) {
 		if (!sb->s_root || !sb->s_bdev)
 			continue;
 
-		down_write(&sb->s_umount);
+		if (sb->s_frozen == SB_FREEZE_TRANS)
+			continue;
 
 		if (!(sb->s_flags & MS_RDONLY)) {
+			char b[255];
 
-			tries = 1;
-
-			new = kmalloc(sizeof(struct remounted_fs), GFP_ATOMIC);
+			new = kmalloc(sizeof(struct frozen_fs), GFP_ATOMIC);
 			new->sb = sb;
-			new->next = remounted_fs_list;
+			new->next = frozen_fs_list;
 
-again:
-			lock_kernel();
-			retval = do_remount_sb(sb, MS_RDONLY, NULL, 2);
-			unlock_kernel();
-			
-			if (retval && tries < 3) {
-				tries++;
-				goto again;
-			}
-			
-			if (retval) {
-				kfree(new);
-				freezer_make_fses_rw();
-				up_write(&sb->s_umount);
-				return 1;
-			}
+			bdevname(sb->s_bdev, b);
 
-			remounted_fs_list = new;
-		}
+			printk("Attemting to freeze %s.\n", b);
 
-		up_write(&sb->s_umount);
+			freeze_bdev(sb->s_bdev);
+
+			frozen_fs_list = new;
+		}
 	}
 
 	return 0;

