diff -urNp linux-2.6.10/drivers/char/moxa.c linux-2.6.10-new/drivers/char/moxa.c
--- linux-2.6.10/drivers/char/moxa.c	2005-01-07 10:51:23 -0500
+++ linux-2.6.10-new/drivers/char/moxa.c	2005-01-07 10:51:33 -0500
@@ -1668,6 +1668,8 @@ int MoxaDriverIoctl(unsigned int cmd, un
 		return -EFAULT;
 	if(dltmp.cardno < 0 || dltmp.cardno >= MAX_BOARDS)
 		return -EINVAL;
+	if(dltmp.len < 0 || dltmp.len > sizeof(moxaBuff))
+		return -EINVAL;
 
 	switch(cmd)
 	{
@@ -2822,8 +2824,6 @@ static int moxaload320b(int cardno, unsi
 	void __iomem *baseAddr;
 	int i;
 
-	if(len > sizeof(moxaBuff))
-		return -EINVAL;
 	if(copy_from_user(moxaBuff, tmp, len))
 		return -EFAULT;
 	baseAddr = moxaBaseAddr[cardno];
diff -urNp linux-2.6.10/include/linux/writeback.h linux-2.6.10-new/include/linux/writeback.h
--- linux-2.6.10/include/linux/writeback.h	2005-01-07 10:51:22 -0500
+++ linux-2.6.10-new/include/linux/writeback.h	2005-01-07 10:51:33 -0500
@@ -86,6 +86,7 @@ static inline void wait_on_inode(struct 
 int wakeup_bdflush(long nr_pages);
 void laptop_io_completion(void);
 void laptop_sync_completion(void);
+void throttle_vm_writeout(void);
 
 /* These are exported to sysctl. */
 extern int dirty_background_ratio;
diff -urNp linux-2.6.10/mm/mmap.c linux-2.6.10-new/mm/mmap.c
--- linux-2.6.10/mm/mmap.c	2004-12-24 22:35:00.000000000 +0100
+++ linux-2.6.10-new/mm/mmap.c	2004-12-27 16:37:47.000000000 +0100
@@ -1360,6 +1360,13 @@ int expand_stack(struct vm_area_struct *
 		vm_unacct_memory(grow);
 		return -ENOMEM;
 	}
+	if ((vma->vm_flags & VM_LOCKED) && !capable(CAP_IPC_LOCK) &&
+			((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) >
+			current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur) {
+		anon_vma_unlock(vma);
+		vm_unacct_memory(grow);
+		return -ENOMEM;
+	}
 	vma->vm_end = address;
 	vma->vm_mm->total_vm += grow;
 	if (vma->vm_flags & VM_LOCKED)
@@ -1422,6 +1429,13 @@ int expand_stack(struct vm_area_struct *
 		vm_unacct_memory(grow);
 		return -ENOMEM;
 	}
+	if ((vma->vm_flags & VM_LOCKED) && !capable(CAP_IPC_LOCK) &&
+			((vma->vm_mm->locked_vm + grow) << PAGE_SHIFT) >
+			current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur) {
+		anon_vma_unlock(vma);
+		vm_unacct_memory(grow);
+		return -ENOMEM;
+	}
 	vma->vm_start = address;
 	vma->vm_pgoff -= grow;
 	vma->vm_mm->total_vm += grow;
diff -urNp linux-2.6.10/mm/page-writeback.c linux-2.6.10-new/mm/page-writeback.c
--- linux-2.6.10/mm/page-writeback.c	2005-01-07 10:51:24 -0500
+++ linux-2.6.10-new/mm/page-writeback.c	2005-01-07 10:51:33 -0500
@@ -276,6 +276,28 @@ void balance_dirty_pages_ratelimited(str
 }
 EXPORT_SYMBOL(balance_dirty_pages_ratelimited);
 
+void throttle_vm_writeout(void)
+{
+	struct writeback_state wbs;
+	long background_thresh;
+	long dirty_thresh;
+
+        for ( ; ; ) {
+		get_dirty_limits(&wbs, &background_thresh, &dirty_thresh);
+
+                /*
+                 * Boost the allowable dirty threshold a bit for page
+                 * allocators so they don't get DoS'ed by heavy writers
+                 */
+                dirty_thresh += dirty_thresh / 10;      /* wheeee... */
+
+                if (wbs.nr_unstable + wbs.nr_writeback <= dirty_thresh)
+                        break;
+                blk_congestion_wait(WRITE, HZ/10);
+        }
+}
+
+
 /*
  * writeback at least _min_pages, and keep writing until the amount of dirty
  * memory is less than the background threshold, or until we're all clean.
diff -urNp linux-2.6.10/mm/vmscan.c linux-2.6.10-new/mm/vmscan.c
--- linux-2.6.10/mm/vmscan.c	2005-01-07 10:51:24 -0500
+++ linux-2.6.10-new/mm/vmscan.c	2005-01-07 10:51:33 -0500
@@ -825,6 +825,8 @@ shrink_zone(struct zone *zone, struct sc
 				break;
 		}
 	}
+
+	throttle_vm_writeout();
 }
 
 /*
