--- linux-2.2.16-clean/fs/stat.c	Fri Nov 13 13:07:26 1998
+++ linux-2.2.16-lfs/fs/stat.c	Tue Jul 11 15:23:28 2000
@@ -57,7 +57,12 @@
 
 #endif
 
-static int cp_new_stat(struct inode * inode, struct stat * statbuf)
+static int all_fail_alike_fstat = 0;
+/* "No lie" policy yields EOVERFLOW if file size exceeds
+   a value which is presentable in field st_size (or st_blocks,
+   or st_ino). But then the file will not appear in the directory
+   listing at all before we have stat64() syscalls in use.. */
+static int cp_new_stat(struct inode * inode, struct stat * statbuf, int f)
 {
 	struct stat tmp;
 	unsigned int blocks, indirect;
@@ -74,6 +79,18 @@
 	tmp.st_atime = inode->i_atime;
 	tmp.st_mtime = inode->i_mtime;
 	tmp.st_ctime = inode->i_ctime;
+	/* large-file stat() problem...
+	   If your file size is 4G-1, it *propably*
+	   is over 4G in a 32-bit system... */
+#if BITS_PER_LONG < 64
+	if (inode->i_size != tmp.st_size) {
+		if (f || all_fail_alike_fstat)
+			return -EOVERFLOW; /* See LFS spec: 2.2.1.14
+					      Xstat() shall fail with
+					      EOVERFLOW. */
+		tmp.st_size = ULONG_MAX;
+	}
+#endif
 /*
  * st_blocks and st_blksize are approximated with a simple algorithm if
  * they aren't supported directly by the filesystem. The minix and msdos
@@ -152,7 +169,7 @@
 	if (!IS_ERR(dentry)) {
 		error = do_revalidate(dentry);
 		if (!error)
-			error = cp_new_stat(dentry->d_inode, statbuf);
+			error = cp_new_stat(dentry->d_inode, statbuf, 0);
 
 		dput(dentry);
 	}
@@ -200,7 +217,7 @@
 	if (!IS_ERR(dentry)) {
 		error = do_revalidate(dentry);
 		if (!error)
-			error = cp_new_stat(dentry->d_inode, statbuf);
+			error = cp_new_stat(dentry->d_inode, statbuf, 0);
 
 		dput(dentry);
 	}
@@ -247,7 +264,125 @@
 
 		err = do_revalidate(dentry);
 		if (!err)
-			err = cp_new_stat(dentry->d_inode, statbuf);
+			err = cp_new_stat(dentry->d_inode, statbuf, 1);
+		fput(f);
+	}
+	unlock_kernel();
+	return err;
+}
+
+/* ---------- LFS-64 ----------- */
+
+static int cp_new_stat64(struct inode * inode, struct stat64 * statbuf)
+{
+	struct stat64 tmp;
+	unsigned int blocks, indirect;
+
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.st_dev = kdev_t_to_nr(inode->i_dev);
+	tmp.st_ino = inode->i_ino;
+	tmp.st_mode = inode->i_mode;
+	tmp.st_nlink = inode->i_nlink;
+	tmp.st_uid = inode->i_uid;
+	tmp.st_gid = inode->i_gid;
+	tmp.st_rdev = kdev_t_to_nr(inode->i_rdev);
+	tmp.st_atime = inode->i_atime;
+	tmp.st_mtime = inode->i_mtime;
+	tmp.st_ctime = inode->i_ctime;
+	tmp.st_size = inode->i_size;
+/*
+ * st_blocks and st_blksize are approximated with a simple algorithm if
+ * they aren't supported directly by the filesystem. The minix and msdos
+ * filesystems don't keep track of blocks, so they would either have to
+ * be counted explicitly (by delving into the file itself), or by using
+ * this simple algorithm to get a reasonable (although not 100% accurate)
+ * value.
+ */
+
+/*
+ * Use minix fs values for the number of direct and indirect blocks.  The
+ * count is now exact for the minix fs except that it counts zero blocks.
+ * Everything is in units of BLOCK_SIZE until the assignment to
+ * tmp.st_blksize.
+ */
+#define D_B   7
+#define I_B   (BLOCK_SIZE / sizeof(unsigned short))
+
+	if (!inode->i_blksize) {
+		blocks = (tmp.st_size + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
+		if (blocks > D_B) {
+			indirect = (blocks - D_B + I_B - 1) / I_B;
+			blocks += indirect;
+			if (indirect > 1) {
+				indirect = (indirect - 1 + I_B - 1) / I_B;
+				blocks += indirect;
+				if (indirect > 1)
+					blocks++;
+			}
+		}
+		tmp.st_blocks = (BLOCK_SIZE / 512) * blocks;
+		tmp.st_blksize = BLOCK_SIZE;
+	} else {
+		tmp.st_blocks = inode->i_blocks;
+		tmp.st_blksize = inode->i_blksize;
+	}
+	return copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;
+}
+
+
+asmlinkage int sys_stat64(char * filename, struct stat64 * statbuf)
+{
+	struct dentry * dentry;
+	int error;
+
+	lock_kernel();
+	dentry = namei(filename);
+
+	error = PTR_ERR(dentry);
+	if (!IS_ERR(dentry)) {
+		error = do_revalidate(dentry);
+		if (!error)
+			error = cp_new_stat64(dentry->d_inode, statbuf);
+
+		dput(dentry);
+	}
+	unlock_kernel();
+	return error;
+}
+
+asmlinkage int sys_lstat64(char * filename, struct stat64 * statbuf)
+{
+	struct dentry * dentry;
+	int error;
+
+	lock_kernel();
+	dentry = lnamei(filename);
+
+	error = PTR_ERR(dentry);
+	if (!IS_ERR(dentry)) {
+		error = do_revalidate(dentry);
+		if (!error)
+			error = cp_new_stat64(dentry->d_inode, statbuf);
+
+		dput(dentry);
+	}
+	unlock_kernel();
+	return error;
+}
+
+asmlinkage int sys_fstat64(unsigned int fd, struct stat64 * statbuf)
+{
+	struct file * f;
+	int err = -EBADF;
+
+	lock_kernel();
+	f = fget(fd);
+	if (f) {
+		struct dentry * dentry = f->f_dentry;
+
+		err = do_revalidate(dentry);
+		if (!err)
+			err = cp_new_stat64(dentry->d_inode, statbuf);
 		fput(f);
 	}
 	unlock_kernel();
--- linux-2.2.16-clean/fs/read_write.c	Wed Jun  7 17:26:44 2000
+++ linux-2.2.16-lfs/fs/read_write.c	Tue Jul 11 15:23:28 2000
@@ -48,7 +48,7 @@
 
 asmlinkage off_t sys_lseek(unsigned int fd, off_t offset, unsigned int origin)
 {
-	off_t retval;
+	off_t retval, oldpos;
 	struct file * file;
 	struct dentry * dentry;
 	struct inode * inode;
@@ -62,9 +62,19 @@
 	if (!(dentry = file->f_dentry) ||
 	    !(inode = dentry->d_inode))
 		goto out_putf;
+	oldpos = file->f_pos;
 	retval = -EINVAL;
 	if (origin <= 2)
 		retval = llseek(file, offset, origin);
+
+	/* Demand L-F-S compliance only from normal files,
+	   thus raw devices can do whatever they please.. */
+	if (retval >= 0 && S_ISREG(inode->i_mode) &&
+	    !(file->f_flags & O_LARGEFILE) &&
+	    !off_t_presentable(file->f_pos+1LL)) {
+		file->f_pos = oldpos;
+		retval = -EOVERFLOW;
+	}
 out_putf:
 	fput(file);
 bad:
@@ -81,7 +91,7 @@
 	struct file * file;
 	struct dentry * dentry;
 	struct inode * inode;
-	loff_t offset;
+	loff_t offset, oldpos;
 
 	lock_kernel();
 	retval = -EBADF;
@@ -96,6 +106,7 @@
 	if (origin > 2)
 		goto out_putf;
 
+	oldpos = file->f_pos;
 	offset = llseek(file, ((loff_t) offset_high << 32) | offset_low,
 			origin);
 
@@ -105,6 +116,14 @@
 		if (!copy_to_user(result, &offset, sizeof(offset)))
 			retval = 0;
 	}
+	if (!(file->f_flags & O_LARGEFILE) && S_ISREG(inode->i_mode) &&
+	    !off_t_presentable(file->f_pos+1LL)) {
+		/* The target position isn't presentable without
+		   O_LARGEFILE flag being set --> yield error, and
+		   restore the file position. */
+		file->f_pos = oldpos;
+		retval = -EOVERFLOW;
+	}
 out_putf:
 	fput(file);
 bad:
@@ -134,6 +153,20 @@
 	ret = -EINVAL;
 	if (!file->f_op || !(read = file->f_op->read))
 		goto out;
+
+	/* L-F-S spec 2.2.1.25 */
+	if (count && !(file->f_flags & O_LARGEFILE) &&
+	    S_ISREG(file->f_dentry->d_inode->i_mode) &&
+	    (file->f_pos < file->f_dentry->d_inode->i_size) &&
+	    !off_t_presentable(1 + file->f_pos)) /* pos@LONG_MAX forbidden */
+		return -EOVERFLOW;
+	if (count && !(file->f_flags & O_LARGEFILE) &&
+	    S_ISREG(file->f_dentry->d_inode->i_mode) &&
+	    (file->f_pos < file->f_dentry->d_inode->i_size) &&
+	    !off_t_presentable(file->f_pos + count)) {
+		/* Read only until end of allowed region */
+		count = LONG_MAX - file->f_pos;
+	}
 	ret = read(file, buf, count, &file->f_pos);
 out:
 	fput(file);
@@ -167,6 +200,20 @@
 		goto out;
 
 	down(&inode->i_sem);
+	/* L-F-S spec 2.2.1.27: */
+	/* This check is done after down() so that f_pos won't change
+	 * on us between now and the write call */
+	if (!(file->f_flags & O_LARGEFILE) &&
+	    S_ISREG(file->f_dentry->d_inode->i_mode)) {
+		if (!off_t_presentable(1 + file->f_pos)) { /* pos@LONG_MAX forbidden */
+			up(&inode->i_sem);
+			ret = -EFBIG;
+			goto out;
+		}
+		if (!off_t_presentable(file->f_pos + count))
+			/* Write only until end of allowed region */
+			count = LONG_MAX - file->f_pos;
+	}
 	ret = write(file, buf, count, &file->f_pos);
 	up(&inode->i_sem);
 out:
@@ -255,7 +302,32 @@
 		vector++;
 		count--;
 
-		nr = fn(file, base, len, &file->f_pos);
+		nr = 0;
+		/* L-F-S spec checking... */
+		if (!(file->f_flags & O_LARGEFILE) &&
+		    S_ISREG(file->f_dentry->d_inode->i_mode)) {
+			struct inode *inode = file->f_dentry->d_inode;
+			if (type == VERIFY_WRITE) {
+				/* L-F-S 2.2.1.25 (readv)*/
+				if (len && (file->f_pos < inode->i_size) &&
+				    !off_t_presentable(1 + file->f_pos)) /* pos@LONG_MAX forbidden */
+					nr = -EOVERFLOW;
+				if (len && (file->f_pos < inode->i_size) &&
+				    !off_t_presentable(file->f_pos + len)) {
+					/* Read only until end of allowed region */
+					len = LONG_MAX - file->f_pos;
+				}
+			} else {
+				/* L-F-S spec 2.2.1.27 (writev) */
+				if (!off_t_presentable(1 + file->f_pos)) /* pos@LONG_MAX forbidden */
+					nr =  -EFBIG;
+				if (!off_t_presentable(file->f_pos + len)) /* Write only until end of allowed region */
+					len = LONG_MAX - file->f_pos;
+			}
+		}
+
+		if (!nr) 
+			nr = fn(file, base, len, &file->f_pos);
 
 		if (nr < 0) {
 			if (!ret) ret = nr;
@@ -328,6 +400,7 @@
 	ssize_t ret;
 	struct file * file;
 	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
+	struct inode * inode;
 
 	lock_kernel();
 
@@ -335,10 +408,30 @@
 	file = fget(fd);
 	if (!file)
 		goto bad_file;
+
+	inode = file->f_dentry->d_inode;
+
 	if (!(file->f_mode & FMODE_READ))
 		goto out;
-	ret = locks_verify_area(FLOCK_VERIFY_READ, file->f_dentry->d_inode,
-				file, pos, count);
+
+	/* Start position must be non-negative! */
+	if (pos < 0) {
+	  ret = -EINVAL;
+	  goto out;
+	}
+	/* Read starting from beyond the end of file ? */
+	if (inode->i_size <= pos) {
+	  ret = -EOVERFLOW;
+	  goto out;
+	}
+
+	if (!(file->f_flags & O_LARGEFILE) && S_ISREG(inode->i_mode) &&
+	    !off_t_presentable(pos+1LL)) {
+	  ret = -EOVERFLOW;
+	  goto out;
+	}
+
+	ret = locks_verify_area(FLOCK_VERIFY_READ, inode, file, pos, count);
 	if (ret)
 		goto out;
 	ret = -EINVAL;
@@ -360,6 +453,7 @@
 	ssize_t ret;
 	struct file * file;
 	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
+	struct inode * inode;
 
 	lock_kernel();
 
@@ -369,8 +463,21 @@
 		goto bad_file;
 	if (!(file->f_mode & FMODE_WRITE))
 		goto out;
-	ret = locks_verify_area(FLOCK_VERIFY_WRITE, file->f_dentry->d_inode,
-				file, pos, count);
+	/* Start position must be non-negative! */
+	if (pos < 0) {
+	  ret = -EINVAL;
+	  goto out;
+	}
+
+	inode = file->f_dentry->d_inode;
+
+	if (!(file->f_flags & O_LARGEFILE) && S_ISREG(inode->i_mode) &&
+	    !off_t_presentable(pos+1LL)) {
+	  ret = -EOVERFLOW;
+	  goto out;
+	}
+
+	ret = locks_verify_area(FLOCK_VERIFY_WRITE, inode, file, pos, count);
 	if (ret)
 		goto out;
 	ret = -EINVAL;
@@ -379,9 +486,9 @@
 	if (pos < 0)
 		goto out;
 
-	down(&file->f_dentry->d_inode->i_sem);
+	down(&inode->i_sem);
 	ret = write(file, buf, count, &pos);
-	up(&file->f_dentry->d_inode->i_sem);
+	up(&inode->i_sem);
 
 out:
 	fput(file);
--- linux-2.2.16-clean/fs/buffer.c	Wed Jun  7 17:26:43 2000
+++ linux-2.2.16-lfs/fs/buffer.c	Tue Jul 11 16:10:34 2000
@@ -1391,6 +1391,14 @@
 	set_bit(PG_locked, &page->flags);
 	set_bit(PG_free_after, &page->flags);
 	
+	/* LFS: Check for block number overflow.  only check here
+	 * since this should all be nicely page aligned. */
+	if ((page->offset >> inode->i_sb->s_blocksize_bits) > (unsigned long long) LONG_MAX) {
+		memset(nr, 0, sizeof(nr));
+		brw_page(READ, page, inode->i_dev, nr, inode->i_sb->s_blocksize, 1);
+		return 0;
+	}
+
 	i = PAGE_SIZE >> inode->i_sb->s_blocksize_bits;
 	block = page->offset >> inode->i_sb->s_blocksize_bits;
 	p = nr;
--- linux-2.2.16-clean/fs/open.c	Tue Jan  4 13:12:23 2000
+++ linux-2.2.16-lfs/fs/open.c	Tue Jul 11 15:23:28 2000
@@ -63,16 +63,23 @@
 	return error;
 }
 
-int do_truncate(struct dentry *dentry, unsigned long length)
+int do_truncate(struct dentry *dentry, loff_t length)
 {
 	struct inode *inode = dentry->d_inode;
 	int error;
 	struct iattr newattrs;
 
-	/* Not pretty: "inode->i_size" shouldn't really be "off_t". But it is. */
-	if ((off_t) length < 0)
+	if (length < 0)
 		return -EINVAL;
 
+	if (current->rlimfsz.rlim_cur < inode->i_size) {
+		/* If the target size is higher than our current (soft)
+		   file size limit, a SIGXFSZ shall be sent along
+		   with error -EFBIG. */
+		send_sig(SIGXFSZ, current, 0);
+		return -EFBIG;
+	}
+
 	down(&inode->i_sem);
 	newattrs.ia_size = length;
 	newattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;
@@ -101,7 +108,7 @@
 		goto out;
 	inode = dentry->d_inode;
 
-	error = -EACCES;
+	error = -EISDIR;
 	if (S_ISDIR(inode->i_mode))
 		goto dput_and_out;
 
@@ -153,12 +160,111 @@
 		goto out_putf;
 	if (!(inode = dentry->d_inode))
 		goto out_putf;
+	error = -EISDIR;
+	if (S_ISDIR(inode->i_mode))
+		goto out_putf;
+	error = -EACCES;
+	if (!(file->f_mode & FMODE_WRITE))
+		goto out_putf;
+	error = -EPERM;
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		goto out_putf;
+	/* Large File Summit */
+	error = -EFBIG;
+	if (S_ISREG(inode->i_mode) && !(file->f_flags & O_LARGEFILE) &&
+	    !off_t_presentable(inode->i_size))
+		goto out_putf;
+	error = locks_verify_area(FLOCK_VERIFY_WRITE, inode, file,
+				  length<inode->i_size ? length : inode->i_size,
+				  abs(inode->i_size - length));
+	if (!error)
+		error = do_truncate(dentry, length);
+out_putf:
+	fput(file);
+out:
+	unlock_kernel();
+	return error;
+}
+
+#if BITS_PER_LONG < 64
+asmlinkage int sys_truncate64(const char * path, loff_t length)
+{
+	struct dentry * dentry;
+	struct inode * inode;
+	int error;
+
+	lock_kernel();
+	dentry = namei(path);
+
+	error = PTR_ERR(dentry);
+	if (IS_ERR(dentry))
+		goto out;
+	inode = dentry->d_inode;
+
+	error = -EACCES;
+	if (S_ISDIR(inode->i_mode))
+		goto dput_and_out;
+
+	error = permission(inode,MAY_WRITE);
+	if (error)
+		goto dput_and_out;
+
+	error = -EROFS;
+	if (IS_RDONLY(inode))
+		goto dput_and_out;
+
+	error = -EPERM;
+	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
+		goto dput_and_out;
+
+	error = get_write_access(inode);
+	if (error)
+		goto dput_and_out;
+
+	error = locks_verify_area(FLOCK_VERIFY_WRITE, inode, NULL,
+				  length < inode->i_size ? length : inode->i_size,
+				  abs(inode->i_size - length));
+	if (!error) {
+		DQUOT_INIT(inode);
+		error = do_truncate(dentry, length);
+	}
+	put_write_access(inode);
+dput_and_out:
+	dput(dentry);
+out:
+	unlock_kernel();
+	return error;
+}
+
+asmlinkage int sys_ftruncate64(unsigned int fd, loff_t length)
+{
+	struct inode * inode;
+	struct dentry *dentry;
+	struct file * file;
+	int error;
+
+	lock_kernel();
+	error = -EBADF;
+	file = fget(fd);
+	if (!file)
+		goto out;
+	error = -ENOENT;
+	if (!(dentry = file->f_dentry))
+		goto out_putf;
+	if (!(inode = dentry->d_inode))
+		goto out_putf;
 	error = -EACCES;
 	if (S_ISDIR(inode->i_mode) || !(file->f_mode & FMODE_WRITE))
 		goto out_putf;
 	error = -EPERM;
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto out_putf;
+	error = -EINVAL;
+	/* Large File Summit */
+	error = -EFBIG;
+	if (S_ISREG(inode->i_mode) && !(file->f_flags & O_LARGEFILE) &&
+	    !off_t_presentable(inode->i_size))
+		goto out_putf;
 	error = locks_verify_area(FLOCK_VERIFY_WRITE, inode, file,
 				  length<inode->i_size ? length : inode->i_size,
 				  abs(inode->i_size - length));
@@ -170,6 +276,7 @@
 	unlock_kernel();
 	return error;
 }
+#endif /* BITS_PER_LONG < 64 */
 
 #ifndef __alpha__
 
@@ -660,6 +767,16 @@
 		error = get_write_access(inode);
 		if (error)
 			goto cleanup_dentry;
+	}
+
+	/* L-F-S spec: 3.1.1.3:  If open() is done without  O_LARGEFILE,
+	   and the target (regular) file size exceeds that presentable with
+	   'off_t' datatype in the system, the open shall be rejected with
+	   EOVERFLOW  error. */
+	if (S_ISREG(inode->i_mode) && !(flags & O_LARGEFILE) &&
+	    !off_t_presentable(inode->i_size)) {
+		error = -EOVERFLOW;
+		goto cleanup_all;
 	}
 
 	f->f_dentry = dentry;
--- linux-2.2.16-clean/fs/fcntl.c	Wed Aug 25 20:29:49 1999
+++ linux-2.2.16-lfs/fs/fcntl.c	Tue Jul 11 15:23:28 2000
@@ -182,6 +182,17 @@
 		case F_SETLKW:
 			err = fcntl_setlk(fd, cmd, (struct flock *) arg);
 			break;
+
+		case F_GETLK64:
+			err = fcntl_getlk64(fd, (struct flock64 *) arg);
+			break;
+		case F_SETLK64:
+			err = fcntl_setlk64(fd, cmd, (struct flock64 *) arg);
+			break;
+		case F_SETLKW64:
+			err = fcntl_setlk64(fd, cmd, (struct flock64 *) arg);
+			break;
+
 		case F_GETOWN:
 			/*
 			 * XXX If f_owner is a process group, the
--- linux-2.2.16-clean/fs/locks.c	Tue Jan  4 13:12:23 2000
+++ linux-2.2.16-lfs/fs/locks.c	Tue Jul 11 15:49:01 2000
@@ -111,12 +111,12 @@
 
 #include <asm/uaccess.h>
 
-#define OFFSET_MAX	((off_t)LONG_MAX)	/* FIXME: move elsewhere? */
+#define OFFSET_MAX	((loff_t)((~0ULL)>>1))	/* FIXME: move elsewhere? */
 
 static int flock_make_lock(struct file *filp, struct file_lock *fl,
 			       unsigned int cmd);
 static int posix_make_lock(struct file *filp, struct file_lock *fl,
-			       struct flock *l);
+			       struct flock64 *l);
 static int flock_locks_conflict(struct file_lock *caller_fl,
 				struct file_lock *sys_fl);
 static int posix_locks_conflict(struct file_lock *caller_fl,
@@ -195,7 +195,7 @@
 
 	if (waiter->fl_prevblock) {
 		printk(KERN_ERR "locks_insert_block: remove duplicated lock "
-			"(pid=%d %ld-%ld type=%d)\n",
+			"(pid=%d %Ld-%Ld type=%d)\n",
 			waiter->fl_pid, waiter->fl_start,
 			waiter->fl_end, waiter->fl_type);
 		locks_delete_block(waiter->fl_prevblock, waiter);
@@ -319,18 +319,14 @@
 /* Report the first existing lock that would conflict with l.
  * This implements the F_GETLK command of fcntl().
  */
-int fcntl_getlk(unsigned int fd, struct flock *l)
+int do_fcntl_getlk(unsigned int fd, struct flock64 *flock)
 {
 	struct file *filp;
 	struct file_lock *fl,file_lock;
-	struct flock flock;
 	int error;
 
-	error = -EFAULT;
-	if (copy_from_user(&flock, l, sizeof(flock)))
-		goto out;
 	error = -EINVAL;
-	if ((flock.l_type != F_RDLCK) && (flock.l_type != F_WRLCK))
+	if ((flock->l_type != F_RDLCK) && (flock->l_type != F_WRLCK))
 		goto out;
 
 	error = -EBADF;
@@ -342,7 +338,7 @@
 	if (!filp->f_dentry || !filp->f_dentry->d_inode)
 		goto out_putf;
 
-	if (!posix_make_lock(filp, &file_lock, &flock))
+	if (!posix_make_lock(filp, &file_lock, flock))
 		goto out_putf;
 
 	if (filp->f_op->lock) {
@@ -358,18 +354,16 @@
 		fl = posix_test_lock(filp, &file_lock);
 	}
  
-	flock.l_type = F_UNLCK;
+	flock->l_type = F_UNLCK;
 	if (fl != NULL) {
-		flock.l_pid = fl->fl_pid;
-		flock.l_start = fl->fl_start;
-		flock.l_len = fl->fl_end == OFFSET_MAX ? 0 :
+		flock->l_pid = fl->fl_pid;
+		flock->l_start = fl->fl_start;
+		flock->l_len = fl->fl_end == OFFSET_MAX ? 0 :
 			fl->fl_end - fl->fl_start + 1;
-		flock.l_whence = 0;
-		flock.l_type = fl->fl_type;
+		flock->l_whence = 0;
+		flock->l_type = fl->fl_type;
 	}
-	error = -EFAULT;
-	if (!copy_to_user(l, &flock, sizeof(flock)))
-		error = 0;
+	error = 0;
   
 out_putf:
 	fput(filp);
@@ -377,25 +371,64 @@
 	return error;
 }
 
+int fcntl_getlk(unsigned int fd, struct flock *l) {
+	int err;
+	struct flock flock32;
+	struct flock64 flock64;
+
+	if (copy_from_user(&flock32, l, sizeof(flock32)))
+		return -EFAULT;
+	/* Convert to 64 bit offsets */
+	flock64.l_type   = flock32.l_type;
+	flock64.l_whence = flock32.l_whence;
+	flock64.l_start  = (unsigned long)flock32.l_start;
+	flock64.l_len    = (unsigned long)flock32.l_len;
+	flock64.l_pid    = flock32.l_pid;
+
+	err = do_fcntl_getlk(fd, &flock64);
+	if (err) return err;
+
+	/* Convert back to 32 bit offsets. */
+	if (!off_t_presentable(flock64.l_start) ||
+	    !off_t_presentable(flock64.l_len) ||
+	    !off_t_presentable(flock64.l_start + flock64.l_len)) {
+		return -EOVERFLOW;
+	}
+	flock32.l_type   = flock64.l_type;
+	flock32.l_whence = flock64.l_whence;
+	flock32.l_start  = flock64.l_start;
+	flock32.l_len    = flock64.l_len;
+	flock32.l_pid    = flock64.l_pid;
+
+	if (copy_to_user(l, &flock32, sizeof(flock32)))
+		return -EFAULT;
+	return 0;
+}
+
+int fcntl_getlk64(unsigned int fd, struct flock64 *l) {
+	int err;
+	struct flock64 flock;
+
+	if (copy_from_user(&flock, l, sizeof(flock)))
+		return -EFAULT;
+	err = do_fcntl_getlk(fd, &flock);
+	if (err) return err;
+	if (copy_to_user(l, &flock, sizeof(flock)))
+		return -EFAULT;
+	return 0;
+}
+
 /* Apply the lock described by l to an open file descriptor.
  * This implements both the F_SETLK and F_SETLKW commands of fcntl().
  */
-int fcntl_setlk(unsigned int fd, unsigned int cmd, struct flock *l)
+int do_fcntl_setlk(unsigned int fd, unsigned int cmd, struct flock64 *flock)
 {
 	struct file *filp;
 	struct file_lock file_lock;
-	struct flock flock;
 	struct dentry * dentry;
 	struct inode *inode;
 	int error;
 
-	/*
-	 * This might block, so we do it before checking the inode.
-	 */
-	error = -EFAULT;
-	if (copy_from_user(&flock, l, sizeof(flock)))
-		goto out;
-
 	/* Get arguments and validate them ...
 	 */
 
@@ -425,11 +458,11 @@
 	}
 
 	error = -EINVAL;
-	if (!posix_make_lock(filp, &file_lock, &flock))
+	if (!posix_make_lock(filp, &file_lock, flock))
 		goto out_putf;
 	
 	error = -EBADF;
-	switch (flock.l_type) {
+	switch (flock->l_type) {
 	case F_RDLCK:
 		if (!(filp->f_mode & FMODE_READ))
 			goto out_putf;
@@ -475,6 +508,29 @@
 	return error;
 }
 
+int fcntl_setlk(unsigned int fd, unsigned int cmd, struct flock *l) {
+	struct flock   flock32;
+	struct flock64 flock64;
+
+	if (copy_from_user(&flock32, l, sizeof(flock32)))
+		return -EFAULT;
+	/* Convert to 64 bit offsets */
+	flock64.l_type   = flock32.l_type;
+	flock64.l_whence = flock32.l_whence;
+	flock64.l_start  = (unsigned long)flock32.l_start;
+	flock64.l_len    = (unsigned long)flock32.l_len;
+	flock64.l_pid    = flock32.l_pid;
+
+	return do_fcntl_setlk(fd, cmd, &flock64);
+}
+
+int fcntl_setlk64(unsigned int fd, unsigned int cmd, struct flock64 *l) {
+	struct flock64 flock;
+	if (copy_from_user(&flock, l, sizeof(flock)))
+		return -EFAULT;
+	return do_fcntl_setlk(fd, cmd, &flock);
+}
+
 /*
  * This function is called when the file is being removed
  * from the task's fd array.
@@ -654,9 +710,9 @@
  * style lock.
  */
 static int posix_make_lock(struct file *filp, struct file_lock *fl,
-			   struct flock *l)
+			   struct flock64 *l)
 {
-	off_t start;
+	loff_t start;
 
 	memset(fl, 0, sizeof(*fl));
 	
@@ -1209,8 +1265,9 @@
 	p += sprintf(p, "%s ", (fl->fl_type == F_RDLCK) ? "READ " : "WRITE");
 	p += sprintf(p, "%d %s:%ld %ld %ld ",
 		     fl->fl_pid,
-		     kdevname(inode->i_dev), inode->i_ino, fl->fl_start,
-		     fl->fl_end);
+		     kdevname(inode->i_dev), inode->i_ino,
+		     (u_long)fl->fl_start,
+		     (u_long)fl->fl_end);
 	sprintf(p, "%08lx %08lx %08lx %08lx %08lx\n",
 		(long)fl, (long)fl->fl_prevlink, (long)fl->fl_nextlink,
 		(long)fl->fl_next, (long)fl->fl_nextblock);
--- linux-2.2.16-clean/fs/proc/array.c	Wed Jun  7 17:26:44 2000
+++ linux-2.2.16-lfs/fs/proc/array.c	Tue Jul 11 15:23:28 2000
@@ -1161,11 +1161,11 @@
  *         + (index into the line)
  */
 /* for systems with sizeof(void*) == 4: */
-#define MAPS_LINE_FORMAT4	  "%08lx-%08lx %s %08lx %s %lu"
-#define MAPS_LINE_MAX4	49 /* sum of 8  1  8  1 4 1 8 1 5 1 10 1 */
+#define MAPS_LINE_FORMAT4	  "%08lx-%08lx %s %016Lx %s %lu"
+#define MAPS_LINE_MAX4	57 /* sum of 8  1  8  1 4 1 16 1 5 1 10 1 */
 
 /* for systems with sizeof(void*) == 8: */
-#define MAPS_LINE_FORMAT8	  "%016lx-%016lx %s %016lx %s %lu"
+#define MAPS_LINE_FORMAT8	  "%016lx-%016lx %s %016Lx %s %lu"
 #define MAPS_LINE_MAX8	73 /* sum of 16  1  16  1 4 1 16 1 5 1 10 1 */
 
 #define MAPS_LINE_MAX	MAPS_LINE_MAX8
--- linux-2.2.16-clean/fs/minix/file.c	Mon Aug  9 15:04:41 1999
+++ linux-2.2.16-lfs/fs/minix/file.c	Tue Jul 11 15:23:28 2000
@@ -15,6 +15,7 @@
 #include <linux/locks.h>
 #include <linux/mm.h>
 #include <linux/pagemap.h>
+#include <linux/unistd.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -70,7 +71,7 @@
 				size_t count, loff_t *ppos)
 {
 	struct inode * inode = filp->f_dentry->d_inode;
-	off_t pos;
+	loff_t pos;
 	ssize_t written, c;
 	struct buffer_head * bh;
 	char * p;
@@ -87,6 +88,15 @@
 		pos = inode->i_size;
 	else
 		pos = *ppos;
+
+	/* MINIX i-node file-size can't exceed 4G-1 */
+	/* With 1k blocks and triple indirection MINIX can have files
+	   up to 16 GB in size -- filesystem maximum is then 4G*1k = 4T */
+	if (pos >= 0xffffffffULL)
+		return -EFBIG; /* Absolutely too much! */
+	if ((pos + count) >= 0x100000000ULL) /* too much to write! */
+		count = 0xffffffffULL - pos;
+
 	written = 0;
 	while (written < count) {
 		bh = minix_getblk(inode,pos/BLOCK_SIZE,1);
--- linux-2.2.16-clean/fs/isofs/inode.c	Wed Jun  7 17:26:43 2000
+++ linux-2.2.16-lfs/fs/isofs/inode.c	Tue Jul 11 15:23:28 2000
@@ -898,7 +898,8 @@
 
 int isofs_bmap(struct inode * inode,int block)
 {
-	off_t b_off, offset, size;
+	loff_t b_off;
+	off_t offset, size;
 	struct inode *ino;
 	unsigned int firstext;
 	unsigned long nextino;
@@ -909,7 +910,7 @@
 		return 0;
 	}
 
-	b_off = block << ISOFS_BUFFER_BITS(inode);
+	b_off = (loff_t)block << ISOFS_BUFFER_BITS(inode);
 
 	/*
 	 * If we are beyond the end of this file, don't give out any
@@ -917,7 +918,7 @@
 	 */
 	if( b_off > inode->i_size )
 	  {
-	    off_t	max_legal_read_offset;
+	    loff_t	max_legal_read_offset;
 
 	    /*
 	     * If we are *way* beyond the end of the file, print a message.
@@ -928,12 +929,13 @@
 	     * I/O errors.
 	     */
 	    max_legal_read_offset = (inode->i_size + PAGE_SIZE - 1)
-	      & ~(PAGE_SIZE - 1);
+					& ~(loff_t)(PAGE_SIZE - 1);
 	    if( b_off >= max_legal_read_offset )
 	      {
 
 		printk("_isofs_bmap: block>= EOF(%d, %ld)\n", block,
-		       inode->i_size);
+		       (u_long)((inode->i_size >> ISOFS_BUFFER_BITS(inode)) +
+				((inode->i_size & ((1 << ISOFS_BUFFER_BITS(inode))-1)) != 0)));
 	      }
 	    return 0;
 	  }
--- linux-2.2.16-clean/fs/nfs/proc.c	Tue Jan 13 13:03:40 1998
+++ linux-2.2.16-lfs/fs/nfs/proc.c	Tue Jul 11 15:23:28 2000
@@ -110,14 +110,14 @@
 
 int
 nfs_proc_read(struct nfs_server *server, struct nfs_fh *fhandle, int swap,
-			  unsigned long offset, unsigned int count,
-			  void *buffer, struct nfs_fattr *fattr)
+	      loff_t offset, unsigned int count,
+	      void *buffer, struct nfs_fattr *fattr)
 {
 	struct nfs_readargs	arg = { fhandle, offset, count, buffer };
 	struct nfs_readres	res = { fattr, count };
 	int			status;
 
-	dprintk("NFS call  read %d @ %ld\n", count, offset);
+	dprintk("NFS call  read %d @ %Ld\n", count, offset);
 	status = rpc_call(server->client, NFSPROC_READ, &arg, &res,
 			swap? NFS_RPC_SWAPFLAGS : 0);
 	dprintk("NFS reply read: %d\n", status);
@@ -126,13 +126,13 @@
 
 int
 nfs_proc_write(struct nfs_server *server, struct nfs_fh *fhandle, int swap,
-			unsigned long offset, unsigned int count,
-			const void *buffer, struct nfs_fattr *fattr)
+	       loff_t offset, unsigned int count,
+	       const void *buffer, struct nfs_fattr *fattr)
 {
 	struct nfs_writeargs	arg = { fhandle, offset, count, buffer };
 	int			status;
 
-	dprintk("NFS call  write %d @ %ld\n", count, offset);
+	dprintk("NFS call  write %d @ %Ld\n", count, offset);
 	status = rpc_call(server->client, NFSPROC_WRITE, &arg, fattr,
 			swap? (RPC_TASK_SWAPPER|RPC_TASK_ROOTCREDS) : 0);
 	dprintk("NFS reply read: %d\n", status);
--- linux-2.2.16-clean/fs/nfs/file.c	Tue Oct 26 20:53:42 1999
+++ linux-2.2.16-lfs/fs/nfs/file.c	Tue Jul 11 15:23:28 2000
@@ -26,6 +26,7 @@
 #include <linux/malloc.h>
 #include <linux/pagemap.h>
 #include <linux/lockd/bind.h>
+#include <linux/unistd.h>
 
 #include <asm/segment.h>
 #include <asm/system.h>
@@ -114,6 +115,11 @@
 		dentry->d_parent->d_name.name, dentry->d_name.name,
 		(unsigned long) count, (unsigned long) *ppos);
 
+	/* Unconditionally allow only up to 2G files */
+	/* FIXME: NFSv3 could allow 64-bit file offsets! */
+	if (!off_t_presentable(*ppos+1LL))
+		return -EOVERFLOW;
+
 	result = nfs_revalidate_inode(NFS_DSERVER(dentry), dentry);
 	if (!result)
 		result = generic_file_read(file, buf, count, ppos);
@@ -178,6 +184,13 @@
 	if (result)
 		goto out;
 
+	/* Unconditionally allow only up to 2G files */
+	/* FIXME: NFSv3 could allow 64-bit file offsets! */
+	if (!off_t_presentable(*ppos+1LL)) {
+		result = -EOVERFLOW;
+		goto out;
+	}
+
 	result = count;
 	if (!count)
 		goto out;
@@ -203,7 +216,7 @@
 	dprintk("NFS: nfs_lock(f=%4x/%ld, t=%x, fl=%x, r=%ld:%ld)\n",
 			inode->i_dev, inode->i_ino,
 			fl->fl_type, fl->fl_flags,
-			fl->fl_start, fl->fl_end);
+			(u_long)fl->fl_start, (u_long)fl->fl_end);
 
 	if (!inode)
 		return -EINVAL;
--- linux-2.2.16-clean/fs/nfs/inode.c	Wed Jun  7 17:26:43 2000
+++ linux-2.2.16-lfs/fs/nfs/inode.c	Tue Jul 11 15:23:28 2000
@@ -702,7 +702,7 @@
 	 */
 	if (sattr.size != (u32) -1) {
 		if (sattr.size != fattr.size)
-			printk("nfs_notify_change: sattr=%d, fattr=%d??\n",
+			printk("nfs_notify_change: sattr=%Ld, fattr=%Ld??\n",
 				sattr.size, fattr.size);
 		inode->i_size  = sattr.size;
 		inode->i_mtime = fattr.mtime.seconds;
--- linux-2.2.16-clean/fs/nfs/read.c	Wed May  3 20:16:46 2000
+++ linux-2.2.16-lfs/fs/nfs/read.c	Tue Jul 11 15:23:28 2000
@@ -52,7 +52,7 @@
  */
 static inline void
 nfs_readreq_setup(struct nfs_rreq *req, struct nfs_fh *fh,
-		  unsigned long offset, void *buffer, unsigned int rsize)
+		  loff_t offset, void *buffer, unsigned int rsize)
 {
 	req->ra_args.fh     = fh;
 	req->ra_args.offset = offset;
@@ -70,12 +70,12 @@
 nfs_readpage_sync(struct dentry *dentry, struct inode *inode, struct page *page)
 {
 	struct nfs_rreq	rqst;
-	unsigned long	offset = page->offset;
-	char		*buffer = (char *) page_address(page);
-	int		rsize = NFS_SERVER(inode)->rsize;
-	int		result, refresh = 0;
-	int		count = PAGE_SIZE;
-	int		flags = IS_SWAPFILE(inode)? NFS_RPC_SWAPFLAGS : 0;
+	loff_t	offset = page->offset;
+	char	*buffer = (char *) page_address(page);
+	int	rsize = NFS_SERVER(inode)->rsize;
+	int	result = 0, refresh = 0;
+	int	count = PAGE_SIZE;
+	int	flags = IS_SWAPFILE(inode)? NFS_RPC_SWAPFLAGS : 0;
 
 	dprintk("NFS: nfs_readpage_sync(%p)\n", page);
 	clear_bit(PG_error, &page->flags);
@@ -84,13 +84,28 @@
 		if (count < rsize)
 			rsize = count;
 
-		dprintk("NFS: nfs_proc_read(%s, (%s/%s), %ld, %d, %p)\n",
+		dprintk("NFS: nfs_proc_read(%s, (%s/%s), %Ld, %d, %p)\n",
 			NFS_SERVER(inode)->hostname,
 			dentry->d_parent->d_name.name, dentry->d_name.name,
 			offset, rsize, buffer);
 
+		/* FIXME: NFSv3 could allow 64-bit offsets! ... */
+
+		if (offset > 0x7ffffffeULL) {
+		  if (result)
+		  	break;
+		  result = -EOVERFLOW;
+		  goto io_error;
+		}
+		if ((offset + rsize) > 0x7fffffffULL) /* 2G-1 */
+		  rsize = 0x7fffffffULL - offset;
+
+		/* ... END FIXME! */
+
 		/* Set up arguments and perform rpc call */
-		nfs_readreq_setup(&rqst, NFS_FH(dentry), offset, buffer, rsize);
+		nfs_readreq_setup(&rqst, NFS_FH(dentry), offset,
+				  buffer, rsize);
+
 		result = rpc_call(NFS_CLIENT(inode), NFSPROC_READ,
 					&rqst.ra_args, &rqst.ra_res, flags);
 
@@ -173,8 +188,16 @@
 	unsigned long address = page_address(page);
 	struct nfs_rreq	*req;
 	int		result = -1, flags;
+	loff_t	loffset = page->offset;
 
 	dprintk("NFS: nfs_readpage_async(%p)\n", page);
+
+	/* FIXME: NFSv3 allows 64-bit offsets.. */
+	if ((loffset + PAGE_SIZE) >= 0x7fffffffULL) {
+	  dprintk("NFS: Async read beyond 2G-1 marker!\n");
+	  return -EOVERFLOW;
+	}
+
 	if (NFS_CONGESTED(inode))
 		goto out_defer;
 
@@ -186,8 +209,9 @@
 
 	/* Initialize request */
 	/* N.B. Will the dentry remain valid for life of request? */
-	nfs_readreq_setup(req, NFS_FH(dentry), page->offset,
-				(void *) address, PAGE_SIZE);
+	nfs_readreq_setup(req, NFS_FH(dentry), loffset,
+			  (void *) address, PAGE_SIZE);
+
 	req->ra_inode = inode;
 	req->ra_page = page; /* count has been incremented by caller */
 
@@ -230,7 +254,7 @@
 	struct inode *inode = dentry->d_inode;
 	int		error;
 
-	dprintk("NFS: nfs_readpage (%p %ld@%ld)\n",
+	dprintk("NFS: nfs_readpage (%p %ld@%Ld)\n",
 		page, PAGE_SIZE, page->offset);
 	atomic_inc(&page->count);
 	set_bit(PG_locked, &page->flags);
--- linux-2.2.16-clean/fs/nfs/write.c	Wed Mar  3 14:17:02 1999
+++ linux-2.2.16-lfs/fs/nfs/write.c	Tue Jul 11 15:23:28 2000
@@ -86,26 +86,46 @@
  */
 static int
 nfs_writepage_sync(struct dentry *dentry, struct inode *inode,
-		struct page *page, unsigned long offset, unsigned int count)
+		   struct page *page, unsigned int offset, unsigned int count)
 {
 	unsigned int	wsize = NFS_SERVER(inode)->wsize;
 	int		result, refresh = 0, written = 0;
 	u8		*buffer;
 	struct nfs_fattr fattr;
+	loff_t		loffset = page->offset+offset;
 
-	dprintk("NFS:      nfs_writepage_sync(%s/%s %d@%ld)\n",
+	dprintk("NFS:      nfs_writepage_sync(%s/%s %d@%Ld)\n",
 		dentry->d_parent->d_name.name, dentry->d_name.name,
-		count, page->offset + offset);
+		count, loffset);
 
 	buffer = (u8 *) page_address(page) + offset;
-	offset += page->offset;
+
+	/* FIXME: NFSv3 !!! */
+#if 1
+	if (!off_t_presentable(loffset+1)
+	    || loffset >= 0x7ffffffeULL) {
+	  return -EFBIG;
+	}
+	if (!off_t_presentable(loffset + count)
+	    || (loffset + count) >= 0x7fffffffULL) {
+	  /* At MOST this much! */
+	  count = 0x7fffffffULL - loffset;
+	}
+#else
+	if (S_ISREG(inode->i_flags) &&
+	    !(dentry->d_file->f_flags & O_LARGEFILE) &&
+	    (!off_t_presentable(loffset) ||
+	     !off_t_presentable(loffset + count))) {
+	  /* Writing beyond LargeFile maximums without O_LARGEFILE */
+	}
+#endif
 
 	do {
 		if (count < wsize && !IS_SWAPFILE(inode))
 			wsize = count;
 
 		result = nfs_proc_write(NFS_DSERVER(dentry), NFS_FH(dentry),
-					IS_SWAPFILE(inode), offset, wsize,
+					IS_SWAPFILE(inode), loffset, wsize,
 					buffer, &fattr);
 
 		if (result < 0) {
@@ -118,15 +138,15 @@
 			wsize, result);
 		refresh = 1;
 		buffer  += wsize;
-		offset  += wsize;
+		loffset += wsize;
 		written += wsize;
 		count   -= wsize;
 		/*
 		 * If we've extended the file, update the inode
 		 * now so we don't invalidate the cache.
 		 */
-		if (offset > inode->i_size)
-			inode->i_size = offset;
+		if (loffset > inode->i_size)
+			inode->i_size = loffset;
 	} while (count);
 
 io_error:
@@ -271,7 +291,7 @@
 
 	dprintk("NFS:      create_write_request(%s/%s, %ld+%d)\n",
 		dentry->d_parent->d_name.name, dentry->d_name.name,
-		page->offset + offset, bytes);
+		(u_long)(page->offset) + offset, bytes);
 
 	/* FIXME: Enforce hard limit on number of concurrent writes? */
 	wreq = (struct nfs_wreq *) kmalloc(sizeof(*wreq), GFP_KERNEL);
@@ -417,7 +437,7 @@
 
 	dprintk("NFS:      nfs_updatepage(%s/%s %d@%ld, sync=%d)\n",
 		dentry->d_parent->d_name.name, dentry->d_name.name,
-		count, page->offset+offset, sync);
+		count, (u_long)(page->offset)+offset, sync);
 
 	/*
 	 * Try to find a corresponding request on the writeback queue.
--- linux-2.2.16-clean/fs/ext2/file.c	Tue Jan  4 13:12:23 2000
+++ linux-2.2.16-lfs/fs/ext2/file.c	Tue Jul 11 15:23:28 2000
@@ -39,10 +39,6 @@
 static long long ext2_file_lseek(struct file *, long long, int);
 static ssize_t ext2_file_write (struct file *, const char *, size_t, loff_t *);
 static int ext2_release_file (struct inode *, struct file *);
-#if BITS_PER_LONG < 64
-static int ext2_open_file (struct inode *, struct file *);
-
-#else
 
 #define EXT2_MAX_SIZE(bits)							\
 	(((EXT2_NDIR_BLOCKS + (1LL << (bits - 2)) + 				\
@@ -55,8 +51,6 @@
 EXT2_MAX_SIZE(10), EXT2_MAX_SIZE(11), EXT2_MAX_SIZE(12), EXT2_MAX_SIZE(13)
 };
 
-#endif
-
 /*
  * We have mostly NULL's here: the current defaults are ok for
  * the ext2 filesystem.
@@ -69,11 +63,7 @@
 	NULL,			/* poll - default */
 	ext2_ioctl,		/* ioctl */
 	generic_file_mmap,	/* mmap */
-#if BITS_PER_LONG == 64	
 	NULL,			/* no special open is needed */
-#else
-	ext2_open_file,
-#endif
 	NULL,			/* flush */
 	ext2_release_file,	/* release */
 	ext2_sync_file,		/* fsync */
@@ -121,12 +111,8 @@
 			offset += file->f_pos;
 	}
 	if (((unsigned long long) offset >> 32) != 0) {
-#if BITS_PER_LONG < 64
-		return -EINVAL;
-#else
 		if (offset > ext2_max_sizes[EXT2_BLOCK_SIZE_BITS(inode->i_sb)])
 			return -EINVAL;
-#endif
 	} 
 	if (offset != file->f_pos) {
 		file->f_pos = offset;
@@ -155,7 +141,7 @@
 				size_t count, loff_t *ppos)
 {
 	struct inode * inode = filp->f_dentry->d_inode;
-	off_t pos;
+	loff_t pos;
 	long block;
 	int offset;
 	int written, c;
@@ -201,25 +187,8 @@
 	}
 
 	/* Check for overflow.. */
-
-#if BITS_PER_LONG < 64
-	/* If the fd's pos is already greater than or equal to the file
-	 * descriptor's offset maximum, then we need to return EFBIG for
-	 * any non-zero count (and we already tested for zero above). */
-	if (((unsigned) pos) >= 0x7FFFFFFFUL)
-		return -EFBIG;
-	
-	/* If we are about to overflow the maximum file size, we also
-	 * need to return the error, but only if no bytes can be written
-	 * successfully. */
-	if (((unsigned) pos + count) > 0x7FFFFFFFUL) {
-		count = 0x7FFFFFFFL - pos;
-		if (((signed) count) < 0)
-			return -EFBIG;
-	}
-#else
 	{
-		off_t max = ext2_max_sizes[EXT2_BLOCK_SIZE_BITS(sb)];
+		loff_t max = ext2_max_sizes[EXT2_BLOCK_SIZE_BITS(sb)];
 
 		if (pos >= max)
 			return -EFBIG;
@@ -239,7 +208,6 @@
 			mark_buffer_dirty(sb->u.ext2_sb.s_sbh, 1);
 		}
 	}
-#endif
 
 	/* From SUS: We must generate a SIGXFSZ for file size overflow
 	 * only if no bytes were actually written to the file. --sct */
@@ -381,16 +349,3 @@
 		ext2_discard_prealloc (inode);
 	return 0;
 }
-
-#if BITS_PER_LONG < 64
-/*
- * Called when an inode is about to be open.
- * We use this to disallow opening RW large files on 32bit systems.
- */
-static int ext2_open_file (struct inode * inode, struct file * filp)
-{
-	if (inode->u.ext2_i.i_high_size && (filp->f_mode & FMODE_WRITE))
-		return -EFBIG;
-	return 0;
-}
-#endif
--- linux-2.2.16-clean/fs/ext2/inode.c	Tue Jan  4 13:12:23 2000
+++ linux-2.2.16-lfs/fs/ext2/inode.c	Tue Jul 11 15:23:28 2000
@@ -535,13 +535,8 @@
 		inode->u.ext2_i.i_dir_acl = 0;
 		inode->u.ext2_i.i_high_size =
 			le32_to_cpu(raw_inode->i_size_high);
-#if BITS_PER_LONG < 64
-		if (raw_inode->i_size_high)
-			inode->i_size = (__u32)-1;
-#else
-		inode->i_size |= ((__u64)le32_to_cpu(raw_inode->i_size_high))
-			<< 32;
-#endif
+		inode->i_size = ((__u64)(inode->i_size & 0xFFFFFFFFUL)) |
+			(((__u64)le32_to_cpu(raw_inode->i_size_high)) << 32);
 	}
 	inode->u.ext2_i.i_version = le32_to_cpu(raw_inode->i_version);
 	inode->i_generation = inode->u.ext2_i.i_version;
@@ -667,12 +662,7 @@
 	if (S_ISDIR(inode->i_mode))
 		raw_inode->i_dir_acl = cpu_to_le32(inode->u.ext2_i.i_dir_acl);
 	else { 
-#if BITS_PER_LONG < 64
-		raw_inode->i_size_high =
-			cpu_to_le32(inode->u.ext2_i.i_high_size);
-#else
 		raw_inode->i_size_high = cpu_to_le32(inode->i_size >> 32);
-#endif
 	}
 	raw_inode->i_version = cpu_to_le32(inode->u.ext2_i.i_version);
 	if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))
@@ -728,21 +718,20 @@
 	}
 
 	if (iattr->ia_valid & ATTR_SIZE) {
-		off_t size = iattr->ia_size;
-		unsigned long limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+		loff_t size = iattr->ia_size;
+		loff_t limit = current->rlimfsz.rlim_cur;
 
 		if (size < 0)
 			return -EINVAL;
-#if BITS_PER_LONG == 64	
+
 		if (size > ext2_max_sizes[EXT2_BLOCK_SIZE_BITS(inode->i_sb)])
 			return -EFBIG;
-#endif
+
 		if (limit < RLIM_INFINITY && size > limit) {
 			send_sig(SIGXFSZ, current, 0);
 			return -EFBIG;
 		}
 
-#if BITS_PER_LONG == 64	
 		if (size >> 33) {
 			struct super_block *sb = inode->i_sb;
 			struct ext2_super_block *es = sb->u.ext2_sb.s_es;
@@ -755,7 +744,6 @@
 				mark_buffer_dirty(sb->u.ext2_sb.s_sbh, 1);
 			}
 		}
-#endif
 	}
 	
 	retval = inode_change_ok(inode, iattr);
--- linux-2.2.16-clean/fs/sysv/file.c	Mon Aug 24 16:02:44 1998
+++ linux-2.2.16-lfs/fs/sysv/file.c	Tue Jul 11 15:23:28 2000
@@ -207,7 +207,7 @@
 {
 	struct inode * inode = filp->f_dentry->d_inode;
 	struct super_block * sb = inode->i_sb;
-	off_t pos;
+	loff_t pos;
 	ssize_t written, c;
 	struct buffer_head * bh;
 	char * p;
@@ -232,6 +232,12 @@
 	else
 		pos = *ppos;
 	written = 0;
+
+	if (pos >= 0xffffffffULL)
+		return -EFBIG; /* Only up to 4G-1! */
+	if ((pos + count) > 0xffffffffULL)
+		count = 0xffffffffULL - pos;
+
 	while (written<count) {
 		bh = sysv_getblk (inode, pos >> sb->sv_block_size_bits, 1);
 		if (!bh) {
--- linux-2.2.16-clean/fs/ufs/dir.c	Wed May  3 20:16:47 2000
+++ linux-2.2.16-lfs/fs/ufs/dir.c	Tue Jul 11 15:23:28 2000
@@ -172,7 +172,7 @@
 	if (error_msg != NULL)
 		ufs_error (sb, function, "bad entry in directory #%lu, size %lu: %s - "
 			    "offset=%lu, inode=%lu, reclen=%d, namlen=%d",
-			    dir->i_ino, dir->i_size, error_msg, offset,
+			    dir->i_ino, (u_long)dir->i_size, error_msg, offset,
 			    (unsigned long) SWAB32(de->d_ino),
 			    SWAB16(de->d_reclen), ufs_get_de_namlen(de));
 	
--- linux-2.2.16-clean/fs/ufs/inode.c	Wed Jun  7 17:26:44 2000
+++ linux-2.2.16-lfs/fs/ufs/inode.c	Tue Jul 11 15:23:28 2000
@@ -54,7 +54,7 @@
 {
 	unsigned swab = inode->i_sb->u.ufs_sb.s_swab;
 	printk("ino %lu  mode 0%6.6o  nlink %d  uid %d  uid32 %u"
-	       "  gid %d  gid32 %u  size %lu blocks %lu\n",
+	       "  gid %d  gid32 %u  size %Lu blocks %lu\n",
 	       inode->i_ino, inode->i_mode, inode->i_nlink,
 	       inode->i_uid, inode->u.ufs_i.i_uid, inode->i_gid, 
 	       inode->u.ufs_i.i_gid, inode->i_size, inode->i_blocks);
@@ -212,14 +212,12 @@
 	*err = -EFBIG;
 	if (!create)
 		return NULL;
-	limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
-	if (limit < RLIM_INFINITY) {
-		limit >>= sb->s_blocksize_bits;
-		if (new_fragment >= limit) {
-			send_sig(SIGXFSZ, current, 0);
-			return NULL;
-		}
+	limit = (current->rlimfsz.rlim_cur >> sb->s_blocksize_bits);
+	if (new_fragment >= limit) {
+		send_sig(SIGXFSZ, current, 0);
+		return NULL;
 	}
+
 	lastblock = ufs_fragstoblks (lastfrag);
 	lastblockoff = ufs_fragnum (lastfrag);
 	/*
@@ -321,7 +319,8 @@
 		brelse (result);
 		goto repeat;
 	}
-	if (!create || new_fragment >= (current->rlim[RLIMIT_FSIZE].rlim_cur >> sb->s_blocksize)) {
+	if (!create || (new_fragment >=
+			(current->rlimfsz.rlim_cur >> sb->s_blocksize_bits))) {
 		brelse (bh);
 		*err = -EFBIG;
 		return NULL;
@@ -497,13 +496,11 @@
 	}
 	
 	/*
-	 * Linux i_size can be 32 on some architectures. We will mark 
-	 * big files as read only and let user access first 32 bits.
+	 * Linux i_size used to be 32 bits on some architectures.
+	 * These days we allow access to the entire file as is..
 	 */
 	inode->u.ufs_i.i_size = SWAB64(ufs_inode->ui_size);
-	inode->i_size = (off_t) inode->u.ufs_i.i_size;
-	if (sizeof(off_t) == 4 && (inode->u.ufs_i.i_size >> 32))
-		inode->i_size = (__u32)-1;
+	inode->i_size = inode->u.ufs_i.i_size;
 
 	inode->i_atime = SWAB32(ufs_inode->ui_atime.tv_sec);
 	inode->i_ctime = SWAB32(ufs_inode->ui_ctime.tv_sec);
--- linux-2.2.16-clean/fs/lockd/svclock.c	Mon Aug  9 15:05:02 1999
+++ linux-2.2.16-lfs/fs/lockd/svclock.c	Tue Jul 11 15:23:28 2000
@@ -94,13 +94,15 @@
 	struct file_lock	*fl;
 
 	dprintk("lockd: nlmsvc_lookup_block f=%p pd=%d %ld-%ld ty=%d\n",
-				file, lock->fl.fl_pid, lock->fl.fl_start,
-				lock->fl.fl_end, lock->fl.fl_type);
+		file, lock->fl.fl_pid,
+		(u_long)lock->fl.fl_start, (u_long)lock->fl.fl_end,
+		lock->fl.fl_type);
 	for (head = &nlm_blocked; (block = *head); head = &block->b_next) {
 		fl = &block->b_call.a_args.lock.fl;
 		dprintk("       check f=%p pd=%d %ld-%ld ty=%d\n",
-				block->b_file, fl->fl_pid, fl->fl_start,
-				fl->fl_end, fl->fl_type);
+				block->b_file, fl->fl_pid,
+				(u_long)fl->fl_start, (u_long)fl->fl_end,
+				fl->fl_type);
 		if (block->b_file == file && nlm_compare_locks(fl, &lock->fl)) {
 			if (remove)
 				*head = block->b_next;
@@ -286,8 +288,8 @@
 				file->f_file.f_dentry->d_inode->i_dev,
 				file->f_file.f_dentry->d_inode->i_ino,
 				lock->fl.fl_type, lock->fl.fl_pid,
-				lock->fl.fl_start,
-				lock->fl.fl_end,
+				(u_long)lock->fl.fl_start,
+				(u_long)lock->fl.fl_end,
 				wait);
 
 	/* Lock file against concurrent access */
@@ -359,12 +361,13 @@
 				file->f_file.f_dentry->d_inode->i_dev,
 				file->f_file.f_dentry->d_inode->i_ino,
 				lock->fl.fl_type,
-				lock->fl.fl_start,
-				lock->fl.fl_end);
+				(u_long)lock->fl.fl_start,
+				(u_long)lock->fl.fl_end);
 
 	if ((fl = posix_test_lock(&file->f_file, &lock->fl)) != NULL) {
 		dprintk("lockd: conflicting lock(ty=%d, %ld-%ld)\n",
-				fl->fl_type, fl->fl_start, fl->fl_end);
+				fl->fl_type,
+				(u_long)fl->fl_start, (u_long)fl->fl_end);
 		conflock->caller = "somehost";	/* FIXME */
 		conflock->oh.len = 0;		/* don't return OH info */
 		conflock->fl = *fl;
@@ -390,8 +393,8 @@
 				file->f_file.f_dentry->d_inode->i_dev,
 				file->f_file.f_dentry->d_inode->i_ino,
 				lock->fl.fl_pid,
-				lock->fl.fl_start,
-				lock->fl.fl_end);
+				(u_long)lock->fl.fl_start,
+				(u_long)lock->fl.fl_end);
 
 	/* First, cancel any lock that might be there */
 	nlmsvc_cancel_blocked(file, lock);
@@ -418,8 +421,8 @@
 				file->f_file.f_dentry->d_inode->i_dev,
 				file->f_file.f_dentry->d_inode->i_ino,
 				lock->fl.fl_pid,
-				lock->fl.fl_start,
-				lock->fl.fl_end);
+				(u_long)lock->fl.fl_start,
+				(u_long)lock->fl.fl_end);
 
 	down(&file->f_sema);
 	if ((block = nlmsvc_lookup_block(file, lock, 1)) != NULL)
--- linux-2.2.16-clean/kernel/sys.c	Wed May  3 20:16:53 2000
+++ linux-2.2.16-lfs/kernel/sys.c	Tue Jul 11 15:23:28 2000
@@ -906,11 +906,44 @@
 
 asmlinkage int sys_getrlimit(unsigned int resource, struct rlimit *rlim)
 {
+	struct rlimit rl;
+
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
-	else
-		return copy_to_user(rlim, current->rlim + resource, sizeof(*rlim))
-			? -EFAULT : 0;
+
+	rl = current->rlim[resource];
+	if (resource == RLIMIT_FSIZE) {
+	  rl.rlim_cur = current->rlimfsz.rlim_cur;
+	  if (current->rlimfsz.rlim_cur > RLIM_INFINITY)
+	    rl.rlim_cur = RLIM_INFINITY;
+	  rl.rlim_max = current->rlimfsz.rlim_max;
+	  if (current->rlimfsz.rlim_max > RLIM_INFINITY)
+	    rl.rlim_max = RLIM_INFINITY;
+
+	  /* XX: RLIM_SAVED_MAX ? RLIM_SAVED_CUR ? (See Large-File-Summit) */
+	}
+	return (copy_to_user(rlim, &rl, sizeof(*rlim)) ? -EFAULT : 0);
+}
+
+asmlinkage int sys_getrlimit64(unsigned int resource, struct rlimit64 *rlim)
+{
+	struct rlimit64 rlim64;
+
+	if (resource >= RLIM_NLIMITS)
+		return -EINVAL;
+
+	if (resource == RLIMIT_FSIZE)
+	  rlim64 = current->rlimfsz;
+	else {
+	  rlim64.rlim_cur = current->rlim[resource].rlim_cur;
+	  rlim64.rlim_max = current->rlim[resource].rlim_max;
+	  if (rlim64.rlim_cur == RLIM_INFINITY)
+	    rlim64.rlim_cur = RLIM64_INFINITY;
+	  if (rlim64.rlim_max == RLIM_INFINITY)
+	    rlim64.rlim_max = RLIM64_INFINITY;
+	  /* XX: RLIM_SAVED_MAX ? RLIM_SAVED_CUR ? (See Large-File-Summit) */
+	}
+	return (copy_to_user(rlim, &rlim64, sizeof(*rlim)) ? -EFAULT : 0);
 }
 
 asmlinkage int sys_setrlimit(unsigned int resource, struct rlimit *rlim)
@@ -932,7 +965,58 @@
 		if (new_rlim.rlim_cur > NR_OPEN || new_rlim.rlim_max > NR_OPEN)
 			return -EPERM;
 	}
+	if (resource == RLIMIT_FSIZE) {
+		if (new_rlim.rlim_cur == RLIM_INFINITY) {
+			current->rlimfsz.rlim_cur = RLIM64_INFINITY;
+		}
+		if (new_rlim.rlim_max == RLIM_INFINITY) {
+			current->rlimfsz.rlim_max = RLIM64_INFINITY;
+		}
+	}
 	*old_rlim = new_rlim;
+	return 0;
+}
+
+asmlinkage int sys_setrlimit64(unsigned int resource, struct rlimit64 *rlim)
+{
+	struct rlimit64 new_rlim;
+	struct rlimit  *old_rlim;
+
+	if (resource >= RLIM_NLIMITS)
+		return -EINVAL;
+	if(copy_from_user(&new_rlim, rlim, sizeof(*rlim)))
+		return -EFAULT;
+	old_rlim = &current->rlim[resource];
+	
+	if (new_rlim.rlim_cur > RLIM_INFINITY && resource != RLIMIT_FSIZE)
+	  new_rlim.rlim_cur = RLIM_INFINITY;
+	if (new_rlim.rlim_max > RLIM_INFINITY && resource != RLIMIT_FSIZE)
+	  new_rlim.rlim_max = RLIM_INFINITY;
+
+	if (resource == RLIMIT_FSIZE) {
+		if (((new_rlim.rlim_cur > current->rlimfsz.rlim_max) ||
+		     (new_rlim.rlim_max > current->rlimfsz.rlim_max)) &&
+		    !capable(CAP_SYS_RESOURCE))
+			return -EPERM;
+	} else
+		if (((new_rlim.rlim_cur > old_rlim->rlim_max) ||
+		     (new_rlim.rlim_max > old_rlim->rlim_max)) &&
+		    !capable(CAP_SYS_RESOURCE))
+			return -EPERM;
+	if (resource == RLIMIT_NOFILE) {
+		if (new_rlim.rlim_cur > NR_OPEN || new_rlim.rlim_max > NR_OPEN)
+			return -EPERM;
+	}
+	if (resource == RLIMIT_FSIZE) {
+		current->rlimfsz = new_rlim;
+
+		if (new_rlim.rlim_cur > RLIM_INFINITY)
+		  new_rlim.rlim_cur = RLIM_INFINITY;
+		if (new_rlim.rlim_max > RLIM_INFINITY)
+		  new_rlim.rlim_max = RLIM_INFINITY;
+	}
+	old_rlim->rlim_cur = new_rlim.rlim_cur;
+	old_rlim->rlim_max = new_rlim.rlim_max;
 	return 0;
 }
 
--- linux-2.2.16-clean/lib/vsprintf.c	Mon Mar 15 14:19:05 1999
+++ linux-2.2.16-lfs/lib/vsprintf.c	Tue Jul 11 15:23:28 2000
@@ -68,11 +68,11 @@
 
 #define do_div(n,base) ({ \
 int __res; \
-__res = ((unsigned long) n) % (unsigned) base; \
-n = ((unsigned long) n) / (unsigned) base; \
+__res = ((unsigned long long) n) % (unsigned) base; \
+n = ((unsigned long long) n) / (unsigned) base; \
 __res; })
 
-static char * number(char * str, long num, int base, int size, int precision
+static char * number(char * str, long long num, int base, int size, int precision
 	,int type)
 {
 	char c,sign,tmp[66];
@@ -292,6 +292,8 @@
 		}
 		if (qualifier == 'l')
 			num = va_arg(args, unsigned long);
+		else if (qualifier == 'L')
+			num = va_arg(args, unsigned long long);
 		else if (qualifier == 'h') {
 			num = (unsigned short) va_arg(args, int);
 			if (flags & SIGN)
--- linux-2.2.16-clean/mm/memory.c	Tue Jan  4 13:12:26 2000
+++ linux-2.2.16-lfs/mm/memory.c	Tue Jul 11 15:23:28 2000
@@ -730,7 +730,7 @@
  * between the file and the memory map for a potential last
  * incomplete page.  Ugly, but necessary.
  */
-void vmtruncate(struct inode * inode, unsigned long offset)
+void vmtruncate(struct inode * inode, loff_t offset)
 {
 	struct vm_area_struct * mpnt;
 
--- linux-2.2.16-clean/mm/mmap.c	Wed Jun  7 17:26:44 2000
+++ linux-2.2.16-lfs/mm/mmap.c	Tue Jul 11 15:23:28 2000
@@ -170,14 +170,21 @@
 }
 
 unsigned long do_mmap(struct file * file, unsigned long addr, unsigned long len,
-	unsigned long prot, unsigned long flags, unsigned long off)
+	unsigned long prot, unsigned long flags, loff_t off)
 {
 	struct mm_struct * mm = current->mm;
 	struct vm_area_struct * vma;
 	int error;
 
-	if (file && (!file->f_op || !file->f_op->mmap))
-		return -ENODEV;
+	if (file) {
+		if (!file->f_op || !file->f_op->mmap)
+			return -ENODEV;
+
+		/* L-F-S spec 2.2.1.23 */
+		if (!(file->f_flags & O_LARGEFILE) &&
+		    !off_t_presentable(file->f_pos+len))
+			return -EOVERFLOW;
+	}
 
 	if ((len = PAGE_ALIGN(len)) == 0)
 		return addr;
@@ -836,7 +843,8 @@
 		 * the offsets must be contiguous..
 		 */
 		if ((mpnt->vm_file != NULL) || (mpnt->vm_flags & VM_SHM)) {
-			unsigned long off = prev->vm_offset+prev->vm_end-prev->vm_start;
+			loff_t off = (prev->vm_offset +
+				      (loff_t)(prev->vm_end - prev->vm_start));
 			if (off != mpnt->vm_offset)
 				continue;
 		}
--- linux-2.2.16-clean/mm/filemap.c	Wed Jun  7 17:26:44 2000
+++ linux-2.2.16-lfs/mm/filemap.c	Tue Jul 11 15:23:28 2000
@@ -88,7 +88,7 @@
  * Truncate the page cache at a set offset, removing the pages
  * that are beyond that offset (and zeroing out partial pages).
  */
-void truncate_inode_pages(struct inode * inode, unsigned long start)
+void truncate_inode_pages(struct inode * inode, loff_t start)
 {
 	struct page ** p;
 	struct page * page;
@@ -96,7 +96,7 @@
 repeat:
 	p = &inode->i_pages;
 	while ((page = *p) != NULL) {
-		unsigned long offset = page->offset;
+		loff_t offset = page->offset;
 
 		/* page wholly truncated - free it */
 		if (offset >= start) {
@@ -119,7 +119,7 @@
 		/* partial truncate, clear end of page */
 		if (offset < PAGE_CACHE_SIZE) {
 			unsigned long address = page_address(page);
-			memset((void *) (offset + address), 0, PAGE_CACHE_SIZE - offset);
+			memset((void *)(unsigned long)(offset + address), 0, PAGE_CACHE_SIZE - offset);
 			flush_page_to_ram(address);
 		}
 	}
@@ -236,12 +236,12 @@
  * memory maps.  --sct
  */
 
-void update_vm_cache_conditional(struct inode * inode, unsigned long pos, const char * buf, int count, unsigned long source_address)
+void update_vm_cache_conditional(struct inode * inode, loff_t pos, const char * buf, int count, unsigned long source_address)
 {
 	unsigned long offset, len;
 
-	offset = (pos & ~PAGE_CACHE_MASK);
-	pos = pos & PAGE_CACHE_MASK;
+	offset = (pos & ~PAGE_CACHE_MASK_loff);
+	pos = pos & PAGE_CACHE_MASK_loff;
 	len = PAGE_CACHE_SIZE - offset;
 	do {
 		struct page * page;
@@ -267,14 +267,14 @@
 	} while (count);
 }
 
-void update_vm_cache(struct inode * inode, unsigned long pos, const char * buf, int count)
+void update_vm_cache(struct inode * inode, loff_t pos, const char * buf, int count)
 {
 	update_vm_cache_conditional(inode, pos, buf, count, 0);
 }
 
 
 static inline void add_to_page_cache(struct page * page,
-	struct inode * inode, unsigned long offset,
+	struct inode * inode, loff_t offset,
 	struct page **hash)
 {
 	atomic_inc(&page->count);
@@ -290,13 +290,13 @@
  * this is all overlapped with the IO on the previous page finishing anyway)
  */
 static unsigned long try_to_read_ahead(struct file * file,
-				unsigned long offset, unsigned long page_cache)
+				       loff_t offset, unsigned long page_cache)
 {
 	struct inode *inode = file->f_dentry->d_inode;
 	struct page * page;
 	struct page ** hash;
 
-	offset &= PAGE_CACHE_MASK;
+	offset &= PAGE_CACHE_MASK_loff;
 	switch (page_cache) {
 	case 0:
 		page_cache = page_cache_alloc();
@@ -478,13 +478,13 @@
 
 static inline unsigned long generic_file_readahead(int reada_ok,
 	struct file * filp, struct inode * inode,
-	unsigned long ppos, struct page * page, unsigned long page_cache)
+	loff_t ppos, struct page * page, unsigned long page_cache)
 {
-	unsigned long max_ahead, ahead;
-	unsigned long raend;
+	loff_t max_ahead, ahead;
+	loff_t raend;
 	int max_readahead = get_max_readahead(inode);
 
-	raend = filp->f_raend & PAGE_CACHE_MASK;
+	raend = filp->f_raend & PAGE_CACHE_MASK_loff;
 	max_ahead = 0;
 
 /*
@@ -608,14 +608,15 @@
 {
 	struct dentry *dentry = filp->f_dentry;
 	struct inode *inode = dentry->d_inode;
-	size_t pos, pgpos, page_cache;
+	size_t page_cache;
+	loff_t pos, pgpos;
 	int reada_ok;
 	int max_readahead = get_max_readahead(inode);
 
 	page_cache = 0;
 
 	pos = *ppos;
-	pgpos = pos & PAGE_CACHE_MASK;
+	pgpos = pos & PAGE_CACHE_MASK_loff;
 /*
  * If the current position is outside the previous read-ahead window, 
  * we reset the current read-ahead context and set read ahead max to zero
@@ -639,12 +640,12 @@
  * Then, at least MIN_READAHEAD if read ahead is ok,
  * and at most MAX_READAHEAD in all cases.
  */
-	if (pos + desc->count <= (PAGE_CACHE_SIZE >> 1)) {
+	if (pos + desc->count <= (loff_t)(PAGE_CACHE_SIZE >> 1)) {
 		filp->f_ramax = 0;
 	} else {
-		unsigned long needed;
+		loff_t needed;
 
-		needed = ((pos + desc->count) & PAGE_CACHE_MASK) - pgpos;
+		needed = ((pos + desc->count) & PAGE_CACHE_MASK_loff) - pgpos;
 
 		if (filp->f_ramax < needed)
 			filp->f_ramax = needed;
@@ -664,8 +665,8 @@
 		/*
 		 * Try to find the data in the page cache..
 		 */
-		hash = page_hash(inode, pos & PAGE_CACHE_MASK);
-		page = __find_page(inode, pos & PAGE_CACHE_MASK, *hash);
+		hash = page_hash(inode, pos & PAGE_CACHE_MASK_loff);
+		page = __find_page(inode, pos & PAGE_CACHE_MASK_loff, *hash);
 		if (!page)
 			goto no_cached_page;
 
@@ -678,7 +679,7 @@
  * the page has been rewritten.
  */
 		if (PageUptodate(page) || PageLocked(page))
-			page_cache = generic_file_readahead(reada_ok, filp, inode, pos & PAGE_CACHE_MASK, page, page_cache);
+			page_cache = generic_file_readahead(reada_ok, filp, inode, pos & PAGE_CACHE_MASK_loff, page, page_cache);
 		else if (reada_ok && filp->f_ramax > MIN_READAHEAD)
 				filp->f_ramax = MIN_READAHEAD;
 
@@ -697,7 +698,7 @@
 
 		offset = pos & ~PAGE_CACHE_MASK;
 		nr = PAGE_CACHE_SIZE - offset;
-		if (nr > inode->i_size - pos)
+		if ((loff_t)nr > (inode->i_size - pos))
 			nr = inode->i_size - pos;
 
 		/*
@@ -737,7 +738,7 @@
 		 */
 		page = page_cache_entry(page_cache);
 		page_cache = 0;
-		add_to_page_cache(page, inode, pos & PAGE_CACHE_MASK, hash);
+		add_to_page_cache(page, inode, pos & PAGE_CACHE_MASK_loff, hash);
 
 		/*
 		 * Error handling is tricky. If we get a read error,
@@ -963,12 +964,15 @@
 	struct file * file = area->vm_file;
 	struct dentry * dentry = file->f_dentry;
 	struct inode * inode = dentry->d_inode;
-	unsigned long offset, reada, i;
+	loff_t offset, reada;
+	int i;
 	struct page * page, **hash;
 	unsigned long old_page, new_page;
 
 	new_page = 0;
-	offset = (address & PAGE_MASK) - area->vm_start + area->vm_offset;
+	offset = ((loff_t)((address & PAGE_MASK) - area->vm_start) +
+		  area->vm_offset);
+
 	if (offset >= inode->i_size && (area->vm_flags & VM_SHARED) && area->vm_mm == current->mm)
 		goto no_page;
 
@@ -1103,10 +1107,10 @@
  * if the disk is full.
  */
 static inline int do_write_page(struct inode * inode, struct file * file,
-	const char * page, unsigned long offset)
+				const char * page, loff_t offset)
 {
 	int retval;
-	unsigned long size;
+	loff_t size;
 	loff_t loff = offset;
 	mm_segment_t old_fs;
 
@@ -1130,7 +1134,7 @@
 }
 
 static int filemap_write_page(struct vm_area_struct * vma,
-			      unsigned long offset,
+			      loff_t offset,
 			      unsigned long page,
 			      int wait)
 {
@@ -1475,8 +1479,8 @@
 {
 	struct dentry	*dentry = file->f_dentry; 
 	struct inode	*inode = dentry->d_inode; 
-	unsigned long	pos = *ppos;
-	unsigned long	limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+	loff_t		pos = *ppos;
+	loff_t		limit = current->rlimfsz.rlim_cur;
 	struct page	*page, **hash;
 	unsigned long	page_cache = 0;
 	unsigned long	written;
@@ -1517,7 +1521,8 @@
 	}
 
 	while (count) {
-		unsigned long bytes, pgpos, offset;
+		unsigned long bytes, offset;
+		loff_t pgpos;
 		char * dest;
 
 		/*
@@ -1597,8 +1602,7 @@
  * Note: we don't have to worry about races here, as the caller
  * is holding the inode semaphore.
  */
-unsigned long get_cached_page(struct inode * inode, unsigned long offset,
-				int new)
+unsigned long get_cached_page(struct inode * inode, loff_t offset, int new)
 {
 	struct page * page;
 	struct page ** hash;
--- linux-2.2.16-clean/mm/page_io.c	Wed Jun  7 17:26:44 2000
+++ linux-2.2.16-lfs/mm/page_io.c	Tue Jul 11 15:23:28 2000
@@ -112,7 +112,7 @@
 		 * as if it were: we are not allowed to manipulate the inode
 		 * hashing for locked pages.
 		 */
-		if (page->offset != entry) {
+		if (((unsigned long)(page->offset)) != entry) {
 			printk ("swap entry mismatch");
 			return;
 		}
@@ -265,8 +265,8 @@
 		printk("VM: swap page is not in swap cache\n");
 		return;
 	}
-	if (page->offset != entry) {
-		printk ("swap entry mismatch");
+	if (((unsigned long)(page->offset)) != entry) {
+		printk ("VM: swap entry mismatch");
 		return;
 	}
 	rw_swap_page_base(rw, entry, page, wait);
--- linux-2.2.16-clean/mm/swap_state.c	Wed Jan 13 12:54:50 1999
+++ linux-2.2.16-lfs/mm/swap_state.c	Tue Jul 11 15:23:28 2000
@@ -54,7 +54,7 @@
 	if (PageTestandSetSwapCache(page)) {
 		printk(KERN_ERR "swap_cache: replacing non-empty entry %08lx "
 		       "on page %08lx\n",
-		       page->offset, page_address(page));
+		       (unsigned long)(page->offset), page_address(page));
 		return 0;
 	}
 	if (page->inode) {
--- linux-2.2.16-clean/include/linux/sched.h	Wed May  3 20:16:52 2000
+++ linux-2.2.16-lfs/include/linux/sched.h	Tue Jul 11 16:46:01 2000
@@ -301,6 +301,7 @@
 	struct user_struct *user;
 /* limits */
 	struct rlimit rlim[RLIM_NLIMITS];
+	struct rlimit64 rlimfsz; /* RLIM_FSIZE -- only! at 32-bit systems */
 	unsigned short used_math;
 	char comm[16];
 /* file system info */
@@ -389,6 +390,7 @@
 /* caps */      CAP_INIT_EFF_SET,CAP_INIT_INH_SET,CAP_FULL_SET, \
 /* user */	NULL,						\
 /* rlimits */   INIT_RLIMITS, \
+/* rlimfsz */   INIT_RLIMFSZ, \
 /* math */	0, \
 /* comm */	"swapper", \
 /* fs info */	0,NULL, \
--- linux-2.2.16-clean/include/linux/fs.h	Wed Jun  7 17:26:44 2000
+++ linux-2.2.16-lfs/include/linux/fs.h	Tue Jul 11 16:46:00 2000
@@ -260,6 +260,25 @@
 #define buffer_page(bh)		(mem_map + MAP_NR((bh)->b_data))
 #define touch_buffer(bh)	set_bit(PG_referenced, &buffer_page(bh)->flags)
 
+/* log of base-2 for filesystem uses, in case their super-blocks
+   don't have the shift counts readily calculated.. -- presuming
+   the divisors in question are power-of-two values! */
+static int fslog2(unsigned long val) __attribute__ ((const));
+static __inline__ int fslog2(unsigned long val)
+{
+	int i;
+	for (i = 0; val != 0; ++i, val >>= 1) {
+	  if (val & 1) return i;
+	}
+	return 0;
+}
+
+static int off_t_presentable(loff_t) __attribute((const));
+static __inline__ int off_t_presentable(loff_t loff)
+{
+	return ((unsigned long long)loff < LONG_MAX);
+}
+
 #include <linux/pipe_fs_i.h>
 #include <linux/minix_fs_i.h>
 #include <linux/ext2_fs_i.h>
@@ -310,7 +329,7 @@
 	umode_t		ia_mode;
 	uid_t		ia_uid;
 	gid_t		ia_gid;
-	off_t		ia_size;
+	loff_t		ia_size;
 	time_t		ia_atime;
 	time_t		ia_mtime;
 	time_t		ia_ctime;
@@ -345,7 +364,7 @@
 	uid_t			i_uid;
 	gid_t			i_gid;
 	kdev_t			i_rdev;
-	off_t			i_size;
+	loff_t			i_size;
 	time_t			i_atime;
 	time_t			i_mtime;
 	time_t			i_ctime;
@@ -422,7 +441,7 @@
 	mode_t			f_mode;
 	loff_t			f_pos;
 	unsigned int 		f_count, f_flags;
-	unsigned long 		f_reada, f_ramax, f_raend, f_ralen, f_rawin;
+	loff_t			f_reada, f_ramax, f_raend, f_ralen, f_rawin;
 	struct fown_struct	f_owner;
 	unsigned int		f_uid, f_gid;
 	int			f_error;
@@ -462,8 +481,8 @@
 	struct file *fl_file;
 	unsigned char fl_flags;
 	unsigned char fl_type;
-	off_t fl_start;
-	off_t fl_end;
+	loff_t fl_start;
+	loff_t fl_end;
 
 	void (*fl_notify)(struct file_lock *);	/* unblock callback */
 
@@ -479,6 +498,9 @@
 extern int fcntl_getlk(unsigned int fd, struct flock *l);
 extern int fcntl_setlk(unsigned int fd, unsigned int cmd, struct flock *l);
 
+extern int fcntl_getlk64(unsigned int fd, struct flock64 *l);
+extern int fcntl_setlk64(unsigned int fd, unsigned int cmd, struct flock64 *l);
+
 /* fs/locks.c */
 extern void locks_remove_posix(struct file *, fl_owner_t id);
 extern void locks_remove_flock(struct file *);
@@ -700,7 +722,7 @@
 
 asmlinkage int sys_open(const char *, int, int);
 asmlinkage int sys_close(unsigned int);		/* yes, it's really unsigned */
-extern int do_truncate(struct dentry *, unsigned long);
+extern int do_truncate(struct dentry *, loff_t);
 extern int get_unused_fd(void);
 extern void put_unused_fd(unsigned int);
 
--- linux-2.2.16-clean/include/linux/mm.h	Wed May  3 20:16:52 2000
+++ linux-2.2.16-lfs/include/linux/mm.h	Tue Jul 11 16:46:01 2000
@@ -54,7 +54,7 @@
 	struct vm_area_struct **vm_pprev_share;
 
 	struct vm_operations_struct * vm_ops;
-	unsigned long vm_offset;
+	loff_t vm_offset;
 	struct file * vm_file;
 	unsigned long vm_pte;			/* shared mem */
 };
@@ -106,9 +106,11 @@
 	unsigned long (*wppage)(struct vm_area_struct * area, unsigned long address,
 		unsigned long page);
 	int (*swapout)(struct vm_area_struct *, struct page *);
-	pte_t (*swapin)(struct vm_area_struct *, unsigned long, unsigned long);
+	pte_t (*swapin)(struct vm_area_struct *, loff_t, unsigned long);
 };
 
+#define PAGE_MASK_loff ((loff_t)(long)(PAGE_MASK))
+
 /*
  * Try to keep the most commonly accessed fields in single cache lines
  * here (16 bytes or greater).  This ordering should be particularly
@@ -122,7 +124,7 @@
 	struct page *next;
 	struct page *prev;
 	struct inode *inode;
-	unsigned long offset;
+	loff_t offset;
 	struct page *next_hash;
 	atomic_t count;
 	unsigned long flags;	/* atomic flags, some possibly updated asynchronously */
@@ -291,7 +293,7 @@
 extern int remap_page_range(unsigned long from, unsigned long to, unsigned long size, pgprot_t prot);
 extern int zeromap_page_range(unsigned long from, unsigned long size, pgprot_t prot);
 
-extern void vmtruncate(struct inode * inode, unsigned long offset);
+extern void vmtruncate(struct inode * inode, loff_t offset);
 extern int handle_mm_fault(struct task_struct *tsk,struct vm_area_struct *vma, unsigned long address, int write_access);
 extern int make_pages_present(unsigned long addr, unsigned long end);
 
@@ -312,15 +314,15 @@
 extern unsigned long get_unmapped_area(unsigned long, unsigned long);
 
 extern unsigned long do_mmap(struct file *, unsigned long, unsigned long,
-	unsigned long, unsigned long, unsigned long);
+			     unsigned long, unsigned long, loff_t);
 extern int do_munmap(unsigned long, size_t);
 
 /* filemap.c */
 extern void remove_inode_page(struct page *);
 extern unsigned long page_unuse(struct page *);
 extern int shrink_mmap(int, int);
-extern void truncate_inode_pages(struct inode *, unsigned long);
-extern unsigned long get_cached_page(struct inode *, unsigned long, int);
+extern void truncate_inode_pages(struct inode *, loff_t);
+extern unsigned long get_cached_page(struct inode *, loff_t, int);
 extern void put_cached_page(unsigned long);
 
 /*
--- linux-2.2.16-clean/include/linux/types.h	Mon Dec 28 01:18:28 1998
+++ linux-2.2.16-lfs/include/linux/types.h	Tue Jul 11 16:08:55 2000
@@ -9,9 +9,11 @@
 typedef __kernel_fd_set		fd_set;
 typedef __kernel_dev_t		dev_t;
 typedef __kernel_ino_t		ino_t;
+typedef __kernel_ino64_t	ino64_t;
 typedef __kernel_mode_t		mode_t;
 typedef __kernel_nlink_t	nlink_t;
 typedef __kernel_off_t		off_t;
+typedef __kernel_off64_t	off64_t;
 typedef __kernel_pid_t		pid_t;
 typedef __kernel_uid_t		uid_t;
 typedef __kernel_gid_t		gid_t;
--- linux-2.2.16-clean/include/linux/resource.h	Mon Dec 28 01:18:28 1998
+++ linux-2.2.16-lfs/include/linux/resource.h	Tue Jul 11 16:08:55 2000
@@ -38,11 +38,24 @@
 };
 
 #define RLIM_INFINITY	((long)(~0UL>>1))
+#define RLIM_SAVED_MAX  ((long)(~0UL>>1)-1L)
+#define RLIM_SAVED_CUR	((long)(~0UL>>1)-2L)
+
+#define RLIM64_INFINITY	((long long)(~0ULL>>1))
+#define RLIM64_SAVED_MAX RLIM64_INFINITY
+#define RLIM64_SAVED_CUR RLIM64_INFINITY
 
 struct rlimit {
 	long	rlim_cur;
 	long	rlim_max;
 };
+
+struct rlimit64 {
+	__u64	rlim_cur;
+	__u64	rlim_max;
+};
+
+#define INIT_RLIMFSZ   { RLIM64_INFINITY, RLIM64_INFINITY }
 
 #define	PRIO_MIN	(-20)
 #define	PRIO_MAX	20
--- linux-2.2.16-clean/include/linux/nfs.h	Sat Mar  6 17:21:13 1999
+++ linux-2.2.16-lfs/include/linux/nfs.h	Tue Jul 11 15:23:29 2000
@@ -111,7 +111,7 @@
 	__u32			nlink;
 	__u32			uid;
 	__u32			gid;
-	__u32			size;
+	__u64			size;
 	__u32			blocksize;
 	__u32			rdev;
 	__u32			blocks;
@@ -126,7 +126,7 @@
 	__u32			mode;
 	__u32			uid;
 	__u32			gid;
-	__u32			size;
+	__u64			size;
 	struct nfs_time		atime;
 	struct nfs_time		mtime;
 };
@@ -141,7 +141,7 @@
 
 struct nfs_writeargs {
 	struct nfs_fh *		fh;
-	__u32			offset;
+	__u64			offset;
 	__u32			count;
 	const void *		buffer;
 };
@@ -160,7 +160,7 @@
 
 struct nfs_readargs {
 	struct nfs_fh *		fh;
-	__u32			offset;
+	__u64			offset;
 	__u32			count;
 	void *			buffer;
 };
--- linux-2.2.16-clean/include/linux/nfs_fs.h	Tue May 11 13:35:46 1999
+++ linux-2.2.16-lfs/include/linux/nfs_fs.h	Tue Jul 11 16:46:14 2000
@@ -143,10 +143,10 @@
 			void **p0, char **string, unsigned int *len,
 			unsigned int maxlen);
 extern int nfs_proc_read(struct nfs_server *server, struct nfs_fh *fhandle,
-			int swap, unsigned long offset, unsigned int count,
+			int swap, loff_t offset, unsigned int count,
 			void *buffer, struct nfs_fattr *fattr);
 extern int nfs_proc_write(struct nfs_server *server, struct nfs_fh *fhandle,
-			int swap, unsigned long offset, unsigned int count,
+			int swap, loff_t offset, unsigned int count,
 			const void *buffer, struct nfs_fattr *fattr);
 extern int nfs_proc_create(struct nfs_server *server, struct nfs_fh *dir,
 			const char *name, struct nfs_sattr *sattr,
--- linux-2.2.16-clean/include/linux/swap.h	Tue Jan  4 13:12:25 2000
+++ linux-2.2.16-lfs/include/linux/swap.h	Tue Jul 11 16:08:57 2000
@@ -114,7 +114,7 @@
 extern unsigned int nr_swapfiles;
 extern struct swap_info_struct swap_info[];
 void si_swapinfo(struct sysinfo *);
-unsigned long get_swap_page(void);
+extern unsigned long  get_swap_page(void);
 extern void FASTCALL(swap_free(unsigned long));
 struct swap_list_t {
 	int head;	/* head of priority-ordered swapfile list */
--- linux-2.2.16-clean/include/linux/pagemap.h	Tue Jan  4 13:12:25 2000
+++ linux-2.2.16-lfs/include/linux/pagemap.h	Tue Jul 11 16:46:01 2000
@@ -28,6 +28,7 @@
 #define PAGE_CACHE_SHIFT	PAGE_SHIFT
 #define PAGE_CACHE_SIZE		PAGE_SIZE
 #define PAGE_CACHE_MASK		PAGE_MASK
+#define PAGE_CACHE_MASK_loff	PAGE_MASK_loff
 
 #define page_cache_alloc()	__get_free_page(GFP_USER)
 #define page_cache_free(x)	free_page(x)
@@ -54,7 +55,7 @@
  * inode pointer and offsets are distributed (ie, we
  * roughly know which bits are "significant")
  */
-static inline unsigned long _page_hashfn(struct inode * inode, unsigned long offset)
+static inline unsigned long _page_hashfn(struct inode * inode, loff_t offset)
 {
 #define i (((unsigned long) inode)/(sizeof(struct inode) & ~ (sizeof(struct inode) - 1)))
 #define o ((offset >> PAGE_SHIFT) + (offset & ~PAGE_MASK))
@@ -63,9 +64,9 @@
 #undef o
 }
 
-#define page_hash(inode,offset) (page_hash_table+_page_hashfn(inode,offset))
+#define page_hash(inode,poffset) (page_hash_table+_page_hashfn(inode,poffset))
 
-static inline struct page * __find_page(struct inode * inode, unsigned long offset, struct page *page)
+static inline struct page * __find_page(struct inode * inode, loff_t offset, struct page *page)
 {
 	goto inside;
 	for (;;) {
@@ -85,9 +86,9 @@
 	return page;
 }
 
-static inline struct page *find_page(struct inode * inode, unsigned long offset)
+static inline struct page *find_page(struct inode * inode, loff_t poffset)
 {
-	return __find_page(inode, offset, *page_hash(inode, offset));
+	return __find_page(inode, poffset, *page_hash(inode, poffset));
 }
 
 static inline void remove_page_from_hash_queue(struct page * page)
@@ -110,9 +111,9 @@
 	page->pprev_hash = p;
 }
 
-static inline void add_page_to_hash_queue(struct page * page, struct inode * inode, unsigned long offset)
+static inline void add_page_to_hash_queue(struct page * page, struct inode * inode, loff_t poffset)
 {
-	__add_page_to_hash_queue(page, page_hash(inode,offset));
+	__add_page_to_hash_queue(page, page_hash(inode,poffset));
 }
 
 static inline void remove_page_from_inode_queue(struct page * page)
@@ -150,7 +151,7 @@
 		__wait_on_page(page);
 }
 
-extern void update_vm_cache_conditional(struct inode *, unsigned long, const char *, int, unsigned long);
-extern void update_vm_cache(struct inode *, unsigned long, const char *, int);
+extern void update_vm_cache_conditional(struct inode *, loff_t, const char *, int, unsigned long);
+extern void update_vm_cache(struct inode *, loff_t, const char *, int);
 
 #endif
--- linux-2.2.16-clean/include/asm-i386/unistd.h	Wed Jan 20 14:06:24 1999
+++ linux-2.2.16-lfs/include/asm-i386/unistd.h	Tue Jul 11 15:42:01 2000
@@ -195,6 +195,15 @@
 #define __NR_getpmsg		188	/* some people actually want streams */
 #define __NR_putpmsg		189	/* some people actually want streams */
 #define __NR_vfork		190
+#define __NR_mmap2		192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_setrlimit64	231
+#define __NR_getrlimit64	232
+#define __NR_mmap64		233
 
 /* user-visible error numbers are in the range -1 - -122: see <asm-i386/errno.h> */
 
--- linux-2.2.16-clean/include/asm-i386/fcntl.h	Wed Oct 21 13:02:48 1998
+++ linux-2.2.16-lfs/include/asm-i386/fcntl.h	Tue Jul 11 15:23:29 2000
@@ -35,6 +35,10 @@
 #define F_SETSIG	10	/*  for sockets. */
 #define F_GETSIG	11	/*  for sockets. */
 
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
 /* for F_[GET|SET]FL */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
@@ -60,6 +64,14 @@
 	off_t l_start;
 	off_t l_len;
 	pid_t l_pid;
+};
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	pid_t  l_pid;
 };
 
 #endif
--- linux-2.2.16-clean/include/asm-i386/stat.h	Mon Sep 30 10:42:31 1996
+++ linux-2.2.16-lfs/include/asm-i386/stat.h	Tue Jul 11 16:44:36 2000
@@ -38,4 +38,40 @@
 	unsigned long  __unused5;
 };
 
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+        unsigned short  st_dev;
+        unsigned char   __pad0[10];
+
+        unsigned long   st_ino;
+        unsigned int    st_mode;
+        unsigned int    st_nlink;
+
+        unsigned long   st_uid;
+        unsigned long   st_gid;
+
+        unsigned short  st_rdev;
+        unsigned char   __pad3[10];
+
+        long long       st_size;
+        unsigned long   st_blksize;
+
+        unsigned long   st_blocks;      /* Number 512-byte blocks allocated. */
+        unsigned long   __pad4;         /* future possible st_blocks high bits */
+
+        unsigned long   st_atime;
+        unsigned long   __pad5;
+
+        unsigned long   st_mtime;
+        unsigned long   __pad6;
+
+        unsigned long   st_ctime;
+        unsigned long   __pad7;         /* will be high 32 bits of ctime someday */
+
+        unsigned long   __unused1;
+        unsigned long   __unused2;
+};
 #endif
+
--- linux-2.2.16-clean/include/asm-i386/posix_types.h	Sun Dec 27 13:39:50 1998
+++ linux-2.2.16-lfs/include/asm-i386/posix_types.h	Tue Jul 11 15:23:29 2000
@@ -9,9 +9,11 @@
 
 typedef unsigned short	__kernel_dev_t;
 typedef unsigned long	__kernel_ino_t;
+typedef unsigned long long __kernel_ino64_t;
 typedef unsigned short	__kernel_mode_t;
 typedef unsigned short	__kernel_nlink_t;
 typedef long		__kernel_off_t;
+typedef long long	__kernel_off64_t;
 typedef int		__kernel_pid_t;
 typedef unsigned short	__kernel_ipc_pid_t;
 typedef unsigned short	__kernel_uid_t;
--- linux-2.2.16-clean/include/asm-mips/unistd.h	Mon Aug  9 15:04:41 1999
+++ linux-2.2.16-lfs/include/asm-mips/unistd.h	Tue Jul 11 15:23:29 2000
@@ -1196,6 +1196,21 @@
 #define __NR_sendfile			(__NR_Linux + 207)
 #define __NR_getpmsg			(__NR_Linux + 208)
 #define __NR_putpmsg			(__NR_Linux + 209)
+#define __NR_mmap64			(__NR_Linux + 210)
+#define __NR_setrlimit64		(__NR_Linux + 211)
+#define __NR_getrlimit64		(__NR_Linux + 212)
+#define __NR_truncate64			(__NR_Linux + 213)
+#define __NR_ftruncate64		(__NR_Linux + 214)
+#define __NR_stat64			(__NR_Linux + 215)
+#define __NR_lstat64			(__NR_Linux + 216)
+#define __NR_fstat64			(__NR_Linux + 217)
+#define __NR_statfs64			(__NR_Linux + 218)
+#define __NR_fstatfs64			(__NR_Linux + 219)
+#define __NR_getdents64			(__NR_Linux + 220)
+#define __NR_sysconf			(__NR_Linux + 221)
+#define __NR_pathconf			(__NR_Linux + 222)
+#define __NR_fpathconf			(__NR_Linux + 223)
+
 
 /*
  * Offset of the last Linux flavoured syscall
--- linux-2.2.16-clean/include/asm-mips/fcntl.h	Mon Aug  9 15:04:41 1999
+++ linux-2.2.16-lfs/include/asm-mips/fcntl.h	Tue Jul 11 15:23:29 2000
@@ -44,6 +44,10 @@
 #define F_SETSIG	10	/*  for sockets. */
 #define F_GETSIG	11	/*  for sockets. */
 
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
 /* for F_[GET|SET]FL */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
@@ -72,5 +76,15 @@
 	__kernel_pid_t l_pid;
 	long  pad[4];			/* ZZZZZZZZZZZZZZZZZZZZZZZZZZ */
 } flock_t;
+
+typedef struct flock64 {
+	short l_type;
+	short l_whence;
+	__kernel_loff_t l_start;
+	__kernel_loff_t l_len;
+	long  l_sysid;			/* XXXXXXXXXXXXXXXXXXXXXXXXX */
+	__kernel_pid_t l_pid;
+	long  pad[4];			/* ZZZZZZZZZZZZZZZZZZZZZZZZZZ */
+} flock64_t;
 
 #endif /* __ASM_MIPS_FCNTL_H */
--- linux-2.2.16-clean/include/asm-mips/posix_types.h	Mon Aug  9 15:04:41 1999
+++ linux-2.2.16-lfs/include/asm-mips/posix_types.h	Tue Jul 11 15:23:29 2000
@@ -21,9 +21,11 @@
 
 typedef unsigned long	__kernel_dev_t;
 typedef unsigned long	__kernel_ino_t;
+typedef unsigned long long __kernel_ino64_t;
 typedef unsigned long	__kernel_mode_t;
 typedef unsigned long	__kernel_nlink_t;
 typedef long		__kernel_off_t;
+typedef long long	__kernel_off64_t;
 typedef long		__kernel_pid_t;
 typedef long		__kernel_ipc_pid_t;
 typedef long		__kernel_uid_t;
--- linux-2.2.16-clean/include/asm-alpha/posix_types.h	Fri Aug 21 09:33:36 1998
+++ linux-2.2.16-lfs/include/asm-alpha/posix_types.h	Tue Jul 11 15:23:29 2000
@@ -9,9 +9,11 @@
 
 typedef unsigned int	__kernel_dev_t;
 typedef unsigned int	__kernel_ino_t;
+typedef unsigned long	__kernel_ino64_t;
 typedef unsigned int	__kernel_mode_t;
 typedef unsigned int	__kernel_nlink_t;
 typedef long		__kernel_off_t;
+typedef long		__kernel_off64_t;
 typedef int		__kernel_pid_t;
 typedef int		__kernel_ipc_pid_t;
 typedef unsigned int	__kernel_uid_t;
--- linux-2.2.16-clean/include/asm-m68k/unistd.h	Tue Jan 19 13:58:34 1999
+++ linux-2.2.16-lfs/include/asm-m68k/unistd.h	Tue Jul 11 15:23:29 2000
@@ -194,6 +194,20 @@
 #define __NR_getpmsg		188	/* some people actually want streams */
 #define __NR_putpmsg		189	/* some people actually want streams */
 #define __NR_vfork		190
+#define __NR_setrlimit64	191
+#define __NR_getrlimit64	192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_statfs64		198
+#define __NR_fstatfs64		199
+#define __NR_getdents64		200
+#define __NR_mmap64		201
+#define __NR_sysconf		202
+#define __NR_pathconf		203
+#define __NR_fpathconf		204
 
 /* user-visible error numbers are in the range -1 - -122: see
    <asm-m68k/errno.h> */
--- linux-2.2.16-clean/include/asm-m68k/fcntl.h	Wed Oct 21 16:30:56 1998
+++ linux-2.2.16-lfs/include/asm-m68k/fcntl.h	Tue Jul 11 15:23:29 2000
@@ -18,6 +18,7 @@
 #define FASYNC		020000	/* fcntl, for BSD compatibility */
 #define O_DIRECTORY	040000	/* must be a directory */
 #define O_NOFOLLOW	0100000	/* don't follow links */
+#define O_LARGEFILE	0200000 /* file sizes exceeding 32-bit signed value */
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get f_flags */
@@ -33,6 +34,10 @@
 #define F_SETSIG	10	/*  for sockets. */
 #define F_GETSIG	11	/*  for sockets. */
 
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
 /* for F_[GET|SET]FL */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
@@ -58,6 +63,14 @@
 	off_t l_start;
 	off_t l_len;
 	pid_t l_pid;
+};
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	pid_t  l_pid;
 };
 
 #endif /* _M68K_FCNTL_H */
--- linux-2.2.16-clean/include/asm-m68k/posix_types.h	Mon Aug 10 14:02:24 1998
+++ linux-2.2.16-lfs/include/asm-m68k/posix_types.h	Tue Jul 11 15:23:29 2000
@@ -9,9 +9,11 @@
 
 typedef unsigned short	__kernel_dev_t;
 typedef unsigned long	__kernel_ino_t;
+typedef unsigned long long __kernel_ino64_t;
 typedef unsigned short	__kernel_mode_t;
 typedef unsigned short	__kernel_nlink_t;
 typedef long		__kernel_off_t;
+typedef long long	__kernel_off64_t;
 typedef int		__kernel_pid_t;
 typedef unsigned short	__kernel_ipc_pid_t;
 typedef unsigned short	__kernel_uid_t;
--- linux-2.2.16-clean/include/asm-sparc/fcntl.h	Tue Oct 27 12:52:21 1998
+++ linux-2.2.16-lfs/include/asm-sparc/fcntl.h	Tue Jul 11 15:23:29 2000
@@ -19,6 +19,7 @@
 #define O_NOCTTY	0x8000	/* not fcntl */
 #define O_DIRECTORY	0x10000	/* must be a directory */
 #define O_NOFOLLOW	0x20000	/* don't follow links */
+#define O_LARGEFILE	0x40000 /* file sizes exceeding 'off_t' range (2G) */
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get f_flags */
@@ -33,6 +34,10 @@
 #define F_SETSIG	10	/*  for sockets. */
 #define F_GETSIG	11	/*  for sockets. */
 
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
 /* for F_[GET|SET]FL */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
@@ -59,6 +64,14 @@
 	off_t l_len;
 	pid_t l_pid;
 	short __unused;
+};
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	pid_t  l_pid;
 };
 
 #endif
--- linux-2.2.16-clean/include/asm-sparc/posix_types.h	Wed Mar 10 19:53:37 1999
+++ linux-2.2.16-lfs/include/asm-sparc/posix_types.h	Tue Jul 11 15:23:29 2000
@@ -25,11 +25,13 @@
 typedef unsigned short         __kernel_gid_t;
 typedef unsigned short         __kernel_dev_t;
 typedef unsigned long          __kernel_ino_t;
+typedef unsigned long long     __kernel_ino64_t;
 typedef unsigned short         __kernel_mode_t;
 typedef unsigned short         __kernel_umode_t;
 typedef short                  __kernel_nlink_t;
 typedef long                   __kernel_daddr_t;
 typedef long                   __kernel_off_t;
+typedef long long              __kernel_off64_t;
 typedef char *                 __kernel_caddr_t;
 
 #ifdef __GNUC__
--- linux-2.2.16-clean/include/asm-ppc/fcntl.h	Wed Oct 21 16:31:06 1998
+++ linux-2.2.16-lfs/include/asm-ppc/fcntl.h	Tue Jul 11 15:23:29 2000
@@ -18,6 +18,7 @@
 #define FASYNC		020000	/* fcntl, for BSD compatibility */
 #define O_DIRECTORY	040000	/* must be a directory */
 #define O_NOFOLLOW	0100000	/* don't follow links */
+#define O_LARGEFILE	0200000 /* file sizes exceeding 'off_t' */
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get f_flags */
@@ -33,6 +34,10 @@
 #define F_SETSIG	10	/*  for sockets. */
 #define F_GETSIG	11	/*  for sockets. */
 
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
 /* for F_[GET|SET]FL */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
@@ -64,6 +69,14 @@
 	off_t l_start;
 	off_t l_len;
 	pid_t l_pid;
+};
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	pid_t  l_pid;
 };
 
 #endif
--- linux-2.2.16-clean/include/asm-ppc/unistd.h	Mon Aug  9 15:04:57 1999
+++ linux-2.2.16-lfs/include/asm-ppc/unistd.h	Tue Jul 11 15:23:29 2000
@@ -194,6 +194,20 @@
 #define __NR_getpmsg		187	/* some people actually want streams */
 #define __NR_putpmsg		188	/* some people actually want streams */
 #define __NR_vfork		189
+#define __NR_mmap64		190	/* LFS stuff */
+#define __NR_setrlimit64	191
+#define __NR_getrlimit64	192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_statfs64		198
+#define __NR_fstatfs64		199
+#define __NR_getdents64		200
+#define __NR_sysconf		201
+#define __NR_pathconf		202
+#define __NR_fpathconf		203
 
 #define __NR(n)	#n
 
--- linux-2.2.16-clean/include/asm-ppc/posix_types.h	Thu Apr 29 15:39:01 1999
+++ linux-2.2.16-lfs/include/asm-ppc/posix_types.h	Tue Jul 11 15:23:29 2000
@@ -9,9 +9,11 @@
 
 typedef unsigned int	__kernel_dev_t;
 typedef unsigned int	__kernel_ino_t;
+typedef unsigned long long __kernel_ino64_t;
 typedef unsigned int	__kernel_mode_t;
 typedef unsigned short	__kernel_nlink_t;
 typedef long		__kernel_off_t;
+typedef long long	__kernel_off64_t;
 typedef int		__kernel_pid_t;
 typedef unsigned int	__kernel_uid_t;
 typedef unsigned int	__kernel_gid_t;
--- linux-2.2.16-clean/include/asm-sparc64/fcntl.h	Tue Oct 27 12:52:21 1998
+++ linux-2.2.16-lfs/include/asm-sparc64/fcntl.h	Tue Jul 11 15:23:29 2000
@@ -19,6 +19,7 @@
 #define O_NOCTTY	0x8000	/* not fcntl */
 #define O_DIRECTORY	0x10000	/* must be a directory */
 #define O_NOFOLLOW	0x20000	/* don't follow links */
+#define O_LARGEFILE	0x40000 /* file sizes exceeding 'off_t' range (2G) */
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get f_flags */
@@ -33,6 +34,10 @@
 #define F_SETSIG	10	/*  for sockets. */
 #define F_GETSIG	11	/*  for sockets. */
 
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
 /* for F_[GET|SET]FL */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
@@ -71,5 +76,13 @@
 	short __unused;
 };
 #endif
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	__kernel_pid_t32 l_pid;
+};
 
 #endif /* !(_SPARC64_FCNTL_H) */
--- linux-2.2.16-clean/include/asm-sparc64/posix_types.h	Wed Mar 10 19:53:38 1999
+++ linux-2.2.16-lfs/include/asm-sparc64/posix_types.h	Tue Jul 11 15:23:29 2000
@@ -23,11 +23,13 @@
 typedef unsigned int           __kernel_gid_t;
 typedef unsigned int           __kernel_dev_t;
 typedef unsigned long          __kernel_ino_t;
+typedef unsigned long          __kernel_ino64_t;
 typedef unsigned int           __kernel_mode_t;
 typedef unsigned short         __kernel_umode_t;
 typedef unsigned int           __kernel_nlink_t;
 typedef int                    __kernel_daddr_t;
 typedef long                   __kernel_off_t;
+typedef long                   __kernel_off64_t;
 typedef char *                 __kernel_caddr_t;
 
 /* Note this piece of asymmetry from the v9 ABI.  */
--- linux-2.2.16-clean/include/asm-arm/unistd.h	Sat May  8 14:06:58 1999
+++ linux-2.2.16-lfs/include/asm-arm/unistd.h	Tue Jul 11 15:23:29 2000
@@ -198,6 +198,20 @@
 					/* 188 reserved */
 					/* 189 reserved */
 #define __NR_vfork			(__NR_SYSCALL_BASE+190)
+#define __NR_mmap64			(__NR_SYSCALL_BASE+191)
+#define __NR_setrlimit64		(__NR_SYSCALL_BASE+192)
+#define __NR_getrlimit64		(__NR_SYSCALL_BASE+193)
+#define __NR_truncate64			(__NR_SYSCALL_BASE+194)
+#define __NR_ftruncate64		(__NR_SYSCALL_BASE+195)
+#define __NR_stat64			(__NR_SYSCALL_BASE+196)
+#define __NR_lstat64			(__NR_SYSCALL_BASE+197)
+#define __NR_fstat64			(__NR_SYSCALL_BASE+200)
+#define __NR_getdents64			(__NR_SYSCALL_BASE+198)
+#define __NR_statfs64			(__NR_SYSCALL_BASE+199)
+#define __NR_fstatfs64			(__NR_SYSCALL_BASE+201)
+#define __NR_sysconf			(__NR_SYSCALL_BASE+202)
+#define __NR_pathconf			(__NR_SYSCALL_BASE+203)
+#define __NR_fpathconf			(__NR_SYSCALL_BASE+204)
 
 #define __sys2(x) #x
 #define __sys1(x) __sys2(x)
--- linux-2.2.16-clean/include/asm-arm/fcntl.h	Wed Oct 21 16:30:46 1998
+++ linux-2.2.16-lfs/include/asm-arm/fcntl.h	Tue Jul 11 15:23:29 2000
@@ -18,6 +18,7 @@
 #define FASYNC		020000	/* fcntl, for BSD compatibility */
 #define O_DIRECTORY	040000	/* must be a directory */
 #define O_NOFOLLOW	0100000	/* don't follow links */
+#define O_LARGEFILE	0200000 /* file sizes exceeding 32-bit signed value */
 
 #define F_DUPFD		0	/* dup */
 #define F_GETFD		1	/* get f_flags */
@@ -33,6 +34,10 @@
 #define F_SETSIG	10	/*  for sockets. */
 #define F_GETSIG	11	/*  for sockets. */
 
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
 /* for F_[GET|SET]FL */
 #define FD_CLOEXEC	1	/* actually anything with low bit set goes */
 
@@ -58,6 +63,14 @@
 	off_t l_start;
 	off_t l_len;
 	pid_t l_pid;
+};
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	pid_t  l_pid;
 };
 
 #endif
--- linux-2.2.16-clean/include/asm-arm/posix_types.h	Sat May  8 14:06:57 1999
+++ linux-2.2.16-lfs/include/asm-arm/posix_types.h	Tue Jul 11 15:23:29 2000
@@ -17,9 +17,11 @@
 
 typedef unsigned short		__kernel_dev_t;
 typedef unsigned long		__kernel_ino_t;
+typedef unsigned long long	__kernel_ino64_t;
 typedef unsigned short		__kernel_mode_t;
 typedef unsigned short		__kernel_nlink_t;
 typedef long			__kernel_off_t;
+typedef long long		__kernel_off64_t;
 typedef int			__kernel_pid_t;
 typedef unsigned short		__kernel_ipc_pid_t;
 typedef unsigned short		__kernel_uid_t;
--- linux-2.2.16-clean/arch/i386/lib/Makefile	Sun Dec 27 13:33:13 1998
+++ linux-2.2.16-lfs/arch/i386/lib/Makefile	Tue Jul 11 15:23:29 2000
@@ -7,6 +7,6 @@
 
 L_TARGET = lib.a
 L_OBJS  = checksum.o old-checksum.o semaphore.o delay.o \
-	usercopy.o getuser.o putuser.o
+	usercopy.o getuser.o putuser.o longlong.o
 
 include $(TOPDIR)/Rules.make
--- linux-2.2.16-clean/arch/i386/lib/longlong.c	Fri Jul 14 03:02:03 2000
+++ linux-2.2.16-lfs/arch/i386/lib/longlong.c	Tue Jul 11 15:23:29 2000
@@ -0,0 +1,335 @@
+/* These routines allow division on long long int's.  These routines
+ * are taken from egcs 1.1.2's libgcc.a.  (They are boiled down a bit
+ * to the x86 specific case.)  References to these functions are
+ * automagically generated by gcc. */
+
+/* More subroutines needed by GCC output code on some machines.  */
+/* Compile this one with gcc.  */
+/* Copyright (C) 1989, 92-97, 1998 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with other files,
+   some of which are compiled with GCC, to produce an executable,
+   this library does not by itself cause the resulting executable
+   to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+#define SI_TYPE_SIZE 32
+
+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \
+  __asm__ ("subl %5,%1
+        sbbl %3,%0"                                                     \
+           : "=r" ((USItype) (sh)),                                     \
+             "=&r" ((USItype) (sl))                                     \
+           : "0" ((USItype) (ah)),                                      \
+             "g" ((USItype) (bh)),                                      \
+             "1" ((USItype) (al)),                                      \
+             "g" ((USItype) (bl)))
+#define umul_ppmm(w1, w0, u, v) \
+  __asm__ ("mull %3"                                                    \
+           : "=a" ((USItype) (w0)),                                     \
+             "=d" ((USItype) (w1))                                      \
+           : "%0" ((USItype) (u)),                                      \
+             "rm" ((USItype) (v)))
+#define udiv_qrnnd(q, r, n1, n0, d) \
+  __asm__ ("divl %4"                                                    \
+           : "=a" ((USItype) (q)),                                      \
+             "=d" ((USItype) (r))                                       \
+           : "0" ((USItype) (n0)),                                      \
+             "1" ((USItype) (n1)),                                      \
+             "rm" ((USItype) (d)))
+#define count_leading_zeros(count, x) \
+  do {                                                                  \
+    USItype __cbtmp;                                                    \
+    __asm__ ("bsrl %1,%0"                                               \
+             : "=r" (__cbtmp) : "rm" ((USItype) (x)));                  \
+    (count) = __cbtmp ^ 31;                                             \
+  } while (0)
+
+typedef int HItype __attribute__ ((mode (HI)));
+typedef int SItype __attribute__ ((mode (SI)));
+typedef int DItype __attribute__ ((mode (DI)));
+typedef unsigned int UHItype __attribute__ ((mode (HI)));
+typedef unsigned int USItype __attribute__ ((mode (SI)));
+typedef unsigned int UDItype __attribute__ ((mode (DI)));
+typedef unsigned int UQItype __attribute__ ((mode (QI)));
+typedef int word_type __attribute__ ((mode (__word__)));
+
+struct DIstruct {SItype low, high;};
+typedef union
+{
+  struct DIstruct s;
+  DItype ll;
+} DIunion;
+
+static inline
+DItype
+__negdi2 (DItype u)
+{
+  DIunion w;
+  DIunion uu;
+	
+  uu.ll = u;
+	
+  w.s.low = -uu.s.low;
+  w.s.high = -uu.s.high - ((USItype) w.s.low > 0);
+  
+  return w.ll;
+}
+
+static inline
+UDItype
+__udivmoddi4 (UDItype n, UDItype d, UDItype *rp)
+{
+  DIunion ww;
+  DIunion nn, dd;
+  DIunion rr;
+  USItype d0, d1, n0, n1, n2;
+  USItype q0, q1;
+  USItype b, bm;
+
+  nn.ll = n;
+  dd.ll = d;
+
+  d0 = dd.s.low;
+  d1 = dd.s.high;
+  n0 = nn.s.low;
+  n1 = nn.s.high;
+
+  if (d1 == 0)
+    {
+      if (d0 > n1)
+	{
+	  /* 0q = nn / 0D */
+
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+	  q1 = 0;
+
+	  /* Remainder in n0.  */
+	}
+      else
+	{
+	  /* qq = NN / 0d */
+
+	  if (d0 == 0)
+	    d0 = 1 / d0;        /* Divide intentionally by zero.  */
+
+	  udiv_qrnnd (q1, n1, 0, n1, d0);
+	  udiv_qrnnd (q0, n0, n1, n0, d0);
+
+	  /* Remainder in n0.  */
+	}
+
+      if (rp != 0)
+	{
+	  rr.s.low = n0;
+	  rr.s.high = 0;
+	  *rp = rr.ll;
+	}
+    }
+  else
+    {
+      if (d1 > n1)
+	{
+	  /* 00 = nn / DD */
+
+	  q0 = 0;
+	  q1 = 0;
+
+	  /* Remainder in n1n0.  */
+	  if (rp != 0)
+	    {
+	      rr.s.low = n0;
+	      rr.s.high = n1;
+	      *rp = rr.ll;
+	    }
+	}
+      else
+	{
+	  /* 0q = NN / dd */
+
+	  count_leading_zeros (bm, d1);
+	  if (bm == 0)
+	    {
+	      /* From (n1 >= d1) /\ (the most significant bit of d1 is set),
+		 conclude (the most significant bit of n1 is set) /\ (the
+		 quotient digit q0 = 0 or 1).
+
+		 This special case is necessary, not an optimization.  */
+
+	      /* The condition on the next line takes advantage of that
+		 n1 >= d1 (true due to program flow).  */
+	      if (n1 > d1 || n0 >= d0)
+		{
+		  q0 = 1;
+		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
+		}
+	      else
+		q0 = 0;
+
+	      q1 = 0;
+
+	      if (rp != 0)
+		{
+		  rr.s.low = n0;
+		  rr.s.high = n1;
+		  *rp = rr.ll;
+		}
+	    }
+	  else
+	    {
+	      USItype m1, m0;
+	      /* Normalize.  */
+
+	      b = SI_TYPE_SIZE - bm;
+
+	      d1 = (d1 << bm) | (d0 >> b);
+	      d0 = d0 << bm;
+	      n2 = n1 >> b;
+	      n1 = (n1 << bm) | (n0 >> b);
+	      n0 = n0 << bm;
+
+	      udiv_qrnnd (q0, n1, n2, n1, d1);
+	      umul_ppmm (m1, m0, q0, d0);
+
+	      if (m1 > n1 || (m1 == n1 && m0 > n0))
+		{
+		  q0--;
+		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
+		}
+
+	      q1 = 0;
+
+	      /* Remainder in (n1n0 - m1m0) >> bm.  */
+	      if (rp != 0)
+		{
+		  sub_ddmmss (n1, n0, n1, n0, m1, m0);
+		  rr.s.low = (n1 << b) | (n0 >> bm);
+		  rr.s.high = n1 >> bm;
+		  *rp = rr.ll;
+		}
+	    }
+	}
+    }
+
+  ww.s.low = q0;
+  ww.s.high = q1;
+  return ww.ll;
+}
+
+DItype
+__divdi3 (DItype u, DItype v)
+{
+  word_type c = 0;
+  DIunion uu, vv;
+  DItype w;
+
+  uu.ll = u;
+  vv.ll = v;
+
+  if (uu.s.high < 0)
+    c = ~c,
+      uu.ll = __negdi2 (uu.ll);
+  if (vv.s.high < 0)
+    c = ~c,
+      vv.ll = __negdi2 (vv.ll);
+
+  w = __udivmoddi4 (uu.ll, vv.ll, (UDItype *) 0);
+  if (c)
+    w = __negdi2 (w);
+
+  return w;
+}
+
+DItype
+__moddi3 (DItype u, DItype v)
+{
+  word_type c = 0;
+  DIunion uu, vv;
+  DItype w;
+
+  uu.ll = u;
+  vv.ll = v;
+
+  if (uu.s.high < 0)
+    c = ~c,
+    uu.ll = __negdi2 (uu.ll);
+  if (vv.s.high < 0)
+    vv.ll = __negdi2 (vv.ll);
+
+  (void) __udivmoddi4 (uu.ll, vv.ll, &w);
+  if (c)
+    w = __negdi2 (w);
+
+  return w;
+}
+
+UDItype
+__udivdi3 (UDItype n, UDItype d)
+{
+  return __udivmoddi4 (n, d, (UDItype *) 0);
+}
+
+UDItype
+__umoddi3 (UDItype u, UDItype v)
+{
+  UDItype w;
+
+  (void) __udivmoddi4 (u, v, &w);
+
+  return w;
+}
+
+word_type
+__cmpdi2 (DItype a, DItype b)
+{
+  DIunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if (au.s.high < bu.s.high)
+    return 0;
+  else if (au.s.high > bu.s.high)
+    return 2;
+  if ((USItype) au.s.low < (USItype) bu.s.low)
+    return 0;
+  else if ((USItype) au.s.low > (USItype) bu.s.low)
+    return 2;
+  return 1;
+}
+
+word_type
+__ucmpdi2 (DItype a, DItype b)
+{
+  DIunion au, bu;
+
+  au.ll = a, bu.ll = b;
+
+  if ((USItype) au.s.high < (USItype) bu.s.high)
+    return 0;
+  else if ((USItype) au.s.high > (USItype) bu.s.high)
+    return 2;
+  if ((USItype) au.s.low < (USItype) bu.s.low)
+    return 0;
+  else if ((USItype) au.s.low > (USItype) bu.s.low)
+    return 2;
+  return 1;
+}
+
--- linux-2.2.16-clean/arch/i386/kernel/entry.S	Wed May  3 20:16:31 2000
+++ linux-2.2.16-lfs/arch/i386/kernel/entry.S	Tue Jul 11 22:03:34 2000
@@ -563,7 +563,50 @@
 	.long SYMBOL_NAME(sys_sendfile)
 	.long SYMBOL_NAME(sys_ni_syscall)		/* streams1 */
 	.long SYMBOL_NAME(sys_ni_syscall)		/* streams2 */
-	.long SYMBOL_NAME(sys_vfork)            /* 190 */
+	.long SYMBOL_NAME(sys_vfork)		/* 190 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_mmap2)
+	.long SYMBOL_NAME(sys_truncate64)
+	.long SYMBOL_NAME(sys_ftruncate64)
+	.long SYMBOL_NAME(sys_stat64)		/* 195 */
+	.long SYMBOL_NAME(sys_lstat64)
+	.long SYMBOL_NAME(sys_fstat64)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 200 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 205 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 210 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 215 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 220 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 225 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.long SYMBOL_NAME(sys_ni_syscall)	/* 230 */
+	.long SYMBOL_NAME(sys_setrlimit64)
+	.long SYMBOL_NAME(sys_getrlimit64)
+	.long SYMBOL_NAME(sys_mmap64)
 
 	/*
 	 * NOTE!! This doesn't have to be exact - we just have
@@ -571,6 +614,7 @@
 	 * entries. Don't panic if you notice that this hasn't
 	 * been shrunk every time we add a new system call.
 	 */
-	.rept NR_syscalls-190
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.rept NR_syscalls - 233
 		.long SYMBOL_NAME(sys_ni_syscall)
 	.endr
--- linux-2.2.16-clean/arch/i386/kernel/sys_i386.c	Thu Dec 17 19:27:35 1998
+++ linux-2.2.16-lfs/arch/i386/kernel/sys_i386.c	Tue Jul 11 17:23:09 2000
@@ -85,6 +85,70 @@
 	return error;
 }
 
+asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
+        unsigned long prot, unsigned long flags,
+        unsigned long fd, unsigned long pgoff)
+{
+	int error;
+	struct file * file = NULL;
+	unsigned long long offset;
+
+	down(&current->mm->mmap_sem);
+	lock_kernel();
+	if (!(flags & MAP_ANONYMOUS)) {
+		error = -EBADF;
+		file = fget(fd);
+		if (!file)
+			goto out;
+	}
+	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+	offset = ((unsigned long long)pgoff)<<PAGE_SHIFT;
+	error = do_mmap(file, addr, len, prot, flags, offset);
+	if (file)
+		fput(file);
+out:
+	unlock_kernel();
+	up(&current->mm->mmap_sem);
+	return error;
+}
+
+struct mmap_arg_struct64 {
+	unsigned long addr;
+	unsigned long len;
+	unsigned long prot;
+	unsigned long flags;
+	unsigned long fd;
+	unsigned long long offset; /* 64 bits */
+};
+
+asmlinkage int sys_mmap64(struct mmap_arg_struct64 *arg)
+{
+	int error = -EFAULT;
+	struct file * file = NULL;
+	struct mmap_arg_struct64 a;
+
+	if (copy_from_user(&a, arg, sizeof(a)))
+		return -EFAULT;
+
+	down(&current->mm->mmap_sem);
+	lock_kernel();
+	if (!(a.flags & MAP_ANONYMOUS)) {
+		error = -EBADF;
+		file = fget(a.fd);
+		if (!file)
+			goto out;
+	}
+	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+
+	error = do_mmap(file, a.addr, a.len, a.prot, a.flags, a.offset);
+	if (file)
+		fput(file);
+out:
+	unlock_kernel();
+	up(&current->mm->mmap_sem);
+	return error;
+}
+
 extern asmlinkage int sys_select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
 
 struct sel_arg_struct {
--- linux-2.2.16-clean/arch/i386/kernel/i386_ksyms.c	Tue Oct 26 20:53:39 1999
+++ linux-2.2.16-lfs/arch/i386/kernel/i386_ksyms.c	Tue Jul 11 15:23:29 2000
@@ -119,3 +119,17 @@
 #ifdef CONFIG_VT
 EXPORT_SYMBOL(screen_info);
 #endif
+
+/* math helpers from libgcc */
+extern long long __divdi3(long long, long long);
+extern long long __moddi3(long long, long long);
+extern long long __udivdi3(long long, long long);
+extern long long __umoddi3(long long, long long);
+extern int       __cmpdi2(long long, long long);
+extern int       __ucmpdi2(long long, long long);
+EXPORT_SYMBOL_NOVERS(__divdi3);
+EXPORT_SYMBOL_NOVERS(__moddi3);
+EXPORT_SYMBOL_NOVERS(__udivdi3);
+EXPORT_SYMBOL_NOVERS(__umoddi3);
+EXPORT_SYMBOL_NOVERS(__cmpdi2);
+EXPORT_SYMBOL_NOVERS(__ucmpdi2);
--- linux-2.2.16-clean/arch/mips/kernel/syscalls.h	Mon Aug  9 15:04:38 1999
+++ linux-2.2.16-lfs/arch/mips/kernel/syscalls.h	Tue Jul 11 15:23:29 2000
@@ -223,5 +223,19 @@
 SYS(sys_capset, 2)				/* 4205 */
 SYS(sys_sigaltstack, 2)
 SYS(sys_sendfile, 3)
-SYS(sys_ni_syscall, 0)
-SYS(sys_ni_syscall, 0)
+SYS(sys_ni_syscall, 0) /* streams getpmsg */
+SYS(sys_ni_syscall, 0) /* streams putpmsg */
+SYS(sys_ni_syscall, 0) /* mmap64 */		/* 4210 */
+SYS(sys_ni_syscall, 0) /* setrlimit64 */
+SYS(sys_ni_syscall, 0) /* getrlimit64 */
+SYS(sys_ni_syscall, 0) /* truncate64 */
+SYS(sys_ni_syscall, 0) /* ftruncate64 */
+SYS(sys_ni_syscall, 0) /* stat64 */		/* 4215 */
+SYS(sys_ni_syscall, 0) /* lstat64 */
+SYS(sys_ni_syscall, 0) /* fstat64 */
+SYS(sys_ni_syscall, 0) /* statfs64 */
+SYS(sys_ni_syscall, 0) /* fstatfs64 */
+SYS(sys_ni_syscall, 0) /* getdents64 */		/* 4220 */
+SYS(sys_ni_syscall, 0) /* sysconf */
+SYS(sys_ni_syscall, 0) /* pathconf */
+SYS(sys_ni_syscall, 0) /* fpathconf */
--- linux-2.2.16-clean/arch/ppc/kernel/misc.S	Wed May  3 20:16:31 2000
+++ linux-2.2.16-lfs/arch/ppc/kernel/misc.S	Tue Jul 11 15:23:29 2000
@@ -943,4 +943,28 @@
 	.long sys_ni_syscall		/* streams1 */
 	.long sys_ni_syscall		/* streams2 */
 	.long sys_vfork
-	.space (NR_syscalls-183)*4
+	.long sys_ni_syscall /* mmap64 */ /* 190 */
+	.long sys_setrlimit64
+	.long sys_getrlimit64
+	.long sys_truncate64
+	.long sys_ftruncate64
+	.long sys_newstat64	/* 195 */
+	.long sys_newlstat64
+	.long sys_newfstat64
+	.long sys_statfs64
+	.long sys_fstatfs64
+	.long sys_getdents64	/* 200 */
+	.long sys_sysconf
+	.long sys_pathconf
+	.long sys_fpathconf
+
+	/*
+	 * NOTE!! This doesn't have to be exact - we just have
+	 * to make sure we have _enough_ of the "sys_ni_syscall"
+	 * entries. Don't panic if you notice that this hasn't
+	 * been shrunk every time we add a new system call.
+	 */
+	.long sys_ni_syscall
+	.rept NR_syscalls - 203
+		.long sys_ni_syscall
+	.endr
--- linux-2.2.16-clean/arch/m68k/kernel/entry.S	Tue May 11 12:57:14 1999
+++ linux-2.2.16-lfs/arch/m68k/kernel/entry.S	Tue Jul 11 15:23:29 2000
@@ -609,7 +609,28 @@
 	.long SYMBOL_NAME(sys_ni_syscall)		/* streams1 */
 	.long SYMBOL_NAME(sys_ni_syscall)		/* streams2 */
 	.long SYMBOL_NAME(sys_vfork)            /* 190 */
+	.long SYMBOL_NAME(sys_setrlimit64)
+	.long SYMBOL_NAME(sys_getrlimit64)
+	.long SYMBOL_NAME(sys_truncate64)
+	.long SYMBOL_NAME(sys_ftruncate64)
+	.long SYMBOL_NAME(sys_newstat64)	/* 195 */
+	.long SYMBOL_NAME(sys_newlstat64)
+	.long SYMBOL_NAME(sys_newfstat64)
+	.long SYMBOL_NAME(sys_statfs64)
+	.long SYMBOL_NAME(sys_fstatfs64)
+	.long SYMBOL_NAME(sys_getdents64)	/* 200 */ /* "getdents64" */
+	.long SYMBOL_NAME(sys_oldmmap64)
+	.long SYMBOL_NAME(sys_sysconf)
+	.long SYMBOL_NAME(sys_pathconf)
+	.long SYMBOL_NAME(sys_fpathconf)
 
-	.rept NR_syscalls-(.-SYMBOL_NAME(sys_call_table))/4
+	/*
+	 * NOTE!! This doesn't have to be exact - we just have
+	 * to make sure we have _enough_ of the "sys_ni_syscall"
+	 * entries. Don't panic if you notice that this hasn't
+	 * been shrunk every time we add a new system call.
+	 */
+	.long SYMBOL_NAME(sys_ni_syscall)
+	.rept NR_syscalls - 204
 		.long SYMBOL_NAME(sys_ni_syscall)
 	.endr
--- linux-2.2.16-clean/arch/m68k/kernel/sys_m68k.c	Tue Jan 19 13:58:34 1999
+++ linux-2.2.16-lfs/arch/m68k/kernel/sys_m68k.c	Tue Jul 11 15:23:29 2000
@@ -89,6 +89,43 @@
 }
 
 
+struct mmap_arg_struct64 {
+	unsigned long addr;
+	unsigned long len;
+	unsigned long prot;
+	unsigned long flags;
+	unsigned long fd;
+	unsigned long long offset; /* 64 bits */
+};
+
+asmlinkage int old_mmap64(struct mmap_arg_struct64 *arg)
+{
+	int error = -EFAULT;
+	struct file * file = NULL;
+	struct mmap_arg_struct64 a;
+
+	if (copy_from_user(&a, arg, sizeof(a)))
+		return -EFAULT;
+
+	down(&current->mm->mmap_sem);
+	lock_kernel();
+	if (!(a.flags & MAP_ANONYMOUS)) {
+		error = -EBADF;
+		file = fget(a.fd);
+		if (!file)
+			goto out;
+	}
+	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+
+	error = do_mmap(file, a.addr, a.len, a.prot, a.flags, a.offset);
+	if (file)
+		fput(file);
+out:
+	unlock_kernel();
+	up(&current->mm->mmap_sem);
+	return error;
+}
+
 extern asmlinkage int sys_select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
 
 struct sel_arg_struct {
--- linux-2.2.16-clean/arch/arm/kernel/calls.S	Thu Dec 17 12:05:42 1998
+++ linux-2.2.16-lfs/arch/arm/kernel/calls.S	Tue Jul 11 15:23:29 2000
@@ -196,8 +196,26 @@
 		.long	SYMBOL_NAME(sys_capget)
 /* 185 */	.long	SYMBOL_NAME(sys_capset)
 		.long	SYMBOL_NAME(sys_sigaltstack_wrapper)
-
-		.rept	NR_syscalls-186
+		.long	SYMBOL_NAME(sys_sendfile)
+		.long	SYMBOL_NAME(sys_ni_syscall) /* streams1 */
+		.long	SYMBOL_NAME(sys_ni_syscall) /* streams2 */
+/* 190 */	.long	SYMBOL_NAME(sys_vfork_wrapper)
+		.long	SYMBOL_NAME(old_mmap64)
+		.long	SYMBOL_NAME(sys_setrlimit64)
+		.long	SYMBOL_NAME(sys_getrlimit64)
+		.long	SYMBOL_NAME(sys_truncate64)
+/* 195 */	.long	SYMBOL_NAME(sys_ftruncate64)
+		.long	SYMBOL_NAME(sys_newstat64)
+		.long	SYMBOL_NAME(sys_newlstat64)
+		.long	SYMBOL_NAME(sys_newfstat64)
+		.long	SYMBOL_NAME(sys_statfs64)
+/* 200 */	.long	SYMBOL_NAME(sys_fstatfs64)
+		.long	SYMBOL_NAME(sys_getdents64)
+		.long	SYMBOL_NAME(sys_sysconf)
+		.long	SYMBOL_NAME(sys_pathconf)
+		.long	SYMBOL_NAME(sys_fpathconf)
+/* 205 */
+		.rept	NR_syscalls-200
 			.long	SYMBOL_NAME(sys_ni_syscall)
 		.endr
 #endif
--- linux-2.2.16-clean/arch/arm/kernel/sys_arm.c	Sat May  8 14:14:01 1999
+++ linux-2.2.16-lfs/arch/arm/kernel/sys_arm.c	Tue Jul 11 15:23:29 2000
@@ -90,6 +90,42 @@
 	return error;
 }
 
+struct mmap_arg_struct64 {
+	unsigned long addr;
+	unsigned long len;
+	unsigned long prot;
+	unsigned long flags;
+	unsigned long fd;
+	unsigned long long offset; /* 64 bits */
+};
+
+asmlinkage int old_mmap64(struct mmap_arg_struct64 *arg)
+{
+	int error = -EFAULT;
+	struct file * file = NULL;
+	struct mmap_arg_struct64 a;
+
+	if (copy_from_user(&a, arg, sizeof(a)))
+		return -EFAULT;
+
+	down(&current->mm->mmap_sem);
+	lock_kernel();
+	if (!(a.flags & MAP_ANONYMOUS)) {
+		error = -EBADF;
+		file = fget(a.fd);
+		if (!file)
+			goto out;
+	}
+	a.flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+
+	error = do_mmap(file, a.addr, a.len, a.prot, a.flags, a.offset);
+	if (file)
+		fput(file);
+out:
+	unlock_kernel();
+	up(&current->mm->mmap_sem);
+	return error;
+}
 
 extern asmlinkage int sys_select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
 
