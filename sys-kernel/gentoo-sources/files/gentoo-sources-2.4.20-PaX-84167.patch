--- linux-2.4.20-gentoo-r32/mm/mmap.c	2005-03-06 19:33:42.000000000 +0000
+++ linux-2.4.20-gentoo-r33/mm/mmap.c	2005-03-06 19:53:59.501141080 +0000
@@ -982,7 +982,7 @@
  * we just free'd - but there's no telling how much before.
  */
 static void free_pgtables(struct mm_struct * mm, struct vm_area_struct *prev,
-	unsigned long start, unsigned long end)
+	struct vm_area_struct *mpnt, unsigned long start, unsigned long end)
 {
 	unsigned long first = start & PGDIR_MASK;
 	unsigned long last = end + PGDIR_SIZE - 1;
@@ -1014,6 +1014,14 @@
 		break;
 	}
 no_mmaps:
+	while (mpnt && first < last) {
+		if ((mpnt->vm_end > first) &&(last > mpnt->vm_start)) {
+			first = mpnt->vm_end + PGDIR_SIZE - 1;
+			last = mpnt->vm_start;
+		}
+		mpnt = mpnt->vm_next;
+	}
+
 	/*
 	 * If the PGD bits are not consecutive in the virtual address, the
 	 * old method of shifting the VA >> by PGDIR_SHIFT doesn't work.
@@ -1072,7 +1080,7 @@
 		extra = unmap_vma(mm, addr, len, mpnt, extra);
 	}
 
-	free_pgtables(mm, prev, addr, addr+len);
+	free_pgtables(mm, prev, NULL, addr, addr+len);
 
 	return extra;
 }
@@ -1096,7 +1104,7 @@
 		find_vma_prev(mm, mpnt->vm_start, &prev);
 		extra_m = unmap_vma(mm, addr_m, len, mpnt, extra_m);
 
-		free_pgtables(mm, prev, start, end);
+		free_pgtables(mm, prev, free_m, start, end);
 	}               
 
 	return extra_m;
