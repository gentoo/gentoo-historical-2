[plasmaroo@gentoo.org]: Patch backported from 2.4.22-pre9...

Because an md array may not exist yet when the device it opened, the ->active
count, which is incremented on opening if the array exists, is not 100% reliable.
This patch changes md to test inode->i_bdev->bd_openers rather than mddev->active
to test if an array is still in used before stopping it.

diff ./drivers/md/md.c~current~ ./drivers/md/md.c
--- ./drivers/md/md.c~current~	2003-09-04 11:32:15.000000000 +1000
+++ ./drivers/md/md.c	2003-09-04 11:32:14.000000000 +1000
@@ -1805,10 +1805,12 @@ static int do_md_stop(mddev_t * mddev, i
 	int err = 0, resync_interrupted = 0;
 	kdev_t dev = mddev_to_kdev(mddev);
 
+#if 0 /* ->active is not currently reliable */
 	if (atomic_read(&mddev->active)>1) {
 		printk(STILL_IN_USE, mdidx(mddev));
 		OUT(-EBUSY);
 	}
+#endif
 
 	if (mddev->pers) {
 		/*
@@ -2742,12 +2744,17 @@ static int md_ioctl(struct inode *inode,
 			goto done_unlock;
 
 		case STOP_ARRAY:
-			if (!(err = do_md_stop (mddev, 0)))
+			if (inode->i_bdev->bd_openers > 1)
+				err = -EBUSY;
+			else if (!(err = do_md_stop (mddev, 0)))
 				mddev = NULL;
 			goto done_unlock;
 
 		case STOP_ARRAY_RO:
-			err = do_md_stop (mddev, 1);
+			if (inode->i_bdev->bd_openers > 1)
+				err = -EBUSY;
+			else 
+				err = do_md_stop (mddev, 1);
 			goto done_unlock;
 
 	/*
