unchanged:
--- vcl/inc/button.hxx	17 Apr 2003 17:55:12 -0000	1.8
+++ vcl/inc/button.hxx	3 Mar 2004 15:32:06 -0000
@@ -78,6 +78,10 @@
 #include <bitmap.hxx>
 #endif
 
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
 class UserDrawEvent;
 
 // ----------
@@ -180,6 +184,7 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
     virtual void    UserDraw( const UserDrawEvent& rUDEvt );
 
     virtual void    Toggle();
@@ -376,6 +381,7 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     virtual void    Toggle();
 
@@ -465,6 +471,7 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     virtual void    Toggle();
 
unchanged:
--- vcl/inc/ctrl.hxx	16 May 2002 11:52:49 -0000	1.5
+++ vcl/inc/ctrl.hxx	3 Mar 2004 15:32:06 -0000
@@ -73,6 +73,10 @@
 #include <window.hxx>
 #endif
 
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
 // forward
 namespace vcl { struct ControlLayoutData; }
 
unchanged:
--- vcl/inc/edit.hxx	27 Mar 2003 17:57:20 -0000	1.11
+++ vcl/inc/edit.hxx	3 Mar 2004 15:32:06 -0000
@@ -174,6 +174,7 @@ protected:
 	void				ImplLoadRes( const ResId& rResId );
 	void				ImplSetSelection( const Selection& rSelection, BOOL bPaint = TRUE );
 #endif
+    int                 ImplGetNativeControlType();
 
 	::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::dnd::XDragSourceListener > mxDnDListener;
 
unchanged:
--- vcl/inc/ilstbox.hxx	24 Apr 2003 16:29:18 -0000	1.20
+++ vcl/inc/ilstbox.hxx	3 Mar 2004 15:32:07 -0000
@@ -573,6 +573,7 @@ public:
 	virtual void	Resize();
 	virtual void	GetFocus();
 	virtual void	LoseFocus();
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
 	USHORT			GetItemPos() const { return mnItemPos; }
 	void			SetItemPos( USHORT n ) { mnItemPos = n; }
unchanged:
--- vcl/inc/salframe.hxx	24 Apr 2003 15:16:48 -0000	1.16
+++ vcl/inc/salframe.hxx	3 Mar 2004 15:32:07 -0000
@@ -91,6 +91,14 @@
 #include <tools/gen.hxx>
 #endif
 
+#ifndef _SV_REGION_HXX
+#include <region.hxx>
+#endif
+
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
 #ifdef __cplusplus
 
 class AllSettings;
@@ -159,6 +167,8 @@ struct SystemEnvData;
 #define SAL_FRAME_POSSIZE_HEIGHT            ((USHORT)0x0008)
 
 #ifdef __cplusplus
+
+using namespace rtl;
 
 // ------------
 // - SalFrame -
unchanged:
--- vcl/inc/salgdi.hxx	9 Jan 2004 18:13:40 -0000	1.20.116.1
+++ vcl/inc/salgdi.hxx	3 Mar 2004 15:32:07 -0000
@@ -81,6 +81,15 @@
 #ifndef _SV_OUTDEV_HXX
 #include <outdev.hxx>
 #endif
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+#ifndef _SV_SALCTRLHANDLE_HXX
+#include <salctrlhandle.hxx>
+#endif
 
 #include <map>
 
@@ -277,6 +286,54 @@ public:
     virtual void                    Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev );
 
     virtual BOOL                    DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev );
+
+    //-------------------------------------
+    //  Native Widget Rendering functions
+    //-------------------------------------
+
+    // Query the platform layer for control support
+    virtual BOOL IsNativeControlSupported( ControlType nType, ControlPart nPart );
+
+    // Query the native control to determine if it was acted upon
+    virtual BOOL HitTestNativeControl( ControlType nType,
+									  ControlPart nPart,
+									  const Region& rControlRegion,
+									  const Point& aPos,
+									  SalControlHandle& rControlHandle,
+                                      BOOL& rIsInside,
+                                      const OutputDevice *pOutDev );
+
+    // Request rendering of a particular control and/or part
+    virtual BOOL DrawNativeControl( ControlType nType,
+									ControlPart nPart,
+									const Region& rControlRegion,
+									ControlState nState,
+									const ImplControlValue& aValue,
+									SalControlHandle& rControlHandle,
+									rtl::OUString aCaption,
+                                    const OutputDevice *pOutDev );
+
+     // Request rendering of a caption string for a control
+    virtual BOOL DrawNativeControlText( ControlType nType,
+										ControlPart nPart,
+										const Region& rControlRegion,
+										ControlState nState,
+										const ImplControlValue& aValue,
+										SalControlHandle& rControlHandle,
+										rtl::OUString aCaption,
+                                        const OutputDevice *pOutDev );
+
+   // Query the native control's actual drawing region (including adornment)
+    virtual BOOL GetNativeControlRegion( ControlType nType,
+										 ControlPart nPart,
+										 const Region& rControlRegion,
+										 ControlState nState,
+										 const ImplControlValue& aValue,
+										 SalControlHandle& rControlHandle,
+										 rtl::OUString aCaption,
+										 Region &rNativeBoundingRegion,
+										 Region &rNativeContentRegion,
+                                         const OutputDevice *pOutDev );
 };
 
 
@@ -305,6 +362,7 @@ public:
 	void					mirror( long& nX, const OutputDevice *pOutDev );
 	void					mirror( long& nX, long& nWidth, const OutputDevice *pOutDev );
 	BOOL					mirror( sal_uInt32 nPoints, const SalPoint *pPtAry, SalPoint *pPtAry2, const OutputDevice *pOutDev );
+    void                    mirror( Region& rRgn, const OutputDevice *pOutDev );
 
 	// overwrite those SalGraphics methods that require mirroring
     // note: text methods will not be mirrored here, this is handled in outdev3.cxx
@@ -343,6 +401,19 @@ public:
 	void					Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice *pOutDev );
 	void					Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev );
 	BOOL					DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev );
+
+    // native widget rendering methods that require mirroring
+    BOOL                    HitTestNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                    const Point& aPos, SalControlHandle& rControlHandle, BOOL& rIsInside, const OutputDevice *pOutDev );
+    BOOL                    DrawNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                    ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+                                                    rtl::OUString aCaption, const OutputDevice *pOutDev );
+    BOOL                    DrawNativeControlText( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                    ControlState nState, const ImplControlValue& aValue,
+                                                    SalControlHandle& rControlHandle, rtl::OUString aCaption, const OutputDevice *pOutDev );
+    BOOL                    GetNativeControlRegion( ControlType nType, ControlPart nPart, const Region& rControlRegion, ControlState nState,
+                                                    const ImplControlValue& aValue, SalControlHandle& rControlHandle, rtl::OUString aCaption,
+                                                    Region &rNativeBoundingRegion, Region &rNativeContentRegion, const OutputDevice *pOutDev );
 };
 
 #endif // _SV_SALGDI_HXX
unchanged:
--- vcl/inc/scrbar.hxx	25 Jul 2001 11:39:21 -0000	1.5
+++ vcl/inc/scrbar.hxx	3 Mar 2004 15:32:07 -0000
@@ -111,6 +111,7 @@ private:
     BOOL            mbDummy2;
     Link            maScrollHdl;
     Link            maEndScrollHdl;
+    Rectangle*      ImplFindPartRect( const Point& rPt );
 
 #ifdef _SV_SCRBAR_CXX
 #include <scrbar.imp>
@@ -128,6 +129,7 @@ public:
     virtual void    Resize();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     virtual void    Scroll();
     virtual void    EndScroll();
unchanged:
--- vcl/inc/scrbar.imp	27 Mar 2003 17:57:32 -0000	1.3
+++ vcl/inc/scrbar.imp	3 Mar 2004 15:32:07 -0000
@@ -50,5 +50,6 @@
 	long			ImplScroll( long nNewPos, BOOL bCallEndScroll );
 	long			ImplDoAction( BOOL bCallEndScroll );
 	void			ImplDoMouseAction( const Point& rPos, BOOL bCallAction = TRUE );
+    BOOL            ImplDrawNative( USHORT nDrawFlags );
 
 					DECL_LINK( ImplTimerHdl, Timer* );
unchanged:
--- vcl/inc/settings.hxx	17 Apr 2003 15:16:59 -0000	1.19
+++ vcl/inc/settings.hxx	3 Mar 2004 15:32:07 -0000
@@ -486,7 +486,7 @@ private:
     ULONG                           mnDisplayOptions;
     ULONG                           mnToolbarIconSize;
     ULONG                           mnDummyOption3;
-    ULONG                           mnDummyOption4;
+    ULONG                           mnUseFlatBorders;
     ULONG                           mnUseFlatMenues;
     ULONG                           mnOptions;
     USHORT                          mnScreenZoom;
@@ -754,6 +754,10 @@ public:
                                         { CopyData(); mpData->mnUseSystemUIFonts = bUseSystemUIFonts; }
     BOOL							GetUseSystemUIFonts() const
                                         { return (BOOL) mpData->mnUseSystemUIFonts; }
+    void							SetUseFlatBorders( BOOL bUseFlatBorders )
+                                        { CopyData(); mpData->mnUseFlatBorders = bUseFlatBorders; }
+    BOOL							GetUseFlatBorders() const
+                                        { return (BOOL) mpData->mnUseFlatBorders; }
     void							SetUseFlatMenues( BOOL bUseFlatMenues )
                                         { CopyData(); mpData->mnUseFlatMenues = bUseFlatMenues; }
     BOOL							GetUseFlatMenues() const
unchanged:
--- vcl/inc/spin.hxx	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/spin.hxx	3 Mar 2004 15:32:07 -0000
@@ -90,6 +90,7 @@ private:
     BOOL            mbHorz        : 1;
     Link            maUpHdlLink;
     Link            maDownHdlLink;
+    Rectangle*      ImplFindPartRect( const Point& rPt );
 
 #ifdef _SV_SPIN_CXX
     void            ImplInit( Window* pParent, WinBits nStyle );
@@ -111,6 +112,7 @@ public:
     virtual void    MouseMove( const MouseEvent& rMEvt );
     virtual void    KeyInput( const KeyEvent& rKEvt );
     virtual void    StateChanged( StateChangedType nStateChange );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     void            SetUpHdl( const Link& rLink ) { maUpHdlLink = rLink; }
     const Link&     GetUpHdl() const   { return maUpHdlLink;   }
unchanged:
--- vcl/inc/spinfld.hxx	3 May 2002 13:04:10 -0000	1.3
+++ vcl/inc/spinfld.hxx	3 Mar 2004 15:32:07 -0000
@@ -117,6 +117,7 @@ protected:
 	void			EndDropDown();
 
     virtual void  FillLayoutData() const;
+    Rectangle *     ImplFindPartRect( const Point& rPt );
 public:
 					SpinField( Window* pParent, WinBits nWinStyle = 0 );
 					SpinField( Window* pParent, const ResId& rResId );
@@ -137,6 +138,7 @@ public:
 	virtual void	Resize();
 	virtual void	StateChanged( StateChangedType nType );
 	virtual void	DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
 	void			SetUpHdl( const Link& rLink ) { maUpHdlLink = rLink; }
 	const Link& 	GetUpHdl() const { return maUpHdlLink; }
diff -u vcl/inc/tabctrl.hxx vcl/inc/tabctrl.hxx
--- vcl/inc/tabctrl.hxx	3 Mar 2004 15:32:07 -0000
+++ vcl/inc/tabctrl.hxx	2004-03-17 17:25:30.000000000 +0100
@@ -124,7 +124,7 @@
     void                ImplActivateTabPage( BOOL bNext );
     void                ImplSetFirstPagePos( USHORT nPagePos );
     void                ImplShowFocus();
-    void                ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout = false );
+    void                ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout = false, bool bFirstInGroup = false, bool bLastInGroup = false, bool bIsCurrentItem = false );
     void				ImplPaint( const Rectangle& rRect, bool bLayout = false );
     void				ImplFreeLayoutData();
                         DECL_LINK( ImplScrollBtnHdl, PushButton* pBtn );
@@ -134,6 +134,7 @@
     void                ImplLoadRes( const ResId& rResId );
 
     virtual void		FillLayoutData() const;
+    Rectangle*          ImplFindPartRect( const Point& rPt );
 
 public:
                         TabControl( Window* pParent,
@@ -152,6 +153,7 @@
     virtual long        Notify( NotifyEvent& rNEvt );
     virtual void        StateChanged( StateChangedType nType );
     virtual void        DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long        PreNotify( NotifyEvent& rNEvt );
 
     virtual void        ActivatePage();
     virtual long        DeactivatePage();
unchanged:
--- vcl/inc/tabpage.hxx	24 Apr 2003 16:30:10 -0000	1.3
+++ vcl/inc/tabpage.hxx	3 Mar 2004 15:32:07 -0000
@@ -85,6 +85,8 @@ public:
 					TabPage( Window* pParent, WinBits nStyle = 0 );
 					TabPage( Window* pParent, const ResId& rResId );
 
+    virtual void    Paint( const Rectangle& rRect );
+
 	virtual void	StateChanged( StateChangedType nStateChange );
 	virtual void	DataChanged( const DataChangedEvent& rDCEvt );
 
unchanged:
--- vcl/inc/window.h	9 Jan 2004 18:13:41 -0000	1.11.136.1
+++ vcl/inc/window.h	3 Mar 2004 15:32:07 -0000
@@ -113,6 +113,7 @@ struct ImplWinData
     Rectangle*          mpFocusRect;
     Rectangle*          mpTrackRect;
     USHORT              mnTrackFlags;
+    BOOL                mbMouseOver;    // tracks mouse over for native widget paint effect
 };
 
 // -------------------
@@ -155,6 +156,8 @@ struct ImplFrameData
     ULONG               mnMouseMoveId;      // MoveId for PostUserLink
     long                mnLastMouseX;       // last x mouse position
     long                mnLastMouseY;       // last y mouse position
+    long                mnBeforeLastMouseX; // last but one x mouse position
+    long                mnBeforeLastMouseY; // last but one y mouse position
     long                mnFirstMouseX;      // first x mouse position by mousebuttondown
     long                mnFirstMouseY;      // first y mouse position by mousebuttondown
     long                mnLastMouseWinX;    // last x mouse position, rel. to pMouseMoveWin
unchanged:
--- vcl/inc/window.hxx	26 Jan 2004 17:20:36 -0000	1.47.112.1
+++ vcl/inc/window.hxx	3 Mar 2004 15:32:07 -0000
@@ -91,6 +91,18 @@
 #include <event.hxx>
 #endif
 
+#ifndef _SV_REGION_HXX
+#include <region.hxx>
+#endif
+
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
 #include <com/sun/star/uno/Reference.hxx>
 #endif
@@ -131,6 +143,7 @@ class AccessObjectRef;
 class RmFrameWindow;
 class VCLXWindow;
 struct ImplAccessibleInfos;
+class SalControlHandle;
 
 namespace com {
 namespace sun {
@@ -375,7 +388,7 @@ private:
     void*               mpDummy1;
     void*               mpDummy2;
     void*               mpDummy3;
-    void*               mpDummy4;
+    SalControlHandle*   mpSalControlHandle;
     ImplDelData*        mpFirstDel;
     void*               mpUserData;
     Cursor*             mpCursor;
@@ -422,7 +435,22 @@ private:
     USHORT              mnActivateMode;
     USHORT              mnDlgCtrlFlags;
     USHORT              mnLockCount;
-    USHORT              mnDummy3;
+    BOOL                mbEnableNativeWidget:1,
+                        mbDummy1:1,
+                        mbDummy2:1,
+                        mbDummy3:1,
+                        mbDummy4:1,
+                        mbDummy5:1,
+                        mbDummy6:1,
+                        mbDummy7:1,
+                        mbDummy8:1,
+                        mbDummy9:1,
+                        mbDummy10:1,
+                        mbDummy11:1,
+                        mbDummy12:1,
+                        mbDummy13:1,
+                        mbDummy14:1,
+                        mbDummy15:1;
     USHORT              mnIsTopWindow;
     BOOL                mbFrame:1,
                         mbBorderWin:1,
@@ -594,6 +622,8 @@ public:
     void                SetDialogControlFlags( USHORT nFlags ) { mnDlgCtrlFlags = nFlags; }
     USHORT              GetDialogControlFlags() const { return mnDlgCtrlFlags; }
 
+    BOOL                IsMouseOver();
+
     ULONG               GetCurrentModButtons();
 
     void                SetInputContext( const InputContext& rInputContext );
@@ -753,6 +783,7 @@ public:
     BOOL                IsChildPointerOverwrite() const { return mbChildPtrOverwrite; }
     void                SetPointerPosPixel( const Point& rPos );
     Point               GetPointerPosPixel();
+    Point               GetLastPointerPosPixel();
     void                ShowPointer( BOOL bVisible );
     BOOL                IsPointerVisible() const { return !mbNoPtrVisible; }
     void                EnterWait();
@@ -900,6 +931,52 @@ public:
     // Clipboard/Selection interfaces
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::clipboard::XClipboard > GetClipboard();
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::clipboard::XClipboard > GetSelection();
+
+    //-------------------------------------
+    //  Native Widget Rendering functions
+    //-------------------------------------
+
+    // form controls will never use native widgets
+    void    EnableNativeWidget( BOOL bEnable = TRUE ) { mbEnableNativeWidget = bEnable; }
+    BOOL    IsNativeWidgetEnabled() const { return mbEnableNativeWidget; }
+
+    // These all just call through to the private mpFrame functions of the same name.
+
+    // Query the platform layer for control support
+    BOOL					IsNativeControlSupported( ControlType nType, ControlPart nPart );
+
+    // Query the native control to determine if it was acted upon
+    BOOL				HitTestNativeControl( ControlType nType,
+									  ControlPart nPart,
+									  const Region& rControlRegion,
+									  const Point& aPos,
+									  BOOL& rIsInside );
+
+    // Request rendering of a particular control and/or part
+    BOOL				DrawNativeControl(    ControlType nType,
+									  ControlPart nPart,
+									  const Region& rControlRegion,
+									  ControlState nState,
+									  const ImplControlValue& aValue,
+									  rtl::OUString aCaption );
+
+     // Request rendering of a caption string for a control
+    BOOL				DrawNativeControlText(     ControlType nType,
+										  ControlPart nPart,
+										  const Region& rControlRegion,
+										  ControlState nState,
+										  const ImplControlValue& aValue,
+										  rtl::OUString aCaption );
+
+    // Query the native control's actual drawing region (including adornment)
+    BOOL				GetNativeControlRegion(  ControlType nType,
+										  ControlPart nPart,
+										  const Region& rControlRegion,
+										  ControlState nState,
+										  const ImplControlValue& aValue,
+										  rtl::OUString aCaption,
+										  Region &rNativeBoundingRegion,
+										  Region &rNativeContentRegion );
 };
 
 inline void Window::SetPosPixel( const Point& rNewPos )
unchanged:
--- vcl/inc/window.imp	28 May 2003 12:30:26 -0000	1.16
+++ vcl/inc/window.imp	3 Mar 2004 15:32:07 -0000
@@ -268,3 +268,4 @@ public:
     void				ImplStartDnd();
 
     static void			ImplInitAppFontData( Window* pWindow );
+    void                ImplInitSalControlHandle();
unchanged:
--- vcl/inc/wintypes.hxx	11 Apr 2003 17:27:04 -0000	1.14
+++ vcl/inc/wintypes.hxx	3 Mar 2004 15:32:07 -0000
@@ -154,7 +154,8 @@ typedef USHORT WindowType;
 #define WINDOW_TREELISTBOX	        (WINDOW_FIRST + 0x4d)
 #define WINDOW_HELPTEXTWINDOW		(WINDOW_FIRST + 0x4e)
 #define WINDOW_INTROWINDOW		    (WINDOW_FIRST + 0x4f)
-#define WINDOW_LAST 				(WINDOW_INTROWINDOW)
+#define WINDOW_LISTBOXWINDOW        (WINDOW_FIRST + 0x50)
+#define WINDOW_LAST 				(WINDOW_LISTBOXWINDOW)
 
 
 // ---------------
unchanged:
--- vcl/prj/d.lst	28 Jan 2004 15:21:59 -0000	1.29.102.1
+++ vcl/prj/d.lst	3 Mar 2004 15:32:07 -0000
@@ -131,6 +131,8 @@ hedabu: ..\inc\salctype.hxx %_DEST%\inc%
 hedabu: ..\inc\salgtype.hxx %_DEST%\inc%_EXT%\vcl\salgtype.hxx
 hedabu: ..\inc\salotype.hxx %_DEST%\inc%_EXT%\vcl\salotype.hxx
 hedabu: ..\inc\salstype.hxx %_DEST%\inc%_EXT%\vcl\salstype.hxx
+hedabu: ..\inc\salnativewidgets.hxx %_DEST%\inc%_EXT%\vcl\salnativewidgets.hxx
+hedabu: ..\unx\inc\salnativewidgets.h %_DEST%\inc%_EXT%\vcl\salnativewidgets.h
 hedabu: ..\inc\scrbar.hxx %_DEST%\inc%_EXT%\vcl\scrbar.hxx
 hedabu: ..\inc\seleng.hxx %_DEST%\inc%_EXT%\vcl\seleng.hxx
 hedabu: ..\inc\settings.hxx %_DEST%\inc%_EXT%\vcl\settings.hxx
unchanged:
--- vcl/source/app/settings.cxx	3 Mar 2004 15:32:07 -0000
+++ vcl/source/app/settings.cxx	2004-03-17 17:45:57.000000000 +0100
@@ -582,6 +582,7 @@
     mnOptions                   = rData.mnOptions;
 	mnHighContrast				= rData.mnHighContrast;
 	mnUseSystemUIFonts			= rData.mnUseSystemUIFonts;
+	mnUseFlatBorders 			= rData.mnUseFlatBorders;
 	mnUseFlatMenues 			= rData.mnUseFlatMenues;
     mnAutoMnemonic				= rData.mnAutoMnemonic;
     mnUseImagesInMenus			= rData.mnUseImagesInMenus;
@@ -667,6 +668,7 @@
     mnMenuBarHeight             = 14;
 	mnHighContrast				= 0;
 	mnUseSystemUIFonts			= 0;
+	mnUseFlatBorders 			= 0;
 	mnUseFlatMenues 			= 0;
 	mnUseImagesInMenus			= (USHORT)TRUE;
 }
@@ -769,6 +771,7 @@
     mnMenuBarHeight             = 14;
 	mnHighContrast				= 0;
 	mnUseSystemUIFonts			= 0;
+	mnUseFlatBorders 			= 0;
 	mnUseFlatMenues 			= 0;
 	mnUseImagesInMenus			= (USHORT)TRUE;	
 }
@@ -855,6 +858,7 @@
     mnMenuBarHeight             = 14;
 	mnHighContrast				= 0;
 	mnUseSystemUIFonts			= 0;
+	mnUseFlatBorders 			= 0;
 	mnUseFlatMenues 			= 0;
 	mnUseImagesInMenus			= (USHORT)TRUE;
 }
@@ -960,6 +964,7 @@
 
 void StyleSettings::SetStandardWinStyles()
 {
+    return; // no more style changes since NWF
     CopyData();
     mpData->SetStandardWinStyles();
 }
@@ -968,6 +973,7 @@
 
 void StyleSettings::SetStandardOS2Styles()
 {
+    return; // no more style changes since NWF
     CopyData();
     mpData->SetStandardOS2Styles();
 }
@@ -976,6 +982,7 @@
 
 void StyleSettings::SetStandardMacStyles()
 {
+    return; // no more style changes since NWF
     CopyData();
     mpData->SetStandardMacStyles();
 }
@@ -984,6 +991,7 @@
 
 void StyleSettings::SetStandardUnixStyles()
 {
+    return; // no more style changes since NWF
     CopyData();
     mpData->SetStandardUnixStyles();
 }
@@ -1056,6 +1064,7 @@
          (mpData->mnTabControlStyle         == rSet.mpData->mnTabControlStyle)          &&
          (mpData->mnHighContrast			== rSet.mpData->mnHighContrast)             &&
          (mpData->mnUseSystemUIFonts		== rSet.mpData->mnUseSystemUIFonts)         &&
+         (mpData->mnUseFlatBorders   		== rSet.mpData->mnUseFlatBorders)           &&
          (mpData->mnUseFlatMenues   		== rSet.mpData->mnUseFlatMenues)            &&
          (mpData->maFaceColor               == rSet.mpData->maFaceColor)                &&
          (mpData->maCheckedColor            == rSet.mpData->maCheckedColor)             &&
unchanged:
--- vcl/source/app/svmain.cxx	11 Apr 2003 17:28:07 -0000	1.41
+++ vcl/source/app/svmain.cxx	3 Mar 2004 15:32:07 -0000
@@ -316,6 +316,8 @@ BOOL InitVCL( const ::com::sun::star::un
     InitSalMain();
 #endif
 
+    VCLInitNativeWidgets();
+
 #ifdef WNT
     // remember data, copied from WinMain
     SalData* pData = GetAppSalData();
@@ -643,6 +645,9 @@ void DeInitVCL()
 #ifndef REMOTE_APPSERVER
     DeInitSalMain();
 #endif
+
+    VCLDeinitNativeWidgets();
+
     if( pOwnSvApp )
     {
         delete pOwnSvApp;
diff -u vcl/source/control/button.cxx vcl/source/control/button.cxx
--- vcl/source/control/button.cxx	3 Mar 2004 15:32:07 -0000
+++ vcl/source/control/button.cxx	2004-03-17 17:25:30.000000000 +0100
@@ -102,6 +102,9 @@
 #ifndef _VCL_CONTROLLAYOUT_HXX
 #include <controllayout.hxx>
 #endif
+#ifndef _SV_NATIVEWIDGET_HXX
+#include <salnativewidgets.hxx>
+#endif
 
 #ifndef _SV_RC_H
 #include <rc.h>
@@ -287,27 +290,48 @@
 {
     const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 
-    if ( bFont )
-    {
-        Font aFont = rStyleSettings.GetPushButtonFont();
-        if ( IsControlFont() )
-            aFont.Merge( GetControlFont() );
-        SetZoomedPointFont( aFont );
-    }
+        if ( bFont )
+        {
+            Font aFont = rStyleSettings.GetPushButtonFont();
+            if ( IsControlFont() )
+                aFont.Merge( GetControlFont() );
+            SetZoomedPointFont( aFont );
+        }
 
-    if ( bForeground || bFont )
+        if ( bForeground || bFont )
+        {
+            Color aColor;
+            if ( IsControlForeground() )
+                aColor = GetControlForeground();
+            else
+                aColor = rStyleSettings.GetButtonTextColor();
+            SetTextColor( aColor );
+            SetTextFillColor();
+        }
+
+        if ( bBackground )
     {
-        Color aColor;
-        if ( IsControlForeground() )
-            aColor = GetControlForeground();
+        Window* pParent = GetParent();
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() ) 
+            || IsNativeControlSupported( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL ) )
+        {
+            EnableChildTransparentMode( TRUE );
+            SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+            SetPaintTransparent( TRUE );
+            SetBackground();
+    }
         else
-            aColor = rStyleSettings.GetButtonTextColor();
-        SetTextColor( aColor );
-        SetTextFillColor();
+        {
+            EnableChildTransparentMode( FALSE );
+            SetParentClipMode( 0 );
+            SetPaintTransparent( FALSE );
+
+            if ( IsControlBackground() )
+                SetBackground( GetControlBackground() );
+            else
+                SetBackground( pParent->GetBackground() );
+        }
     }
-
-    if ( bBackground )
-        SetBackground();
 }
 
 // -----------------------------------------------------------------------
@@ -848,20 +872,99 @@
     Rectangle               aRect( aPoint, aOutSz );
     Rectangle               aInRect = aRect;
     Rectangle               aTextRect;
+    BOOL                    bNativeOK = FALSE;
 
     // adjust style if button should be rendered 'pressed'
     if ( mbPressed )
         nButtonStyle |= BUTTON_DRAW_PRESSED;
 
-    // draw PushButtonFrame, aInRect has content size afterwards
-    if( ! bLayout )
-        ImplDrawPushButtonFrame( this, aInRect, nButtonStyle );
+    // TODO: move this to Window class or make it a member !!!
+    ControlType aCtrlType = 0;
+    switch( GetParent()->GetType() )
+    {
+        case WINDOW_LISTBOX:
+        case WINDOW_MULTILISTBOX:
+        case WINDOW_TREELISTBOX:
+            aCtrlType = CTRL_LISTBOX;
+            break;
+
+        case WINDOW_COMBOBOX:
+        case WINDOW_PATTERNBOX:			
+        case WINDOW_NUMERICBOX:			
+        case WINDOW_METRICBOX:			
+        case WINDOW_CURRENCYBOX:
+        case WINDOW_DATEBOX:		
+        case WINDOW_TIMEBOX:			
+        case WINDOW_LONGCURRENCYBOX:
+            aCtrlType = CTRL_COMBOBOX;
+            break;
+        default:
+            break;
+    }
+
+    BOOL bDropDown = ( IsSymbol() && (GetSymbol()==SYMBOL_SPIN_DOWN) && !GetText().Len() );
+
+    if( bDropDown && (aCtrlType == CTRL_COMBOBOX || aCtrlType == CTRL_LISTBOX ) )
+    {
+        if( IsNativeControlSupported( aCtrlType, PART_ENTIRE_CONTROL) )
+        {
+            if( !IsNativeControlSupported( aCtrlType, PART_BUTTON_DOWN) )
+                // skip painting if the button was already drawn by the theme
+                bNativeOK = TRUE;
+            else
+            {
+                // let the theme draw it, note we then need support
+                // for CTRL_LISTBOX/PART_BUTTON_DOWN and CTRL_COMBOBOX/PART_BUTTON_DOWN
+
+                ImplControlValue    aControlValue;
+                Region              aCtrlRegion( aInRect );
+                ControlState        nState = 0;
+
+                if ( mbPressed ) 						nState |= CTRL_STATE_PRESSED;
+                if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+                if ( HasFocus() )						nState |= CTRL_STATE_FOCUSED;
+                if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+                if ( Window::IsEnabled() ) 				nState |= CTRL_STATE_ENABLED;
 
-    // draw content
-    ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+                if ( IsMouseOver() && aInRect.IsInside( GetPointerPosPixel() ) )
+                    nState |= CTRL_STATE_ROLLOVER;
 
-    if( ! bLayout )
+                bNativeOK = DrawNativeControl( aCtrlType, PART_BUTTON_DOWN, aCtrlRegion, nState,
+                                                aControlValue, rtl::OUString() );
+            }
+        }
+    }
+
+    if( bNativeOK )
+        return;
+
+    if ( (bNativeOK=IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
     {
+        ImplControlValue aControlValue;
+        Region			 aCtrlRegion( aInRect );
+        ControlState	 nState = 0;
+
+        if ( mbPressed ) 						nState |= CTRL_STATE_PRESSED;
+        if ( mnButtonState & BUTTON_DRAW_PRESSED ) nState |= CTRL_STATE_PRESSED;
+        if ( HasFocus() )						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( Window::IsEnabled() ) 				nState |= CTRL_STATE_ENABLED;
+
+        if ( IsMouseOver() && aInRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     				aControlValue, rtl::OUString()/*PushButton::GetText()*/ );
+
+        // draw frame into invisible window to have aInRect modified correctly
+        // but do not shift the inner rect for pressed buttons (ie remove BUTTON_DRAW_PRESSED)
+        // this assumes the theme has enough visual cues to signalize the button was pressed
+        Window aWin( this );
+        ImplDrawPushButtonFrame( &aWin, aInRect, nButtonStyle & ~BUTTON_DRAW_PRESSED );
+
+        // draw content using the same aInRect as non-native VCL would do
+        ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+
         maFocusRect = aTextRect;
         if( !maFocusRect.IsEmpty() )
         {
@@ -870,21 +973,97 @@
             maFocusRect.Right()++;
             maFocusRect.Bottom()++;
             if ( HasFocus() )
-            {
                 ShowFocus( maFocusRect );
-            }
         }
     }
+
+    if ( bNativeOK == FALSE )
+    {
+        // draw PushButtonFrame, aInRect has content size afterwards
+        if( ! bLayout )
+            ImplDrawPushButtonFrame( this, aInRect, nButtonStyle );
+
+        // draw content
+        ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+
+        if( ! bLayout )
+        {
+            maFocusRect = aTextRect;
+            if( !maFocusRect.IsEmpty() )
+            {
+                maFocusRect.Left()--;
+                maFocusRect.Top()--;
+                maFocusRect.Right()++;
+                maFocusRect.Bottom()++;
+                if ( HasFocus() )
+                {
+                    ShowFocus( maFocusRect );
+                }
+            }
+        } 
+    }
 }
 
 // -----------------------------------------------------------------------
 
 void PushButton::ImplSetDefButton( BOOL bSet )
 {
+    Size aSize( GetSizePixel() );
+    Point aPos( GetPosPixel() );
+    int dLeft(0), dRight(0), dTop(0), dBottom(0);
+    BOOL bSetPos = FALSE;
+
+    if ( (IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        Region aBoundingRgn, aContentRgn;
+        Rectangle aCtrlRect( 0, 0, 80, 20 ); // use a constant size to avoid accumulating
+                                             // will not work if the theme has dynamic adornment sizes
+        ImplControlValue aControlValue;
+        Region			 aCtrlRegion( aCtrlRect );
+        ControlState	 nState = CTRL_STATE_DEFAULT|CTRL_STATE_ENABLED;
+
+        // get native size of a 'default' button
+        // and adjust the VCL button if more space for adornment is required
+        if( GetNativeControlRegion( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion,
+                                nState, aControlValue, rtl::OUString(),
+								aBoundingRgn, aContentRgn ) )
+        {
+            Rectangle aCont(aContentRgn.GetBoundRect());
+            Rectangle aBound(aBoundingRgn.GetBoundRect());
+
+            dLeft = aCont.Left() - aBound.Left();
+            dTop = aCont.Top() - aBound.Top();
+            dRight = aBound.Right() - aCont.Right();
+            dBottom = aBound.Bottom() - aCont.Bottom();
+            bSetPos = dLeft || dTop || dRight || dBottom;
+        }
+    }
+
     if ( bSet )
+    {
+        if( !(mnButtonState & BUTTON_DRAW_DEFAULT) && bSetPos )
+        {
+            // adjust pos/size when toggling from non-default to default
+            aPos.Move(-dLeft, -dTop);
+            aSize.Width() += dLeft + dRight;
+            aSize.Height() += dTop + dBottom;
+        }
         mnButtonState |= BUTTON_DRAW_DEFAULT;
+    }
     else
+    {
+        if( (mnButtonState & BUTTON_DRAW_DEFAULT) && bSetPos )
+        {
+            // adjust pos/size when toggling from default to non-default
+            aPos.Move(dLeft, dTop);
+            aSize.Width() -= dLeft + dRight;
+            aSize.Height() -= dTop + dBottom;
+        }
         mnButtonState &= ~BUTTON_DRAW_DEFAULT;
+    }
+    if( bSetPos )
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+
     Invalidate();
 }
 
@@ -1076,6 +1255,8 @@
     Rectangle   aTextRect;
     Font        aFont = GetDrawPixelFont( pDev );
 
+	return;
+
     pDev->Push();
     pDev->SetMapMode();
     pDev->SetFont( aFont );
@@ -1186,6 +1367,79 @@
 
 // -----------------------------------------------------------------------
 
+long PushButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( pMouseEvt->IsEnterWindow() || pMouseEvt->IsLeaveWindow() )
+        {
+            // trigger redraw as mouse over state has changed
+
+            // TODO: move this to Window class or make it a member !!!
+            ControlType aCtrlType = 0;
+            switch( GetParent()->GetType() )
+            {
+                case WINDOW_LISTBOX:
+                case WINDOW_MULTILISTBOX:
+                case WINDOW_TREELISTBOX:
+                    aCtrlType = CTRL_LISTBOX;
+                    break;
+
+                case WINDOW_COMBOBOX:
+                case WINDOW_PATTERNBOX:			
+                case WINDOW_NUMERICBOX:			
+                case WINDOW_METRICBOX:			
+                case WINDOW_CURRENCYBOX:
+                case WINDOW_DATEBOX:		
+                case WINDOW_TIMEBOX:			
+                case WINDOW_LONGCURRENCYBOX:
+                    aCtrlType = CTRL_COMBOBOX;
+                    break;
+                default:
+                    break;
+            }
+
+            BOOL bDropDown = ( IsSymbol() && (GetSymbol()==SYMBOL_SPIN_DOWN) && !GetText().Len() );
+
+            if( bDropDown && IsNativeControlSupported( aCtrlType, PART_ENTIRE_CONTROL) && 
+                   !IsNativeControlSupported( aCtrlType, PART_BUTTON_DOWN) )
+            {
+                Window *pBorder = GetParent()->GetWindow( WINDOW_BORDER );
+                if(aCtrlType == CTRL_COMBOBOX)
+                {
+                    // only paint the button part to avoid flickering of the combobox text
+                    Point aPt;
+                    Rectangle aClipRect( aPt, GetOutputSizePixel() );
+                    aClipRect.SetPos(pBorder->ScreenToOutputPixel(OutputToScreenPixel(aClipRect.TopLeft())));
+                    Region oldRgn( pBorder->GetClipRegion() );
+                    pBorder->SetClipRegion(Region( aClipRect ));
+                    pBorder->Paint( Rectangle() );
+                    pBorder->SetClipRegion( oldRgn );
+                }
+                else
+                {
+                    pBorder->Invalidate( INVALIDATE_NOERASE );
+                    pBorder->Update();
+                }
+            }
+            else if( IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL) )
+            {
+                Region aRgn( GetActiveClipRegion() );
+                SetClipRegion();
+                Paint( Rectangle() );
+                SetClipRegion( aRgn );
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void PushButton::Toggle()
 {
     ImplCallEventListeners( VCLEVENT_PUSHBUTTON_TOGGLE );
@@ -1635,7 +1889,8 @@
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() ) 
+            || IsNativeControlSupported( CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL ) )
         {
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
@@ -1669,7 +1924,31 @@
 void RadioButton::ImplDrawRadioButtonState()
 {
     USHORT nStyle = 0;
+    BOOL   bNativeOK = FALSE;
+
+    // no native drawing for image radio buttons
+    if ( !maImage && (bNativeOK=IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue		    aControlValue( mbChecked ? BUTTONVALUE_ON : BUTTONVALUE_OFF, rtl::OUString(), 0 );
+        Rectangle					aCtrlRect( maStateRect.TopLeft(), maStateRect.GetSize() );
+        Region						aCtrlRegion( aCtrlRect );
+        ControlState				nState = 0;
+
+        if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+        if ( HasFocus() ) 						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( IsEnabled() )						nState |= CTRL_STATE_ENABLED;
 
+        if ( IsMouseOver() && maMouseRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+                    aControlValue,rtl::OUString() );
+
+    }
+
+if ( bNativeOK == FALSE )
+{
     // kein Image-RadioButton
     if ( !maImage )
     {
@@ -1762,6 +2041,7 @@
             ShowFocus( maFocusRect );
     }
 }
+}
 
 // -----------------------------------------------------------------------
 
@@ -1812,6 +2092,7 @@
             rFocusRect = rMouseRect;
             rFocusRect.Left()--;
             rFocusRect.Right()++;
+            //rFocusRect.Bottom()++;  // provide space for mnemonic underline
 
             rMouseRect.Left()   = rPos.X();
             rStateRect.Left()   = rPos.X();
@@ -1910,10 +2191,11 @@
     aImageSize.Width()  = CalcZoom( aImageSize.Width() );
     aImageSize.Height() = CalcZoom( aImageSize.Height() );
 
+    // Draw control text
     ImplDraw( this, 0, Point(), GetOutputSizePixel(),
               aImageSize, IMPL_SEP_BUTTON_IMAGE, maStateRect, maMouseRect, maFocusRect, bLayout );
 
-    if( !bLayout )
+    if( !bLayout || (IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL)==TRUE) )
     {
         if ( !maImage )
         {
@@ -2352,6 +2634,39 @@
 
 // -----------------------------------------------------------------------
 
+long RadioButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL) )
+            {
+                if( ( maMouseRect.IsInside( GetPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetLastPointerPosPixel()) ) ||
+                    ( maMouseRect.IsInside( GetLastPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetPointerPosPixel()) ) ||
+                     pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+
+                    Region aRgn( GetActiveClipRegion() );
+                    SetClipRegion( maStateRect );
+                    Paint( maStateRect );
+                    SetClipRegion( aRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void RadioButton::Toggle()
 {
     ImplCallEventListeners( VCLEVENT_RADIOBUTTON_TOGGLE );
@@ -2611,7 +2926,8 @@
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+            || IsNativeControlSupported( CTRL_CHECKBOX, PART_ENTIRE_CONTROL ) )
         {
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
@@ -2651,18 +2967,46 @@
 
 void CheckBox::ImplDrawCheckBoxState()
 {
-    USHORT nStyle = mnButtonState;
-    if ( !IsEnabled() )
-        nStyle |= BUTTON_DRAW_DISABLED;
-    if ( meState == STATE_DONTKNOW )
-        nStyle |= BUTTON_DRAW_DONTKNOW;
-    else if ( meState == STATE_CHECK )
-        nStyle |= BUTTON_DRAW_CHECKED;
-    Image aImage = GetCheckImage( GetSettings(), nStyle );
-    if ( IsZoom() )
-        DrawImage( maStateRect.TopLeft(), maStateRect.GetSize(), aImage );
-    else
-        DrawImage( maStateRect.TopLeft(), aImage );
+    bool	bNativeOK = TRUE;
+
+    if ( (bNativeOK=IsNativeControlSupported(CTRL_CHECKBOX, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue    aControlValue( meState == STATE_CHECK ? BUTTONVALUE_ON : BUTTONVALUE_OFF, rtl::OUString(), 0 );
+        Region              aCtrlRegion( maStateRect );
+        ControlState        nState = 0;
+
+        if ( HasFocus() ) 						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+        if ( IsEnabled() )						nState |= CTRL_STATE_ENABLED;
+
+        if ( meState == STATE_CHECK )
+            aControlValue.setTristateVal( BUTTONVALUE_ON );
+        else if ( meState == STATE_DONTKNOW )					
+            aControlValue.setTristateVal( BUTTONVALUE_MIXED );
+
+        if ( IsMouseOver() && maMouseRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_CHECKBOX, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     						aControlValue, rtl::OUString() );
+    }
+
+    if ( bNativeOK == FALSE )
+    {
+        USHORT nStyle = mnButtonState;
+        if ( !IsEnabled() )
+            nStyle |= BUTTON_DRAW_DISABLED;
+        if ( meState == STATE_DONTKNOW )
+            nStyle |= BUTTON_DRAW_DONTKNOW;
+        else if ( meState == STATE_CHECK )
+            nStyle |= BUTTON_DRAW_CHECKED;
+        Image aImage = GetCheckImage( GetSettings(), nStyle );
+        if ( IsZoom() )
+            DrawImage( maStateRect.TopLeft(), maStateRect.GetSize(), aImage );
+        else
+            DrawImage( maStateRect.TopLeft(), aImage );
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -2711,11 +3055,11 @@
         rFocusRect = rMouseRect;
         rFocusRect.Left()--;
         rFocusRect.Right()++;
+        //rFocusRect.Bottom()++;  // provide space for mnemonic underline
 
+        rStateRect.Left()   = rPos.X();
+        rStateRect.Top()    = rMouseRect.Top();
         rMouseRect.Left()   = rPos.X();
-        // add 1 so that checkboxes with and without text are aligned
-        rStateRect.Left()   = rPos.X()+1;
-        rStateRect.Top()    = rMouseRect.Top()+1;
 
         long nTextHeight = GetTextHeight();
         if ( nTextHeight > rImageSize.Height() )
@@ -2730,17 +3074,22 @@
         if ( nWinStyle & WB_CENTER )
             rStateRect.Left() = rPos.X()+((rSize.Width()-rImageSize.Width())/2);
         else if ( nWinStyle & WB_RIGHT )
-            rStateRect.Left() = rPos.X()+rSize.Width()-rImageSize.Width()-1;
+            rStateRect.Left() = rPos.X()+rSize.Width()-rImageSize.Width();
         else
-            rStateRect.Left() = rPos.X()+1;
+            rStateRect.Left() = rPos.X();
         if ( nWinStyle & WB_VCENTER )
             rStateRect.Top() = rPos.Y()+((rSize.Height()-rImageSize.Height())/2);
         else if ( nWinStyle & WB_BOTTOM )
-            rStateRect.Top() = rPos.Y()+rSize.Height()-rImageSize.Height()-1;
+            rStateRect.Top() = rPos.Y()+rSize.Height()-rImageSize.Height();
         else
-            rStateRect.Top() = rPos.Y()+1;
+            rStateRect.Top() = rPos.Y();
         rStateRect.Right()  = rStateRect.Left()+rImageSize.Width()-1;
         rStateRect.Bottom() = rStateRect.Top()+rImageSize.Height()-1;
+        // provide space for focusrect
+        // note: this assumes that the control's size was adjusted
+        // accordingly in Get/LoseFocus, so the onscreen position won't change
+        if( HasFocus() )
+            rStateRect.Move( 1, 1 );    
         rMouseRect          = rStateRect;
 
         rFocusRect          = rStateRect;
@@ -3044,7 +3393,21 @@
 
 void CheckBox::GetFocus()
 {
-    ShowFocus( maFocusRect );
+    if ( !GetText().Len() || (mnButtonState & BUTTON_DRAW_NOTEXT) )
+    {
+        // increase button size to have space for focus rect
+        // checkboxes without text will draw focusrect around the check
+        // See CheckBox::ImplDraw()
+        Point aPos( GetPosPixel() );
+        Size aSize( GetSizePixel() );
+        aPos.Move(-1,-1);
+        aSize.Height() += 2;
+        aSize.Width() += 2;
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+        ImplDrawCheckBox();
+    }
+    else
+        ShowFocus( maFocusRect );
     SetInputContext( InputContext( GetFont() ) );
     Button::GetFocus();
 }
@@ -3061,6 +3424,19 @@
 
     HideFocus();
     Button::LoseFocus();
+
+    if ( !GetText().Len() || (mnButtonState & BUTTON_DRAW_NOTEXT) )
+    {
+        // decrease button size again (see GetFocus())
+        // checkboxes without text will draw focusrect around the check
+        Point aPos( GetPosPixel() );
+        Size aSize( GetSizePixel() );
+        aPos.Move(1,1);
+        aSize.Height() -= 2;
+        aSize.Width() -= 2;
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+        ImplDrawCheckBox();
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -3136,0 +3513,33 @@
+
+long CheckBox::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_CHECKBOX, PART_ENTIRE_CONTROL) )
+            {
+                if( ( maMouseRect.IsInside( GetPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetLastPointerPosPixel()) ) ||
+                    ( maMouseRect.IsInside( GetLastPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetPointerPosPixel()) ) ||
+                    pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+
+                    Region aRgn( GetActiveClipRegion() );
+                    SetClipRegion( maStateRect );
+                    Paint( maStateRect );
+                    SetClipRegion( aRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
diff -u vcl/source/control/combobox.cxx vcl/source/control/combobox.cxx
--- vcl/source/control/combobox.cxx	3 Mar 2004 15:32:07 -0000
+++ vcl/source/control/combobox.cxx	2004-03-17 17:25:30.000000000 +0100
@@ -268,8 +268,8 @@
 
 	if ( mpFloatWin )
 		mpFloatWin->SetImplListBox( mpImplLB );
-//	else
-//		mpImplLB->GetMainWindow()->AllowGrabFocus( TRUE );
+	else
+		mpImplLB->GetMainWindow()->AllowGrabFocus( TRUE );
 
 	ImplCalcEditHeight();
 
@@ -653,9 +653,48 @@
 	if( IsDropDownBox() )
 	{
 		long nSBWidth = GetSettings().GetStyleSettings().GetScrollBarSize();
-		nSBWidth = CalcZoom( nSBWidth );
-		mpSubEdit->SetSizePixel( Size( aOutSz.Width() - nSBWidth, aOutSz.Height() ) );
-		mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		long	nTop = 0;
+		long	nBottom = aOutSz.Height();
+
+        Window *pBorder = GetWindow( WINDOW_BORDER );
+		ImplControlValue aControlValue;
+		Point aPoint;
+		Region aContent, aBound;
+
+        // use the full extent of the control
+		Region aArea( Rectangle(aPoint, pBorder->GetOutputSizePixel()) );
+
+		if ( GetNativeControlRegion(CTRL_COMBOBOX, PART_BUTTON_DOWN,
+				aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+		{
+            // convert back from border space to local coordinates
+            aPoint = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aPoint ) );
+            aContent.Move(-aPoint.X(), -aPoint.Y());
+
+			// use the themes drop down size for the button
+            aOutSz.Width() = aContent.GetBoundRect().Left();
+		    mpBtn->SetPosSizePixel( aContent.GetBoundRect().Left(), nTop, aContent.GetBoundRect().getWidth(), (nBottom-nTop) );
+
+            // adjust the size of the edit field
+            if ( GetNativeControlRegion(CTRL_COMBOBOX, PART_SUB_EDIT,
+                        aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+            {
+                // convert back from border space to local coordinates
+                aContent.Move(-aPoint.X(), -aPoint.Y());
+
+                // use the themes drop down size
+                Rectangle aContentRect = aContent.GetBoundRect();
+                mpSubEdit->SetPosSizePixel( aContentRect.TopLeft(), aContentRect.GetSize() );
+            }
+            else
+                mpSubEdit->SetSizePixel( aOutSz );
+		}
+		else
+        {
+            nSBWidth = CalcZoom( nSBWidth );
+		    mpSubEdit->SetSizePixel( Size( aOutSz.Width() - nSBWidth, aOutSz.Height() ) );
+		    mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, nTop, nSBWidth, (nBottom-nTop) );
+        }
 	}
 	else
 	{
@@ -768,6 +807,8 @@
 		}
 		Resize();
 		mpImplLB->Resize(); // Wird nicht durch ComboBox::Resize() gerufen, wenn sich die ImplLB nicht aendert.
+        SetBackground();    // due to a hack in Window::UpdateSettings the background must be reset 
+                            // otherwise it will overpaint NWF drawn comboboxes
 	}
 }
 
unchanged:
--- vcl/source/control/ctrl.cxx	4 Jun 2003 11:21:43 -0000	1.10
+++ vcl/source/control/ctrl.cxx	3 Mar 2004 15:32:07 -0000
@@ -79,6 +79,9 @@
 #ifndef _VCL_CONTROLLAYOUT_HXX
 #include <controllayout.hxx>
 #endif
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
 
 #pragma hdrstop
 
unchanged:
--- vcl/source/control/edit.cxx	3 Mar 2004 15:32:07 -0000
+++ vcl/source/control/edit.cxx	2004-03-11 14:33:37.000000000 +0100
@@ -390,18 +390,26 @@
     if( Application::GetSettings().GetLayoutRTL() )
         mnAlign	= EDIT_ALIGN_RIGHT;
 
-	if ( nStyle & WB_RIGHT )
-		mnAlign = EDIT_ALIGN_RIGHT;
-	else if ( nStyle & WB_CENTER )
-		mnAlign = EDIT_ALIGN_CENTER;
-
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
-	SetBackground( Wallpaper( rStyleSettings.GetFieldColor() ) );
-	SetFillColor( rStyleSettings.GetFieldColor() );
-	SetCursor( new Cursor );
+    if ( nStyle & WB_RIGHT )
+        mnAlign = EDIT_ALIGN_RIGHT;
+    else if ( nStyle & WB_CENTER )
+        mnAlign = EDIT_ALIGN_CENTER;
+
+    const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
+    if ( IsNativeControlSupported(ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE) )
+    {
+        SetBackground();
+        SetFillColor();
+    }
+    else
+    {
+        SetBackground( Wallpaper( rStyleSettings.GetFieldColor() ) );
+        SetFillColor( rStyleSettings.GetFieldColor() );
+    }
+    SetCursor( new Cursor );
 
-	SetPointer( Pointer( POINTER_TEXT ) );
-	ImplInitSettings( TRUE, TRUE, TRUE );
+    SetPointer( Pointer( POINTER_TEXT ) );
+    ImplInitSettings( TRUE, TRUE, TRUE );
 
     uno::Reference< datatransfer::dnd::XDragGestureListener> xDGL( mxDnDListener, uno::UNO_QUERY );
     uno::Reference< datatransfer::dnd::XDragGestureRecognizer > xDGR = GetDragGestureRecognizer();
@@ -470,7 +478,13 @@
 
 	if ( bBackground )
 	{
-		if( IsControlBackground() )
+		if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		{
+			// Transparent background
+			SetBackground();
+			SetFillColor();
+		}
+		else if ( IsControlBackground() )
 		{
 			SetBackground( GetControlBackground() );
 			SetFillColor( GetControlBackground() );
@@ -576,7 +590,11 @@
 	else
 		SetTextColor( rStyleSettings.GetDisableColor() );
 
-	SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
+	// Set background color of the normal text
+	if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		SetTextFillColor();
+	else
+		SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
 
 	BOOL bDrawSelection = maSelection.Len() && ( HasFocus() || ( GetStyle() & WB_NOHIDESELECTION ) || mbActivePopup );
 
@@ -619,8 +637,14 @@
         // draw normal text
         Color aNormalTextColor = GetTextColor();
         SetClipRegion( aNormalClipRegion );
-        SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
+
+	    // Set background color when part of the text is selected
+	    if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		    SetTextFillColor();
+	    else
+		    SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
 		DrawText( aPos, aText, nStart, nEnd - nStart );
+
         // draw highlighted text
         SetClipRegion( aHiglightClipRegion );
         SetTextColor( rStyleSettings.GetHighlightTextColor() );
@@ -853,6 +877,51 @@
 
 // -----------------------------------------------------------------------
 
+int Edit::ImplGetNativeControlType()
+{
+    int nCtrl = 0;
+    Window *pControl = mbIsSubEdit ? GetParent() : this;
+
+    switch( pControl->GetType() )
+    {
+        case WINDOW_COMBOBOX:
+        case WINDOW_PATTERNBOX:			
+        case WINDOW_NUMERICBOX:			
+        case WINDOW_METRICBOX:			
+        case WINDOW_CURRENCYBOX:
+        case WINDOW_DATEBOX:		
+        case WINDOW_TIMEBOX:			
+        case WINDOW_LONGCURRENCYBOX:
+            nCtrl = CTRL_COMBOBOX;
+            break;
+
+        case WINDOW_EDIT:
+        case WINDOW_MULTILINEEDIT:
+        case WINDOW_PATTERNFIELD:
+        case WINDOW_METRICFIELD:
+        case WINDOW_CURRENCYFIELD:
+        case WINDOW_DATEFIELD:
+        case WINDOW_TIMEFIELD:
+        case WINDOW_LONGCURRENCYFIELD:
+        case WINDOW_NUMERICFIELD:
+        case WINDOW_SPINFIELD:
+            if( pControl->GetStyle() & WB_SPIN )
+                nCtrl = CTRL_SPINBOX;
+            else
+            {
+                if ( GetWindow( WINDOW_BORDER ) != this )
+                    nCtrl = CTRL_EDITBOX;
+                else
+                    nCtrl = CTRL_EDITBOX_NOBORDER;
+            }
+            break;
+
+        default:
+            nCtrl = CTRL_EDITBOX;
+    }
+    return nCtrl;
+}
+
 void Edit::ImplClearBackground( long nXStart, long nXEnd )
 {
 	Point aTmpPoint;
@@ -865,7 +934,43 @@
 	if ( pCursor )
 		pCursor->Hide();
 
-	Erase( aRect );
+    if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+    {
+        // draw the inner part by painting the whole control using its border window
+        Window *pControl = this;
+        Window *pBorder = GetWindow( WINDOW_BORDER );
+        if( pBorder == this )
+        {
+            // we have no border, use parent
+            pControl = mbIsSubEdit ? GetParent() : this;
+            pBorder = pControl->GetWindow( WINDOW_BORDER );
+        }
+        
+        if( pBorder )
+        {
+            // set proper clipping region to not overdraw the whole control
+            Region aClipRgn = GetPaintRegion();
+            if( !aClipRgn.IsNull() )
+            {
+                // transform clipping region to border window's coordinate system
+                Point aBorderOffs;
+                aBorderOffs = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aBorderOffs ) );
+                aClipRgn.Move( aBorderOffs.X(), aBorderOffs.Y() );
+
+                Region oldRgn( pBorder->GetClipRegion() );
+                pBorder->SetClipRegion( aClipRgn );
+
+                pBorder->Paint( Rectangle() );
+
+                pBorder->SetClipRegion( oldRgn );
+            }
+            else
+                pBorder->Paint( Rectangle() );
+
+        }
+    }
+    else
+	    Erase( aRect );
 
 	if ( pCursor )
 		pCursor->Show();
unchanged:
--- vcl/source/control/fixbrd.cxx	18 Sep 2000 17:05:36 -0000	1.1.1.1
+++ vcl/source/control/fixbrd.cxx	3 Mar 2004 15:32:07 -0000
@@ -164,8 +164,21 @@ void FixedBorder::ImplDraw( OutputDevice
 		 (rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
 		nBorderStyle |= FRAME_DRAW_MONO;
 
-	DecorationView	aDecoView( pDev );
-	aDecoView.DrawFrame( aRect, nBorderStyle );
+    Window *pWin = pDev->GetOutDevType() == OUTDEV_WINDOW ? (Window*) pDev : NULL;
+    if( !(nBorderStyle & FRAME_DRAW_MONO) && pWin && pWin->IsNativeControlSupported( CTRL_FIXEDBORDER, PART_ENTIRE_CONTROL ) )
+    {
+        ImplControlValue aControlValue;
+        Point aPt;
+        Region aCtrlRegion( Rectangle( aPt, GetOutputSizePixel() ) );
+        ControlState nState = IsEnabled() ? CTRL_STATE_ENABLED : 0;
+        pWin->DrawNativeControl( CTRL_FIXEDBORDER, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     						aControlValue, rtl::OUString() );
+    }
+    else
+    {
+	    DecorationView	aDecoView( pDev );
+	    aDecoView.DrawFrame( aRect, nBorderStyle );
+    }
 }
 
 // -----------------------------------------------------------------------
unchanged:
--- vcl/source/control/ilstbox.cxx	24 Apr 2003 16:31:26 -0000	1.41
+++ vcl/source/control/ilstbox.cxx	3 Mar 2004 15:32:07 -0000
@@ -149,10 +149,14 @@ void ImplInitDropDownButton( PushButton*
 		pButton->SetSymbol( SYMBOL_SPIN_UPDOWN );
 	else
 		pButton->SetSymbol( SYMBOL_SPIN_DOWN );
+
+	if ( pButton->IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! pButton->IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+		pButton->SetBackground();
 }
 
 // =======================================================================
-
+
 ImplEntryList::ImplEntryList( Window* pWindow )
 {
     mpWindow = pWindow;
@@ -1926,6 +1930,9 @@ ImplListBox::ImplListBox( Window* pParen
 	Control( pParent, nWinStyle ),
 	maLBWindow( this, nWinStyle&(~WB_BORDER) )
 {
+    // for native widget rendering we must be able to detect this window type
+    SetType( WINDOW_LISTBOXWINDOW );
+
 	mpVScrollBar	= new ScrollBar( this, WB_VSCROLL | WB_DRAG );
 	mpHScrollBar	= new ScrollBar( this, WB_HSCROLL | WB_DRAG );
 	mpScrollBarBox	= new ScrollBarBox( this );
@@ -2390,7 +2397,12 @@ XubString ImplListBox::GetMRUEntries( xu
 ImplWin::ImplWin( Window* pParent, WinBits nWinStyle ) :
 	Control ( pParent, nWinStyle )
 {
-	SetBackground( Wallpaper( GetSettings().GetStyleSettings().GetFieldColor() ) );
+	if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+		SetBackground();
+	else
+		SetBackground( Wallpaper( GetSettings().GetStyleSettings().GetFieldColor() ) );
+
 	mbInUserDraw = FALSE;
 	mbUserDrawEnabled = FALSE;
 	mnItemPos = LISTBOX_ENTRY_NOTFOUND;
@@ -2448,12 +2460,76 @@ void ImplWin::FillLayoutData() const
 
 // -----------------------------------------------------------------------
 
+long ImplWin::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( pMouseEvt->IsEnterWindow() || pMouseEvt->IsLeaveWindow() )
+        {
+            // trigger redraw as mouse over state has changed
+            if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+            {
+                GetParent()->GetWindow( WINDOW_BORDER )->Invalidate( INVALIDATE_NOERASE );
+                GetParent()->GetWindow( WINDOW_BORDER )->Update();
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void ImplWin::ImplDraw( bool bLayout )
 {
 	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 
+    BOOL bNativeOK = FALSE;
+
     if( ! bLayout )
     {
+        if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+        {
+	        // Repaint the (focused) area similarly to
+	        // ImplSmallBorderWindowView::DrawWindow() in
+	        // vcl/source/window/brdwin.cxx
+	        Window *pWin = GetParent();
+
+	        ImplControlValue aControlValue;
+	        ControlState nState = CTRL_STATE_ENABLED;
+	        if ( !pWin->IsEnabled() )
+		    nState &= ~CTRL_STATE_ENABLED;
+	        if ( pWin->HasFocus() )
+		    nState |= CTRL_STATE_FOCUSED;
+    	    
+	        // The listbox is painted over the entire control including the
+	        // border, but ImplWin does not contain the border => correction
+	        // needed.
+	        long nLeft, nTop, nRight, nBottom;
+	        pWin->GetBorder( nLeft, nTop, nRight, nBottom );
+	        Point aPoint( -nLeft, -nTop );
+	        Region aCtrlRegion( Rectangle( aPoint - GetPosPixel(), pWin->GetSizePixel() ) );
+
+            BOOL bMouseOver = FALSE;
+            if( GetParent() )
+            {
+                Window *pChild = GetParent()->GetWindow( WINDOW_FIRSTCHILD );
+                while( pChild && !(bMouseOver = pChild->IsMouseOver()) )
+                    pChild = pChild->GetWindow( WINDOW_NEXT );
+            }
+    	    
+            if( bMouseOver )
+                nState |= CTRL_STATE_ROLLOVER;
+
+	        bNativeOK = DrawNativeControl( CTRL_LISTBOX, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+		        aControlValue, rtl::OUString() );
+	    }
+
         if( IsEnabled() )
         {
             if( HasFocus() )
@@ -2468,13 +2544,15 @@ void ImplWin::ImplDraw( bool bLayout )
                 if( IsControlForeground() )
                     aColor = GetControlForeground();
                 SetTextColor( aColor );
-                Erase( maFocusRect );
+		        if ( !bNativeOK )
+		            Erase( maFocusRect );
             }
         }
         else // Disabled
         {
             SetTextColor( rStyleSettings.GetDisableColor() );
-            Erase( maFocusRect );
+	        if ( !bNativeOK )
+		        Erase( maFocusRect );
         }
     }
 
@@ -2594,7 +2672,7 @@ void ImplWin::LoseFocus()
 }
 
 // =======================================================================
-
+
 ImplBtn::ImplBtn( Window* pParent, WinBits nWinStyle ) :
 	PushButton(  pParent, nWinStyle ),
 	mbDown	( FALSE )
diff -u vcl/source/control/lstbox.cxx vcl/source/control/lstbox.cxx
--- vcl/source/control/lstbox.cxx	3 Mar 2004 15:32:07 -0000
+++ vcl/source/control/lstbox.cxx	2004-03-17 17:25:30.000000000 +0100
@@ -547,6 +547,8 @@
 		 ((rDCEvt.GetType() == DATACHANGED_SETTINGS) &&
 		  (rDCEvt.GetFlags() & SETTINGS_STYLE)) )
 	{
+        SetBackground();    // due to a hack in Window::UpdateSettings the background must be reset 
+                            // otherwise it will overpaint NWF drawn listboxes
 		Resize();
 		mpImplLB->Resize(); // Wird nicht durch ListBox::Resize() gerufen, wenn sich die ImplLB nicht aendert.
 
@@ -639,10 +641,50 @@
 	Size aOutSz = GetOutputSizePixel();
 	if( IsDropDownBox() )
 	{
+		// initialize the dropdown button size with the standard scrollbar width
 		long nSBWidth = GetSettings().GetStyleSettings().GetScrollBarSize();
-		nSBWidth = CalcZoom( nSBWidth );
-		mpImplWin->SetPosSizePixel( 0, 0, aOutSz.Width() - nSBWidth, aOutSz.Height() );
-		mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		long	nTop = 0;
+		long	nBottom = aOutSz.Height();
+
+		Window *pBorder = GetWindow( WINDOW_BORDER );
+		ImplControlValue aControlValue;
+		Point aPoint;
+		Region aContent, aBound;
+
+		// use the full extent of the control
+		Region aArea( Rectangle(aPoint, pBorder->GetOutputSizePixel()) );
+
+		if ( GetNativeControlRegion( CTRL_LISTBOX, PART_BUTTON_DOWN,
+					aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+		{
+			// convert back from border space to local coordinates
+			aPoint = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aPoint ) );
+			aContent.Move( -aPoint.X(), -aPoint.Y() );
+
+			// use the themes drop down size for the button
+			aOutSz.Width() = aContent.GetBoundRect().Left();
+			mpBtn->SetPosSizePixel( aContent.GetBoundRect().Left(), nTop, aContent.GetBoundRect().Right(), (nBottom-nTop) );
+
+			// adjust the size of the edit field
+			if ( GetNativeControlRegion( CTRL_LISTBOX, PART_SUB_EDIT,
+						aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+			{
+				// convert back from border space to local coordinates
+				aContent.Move( -aPoint.X(), -aPoint.Y() );
+
+				// use the themes drop down size
+				Rectangle aContentRect = aContent.GetBoundRect();
+				mpImplWin->SetPosSizePixel( aContentRect.TopLeft(), aContentRect.GetSize() );
+			}
+			else
+				mpImplWin->SetSizePixel( aOutSz );
+		}
+		else
+		{
+			nSBWidth = CalcZoom( nSBWidth );
+			mpImplWin->SetPosSizePixel( 0, 0, aOutSz.Width() - nSBWidth, aOutSz.Height() );
+			mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		}
 	}
 	else
 	{
@@ -698,7 +740,13 @@
 		if( mpImplWin )
 		{
 			mpImplWin->Enable( IsEnabled() );
-			mpImplWin->Invalidate();
+			if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+					&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+			{
+				GetWindow( WINDOW_BORDER )->Invalidate( INVALIDATE_NOERASE );
+			}
+			else
+				mpImplWin->Invalidate();
 		}
 		if( mpBtn )
 			mpBtn->Enable( IsEnabled() );
@@ -745,8 +793,17 @@
 		mpImplLB->SetControlBackground( GetControlBackground() );
 		if ( mpImplWin )
 		{
-			mpImplWin->SetBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
-			mpImplWin->SetControlBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+			if ( mpImplWin->IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL) )
+			{
+				// Transparent background
+				mpImplWin->SetBackground();
+				mpImplWin->SetControlBackground();
+			}
+			else
+			{
+				mpImplWin->SetBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+				mpImplWin->SetControlBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+			}
 			mpImplWin->SetFont( mpImplLB->GetMainWindow()->GetFont() );
 			mpImplWin->Invalidate();
 		}
unchanged:
--- vcl/source/control/scrbar.cxx	19 Jul 2002 11:12:18 -0000	1.8
+++ vcl/source/control/scrbar.cxx	3 Mar 2004 15:32:07 -0000
@@ -74,12 +74,18 @@
 #include <scrbar.hxx>
 #endif
 
+#ifndef _RTL_STRING_HXX_
+#include <rtl/string.hxx>
+#endif
+
 #ifndef _SV_RC_H
 #include <rc.h>
 #endif
 
 #pragma hdrstop
 
+using namespace rtl;
+
 // =======================================================================
 
 static long ImplMulDiv( long nNumber, long nNumerator, long nDenominator )
@@ -95,9 +101,10 @@ static long ImplMulDiv( long nNumber, lo
 #define SCRBAR_DRAW_PAGE1           ((USHORT)0x0004)
 #define SCRBAR_DRAW_PAGE2           ((USHORT)0x0008)
 #define SCRBAR_DRAW_THUMB           ((USHORT)0x0010)
+#define SCRBAR_DRAW_BACKGROUND      ((USHORT)0x0020)
 #define SCRBAR_DRAW_ALL             (SCRBAR_DRAW_BTN1 | SCRBAR_DRAW_BTN2 |  \
                                      SCRBAR_DRAW_PAGE1 | SCRBAR_DRAW_PAGE2 |\
-                                     SCRBAR_DRAW_THUMB)
+                                     SCRBAR_DRAW_THUMB | SCRBAR_DRAW_BACKGROUND )
 
 #define SCRBAR_STATE_BTN1_DOWN      ((USHORT)0x0001)
 #define SCRBAR_STATE_BTN1_DISABLE   ((USHORT)0x0002)
@@ -263,10 +270,15 @@ void ScrollBar::ImplUpdateRects( BOOL bU
         }
     }
 
-    if ( mnThumbPos == mnMinRange )
-        mnStateFlags |= SCRBAR_STATE_BTN1_DISABLE;
-    if ( mnThumbPos >= (mnMaxRange-mnVisibleSize) )
-        mnStateFlags |= SCRBAR_STATE_BTN2_DISABLE;
+    if( !IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+    {
+        // disable scrollbar buttons only in VCL's own 'theme'
+        // as it is uncommon on other platforms
+        if ( mnThumbPos == mnMinRange )
+            mnStateFlags |= SCRBAR_STATE_BTN1_DISABLE;
+        if ( mnThumbPos >= (mnMaxRange-mnVisibleSize) )
+            mnStateFlags |= SCRBAR_STATE_BTN2_DISABLE;
+    }
 
     if ( bUpdate )
     {
@@ -333,6 +345,10 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
         Size    aSize = GetOutputSizePixel();
         Size    aBtnSize;
 
+        Point aPoint( 0, 0 );
+        Region aControlRegion( Rectangle( aPoint, aSize ) );
+        Region aBtn1Region, aBtn2Region, aBoundingRegion;
+
         if ( GetStyle() & WB_HORZ )
         {
             if ( aSize.Height()*2 > aSize.Width()-SCRBAR_MIN_THUMB )
@@ -346,11 +362,22 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
             }
             else
             {
-                mnThumbPixRange         = aSize.Width()-(aSize.Height()*2);
-                aBtnSize                = Size( aSize.Height(), aSize.Height() );
-                maBtn2Rect.Left()       = aSize.Width()-aSize.Height();
-                maBtn1Rect.SetSize( aBtnSize );
-                maBtn2Rect.SetSize( aBtnSize );
+                if ( GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_LEFT,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn1Region ) &&
+                     GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_RIGHT,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn2Region ) )
+                {
+                    maBtn1Rect = aBtn1Region.GetBoundRect();
+                    maBtn2Rect = aBtn2Region.GetBoundRect();
+                }
+                else
+                {
+                    aBtnSize                = Size( aSize.Height(), aSize.Height() );
+                    maBtn2Rect.Left()       = aSize.Width()-aSize.Height();
+                    maBtn1Rect.SetSize( aBtnSize );
+                    maBtn2Rect.SetSize( aBtnSize );
+                }
+                mnThumbPixRange         = aSize.Width() - maBtn1Rect.GetWidth() - maBtn2Rect.GetWidth();
                 maPage1Rect.Left()      = maBtn1Rect.Right()+1;
                 maPage1Rect.Bottom()    = maBtn1Rect.Bottom();
                 maPage2Rect.Bottom()    = maBtn1Rect.Bottom();
@@ -370,11 +397,22 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
             }
             else
             {
-                mnThumbPixRange         = aSize.Height()-(aSize.Width()*2);
-                aBtnSize                = Size( aSize.Width(), aSize.Width() );
-                maBtn2Rect.Top()        = aSize.Height()-aSize.Width();
-                maBtn1Rect.SetSize( aBtnSize );
-                maBtn2Rect.SetSize( aBtnSize );
+                if ( GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_UP,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn1Region ) &&
+                     GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_DOWN,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn2Region ) )
+                {
+                    maBtn1Rect = aBtn1Region.GetBoundRect();
+                    maBtn2Rect = aBtn2Region.GetBoundRect();
+                }
+                else
+                {
+                    aBtnSize                = Size( aSize.Width(), aSize.Width() );
+                    maBtn2Rect.Top()        = aSize.Height()-aSize.Width();
+                    maBtn1Rect.SetSize( aBtnSize );
+                    maBtn2Rect.SetSize( aBtnSize );
+                }
+                mnThumbPixRange         = aSize.Height() - maBtn1Rect.GetHeight() - maBtn2Rect.GetHeight();
                 maPage1Rect.Top()       = maBtn1Rect.Bottom()+1;
                 maPage1Rect.Right()     = maBtn1Rect.Right();
                 maPage2Rect.Right()     = maBtn1Rect.Right();
@@ -434,6 +472,172 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
 
 // -----------------------------------------------------------------------
 
+BOOL ScrollBar::ImplDrawNative( USHORT nDrawFlags )
+{
+    BOOL bNativeOK = FALSE;
+    ImplControlValue aControlValue( BUTTONVALUE_DONTKNOW, rtl::OUString(), 0 );
+
+    if( bNativeOK = IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+    {
+        BOOL bHorz = (GetStyle() & WB_HORZ ? true : false);
+
+        // Draw the entire background if the control supports it
+        if( IsNativeControlSupported(CTRL_SCROLLBAR, bHorz ? PART_DRAW_BACKGROUND_HORZ : PART_DRAW_BACKGROUND_VERT) )
+        {
+            Region  		aCtrlRegion;
+            ControlState		nState = ( IsEnabled() ? CTRL_STATE_ENABLED : 0 ) | ( HasFocus() ? CTRL_STATE_FOCUSED : 0 );
+            ScrollbarValue	scrValue;
+
+            scrValue.mnMin = mnMinRange;
+            scrValue.mnMax = mnMaxRange;
+            scrValue.mnCur = mnThumbPos;
+            scrValue.mnVisibleSize = mnVisibleSize;
+            scrValue.maThumbRect = maThumbRect;
+            scrValue.maButton1Rect = maBtn1Rect;
+            scrValue.maButton2Rect = maBtn2Rect;
+            scrValue.mnButton1State = ((mnStateFlags & SCRBAR_STATE_BTN1_DOWN) ? CTRL_STATE_PRESSED : 0) |
+								((!(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE)) ? CTRL_STATE_ENABLED : 0);
+            scrValue.mnButton2State = ((mnStateFlags & SCRBAR_STATE_BTN2_DOWN) ? CTRL_STATE_PRESSED : 0) |
+								((!(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE)) ? CTRL_STATE_ENABLED : 0);
+            scrValue.mnThumbState = nState | ((mnStateFlags & SCRBAR_STATE_THUMB_DOWN) ? CTRL_STATE_PRESSED : 0);
+            scrValue.mnPage1State = nState | ((mnStateFlags & SCRBAR_STATE_PAGE1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            scrValue.mnPage2State = nState | ((mnStateFlags & SCRBAR_STATE_PAGE2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maThumbRect )
+                        scrValue.mnThumbState |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn1Rect )
+                        scrValue.mnButton1State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn2Rect )
+                        scrValue.mnButton2State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage1Rect )
+                        scrValue.mnPage1State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage2Rect )
+                        scrValue.mnPage2State |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            aControlValue.setOptionalVal( (void *)(&scrValue) );
+
+            aCtrlRegion.Union( maBtn1Rect );
+            aCtrlRegion.Union( maBtn2Rect );
+            aCtrlRegion.Union( maPage1Rect );
+            aCtrlRegion.Union( maPage2Rect );
+            aCtrlRegion.Union( maThumbRect );
+
+            bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, (bHorz ? PART_DRAW_BACKGROUND_HORZ : PART_DRAW_BACKGROUND_VERT),
+                            aCtrlRegion, nState, aControlValue, rtl::OUString() );
+        }
+        else
+      {
+        if ( (nDrawFlags & SCRBAR_DRAW_PAGE1) || (nDrawFlags & SCRBAR_DRAW_PAGE2) )
+        {
+            sal_uInt32	part1 = bHorz ? PART_TRACK_HORZ_LEFT : PART_TRACK_VERT_UPPER;
+            sal_uInt32	part2 = bHorz ? PART_TRACK_HORZ_RIGHT : PART_TRACK_VERT_LOWER;
+            Region  	aCtrlRegion1( maPage1Rect );
+            Region  	aCtrlRegion2( maPage2Rect );
+            ControlState nState1 = (IsEnabled() ? CTRL_STATE_ENABLED : 0) | (HasFocus() ? CTRL_STATE_FOCUSED : 0);
+            ControlState nState2 = nState1;
+
+            nState1 |= ((mnStateFlags & SCRBAR_STATE_PAGE1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            nState2 |= ((mnStateFlags & SCRBAR_STATE_PAGE2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maPage1Rect )
+                        nState1 |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage2Rect )
+                        nState2 |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            if ( nDrawFlags & SCRBAR_DRAW_PAGE1 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part1, aCtrlRegion1, nState1, 
+                                aControlValue, rtl::OUString() );
+
+            if ( nDrawFlags & SCRBAR_DRAW_PAGE2 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part2, aCtrlRegion2, nState2, 
+                                aControlValue, rtl::OUString() );
+        }
+        if ( (nDrawFlags & SCRBAR_DRAW_BTN1) || (nDrawFlags & SCRBAR_DRAW_BTN2) )
+        {
+            sal_uInt32	part1 = bHorz ? PART_BUTTON_LEFT : PART_BUTTON_UP;
+            sal_uInt32	part2 = bHorz ? PART_BUTTON_RIGHT : PART_BUTTON_DOWN;
+            Region  	aCtrlRegion1( maBtn1Rect );
+            Region  	aCtrlRegion2( maBtn2Rect );
+            ControlState nState1 = HasFocus() ? CTRL_STATE_FOCUSED : 0;
+            ControlState nState2 = nState1;
+
+            if ( !Window::IsEnabled() || !IsEnabled() )
+                nState1 = (nState2 &= ~CTRL_STATE_ENABLED);
+            else
+                nState1 = (nState2 |= CTRL_STATE_ENABLED);
+
+
+            nState1 |= ((mnStateFlags & SCRBAR_STATE_BTN1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            nState2 |= ((mnStateFlags & SCRBAR_STATE_BTN2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE)
+                nState1 &= ~CTRL_STATE_ENABLED;
+            if(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE)
+                nState2 &= ~CTRL_STATE_ENABLED;
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maBtn1Rect )
+                        nState1 |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn2Rect )
+                        nState2 |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            if ( nDrawFlags & SCRBAR_DRAW_BTN1 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part1, aCtrlRegion1, nState1, 
+                                aControlValue, rtl::OUString() );
+
+            if ( nDrawFlags & SCRBAR_DRAW_BTN2 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part2, aCtrlRegion2, nState2, 
+                                aControlValue, rtl::OUString() );
+        }
+        if ( (nDrawFlags & SCRBAR_DRAW_THUMB) && !maThumbRect.IsEmpty() )
+        {
+            ControlState	nState = IsEnabled() ? CTRL_STATE_ENABLED : 0;
+            Region		aCtrlRegion( maThumbRect );
+
+            if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
+                nState |= CTRL_STATE_PRESSED;
+
+            if ( HasFocus() )
+                nState |= CTRL_STATE_FOCUSED;
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maThumbRect )
+                        nState |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, (bHorz ? PART_THUMB_HORZ : PART_THUMB_VERT),
+                    aCtrlRegion, nState, aControlValue, rtl::OUString() );
+        }
+      }
+    }
+    return bNativeOK;
+}
+
 void ScrollBar::ImplDraw( USHORT nDrawFlags )
 {
     DecorationView          aDecoView( this );
@@ -447,7 +651,14 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
     if ( mbCalcSize )
         ImplCalc( FALSE );
 
-    if ( nDrawFlags & SCRBAR_DRAW_BTN1 )
+    // Draw the entire control if the native theme engine needs it
+    if ( nDrawFlags && IsNativeControlSupported(CTRL_SCROLLBAR, PART_DRAW_BACKGROUND_HORZ) )
+    {
+        ImplDrawNative( SCRBAR_DRAW_BACKGROUND );
+        return;
+    }
+
+    if( (nDrawFlags & SCRBAR_DRAW_BTN1) && !ImplDrawNative( SCRBAR_DRAW_BTN1 ) )
     {
         nStyle = BUTTON_DRAW_NOLIGHTBORDER;
         if ( mnStateFlags & SCRBAR_STATE_BTN1_DOWN )
@@ -474,7 +685,7 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
         aDecoView.DrawSymbol( aTempRect, eSymbolType, rStyleSettings.GetButtonTextColor(), nStyle );
     }
 
-    if ( nDrawFlags & SCRBAR_DRAW_BTN2 )
+    if ( (nDrawFlags & SCRBAR_DRAW_BTN2) && !ImplDrawNative( SCRBAR_DRAW_BTN2 ) )
     {
         nStyle = BUTTON_DRAW_NOLIGHTBORDER;
         if ( mnStateFlags & SCRBAR_STATE_BTN2_DOWN )
@@ -503,17 +714,19 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
 
     SetLineColor();
 
-    if ( nDrawFlags & SCRBAR_DRAW_THUMB )
+    if ( (nDrawFlags & SCRBAR_DRAW_THUMB) && !ImplDrawNative( SCRBAR_DRAW_THUMB ) )
     {
         if ( !maThumbRect.IsEmpty() )
         {
             if ( bEnabled )
             {
                 nStyle = BUTTON_DRAW_NOLIGHTBORDER;
-                if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
-                    nStyle |= BUTTON_DRAW_PRESSED;
+                // pressed thumbs only in OS2 style
+                if ( rStyleSettings.GetOptions() & STYLE_OPTION_OS2STYLE )
+                    if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
+                        nStyle |= BUTTON_DRAW_PRESSED;
                 aTempRect = aDecoView.DrawButton( maThumbRect, nStyle );
-                // Im OS2-Look geben wir auch ein Muster auf dem Thumb aus
+                // OS2 style requires pattern on the thumb
                 if ( rStyleSettings.GetOptions() & STYLE_OPTION_OS2STYLE )
                 {
                     if ( GetStyle() & WB_HORZ )
@@ -575,7 +788,7 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
         }
     }
 
-    if ( nDrawFlags & SCRBAR_DRAW_PAGE1 )
+    if ( (nDrawFlags & SCRBAR_DRAW_PAGE1) && !ImplDrawNative( SCRBAR_DRAW_PAGE1 ) )
     {
         if ( mnStateFlags & SCRBAR_STATE_PAGE1_DOWN )
             SetFillColor( rStyleSettings.GetShadowColor() );
@@ -583,7 +796,7 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
             SetFillColor( rStyleSettings.GetCheckedColor() );
         DrawRect( maPage1Rect );
     }
-    if ( nDrawFlags & SCRBAR_DRAW_PAGE2 )
+    if ( (nDrawFlags & SCRBAR_DRAW_PAGE2) && !ImplDrawNative( SCRBAR_DRAW_PAGE2 ) )
     {
         if ( mnStateFlags & SCRBAR_STATE_PAGE2_DOWN )
             SetFillColor( rStyleSettings.GetShadowColor() );
@@ -645,11 +858,19 @@ void ScrollBar::ImplDoMouseAction( const
 {
     USHORT  nOldStateFlags = mnStateFlags;
     BOOL    bAction = FALSE;
+    BOOL    bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+    BOOL    bIsInside = FALSE;
+
+    Point aPoint( 0, 0 );
+    Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
 
     switch ( meScrollType )
     {
         case SCROLL_LINEUP:
-            if ( maBtn1Rect.IsInside( rMousePos ) )
+            if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                        aControlRegion, rMousePos, bIsInside )?
+                    bIsInside:
+                    maBtn1Rect.IsInside( rMousePos ) )
             {
                 bAction = bCallAction;
                 mnStateFlags |= SCRBAR_STATE_BTN1_DOWN;
@@ -659,7 +880,10 @@ void ScrollBar::ImplDoMouseAction( const
             break;
 
         case SCROLL_LINEDOWN:
-            if ( maBtn2Rect.IsInside( rMousePos ) )
+            if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                        aControlRegion, rMousePos, bIsInside )?
+                    bIsInside:
+                    maBtn2Rect.IsInside( rMousePos ) )
             {
                 bAction = bCallAction;
                 mnStateFlags |= SCRBAR_STATE_BTN2_DOWN;
@@ -703,8 +927,16 @@ void ScrollBar::MouseButtonDown( const M
     {
         const Point&    rMousePos = rMEvt.GetPosPixel();
         USHORT          nTrackFlags = 0;
+        BOOL            bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+        BOOL            bIsInside = FALSE;
+
+        Point aPoint( 0, 0 );
+        Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
 
-        if ( maBtn1Rect.IsInside( rMousePos ) )
+        if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                    aControlRegion, rMousePos, bIsInside )?
+                bIsInside:
+                maBtn1Rect.IsInside( rMousePos ) )
         {
             if ( !(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE) )
             {
@@ -715,7 +947,10 @@ void ScrollBar::MouseButtonDown( const M
             else
                 Sound::Beep( SOUND_DISABLE, this );
         }
-        else if ( maBtn2Rect.IsInside( rMousePos ) )
+        else if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                    aControlRegion, rMousePos, bIsInside )?
+                bIsInside:
+                maBtn2Rect.IsInside( rMousePos ) )
         {
             if ( !(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE) )
             {
@@ -740,12 +975,8 @@ void ScrollBar::MouseButtonDown( const M
                 else
                     mnMouseOff = rMousePos.Y()-maThumbRect.Top();
 
-                // Im OS2-Look geben wir den Thumb gedrueck aus
-                if ( GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_OS2STYLE )
-                {
-                    mnStateFlags |= SCRBAR_STATE_THUMB_DOWN;
-                    ImplDraw( mnDragDraw );
-                }
+                mnStateFlags |= SCRBAR_STATE_THUMB_DOWN;
+                ImplDraw( mnDragDraw );
             }
             else
                 Sound::Beep( SOUND_DISABLE, this );
@@ -977,6 +1208,79 @@ void ScrollBar::DataChanged( const DataC
     if ( (rDCEvt.GetType() == DATACHANGED_SETTINGS) &&
          (rDCEvt.GetFlags() & SETTINGS_STYLE) )
         Invalidate();
+}
+
+// -----------------------------------------------------------------------
+
+Rectangle* ScrollBar::ImplFindPartRect( const Point& rPt )
+{
+    BOOL    bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+    BOOL    bIsInside = FALSE;
+
+    Point aPoint( 0, 0 );
+    Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
+
+    if( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                aControlRegion, rPt, bIsInside )?
+            bIsInside:
+            maBtn1Rect.IsInside( rPt ) )
+        return &maBtn1Rect;
+    else if( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                aControlRegion, rPt, bIsInside )?
+            bIsInside:
+            maBtn2Rect.IsInside( rPt ) )
+        return &maBtn2Rect;
+    else if( maPage1Rect.IsInside( rPt ) )
+        return &maPage1Rect;
+    else if( maPage2Rect.IsInside( rPt ) )
+        return &maPage2Rect;
+    else if( maThumbRect.IsInside( rPt ) )
+        return &maThumbRect;
+    else
+        return NULL;
+}
+
+long ScrollBar::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    Region aClipRegion;
+
+                    if ( pRect )
+                        aClipRegion.Union( *pRect );
+                    if ( pLastRect )
+                        aClipRegion.Union( *pLastRect );
+                    
+                    // Support for 3-button scroll bars
+                    BOOL bHas3Buttons = IsNativeControlSupported( CTRL_SCROLLBAR, HAS_THREE_BUTTONS );
+                    if ( bHas3Buttons && ( pRect == &maBtn1Rect || pLastRect == &maBtn1Rect ) )
+                    {
+                        aClipRegion.Union( maBtn2Rect );
+                    }
+
+                    SetClipRegion( aClipRegion );
+                    Paint( aClipRegion.GetBoundRect() );
+
+                    SetClipRegion( aRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
 }
 
 // -----------------------------------------------------------------------
unchanged:
--- vcl/source/control/spinbtn.cxx	8 May 2002 16:01:30 -0000	1.3
+++ vcl/source/control/spinbtn.cxx	3 Mar 2004 15:32:07 -0000
@@ -315,3 +315,55 @@ void SpinButton::StateChanged( StateChan
         Invalidate();
     Control::StateChanged( nType );
 }
+
+// -----------------------------------------------------------------------
+
+Rectangle* SpinButton::ImplFindPartRect( const Point& rPt )
+{
+    if( maUpperRect.IsInside( rPt ) )
+        return &maUpperRect;
+    else if( maLowerRect.IsInside( rPt ) )
+        return &maLowerRect;
+    else
+        return NULL;
+}
+
+long SpinButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) ||
+                IsNativeControlSupported(CTRL_SPINBOX, PART_ALL_BUTTONS) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    if( pLastRect )
+                    {
+                        SetClipRegion( *pLastRect );
+                        Paint( *pLastRect );
+                        SetClipRegion( aRgn );
+                    }
+                    if( pRect )
+                    {
+                        SetClipRegion( *pRect );
+                        Paint( *pRect );
+                        SetClipRegion( aRgn );
+                    }
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
unchanged:
--- vcl/source/control/spinfld.cxx	12 Sep 2002 08:35:13 -0000	1.10
+++ vcl/source/control/spinfld.cxx	3 Mar 2004 15:32:07 -0000
@@ -82,6 +82,112 @@
 
 // =======================================================================
 
+void ImplGetSpinbuttonValue( Window *pWin, const Rectangle& rUpperRect,
+                            const Rectangle& rLowerRect,
+                            BOOL bUpperIn, BOOL bLowerIn,
+                            BOOL bUpperEnabled, BOOL bLowerEnabled, BOOL bHorz,
+                            SpinbuttonValue& rValue )
+{
+    // convert spinbutton data to a SpinbuttonValue structure for native painting
+
+    rValue.maUpperRect = rUpperRect;
+    rValue.maLowerRect = rLowerRect;
+
+    // convert rectangles to screen coordinates
+    Point aPt = pWin->OutputToScreenPixel( rValue.maUpperRect.TopLeft() );
+    rValue.maUpperRect.SetPos( aPt );
+    aPt = pWin->OutputToScreenPixel( rValue.maLowerRect.TopLeft() );
+    rValue.maLowerRect.SetPos( aPt );
+
+    ControlState nState = CTRL_STATE_ENABLED;
+    if ( bUpperIn )
+        nState |= CTRL_STATE_PRESSED;
+    if ( !pWin->IsEnabled() || !bUpperEnabled )
+        nState &= ~CTRL_STATE_ENABLED;
+    if ( pWin->HasFocus() )
+        nState |= CTRL_STATE_FOCUSED;
+    if( pWin->IsMouseOver() && rUpperRect.IsInside( pWin->GetPointerPosPixel() ) )
+        nState |= CTRL_STATE_ROLLOVER;
+    rValue.mnUpperState = nState;
+
+    nState = CTRL_STATE_ENABLED;
+    if ( bLowerIn )
+        nState |= CTRL_STATE_PRESSED;
+    if ( !pWin->IsEnabled() || !bLowerEnabled )
+        nState &= ~CTRL_STATE_ENABLED;
+    if ( pWin->HasFocus() )
+        nState |= CTRL_STATE_FOCUSED;
+    // for overlapping spins: highlight only one
+    if( pWin->IsMouseOver() && rLowerRect.IsInside( pWin->GetPointerPosPixel() ) &&
+                              !rUpperRect.IsInside( pWin->GetPointerPosPixel() ) )
+        nState |= CTRL_STATE_ROLLOVER;
+    rValue.mnLowerState = nState;
+
+    rValue.mnUpperPart = bHorz ? PART_BUTTON_LEFT : PART_BUTTON_UP;
+    rValue.mnLowerPart = bHorz ? PART_BUTTON_RIGHT : PART_BUTTON_DOWN;
+}
+
+
+BOOL ImplDrawNativeSpinfield( Window *pWin, const SpinbuttonValue& rSpinbuttonValue )
+{
+    BOOL bNativeOK = FALSE;
+
+    if( pWin->IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) )
+    {
+        ImplControlValue aControlValue;
+        aControlValue.setOptionalVal( (void*) &rSpinbuttonValue );
+
+        if( pWin->IsNativeControlSupported(CTRL_SPINBOX, rSpinbuttonValue.mnUpperPart) && 
+            pWin->IsNativeControlSupported(CTRL_SPINBOX, rSpinbuttonValue.mnLowerPart) )
+        {
+            // only paint the embedded spin buttons, all buttons are painted at once
+            bNativeOK = pWin->DrawNativeControl( CTRL_SPINBOX, PART_ALL_BUTTONS, Region(), ControlState(),
+                        aControlValue, rtl::OUString() );
+        }
+        else
+        {
+            // paint the spinbox as a whole, use borderwindow to have proper clipping
+            Window *pBorder = pWin->GetWindow( WINDOW_BORDER );
+
+            // to not overwrite everything, set the button region as clipregion to the border window
+            Rectangle aClipRect( rSpinbuttonValue.maLowerRect );
+            aClipRect.Union( rSpinbuttonValue.maUpperRect );
+
+            // convert from screen space to borderwin space
+            aClipRect.SetPos( pBorder->ScreenToOutputPixel(aClipRect.TopLeft()) );
+
+            Region oldRgn( pBorder->GetClipRegion() );
+            pBorder->SetClipRegion( Region( aClipRect ) );
+
+            Point aPt;
+            Size aSize( pBorder->GetOutputSizePixel() );    // the size of the border window, i.e., the whole control
+            Region aRgn( Rectangle( aPt, aSize ) );
+            bNativeOK = pBorder->DrawNativeControl( CTRL_SPINBOX, PART_ENTIRE_CONTROL, aRgn, ControlState(),
+                        aControlValue, rtl::OUString() );
+
+            pBorder->SetClipRegion( oldRgn );
+        }
+    }
+    return bNativeOK;
+}
+
+BOOL ImplDrawNativeSpinbuttons( Window *pWin, const SpinbuttonValue& rSpinbuttonValue )
+{
+    BOOL bNativeOK = FALSE;
+
+    if( pWin->IsNativeControlSupported(CTRL_SPINBUTTONS, PART_ENTIRE_CONTROL) )
+    {
+        ImplControlValue aControlValue;
+        aControlValue.setOptionalVal( (void*) &rSpinbuttonValue );
+
+        // only paint the standalone spin buttons, all buttons are painted at once
+        bNativeOK = pWin->DrawNativeControl( CTRL_SPINBUTTONS, PART_ALL_BUTTONS, Region(), ControlState(),
+                    aControlValue, rtl::OUString() );
+    }
+    return bNativeOK;
+}
+
+
 void ImplDrawSpinButton( OutputDevice* pOutDev,
 						 const Rectangle& rUpperRect,
 						 const Rectangle& rLowerRect,
@@ -98,6 +204,7 @@ void ImplDrawSpinButton( OutputDevice* p
 	const StyleSettings& rStyleSettings = pOutDev->GetSettings().GetStyleSettings();
 	if ( rStyleSettings.GetOptions() & STYLE_OPTION_SPINARROW )
 	{
+        // arrows are only use in OS/2 look
 		if ( bHorz )
 		{
 			eType1 = SYMBOL_ARROW_LEFT;
@@ -127,12 +234,55 @@ void ImplDrawSpinButton( OutputDevice* p
 	USHORT nTempStyle = nStyle;
 	if ( bUpperIn )
 		nTempStyle |= BUTTON_DRAW_PRESSED;
-	Rectangle aUpRect = aDecoView.DrawButton( rUpperRect, nTempStyle );
+
+    BOOL bNativeOK = FALSE;
+	Rectangle aUpRect;
+
+    if( pOutDev->GetOutDevType() == OUTDEV_WINDOW )
+    {
+        Window *pWin = (Window*) pOutDev;
+
+        // are we drawing standalone spin buttons or members of a spinfield ?
+        ControlType aControl = CTRL_SPINBUTTONS;
+        switch( pWin->GetType() )
+        {
+            case WINDOW_EDIT:
+            case WINDOW_MULTILINEEDIT:
+            case WINDOW_PATTERNFIELD:
+            case WINDOW_METRICFIELD:
+            case WINDOW_CURRENCYFIELD:
+            case WINDOW_DATEFIELD:
+            case WINDOW_TIMEFIELD:
+            case WINDOW_LONGCURRENCYFIELD:
+            case WINDOW_NUMERICFIELD:
+            case WINDOW_SPINFIELD:
+                aControl = CTRL_SPINBOX;
+                break;
+            default:
+                aControl = CTRL_SPINBUTTONS;
+                break;
+        }
+
+        SpinbuttonValue aValue;
+        ImplGetSpinbuttonValue( pWin, rUpperRect, rLowerRect,
+						        bUpperIn, bLowerIn, bUpperEnabled, bLowerEnabled,
+                                bHorz, aValue );
+
+        if( aControl == CTRL_SPINBOX )
+            bNativeOK = ImplDrawNativeSpinfield( pWin, aValue );
+        else if( aControl == CTRL_SPINBUTTONS )
+            bNativeOK = ImplDrawNativeSpinbuttons( pWin, aValue );
+    }
+
+    if( !bNativeOK )
+        aUpRect = aDecoView.DrawButton( rUpperRect, nTempStyle );
 
 	// Unteren/rechten Button malen
 	if ( bLowerIn )
 		nStyle |= BUTTON_DRAW_PRESSED;
-	Rectangle aLowRect = aDecoView.DrawButton( rLowerRect, nStyle );
+	Rectangle aLowRect;
+    if( !bNativeOK )
+	    aLowRect = aDecoView.DrawButton( rLowerRect, nStyle );
 
 	// Zusaetzliche Default-Kante wollen wir auch ausnutzen
 	aUpRect.Left()--;
@@ -177,11 +327,13 @@ void ImplDrawSpinButton( OutputDevice* p
 	nTempStyle = nSymStyle;
 	if ( !bUpperEnabled )
 		nTempStyle |= SYMBOL_DRAW_DISABLE;
-	aDecoView.DrawSymbol( aUpRect, eType1, rStyleSettings.GetButtonTextColor(), nTempStyle );
+    if( !bNativeOK )
+	    aDecoView.DrawSymbol( aUpRect, eType1, rStyleSettings.GetButtonTextColor(), nTempStyle );
 
 	if ( !bLowerEnabled )
 		nSymStyle |= SYMBOL_DRAW_DISABLE;
-	aDecoView.DrawSymbol( aLowRect, eType2, rStyleSettings.GetButtonTextColor(), nSymStyle );
+    if( !bNativeOK )
+        aDecoView.DrawSymbol( aLowRect, eType2, rStyleSettings.GetButtonTextColor(), nSymStyle );
 }
 
 // =======================================================================
@@ -209,8 +361,21 @@ void SpinField::ImplInit( Window* pParen
 	if ( nWinStyle & (WB_SPIN|WB_DROPDOWN) )
 	{
 		mbSpin = TRUE;
-		mpEdit = new Edit( this, WB_NOBORDER );
-        mpEdit->EnableRTL( FALSE );
+		
+		// Some themes want external spin buttons, therefore the main
+		// spinfield should not overdraw the border between its encapsulated
+		// edit field and the spin buttons
+		if ( (nWinStyle & WB_SPIN) &&
+		    IsNativeControlSupported(CTRL_SPINBOX, HAS_BACKGROUND_TEXTURE) ) 
+		{
+			SetBackground();
+			mpEdit = new Edit( this, WB_NOBORDER );
+			mpEdit->SetBackground();
+		}
+		else
+			mpEdit = new Edit( this, WB_NOBORDER );
+
+		mpEdit->EnableRTL( FALSE );
 		mpEdit->SetPosPixel( Point() );
 		mpEdit->Show();
 		SetSubEdit( mpEdit );
@@ -518,9 +683,9 @@ void SpinField::Paint( const Rectangle& 
 {
 	if ( mbSpin )
 	{
-		BOOL bEnable = IsEnabled();
-		ImplDrawSpinButton( this, maUpperRect, maLowerRect,
-							mbUpperIn, mbLowerIn, bEnable, bEnable );
+		BOOL	bEnable = IsEnabled();
+        ImplDrawSpinButton( this, maUpperRect, maLowerRect,
+		                    mbUpperIn, mbLowerIn, bEnable, bEnable );
 	}
 
 	if ( GetStyle() & WB_DROPDOWN )
@@ -547,11 +712,13 @@ void SpinField::Paint( const Rectangle& 
 
 void SpinField::ImplCalcButtonAreas( OutputDevice* pDev, const Size& rOutSz, Rectangle& rDDArea, Rectangle& rSpinUpArea, Rectangle& rSpinDownArea )
 {
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
+	const StyleSettings& rStyleSettings = pDev->GetSettings().GetStyleSettings();
 
 	Size aSize = rOutSz;
 	Size aDropDownSize;
 
+    DBG_ASSERT( !(GetStyle() & WB_DROPDOWN), "SpinField::ImplCalcButtonAreas(): SpinField with drop down not supported on all (native) platforms !" );
+
 	if ( GetStyle() & WB_DROPDOWN )
 	{
 		long nW = rStyleSettings.GetScrollBarSize();
@@ -568,13 +735,56 @@ void SpinField::ImplCalcButtonAreas( Out
 	if ( GetStyle() & WB_SPIN )
 	{
 		long nBottom1 = aSize.Height()/2;
+		long nBottom2 = aSize.Height()-1;
 		long nTop2 = nBottom1;
+		long nTop1 = 0;
 		if ( !(aSize.Height() & 0x01) )
 			nBottom1--;
 
-		aSize.Width() -= CalcZoom( GetDrawPixel( pDev, rStyleSettings.GetSpinSize() ) );
-		rSpinUpArea = Rectangle( aSize.Width(), 0, rOutSz.Width()-aDropDownSize.Width()-1, nBottom1 );
-		rSpinDownArea = Rectangle( rSpinUpArea.Left(), nTop2, rSpinUpArea.Right(), aSize.Height()-1 );
+        BOOL bNativeRegionOK = FALSE;
+        Region aContentUp, aContentDown;
+
+		if ( (pDev->GetOutDevType() == OUTDEV_WINDOW) && 
+            IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) )
+        {
+            Window *pWin = (Window*) pDev;
+            Window *pBorder = pWin->GetWindow( WINDOW_BORDER );
+
+            // get the system's spin button size
+		    ImplControlValue aControlValue;
+		    Region aBound;
+		    Point aPoint;
+
+            // use the full extent of the control
+		    Region aArea( Rectangle( aPoint, pBorder->GetOutputSizePixel() ) );
+
+		    bNativeRegionOK = 
+                pWin->GetNativeControlRegion(CTRL_SPINBOX, PART_BUTTON_UP,
+                    aArea, 0, aControlValue, rtl::OUString(), aBound, aContentUp) &&
+                pWin->GetNativeControlRegion(CTRL_SPINBOX, PART_BUTTON_DOWN,
+                    aArea, 0, aControlValue, rtl::OUString(), aBound, aContentDown);
+
+            if( bNativeRegionOK )
+            {
+                // convert back from border space to local coordinates
+                aPoint = pBorder->ScreenToOutputPixel( pWin->OutputToScreenPixel( aPoint ) );
+                aContentUp.Move(-aPoint.X(), -aPoint.Y());
+                aContentDown.Move(-aPoint.X(), -aPoint.Y());
+            }
+        }
+
+        if( bNativeRegionOK )
+        {
+		    rSpinUpArea = aContentUp.GetBoundRect();
+		    rSpinDownArea = aContentDown.GetBoundRect();
+        }
+        else
+        {
+		    aSize.Width() -= CalcZoom( GetDrawPixel( pDev, rStyleSettings.GetSpinSize() ) );
+
+		    rSpinUpArea = Rectangle( aSize.Width(), nTop1, rOutSz.Width()-aDropDownSize.Width()-1, nBottom1 );
+		    rSpinDownArea = Rectangle( rSpinUpArea.Left(), nTop2, rSpinUpArea.Right(), nBottom2 );
+        }
 	}
 	else
 	{
@@ -589,14 +799,13 @@ void SpinField::Resize()
 {
 	if ( mbSpin )
 	{
-        Control::Resize();
+		Control::Resize();
 		Size aSize = GetOutputSizePixel();
 
 		if ( GetStyle() & (WB_SPIN|WB_DROPDOWN) )
 		{
 			ImplCalcButtonAreas( this, aSize, maDropDownRect, maUpperRect, maLowerRect );
-			aSize.Width() -= maDropDownRect.GetWidth();
-			aSize.Width() -= maUpperRect.GetWidth();
+			aSize.Width() = maUpperRect.Left();
 		}
 
 		mpEdit->SetSizePixel( aSize );
@@ -678,6 +887,56 @@ void SpinField::DataChanged( const DataC
 		Resize();
 		Invalidate();
 	}
+}
+
+// -----------------------------------------------------------------------
+
+Rectangle* SpinField::ImplFindPartRect( const Point& rPt )
+{
+    if( maUpperRect.IsInside( rPt ) )
+        return &maUpperRect;
+    else if( maLowerRect.IsInside( rPt ) )
+        return &maLowerRect;
+    else
+        return NULL;
+}
+
+long SpinField::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) ||
+                IsNativeControlSupported(CTRL_SPINBOX, PART_ALL_BUTTONS) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    if( pLastRect )
+                    {
+                        SetClipRegion( *pLastRect );
+                        Paint( *pLastRect );
+                        SetClipRegion( aRgn );
+                    }
+                    if( pRect )
+                    {
+                        SetClipRegion( *pRect );
+                        Paint( *pRect );
+                        SetClipRegion( aRgn );
+                    }
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Edit::PreNotify(rNEvt);
 }
 
 // -----------------------------------------------------------------------
diff -u vcl/source/control/tabctrl.cxx vcl/source/control/tabctrl.cxx
--- vcl/source/control/tabctrl.cxx	3 Mar 2004 15:32:07 -0000
+++ vcl/source/control/tabctrl.cxx	2004-03-17 17:25:30.000000000 +0100
@@ -204,6 +204,11 @@
         mbSingleLine = TRUE;
 
     ImplInitSettings( TRUE, TRUE, TRUE );
+
+    // if the tabcontrol is drawn (ie filled) by a native widget, make sure all contols will have transparent background
+    // otherwise they will paint with a wrong background
+    if( IsNativeControlSupported(CTRL_TAB_PANE, PART_ENTIRE_CONTROL) )
+        EnableChildTransparentMode( TRUE );
 }
 
 // -----------------------------------------------------------------------
@@ -235,8 +240,13 @@
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+            || IsNativeControlSupported(CTRL_TAB_PANE, PART_ENTIRE_CONTROL) 
+            || IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL) )
+
         {
+            // set transparent mode for NWF tabcontrols to have
+            // the background always cleared properly
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
             SetPaintTransparent( TRUE );
@@ -922,7 +932,7 @@
 
 // -----------------------------------------------------------------------
 
-void TabControl::ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout )
+void TabControl::ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout, bool bFirstInGroup, bool bLastInGroup, bool bIsCurrentItem )
 {
     if ( pItem->maRect.IsEmpty() )
         return;
@@ -945,6 +955,7 @@
     BOOL                    bLeftBorder = TRUE;
     BOOL                    bRightBorder = TRUE;
     USHORT                  nOff;
+    BOOL                    bNativeOK = FALSE;
 
     USHORT nOff2 = 0;
     USHORT nOff3 = 0;
@@ -982,7 +993,47 @@
         }
     }
 
-    if( ! bLayout )
+    if( !bLayout && (bNativeOK = IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue		aControlValue;
+        Region				aCtrlRegion( pItem->maRect );
+        ControlState		nState = 0;
+
+        if( pItem->mnId == mnCurPageId )
+            nState |= CTRL_STATE_SELECTED;
+        if ( HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        if ( IsEnabled() )
+            nState |= CTRL_STATE_ENABLED;
+        if( IsMouseOver() && pItem->maRect.IsInside( GetPointerPosPixel() ) )
+        {
+            nState |= CTRL_STATE_ROLLOVER;
+            ImplTabItem* pI;
+            int idx=0;
+            while( (pI = mpItemList->GetObject(idx++)) )
+                if( (pI != pItem) && (pI->maRect.IsInside( GetPointerPosPixel() ) ) )
+                {
+                    nState &= ~CTRL_STATE_ROLLOVER; // avoid multiple highlighted tabs
+                    break;
+                }
+        }
+
+        TabitemValue tiValue;
+        if(pItem->maRect.Left() < 5)
+            tiValue.mnAlignment |= TABITEM_LEFTALIGNED;
+        if(pItem->maRect.Right() > mnLastWidth - 5)
+            tiValue.mnAlignment |= TABITEM_RIGHTALIGNED;
+        if ( bFirstInGroup )
+            tiValue.mnAlignment |= TABITEM_FIRST_IN_GROUP;
+        if ( bLastInGroup )
+            tiValue.mnAlignment |= TABITEM_LAST_IN_GROUP;
+        aControlValue.setOptionalVal( (void *)(&tiValue) );
+
+        bNativeOK = DrawNativeControl( CTRL_TAB_ITEM, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+                    aControlValue, rtl::OUString() );
+    }
+
+    if( ! bLayout && !bNativeOK )
     {
         if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
         {
@@ -1004,14 +1055,14 @@
             }
             
             SetLineColor( rStyleSettings.GetLightColor() );
-            DrawPixel( Point( aRect.Left()+1-nOff2, aRect.Top()+1-nOff2 ) );
+            DrawPixel( Point( aRect.Left()+1-nOff2, aRect.Top()+1-nOff2 ) );    // diagonally indented top-left pixel
             if ( bLeftBorder )
             {
                 DrawLine( Point( aRect.Left()-nOff2, aRect.Top()+2-nOff2 ),
                           Point( aRect.Left()-nOff2, nLeftBottom-1 ) );
             }
-            DrawLine( Point( aRect.Left()+2-nOff2, aRect.Top()-nOff2 ),
-                      Point( aRect.Right()+nOff2-3, aRect.Top()-nOff2 ) );
+            DrawLine( Point( aRect.Left()+2-nOff2, aRect.Top()-nOff2 ),         // top line starting 2px from left border
+                      Point( aRect.Right()+nOff2-3, aRect.Top()-nOff2 ) );      // ending 3px from right border
             
             if ( bRightBorder )
             {
@@ -1053,6 +1104,13 @@
         mpTabCtrlData->maTabRectangles.push_back( aRect );
     }
 
+    // set font accordingly, current item is painted bold
+    // we set the font attributes always before drawing to be re-entrant (DrawNativeControl may trigger additional paints)
+    Font aFont( GetFont() );
+    aFont.SetTransparent( TRUE );
+    aFont.SetWeight( bIsCurrentItem ? WEIGHT_BOLD : WEIGHT_LIGHT );
+    SetFont( aFont );
+
     Size aTabSize = aRect.GetSize();
     long nTextHeight = GetTextHeight();
     long nTextWidth = GetCtrlTextWidth( pItem->maFormatText );
@@ -1153,65 +1211,105 @@
     aRect.Top()    -= TAB_OFFSET;
     aRect.Right()  += TAB_OFFSET;
     aRect.Bottom() += TAB_OFFSET;
-    if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
-        SetLineColor( rStyleSettings.GetLightColor() );
-    else
-        SetLineColor( Color( COL_BLACK ) );
-    if ( pCurItem && !pCurItem->maRect.IsEmpty() )
+
+    BOOL bNativeOK = FALSE;
+    if( (bNativeOK = IsNativeControlSupported( CTRL_TAB_PANE, PART_ENTIRE_CONTROL) ) == TRUE )
     {
-        aCurRect = pCurItem->maRect;
-        if( ! bLayout )
-            DrawLine( aRect.TopLeft(), Point( aCurRect.Left()-2, aRect.Top() ) );
-        if ( aCurRect.Right()+1 < aRect.Right() )
-        {
-            if( ! bLayout )
-                DrawLine( Point( aCurRect.Right(), aRect.Top() ), aRect.TopRight() );
-        }
-        else
-            nTopOff = 0;
+        const ImplControlValue aControlValue( BUTTONVALUE_DONTKNOW, rtl::OUString(), 0 );
+
+        ControlState nState = CTRL_STATE_ENABLED;
+        int part = PART_ENTIRE_CONTROL;
+        if ( !IsEnabled() )
+            nState &= ~CTRL_STATE_ENABLED;
+        if ( HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        Region aCtrlRegion( aRect );
+        bNativeOK = DrawNativeControl( CTRL_TAB_PANE, part, aCtrlRegion, nState,
+                aControlValue, rtl::OUString() );
     }
     else
-        if( ! bLayout )
-            DrawLine( aRect.TopLeft(), aRect.TopRight() );
-
-    if( ! bLayout )
     {
-        DrawLine( aRect.TopLeft(), aRect.BottomLeft() );
-
         if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
+            SetLineColor( rStyleSettings.GetLightColor() );
+        else
+            SetLineColor( Color( COL_BLACK ) );
+        if ( pCurItem && !pCurItem->maRect.IsEmpty() )
         {
-            SetLineColor( rStyleSettings.GetShadowColor() );
-            DrawLine( Point( 1, aRect.Bottom()-1 ),
-                      Point( aRect.Right()-1, aRect.Bottom()-1 ) );
-            DrawLine( Point( aRect.Right()-1, aRect.Top()+nTopOff ),
-                      Point( aRect.Right()-1, aRect.Bottom()-1 ) );
-            SetLineColor( rStyleSettings.GetDarkShadowColor() );
-            DrawLine( Point( 0, aRect.Bottom() ),
-                      Point( aRect.Right(), aRect.Bottom() ) );
-            DrawLine( Point( aRect.Right(), aRect.Top()+nTopOff ),
-                      Point( aRect.Right(), aRect.Bottom() ) );
+            aCurRect = pCurItem->maRect;
+            if( ! bLayout )
+                DrawLine( aRect.TopLeft(), Point( aCurRect.Left()-2, aRect.Top() ) );
+            if ( aCurRect.Right()+1 < aRect.Right() )
+            {
+                if( ! bLayout )
+                    DrawLine( Point( aCurRect.Right(), aRect.Top() ), aRect.TopRight() );
+            }
+            else
+                nTopOff = 0;
         }
         else
+            if( ! bLayout )
+                DrawLine( aRect.TopLeft(), aRect.TopRight() );
+
+        if( ! bLayout )
         {
-            DrawLine( aRect.TopRight(), aRect.BottomRight() );
-            DrawLine( aRect.BottomLeft(), aRect.BottomRight() );
+            DrawLine( aRect.TopLeft(), aRect.BottomLeft() );
+
+            if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
+            {
+                SetLineColor( rStyleSettings.GetShadowColor() );
+                DrawLine( Point( 1, aRect.Bottom()-1 ),
+                        Point( aRect.Right()-1, aRect.Bottom()-1 ) );
+                DrawLine( Point( aRect.Right()-1, aRect.Top()+nTopOff ),
+                        Point( aRect.Right()-1, aRect.Bottom()-1 ) );
+                SetLineColor( rStyleSettings.GetDarkShadowColor() );
+                DrawLine( Point( 0, aRect.Bottom() ),
+                        Point( aRect.Right(), aRect.Bottom() ) );
+                DrawLine( Point( aRect.Right(), aRect.Top()+nTopOff ),
+                        Point( aRect.Right(), aRect.Bottom() ) );
+            }
+            else
+            {
+                DrawLine( aRect.TopRight(), aRect.BottomRight() );
+                DrawLine( aRect.BottomLeft(), aRect.BottomRight() );
+            }
         }
     }
 
-    // Alle Items bis auf das aktuelle Zeichnen (nicht fett)
-    SetFont( aLightFont );
-    pItem = mpItemList->First();
-    while ( pItem )
+    // Some native toolkits (GTK+) draw tabs right-to-left, with an
+    // overlap between adjacent tabs
+    bool			bDrawTabsRTL = IsNativeControlSupported( CTRL_TAB_ITEM, PART_TABS_DRAW_RTL );
+    ImplTabItem *	pFirstTab = NULL;
+    ImplTabItem *	pLastTab = NULL;
+    unsigned idx;
+
+    // Event though there is a tab overlap with GTK+, the first tab is not
+    // overlapped on the left side.  Other tookits ignore this option.
+    if ( bDrawTabsRTL )
+    {
+        pFirstTab = mpItemList->First();
+        pLastTab = mpItemList->Last();
+        idx = mpItemList->Count()-1;
+    }
+    else
+    {
+        pLastTab = mpItemList->Last();
+        pFirstTab = mpItemList->First();
+        idx = 0;
+    }
+
+    while ( (pItem = mpItemList->GetObject(idx)) != NULL )
     {
         if ( pItem != pCurItem )
-            ImplDrawItem( pItem, aCurRect, bLayout );
-        pItem = mpItemList->Next();
+            ImplDrawItem( pItem, aCurRect, bLayout, (pItem==pFirstTab), (pItem==pLastTab), FALSE );
+
+        if ( bDrawTabsRTL )
+            idx--;
+        else
+            idx++;
     }
 
-    // aktuelles Item zeichnen wir fett
-    SetFont( aFont );
     if ( pCurItem )
-        ImplDrawItem( pCurItem, aCurRect, bLayout );
+        ImplDrawItem( pCurItem, aCurRect, bLayout, (pCurItem==pFirstTab), (pItem==pLastTab), TRUE );
 
     if ( !bLayout && HasFocus() )
         ImplShowFocus();
@@ -1452,0 +1551,52 @@
+
+Rectangle* TabControl::ImplFindPartRect( const Point& rPt )
+{
+    ImplTabItem* pItem = mpItemList->First();
+    ImplTabItem* pFoundItem = NULL;
+    int nFound = 0;
+    while ( pItem )
+    {
+        if ( pItem->maRect.IsInside( rPt ) )
+        {
+            // assure that only one tab is highlighted at a time
+            nFound++;
+            pFoundItem = pItem;
+        }
+        pItem = mpItemList->Next();
+    }
+    // assure that only one tab is highlighted at a time
+    return nFound == 1 ? &pFoundItem->maRect : NULL;
+}
+
+long TabControl::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aClipRgn;
+                    if( pLastRect )
+                        aClipRgn.Union( *pLastRect );
+                    if( pRect )
+                        aClipRgn.Union( *pRect );
+                    if( !aClipRgn.IsEmpty() )
+                        Invalidate( aClipRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
unchanged:
--- vcl/source/gdi/salgdilayout.cxx	27 Mar 2003 17:58:03 -0000	1.12
+++ vcl/source/gdi/salgdilayout.cxx	3 Mar 2004 15:32:07 -0000
@@ -268,6 +268,18 @@ BOOL SalGraphicsLayout::mirror( sal_uInt
 		return FALSE;
 }
 
+void SalGraphicsLayout::mirror( Region& rRgn, const OutputDevice *pOutDev )
+{
+    // mirror the bounding rect and move Region by resulting offset
+    Rectangle aRect( rRgn.GetBoundRect() );
+    long nWidth = aRect.GetWidth();
+    long x      = aRect.Left();
+    long x_org = x;
+
+    mirror( x, nWidth, pOutDev );
+    rRgn.Move( x - x_org, 0 );
+}
+
 // ----------------------------------------------------------------------------
 
 BOOL	SalGraphicsLayout::UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
@@ -484,3 +496,68 @@ BOOL	SalGraphicsLayout::DrawEPS( long nX
 	return SalGraphics::DrawEPS( nX, nY, nWidth, nHeight,  pPtr, nSize, NULL );
 }
 
+BOOL SalGraphicsLayout::HitTestNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                const Point& aPos, SalControlHandle& rControlHandle, BOOL& rIsInside, const OutputDevice *pOutDev )
+{
+	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Point pt( aPos );
+        Region rgn( rControlRegion );
+        mirror( pt.X(), pOutDev );
+        mirror( rgn, pOutDev );
+        return SalGraphics::HitTestNativeControl( nType, nPart, rgn, pt, rControlHandle, rIsInside, NULL );
+    }
+    else
+        return SalGraphics::HitTestNativeControl( nType, nPart, rControlRegion, aPos, rControlHandle, rIsInside, NULL );
+}
+
+BOOL SalGraphicsLayout::DrawNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+                                                OUString aCaption, const OutputDevice *pOutDev )
+{
+	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        return SalGraphics::DrawNativeControl( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption, NULL );
+    }
+    else
+        return SalGraphics::DrawNativeControl( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, NULL );
+}
+
+BOOL SalGraphicsLayout::DrawNativeControlText( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                ControlState nState, const ImplControlValue& aValue,
+                                                SalControlHandle& rControlHandle, OUString aCaption, const OutputDevice *pOutDev )
+{
+	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        return SalGraphics::DrawNativeControlText( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption, NULL );
+    }
+    else
+        return SalGraphics::DrawNativeControlText( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, NULL );
+}
+
+BOOL SalGraphicsLayout::GetNativeControlRegion( ControlType nType, ControlPart nPart, const Region& rControlRegion, ControlState nState,
+                                                const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption,
+                                                Region &rNativeBoundingRegion, Region &rNativeContentRegion, const OutputDevice *pOutDev )
+{
+	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        if( GetNativeControlRegion( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption, 
+                                                rNativeBoundingRegion, rNativeContentRegion, NULL ) )
+        {
+            mirror( rNativeBoundingRegion, pOutDev );
+            mirror( rNativeContentRegion, pOutDev );
+            return TRUE;
+        }
+        else
+            return FALSE;
+    }
+    else
+        return SalGraphics::GetNativeControlRegion( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, 
+                                                rNativeBoundingRegion, rNativeContentRegion, NULL );
+}
unchanged:
--- vcl/source/window/brdwin.cxx	9 Jan 2004 18:13:54 -0000	1.9.82.1
+++ vcl/source/window/brdwin.cxx	3 Mar 2004 15:32:07 -0000
@@ -101,10 +101,12 @@
 #ifndef _SV_HELP_HXX
 #include <help.hxx>
 #endif
+#ifndef _SV_EDIT_HXX
+#include <edit.hxx>
+#endif
 #ifndef _SV_BRDWIN_HXX
 #include <brdwin.hxx>
 #endif
-
 #include <tools/debug.hxx>
 
 #include <rvp.hxx>
@@ -1066,6 +1068,112 @@ void ImplSmallBorderWindowView::DrawWind
 	USHORT nBorderStyle = mpBorderWindow->GetBorderStyle();
 	if ( nBorderStyle & WINDOW_BORDER_NOBORDER )
 		return;
+
+    BOOL bNativeOK = FALSE;
+    // for native widget drawing we must find out what
+    // control this border belongs to
+    Window *pWin = NULL, *pCtrl = NULL;
+    if( mpOutDev->GetOutDevType() == OUTDEV_WINDOW )
+        pWin = (Window*) mpOutDev;
+
+    ControlType aCtrlType = 0;
+    ControlPart aCtrlPart = PART_ENTIRE_CONTROL;
+
+    if( pWin && (pCtrl = mpBorderWindow->GetWindow( WINDOW_CLIENT )) != NULL )
+    {
+        switch( pCtrl->GetType() )
+        {
+            case WINDOW_EDIT:
+            case WINDOW_MULTILINEEDIT:
+            case WINDOW_PATTERNFIELD:
+            case WINDOW_METRICFIELD:
+            case WINDOW_CURRENCYFIELD:
+            case WINDOW_DATEFIELD:
+            case WINDOW_TIMEFIELD:
+            case WINDOW_LONGCURRENCYFIELD:
+            case WINDOW_NUMERICFIELD:
+            case WINDOW_SPINFIELD:
+                if( pCtrl->GetStyle() & WB_SPIN )
+                    aCtrlType = CTRL_SPINBOX;
+                else
+                    aCtrlType = CTRL_EDITBOX;
+                break;
+
+            case WINDOW_LISTBOX:
+            case WINDOW_MULTILISTBOX:
+            case WINDOW_TREELISTBOX:
+                aCtrlType = CTRL_LISTBOX;
+                if( pCtrl->GetStyle() & WB_DROPDOWN )
+                    aCtrlPart = PART_ENTIRE_CONTROL;
+                else
+                    aCtrlPart = PART_WINDOW;
+                break;
+
+            case WINDOW_LISTBOXWINDOW:
+                aCtrlType = CTRL_LISTBOX;
+                aCtrlPart = PART_WINDOW;
+                break;
+
+            case WINDOW_COMBOBOX:
+            case WINDOW_PATTERNBOX:			
+            case WINDOW_NUMERICBOX:			
+            case WINDOW_METRICBOX:			
+            case WINDOW_CURRENCYBOX:
+            case WINDOW_DATEBOX:		
+            case WINDOW_TIMEBOX:			
+            case WINDOW_LONGCURRENCYBOX:
+                if( pCtrl->GetStyle() & WB_DROPDOWN )
+                {
+                    aCtrlType = CTRL_COMBOBOX;
+                    aCtrlPart = PART_ENTIRE_CONTROL;
+                }
+                else
+                {
+                    aCtrlType = CTRL_LISTBOX;
+                    aCtrlPart = PART_WINDOW;
+                }
+                break;
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    if ( aCtrlType && pWin->IsNativeControlSupported(aCtrlType, aCtrlPart) )
+    {
+        ImplControlValue aControlValue;
+        ControlState     nState = CTRL_STATE_ENABLED;
+
+        if ( !pWin->IsEnabled() )
+            nState &= ~CTRL_STATE_ENABLED;
+        if ( pWin->HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        BOOL bMouseOver = FALSE;
+        Window *pCtrlChild = pCtrl->GetWindow( WINDOW_FIRSTCHILD );
+        while( pCtrlChild && !(bMouseOver = pCtrlChild->IsMouseOver()) )
+            pCtrlChild = pCtrlChild->GetWindow( WINDOW_NEXT );
+    	
+        if( bMouseOver )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        Point aPoint;
+        Region aCtrlRegion( Rectangle( aPoint, Size( mnWidth, mnHeight ) ) );
+        bNativeOK = pWin->DrawNativeControl( aCtrlType, aCtrlPart, aCtrlRegion, nState,
+                aControlValue, rtl::OUString() );
+
+        // if the native theme draws the spinbuttons in one call, make sure the proper settings
+        // are passed, this might force a redraw though.... (TODO: improve)
+        if ( (aCtrlType == CTRL_SPINBOX) && !pWin->IsNativeControlSupported( CTRL_SPINBOX, PART_BUTTON_UP ) )
+        {
+            Edit *pEdit = ((Edit*) pCtrl)->GetSubEdit();
+            if ( pEdit )
+                pCtrl->Paint( Rectangle() );  // make sure the buttons are also drawn as they might overwrite the border
+        }
+    }
+
+    if( bNativeOK )
+        return;
 
 	if ( nDrawFlags & BORDERWINDOW_DRAW_FRAME )
 	{
unchanged:
--- vcl/source/window/decoview.cxx	27 Mar 2003 17:58:20 -0000	1.4
+++ vcl/source/window/decoview.cxx	3 Mar 2004 15:32:07 -0000
@@ -969,9 +969,14 @@ static void ImplDrawFrame( OutputDevice*
 				{
 					if ( nFrameStyle == FRAME_DRAW_DOUBLEIN )
 					{
-						pDev->ImplDraw2ColorFrame( rRect,
-												   rStyleSettings.GetShadowColor(),
-												   rStyleSettings.GetLightColor() );
+                        if( rStyleSettings.GetUseFlatBorders() ) // no 3d effect
+                            pDev->ImplDraw2ColorFrame( rRect,
+												    rStyleSettings.GetShadowColor(),
+												    rStyleSettings.GetShadowColor() );
+                        else
+						    pDev->ImplDraw2ColorFrame( rRect,
+												    rStyleSettings.GetShadowColor(),
+												    rStyleSettings.GetLightColor() );
 					}
 					else
 					{
@@ -989,9 +994,14 @@ static void ImplDrawFrame( OutputDevice*
 
 					if ( nFrameStyle == FRAME_DRAW_DOUBLEIN )
 					{
-						pDev->ImplDraw2ColorFrame( rRect,
-												   rStyleSettings.GetDarkShadowColor(),
-												   rStyleSettings.GetLightBorderColor() );
+                        if( rStyleSettings.GetUseFlatBorders() ) // no 3d effect
+						    pDev->ImplDraw2ColorFrame( rRect,
+												    rStyleSettings.GetFaceColor(),
+												    rStyleSettings.GetFaceColor() );
+                        else
+						    pDev->ImplDraw2ColorFrame( rRect,
+												    rStyleSettings.GetDarkShadowColor(),
+												    rStyleSettings.GetLightBorderColor() );
 					}
 					else
 					{
unchanged:
--- vcl/source/window/makefile.mk	27 Mar 2003 17:58:22 -0000	1.10
+++ vcl/source/window/makefile.mk	3 Mar 2004 15:32:07 -0000
@@ -103,6 +103,7 @@ SLOFILES=	$(SLO)$/accel.obj		\
 			$(SLO)$/toolbox2.obj	\
 			$(SLO)$/window.obj		\
 			$(SLO)$/window2.obj 	\
+			$(SLO)$/window3.obj		\
 			$(SLO)$/winproc.obj 	\
 			$(SLO)$/wrkwin.obj		\
 			$(SLO)$/introwin.obj	\
diff -u vcl/source/window/tabpage.cxx vcl/source/window/tabpage.cxx
--- vcl/source/window/tabpage.cxx	3 Mar 2004 15:32:07 -0000
+++ vcl/source/window/tabpage.cxx	2004-03-17 17:25:30.000000000 +0100
@@ -99,6 +99,11 @@
     Window::ImplInit( pParent, nStyle, NULL );
 
     ImplInitSettings();
+
+    // if the tabpage is drawn (ie filled) by a native widget, make sure all contols will have transparent background
+    // otherwise they will paint with a wrong background
+    if( IsNativeControlSupported(CTRL_TAB_BODY, PART_ENTIRE_CONTROL) && GetParent() && (GetParent()->GetType() == WINDOW_TABCONTROL) )
+        EnableChildTransparentMode( TRUE );
 }
 
 // -----------------------------------------------------------------------
@@ -182,0 +188,23 @@
+// -----------------------------------------------------------------------
+
+void TabPage::Paint( const Rectangle& rRect )
+{
+    if( IsNativeControlSupported(CTRL_TAB_BODY, PART_ENTIRE_CONTROL) )
+    {
+        const ImplControlValue aControlValue( BUTTONVALUE_DONTKNOW, rtl::OUString(), 0 );
+
+        ControlState nState = CTRL_STATE_ENABLED;
+        int part = PART_ENTIRE_CONTROL;
+        if ( !IsEnabled() )
+            nState &= ~CTRL_STATE_ENABLED;
+        if ( HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        Point aPoint;
+        // pass the whole window region to NWF as the tab body might be a gradient or bitmap
+        // that has to be scaled properly, clipping makes sure that we do not paint too much
+        Region aCtrlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
+        DrawNativeControl( CTRL_TAB_BODY, part, aCtrlRegion, nState,
+                aControlValue, rtl::OUString() );
+    }
+}
+
unchanged:
--- vcl/source/window/window.cxx	5 Feb 2004 16:45:54 -0000	1.176.46.6
+++ vcl/source/window/window.cxx	3 Mar 2004 15:32:07 -0000
@@ -80,6 +80,9 @@
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
+#ifndef _SV_SALCTRLHANDLE_HXX
+#include <salctrlhandle.hxx>
+#endif
 #endif
 
 #include <unohelp.hxx>
@@ -188,7 +191,6 @@
 #include <com/sun/star/accessibility/AccessibleRole.hpp>
 #endif
 
-
 #ifdef REMOTE_APPSERVER
 #include "rmwindow.hxx"
 #include "xevthdl.hxx"
@@ -584,6 +586,7 @@ void Window::ImplInitData( WindowType nT
     mpControlFont       = NULL;         // font propertie
     mpVCLXWindow        = NULL;
     mpAccessibleInfos   = NULL;
+    mpSalControlHandle  = NULL;
     maControlForeground = Color( COL_TRANSPARENT );     // kein Foreground gesetzt
     maControlBackground = Color( COL_TRANSPARENT );     // kein Background gesetzt
     mnLeftBorder        = 0;            // left border
@@ -675,6 +678,7 @@ void Window::ImplInitData( WindowType nT
     mbSuppressAccessibilityEvents = FALSE; // TRUE: do not send any accessibility events
     mbEnableRTL         = TRUE;         // TRUE: this outdev will be mirrored if RTL window layout (UI mirroring) is globally active
     mbDrawSelectionBackground = FALSE;  // TRUE: draws transparent window background to indicate (toolbox) selection
+    mbEnableNativeWidget = TRUE;        // TRUE: try to draw this control with native theme API
 #ifdef REMOTE_APPSERVER
     mpRmEvents          = NULL;
 
@@ -830,6 +834,8 @@ void Window::ImplInit( Window* pParent, 
         mpFrameData->mnMouseMoveId      = 0;
         mpFrameData->mnLastMouseX       = -1;
         mpFrameData->mnLastMouseY       = -1;
+        mpFrameData->mnBeforeLastMouseX = -1;
+        mpFrameData->mnBeforeLastMouseY = -1;
         mpFrameData->mnFirstMouseX      = -1;
         mpFrameData->mnFirstMouseY      = -1;
         mpFrameData->mnLastMouseWinX    = -1;
@@ -1329,6 +1335,7 @@ ImplWinData* Window::ImplGetWinData() co
         mpWinData->mpFocusRect      = NULL;
         mpWinData->mpTrackRect      = NULL;
         mpWinData->mnTrackFlags     = 0;
+        mpWinData->mbMouseOver      = FALSE;
     }
 
     return mpWinData;
@@ -4611,6 +4618,10 @@ Window::~Window()
         delete mpWinData;
     }
 
+    // Native widget support
+    delete mpSalControlHandle;
+    mpSalControlHandle = NULL;
+
     // Overlap-Window-Daten loeschen
     if ( mpOverlapData )
     {
@@ -7337,6 +7348,23 @@ Point Window::GetPointerPosPixel()
 
 // -----------------------------------------------------------------------
 
+Point Window::GetLastPointerPosPixel()
+{
+    DBG_CHKTHIS( Window, ImplDbgCheckWindow );
+
+    Point aPos( mpFrameData->mnBeforeLastMouseX, mpFrameData->mnBeforeLastMouseY );
+#ifndef REMOTE_APPSERVER
+    if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
+    {
+        // --- RTL --- (re-mirror mouse pos at this window)
+        ImplReMirror( aPos );
+    }
+#endif 
+    return ImplFrameToOutput( aPos );
+}
+
+// -----------------------------------------------------------------------
+
 void Window::ShowPointer( BOOL bVisible )
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
@@ -7356,6 +7384,13 @@ void Window::ShowPointer( BOOL bVisible 
 ULONG Window::GetCurrentModButtons()
 {
     return mpFrame ? mpFrame->GetCurrentModButtons() : 0;
+}
+
+// -----------------------------------------------------------------------
+
+BOOL Window::IsMouseOver()
+{
+    return ImplGetWinData()->mbMouseOver;
 }
 
 // -----------------------------------------------------------------------
unchanged:
--- vcl/source/window/winproc.cxx	15 Jan 2004 12:50:42 -0000	1.80.46.2
+++ vcl/source/window/winproc.cxx	3 Mar 2004 15:32:07 -0000
@@ -445,6 +445,8 @@ long ImplHandleMouseEvent( Window* pWind
     }
 
     // update frame data
+    pWindow->mpFrameData->mnBeforeLastMouseX = pWindow->mpFrameData->mnLastMouseX;
+    pWindow->mpFrameData->mnBeforeLastMouseY = pWindow->mpFrameData->mnLastMouseY;
     pWindow->mpFrameData->mnLastMouseX = nX;
     pWindow->mpFrameData->mnLastMouseY = nY;
     pWindow->mpFrameData->mnMouseCode  = nCode;
@@ -685,6 +687,7 @@ long ImplHandleMouseEvent( Window* pWind
                 ImplDelData aDelData;
                 ImplDelData aDelData2;
                 pWindow->mpFrameData->mbInMouseMove = TRUE;
+                pMouseMoveWin->ImplGetWinData()->mbMouseOver = FALSE;
                 pMouseMoveWin->ImplAddDel( &aDelData );
                 // Durch MouseLeave kann auch dieses Fenster zerstoert
                 // werden
@@ -716,6 +719,8 @@ long ImplHandleMouseEvent( Window* pWind
             nMode |= MOUSE_ENTERWINDOW;
         }
         pWindow->mpFrameData->mpMouseMoveWin = pChild;
+        if( pChild )
+            pChild->ImplGetWinData()->mbMouseOver = TRUE;
 
         // MouseLeave
         if ( !pChild )
unchanged:
--- vcl/unx/source/app/makefile.mk	15 Aug 2003 11:25:34 -0000	1.9.250.1
+++ vcl/unx/source/app/makefile.mk	3 Mar 2004 15:32:07 -0000
@@ -116,6 +116,10 @@ CDEFS+=-DHAVE_LIBSN
 CFLAGS+=$(LIBSN_CFLAGS)
 .ENDIF
 
+.IF "$(WITH_WIDGETSET)"!=""
+CFLAGS+= $(WIDGETSET_CFLAGS)
+.ENDIF
+
 .IF "$(OS)$(CPU)" == "SOLARISS"
 .IF "$(COM)"!="GCC"
 SLOFILES+=$(SLO)$/getfpsols.obj
unchanged:
--- vcl/unx/source/app/saldata.cxx	2003-08-26 16:15:59.000000000 +0200
+++ vcl/unx/source/app/saldata.cxx	2004-06-22 14:31:21.487345480 +0200
@@ -67,6 +67,15 @@
 
 // -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
+#ifdef WIDGETSET_KDE
+#define Region QtXRegion
+#include <kaboutdata.h>
+#include <kapplication.h>
+#include <kcmdlineargs.h>
+#include <qpaintdevice.h>
+#undef Region
+#endif
+
 #include <unistd.h>
 #include <fcntl.h>
 
@@ -148,6 +157,15 @@
 #include "i18n_xkb.hxx"
 #endif
 
+#ifdef WIDGETSET_GTK
+#include <gtk/gtk.h>
+#undef _PREX_H
+#undef _POSTX_H
+#include <prex.h>
+#include <gdk/gdkx.h>
+#include <postx.h>
+#endif
+
 // -=-= <signal.h> -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #ifndef UNX
 #ifndef SIGBUS
@@ -537,6 +555,54 @@ void SalXLib::Init( int *pArgc, char *pp
 	sal_uInt32 nParams = aCommandLine.getCommandArgCount();
 	rtl::OUString aParam;
 	rtl::OString aDisplay;
+
+#if defined( WIDGETSET_GTK )
+	gtk_init( NULL, NULL );
+#elif defined( WIDGETSET_KDE )
+	KAboutData *kAboutData = new KAboutData( "OpenOffice.org",
+			I18N_NOOP( "OpenOffice.org" ),
+			"1.1.0",
+			I18N_NOOP( "OpenOffice.org with KDE Native Widget Support." ),
+			KAboutData::License_LGPL,
+			"(c) 2003, Jan Holesovsky",
+			I18N_NOOP( "OpenOffice.org is an office suite.\n" ),
+			"http://kde.openoffice.org/index.html",
+			"dev@kde.openoffice.org");
+	kAboutData->addAuthor( "Jan Holesovsky",
+			I18N_NOOP( "Original author and maintainer of the KDE NWF." ),
+			"kendy@artax.karlin.mff.cuni.cz",
+			"http://artax.karlin.mff.cuni.cz/~kendy" );
+
+	int nFakeArgc = 1;
+	char** pFakeArgv = NULL;
+	USHORT nIdx;
+	for ( nIdx = 0; nIdx < nParams; ++nIdx ) 
+	{
+		aCommandLine.getCommandArg( nIdx, aParam );
+		if ( !pFakeArgv && aParam.equalsAscii( "-display" ) && nIdx + 1 < nParams )
+		{
+			aCommandLine.getCommandArg( nIdx + 1, aParam );
+			aDisplay = rtl::OUStringToOString( aParam, osl_getThreadTextEncoding() );
+
+			nFakeArgc = 3;
+			pFakeArgv = new char*[ nFakeArgc ];
+			pFakeArgv[ 1 ] = strdup( "-display" );
+			pFakeArgv[ 2 ] = strdup( aDisplay.getStr() );
+		}
+	}
+	if ( !pFakeArgv )
+		pFakeArgv = new char*[ nFakeArgc ];
+
+	rtl::OUString aBin = pSalData->GetCommandLineParam(0);
+	rtl::OUString aBinURL;
+	osl_getSystemPathFromFileURL( aBin.pData, &aBinURL.pData );
+	pFakeArgv[0] = strdup( rtl::OUStringToOString( aBinURL, osl_getThreadTextEncoding() ).getStr() );
+
+	KCmdLineArgs::init( nFakeArgc, pFakeArgv, kAboutData );
+
+	new KApplication();
+#endif
+
 	for (USHORT i=0; i<nParams; i++) 
 	{
 		aCommandLine.getCommandArg(i, aParam);
@@ -545,7 +611,14 @@ void SalXLib::Init( int *pArgc, char *pp
 			aCommandLine.getCommandArg(i+1, aParam);
 			aDisplay = rtl::OUStringToOString(
 				   aParam, osl_getThreadTextEncoding());
+
+		#if defined( WIDGETSET_GTK )
+			if ((pDisp = GDK_DISPLAY_XDISPLAY( gdk_display_get_default() )))
+		#elif defined( WIDGETSET_KDE )
+			if ( pDisp = QPaintDevice::x11AppDisplay() )
+		#else
 			if ((pDisp = XOpenDisplay(aDisplay.getStr()))!=NULL)
+		#endif
 			{
 				/*
 			 	* if a -display switch was used, we need
@@ -568,7 +641,13 @@ void SalXLib::Init( int *pArgc, char *pp
 		char *pDisplay = getenv("DISPLAY");
 		if (pDisplay != NULL)
 			aDisplay = rtl::OString(pDisplay);
+	#if defined( WIDGETSET_GTK )
+		pDisp = GDK_DISPLAY_XDISPLAY( gdk_display_get_default() );
+	#elif defined( WIDGETSET_KDE )
+		pDisp = QPaintDevice::x11AppDisplay();
+	#else
 		pDisp  = XOpenDisplay(pDisplay);
+	#endif
 	}
 
 	if ( !pDisp )
unchanged:
--- vcl/unx/source/app/salsys.cxx	2003-04-15 18:08:33.000000000 +0200
+++ vcl/unx/source/app/salsys.cxx	2004-06-22 11:38:48.368258816 +0200
@@ -59,6 +59,12 @@
  *
  ************************************************************************/
 
+#ifdef WIDGETSET_KDE
+#define Region QtXRegion
+#include <qpaintdevice.h>
+#undef Region
+#endif
+
 #include <salsys.hxx>
 #include <stacktrace.hxx>
 
@@ -71,6 +77,15 @@
 #include <button.hxx>
 #include <svdata.hxx>
 
+#ifdef WIDGETSET_GTK
+#include <gtk/gtk.h>
+#undef _PREX_H
+#undef _POSTX_H
+#include <prex.h>
+#include <gdk/gdkx.h>
+#include <postx.h>
+#endif
+
 // -----------------------------------------------------------------------
 
 String GetSalSummarySystemInfos( ULONG nFlags )
@@ -106,7 +121,14 @@ String GetSalSummarySystemInfos( ULONG n
 bool GetSalSystemDisplayInfo( System::DisplayInfo& rInfo )
 {
     bool bSuccess = false;
+#if defined( WIDGETSET_GTK )
+    gtk_init( NULL, NULL );
+    Display* pDisplay = GDK_DISPLAY_XDISPLAY( gdk_display_get_default() );
+#elif defined( WIDGETSET_KDE )
+    Display* pDisplay = QPaintDevice::x11AppDisplay();
+#else
     Display* pDisplay = XOpenDisplay( NULL );
+#endif
     if( pDisplay )
     {
         int nScreen = DefaultScreen( pDisplay );
@@ -122,7 +144,9 @@ bool GetSalSystemDisplayInfo( System::Di
         rInfo.nDepth	= aVI.depth;
         rInfo.nWidth	= DisplayWidth( pDisplay, nScreen );
         rInfo.nHeight	= DisplayHeight( pDisplay, nScreen );
+#if !defined( WIDGETSET_GTK ) && !defined( WIDGETSET_KDE )
         XCloseDisplay( pDisplay );
+#endif
         bSuccess = true;
     }
     return bSuccess;
unchanged:
--- vcl/unx/source/gdi/makefile.mk	27 Aug 2002 14:52:35 -0000	1.9
+++ vcl/unx/source/gdi/makefile.mk	3 Mar 2004 15:32:07 -0000
@@ -89,7 +89,6 @@ SLOFILES=	\
 		$(SLO)$/salogl.obj		\
 		$(SLO)$/charnames.obj	\
 		$(SLO)$/dtint.obj		\
-		$(SLO)$/kdeint.obj		\
 		$(SLO)$/gnomeint.obj	\
 		$(SLO)$/salcvt.obj		\
 		$(SLO)$/ansi1252.obj	\
@@ -98,6 +97,22 @@ SLOFILES=	\
 		$(SLO)$/xlfd_extd.obj	\
 		$(SLO)$/xlfd_smpl.obj	\
 		$(SLO)$/salgdi3.obj
+
+.IF "$(WITH_WIDGETSET)"=="gtk"
+	SLOFILES+= \
+		$(SLO)/salnativewidgets-gtk.obj \
+		$(SLO)$/kdeint.obj
+	CFLAGS+= $(WIDGETSET_CFLAGS)
+.ELIF "$(WITH_WIDGETSET)"=="kde"
+	# salnativewidgets-kde.cxx contains own implementation of KDEintegrator
+	SLOFILES+= \
+		$(SLO)/salnativewidgets-kde.obj
+	CFLAGS+= $(WIDGETSET_CFLAGS)
+.ELSE
+	SLOFILES+= \
+		$(SLO)/salnativewidgets-none.obj \
+		$(SLO)$/kdeint.obj
+.ENDIF
 
 .IF "$(USE_XPRINT)" == "TRUE"
 CFLAGS+=-D_USE_PRINT_EXTENSION_=1
unchanged:
--- vcl/unx/source/window/makefile.mk	27 Aug 2002 17:49:59 -0000	1.2
+++ vcl/unx/source/window/makefile.mk	3 Mar 2004 15:32:07 -0000
@@ -85,7 +85,13 @@ dummy:
 
 .IF "$(remote)"
 SLOFILES=	\
-		$(SLO)/FWS.obj $(SLO)/salframe.obj $(SLO)/salobj.obj
+		$(SLO)/FWS.obj		\
+		$(SLO)/salframe.obj	\
+		$(SLO)/salobj.obj
+.ENDIF
+
+.IF "$(WITH_WIDGETSET)"!=""
+CFLAGS+= $(WIDGETSET_CFLAGS)
 .ENDIF
 
 .ENDIF		# "$(GUIBASE)"!="unx"
unchanged:
--- vcl/util/makefile.mk	15 Aug 2003 11:26:42 -0000	1.47.10.1
+++ vcl/util/makefile.mk	3 Mar 2004 15:32:07 -0000
@@ -275,6 +275,10 @@ SHL1STDLIBS += -framework Cocoa
 
 .IF "$(GUIBASE)"=="unx"
 
+.IF "$(WITH_WIDGETSET)"=="gtk" || "$(WITH_WIDGETSET)"=="kde"
+	SHL1STDLIBS+=$(WIDGETSET_LIBS)
+.ENDIF
+
 .IF "$(WITH_LIBSN)"=="YES"
 SHL1STDLIBS+=$(LIBSN_LIBS)
 .ENDIF
unchanged:
--- vcl/win/inc/saldata.hxx	28 May 2003 12:34:54 -0000	1.11
+++ vcl/win/inc/saldata.hxx	3 Mar 2004 15:32:07 -0000
@@ -169,6 +169,7 @@ struct SalData
     SysAgt_Enable_PROC      mpSageEnableProc;       // funktion to deactivate the system agent
     SalIcon*                mpFirstIcon;            // icon cache, points to first icon, NULL if none
     TempFontItem*           mpTempFontItem;
+    BOOL                    mbThemeChanged;         // true if visual theme was changed: throw away theme handles
 };
 
 inline void SetSalData( SalData* pData ) { ImplGetSVData()->mpSalData = (void*)pData; }
unchanged:
--- vcl/win/source/gdi/MAKEFILE.MK	11 Apr 2003 17:35:54 -0000	1.4
+++ vcl/win/source/gdi/MAKEFILE.MK	3 Mar 2004 15:32:07 -0000
@@ -34,7 +34,9 @@ SLOFILES=   $(SLO)$/salgdi.obj   \
             $(SLO)$/salvd.obj    \
             $(SLO)$/salprn.obj   \
             $(SLO)$/salbmp.obj	 \
-            $(SLO)$/salogl.obj
+            $(SLO)$/salogl.obj  \
+	        $(SLO)$/salnativewidgets-luna.obj
+            
 
 .IF "$(ENABLE_CTL)" != ""
 SLOFILES+=$(SLO)$/winlayout.obj
@@ -53,7 +55,9 @@ OBJFILES=   $(OBJ)$/salgdi.obj   \
             $(OBJ)$/salvd.obj    \
             $(OBJ)$/salprn.obj   \
             $(OBJ)$/salbmp.obj	 \
-			$(OBJ)$/salogl.obj
+			$(OBJ)$/salogl.obj  \
+	        $(OBJ)$/salnativewidgets-luna.obj
+			
 .ENDIF
 
 # --- Targets ------------------------------------------------------
unchanged:
--- vcl/win/source/window/salframe.cxx	15 Jan 2004 14:21:12 -0000	1.94.112.4
+++ vcl/win/source/window/salframe.cxx	3 Mar 2004 15:32:07 -0000
@@ -169,6 +169,10 @@ const unsigned int WM_USER_SYSTEM_WINDOW
 #define IMN_CLOSECANDIDATE              0x0004
 #endif
 
+#ifndef WM_THEMECHANGED
+#define WM_THEMECHANGED                 0x031A
+#endif
+
 // Macros for support of WM_UNICHAR & Keyman 6.0
 #define Uni_UTF32ToSurrogate1(ch)   (((unsigned long) (ch) - 0x10000) / 0x400 + 0xD800)
 #define Uni_UTF32ToSurrogate2(ch)   (((unsigned long) (ch) - 0x10000) % 0x400 + 0xDC00)
@@ -2754,6 +2758,7 @@ void SalFrame::UpdateSettings( AllSettin
         aStyleSettings.SetMenuColor( ImplWinColorToSal( GetSysColor( COLOR_MENU ) ) );
         aStyleSettings.SetMenuBarColor( aStyleSettings.GetMenuColor() );
         aStyleSettings.SetMenuBorderColor( aStyleSettings.GetLightBorderColor() ); // overriden below for flat menus
+        aStyleSettings.SetUseFlatBorders( FALSE );
         aStyleSettings.SetUseFlatMenues( FALSE );
         aStyleSettings.SetMenuTextColor( ImplWinColorToSal( GetSysColor( COLOR_MENUTEXT ) ) );
         aStyleSettings.SetActiveColor( ImplWinColorToSal( GetSysColor( COLOR_ACTIVECAPTION ) ) );
@@ -2771,6 +2776,10 @@ void SalFrame::UpdateSettings( AllSettin
                 aStyleSettings.SetMenuBarColor( ImplWinColorToSal( GetSysColor( COLOR_MENUBAR ) ) );
                 aStyleSettings.SetMenuHighlightColor( ImplWinColorToSal( GetSysColor( COLOR_MENUHILIGHT ) ) );
                 aStyleSettings.SetMenuBorderColor( ImplWinColorToSal( GetSysColor( COLOR_3DSHADOW ) ) );
+
+                // flat borders for our controls etc. as well in this mode (ie, no 3d borders)
+                // this is not active in the classic style appearance
+                aStyleSettings.SetUseFlatBorders( TRUE );
             }
         }
     }
@@ -3894,6 +3903,14 @@ static void UpdateFrameGeometry( HWND hW
 
     RECT aInnerRect;
     GetClientRect( hWnd, &aInnerRect );
+    if( aInnerRect.right )
+    {
+        // improve right decoration
+        aPt.x=aInnerRect.right;
+        aPt.y=aInnerRect.top;
+        ClientToScreen(hWnd, &aPt);
+        pFrame->maGeometry.nRightDecoration = aRect.right - aPt.x;
+    }
     if( aInnerRect.bottom ) // may be zero if window was not shown yet
         pFrame->maGeometry.nBottomDecoration += aRect.bottom - aPt.y - aInnerRect.bottom;
     else
@@ -5187,6 +5204,10 @@ LRESULT CALLBACK SalFrameWndProc( HWND h
         case WM_SYSCOLORCHANGE:
         case WM_TIMECHANGE:
             ImplHandleSettingsChangeMsg( hWnd, nMsg, wParam, lParam );
+            break;
+
+        case WM_THEMECHANGED:
+            GetSalData()->mbThemeChanged = TRUE;
             break;
 
         case SAL_MSG_USEREVENT:
unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/inc/salctrlhandle.hxx	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,93 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALCTRLHANDLE_HXX
+#define _SV_SALCTRLHANDLE_HXX
+
+// to avoid conflicts with system headers, SalControlHandle
+// is defined in its own header file 
+
+/* Include SalControlHandleData class (platform-specific structures
+ *   and types, from aqua/unx/win subdirs)
+ */
+
+#include <salnativewidgets.h>
+
+
+/* SalControlHandle:
+ *
+ *   Container for platform-specific handles and data
+ *   about controls.  Lives as long as the VCL control
+ *   lives.
+ */
+
+class SalControlHandle
+{
+	public:
+		SalControlHandle();
+		~SalControlHandle();
+
+		void				ThemeChanged( void );
+
+		SalControlHandleData	maData;
+};
+
+#endif
unchanged:
--- vcl/inc/salnativewidgets.hxx	2004-03-03 15:32:34.000000000 +0100
+++ vcl/inc/salnativewidgets.hxx	2004-03-11 14:08:08.000000000 +0100
@@ -0,0 +1,374 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_NATIVEWIDGETS_HXX
+#define _SV_NATIVEWIDGETS_HXX
+
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
+/* Control Types:
+ *
+ *   Specify the overall, whole control
+ *   type (as opposed to parts of the
+ *   control if it were composite).
+ */
+
+typedef sal_uInt32		ControlType;
+
+// Normal PushButton/Command Button
+#define CTRL_PUSHBUTTON			1
+
+// Normal single radio button
+#define CTRL_RADIOBUTTON			2
+
+// Normal single checkbox
+#define CTRL_CHECKBOX			10
+
+// Combobox, i.e. a ListBox
+// that allows data entry by user
+#define CTRL_COMBOBOX			20
+
+// Control that allows text entry
+#define CTRL_EDITBOX			30
+
+// Control that allows text entry, but without the usual border
+// Has to be handled separately, because this one cannot handle
+// HAS_BACKGROUND_TEXTURE, which is drawn in the edit box'es
+// border window.
+#define CTRL_EDITBOX_NOBORDER	31
+
+// Control that pops up a menu,
+// but does NOT allow data entry
+#define CTRL_LISTBOX			35
+
+// An edit field together with two little 
+// buttons on the side (aka spin field)
+#define CTRL_SPINBOX			40
+
+// Two standalone spin buttons
+// without an edit field
+#define CTRL_SPINBUTTONS		45
+
+// A single tab
+#define CTRL_TAB_ITEM			50
+
+// The border around a tab area,
+// but without the tabs themselves.
+// May have a gap at the top for
+// the active tab
+#define CTRL_TAB_PANE			55
+
+// Background of a Tab Pane
+#define CTRL_TAB_BODY			56
+
+// Normal scrollbar, including
+// all parts like slider, buttons
+#define CTRL_SCROLLBAR			60
+
+// Border around a group of related
+// items, perhaps also displaying
+// a label of identification
+#define CTRL_GROUPBOX			70
+
+// A separator line
+#define CTRL_FIXEDLINE			80
+
+// A rectangular border, like a
+// Tab Pane, but without the
+// possible gap for a tab
+#define CTRL_FIXEDBORDER			90
+
+
+
+/* Control Parts:
+ *
+ *   Uniquely identify a part of a control,
+ *   for example the slider of a scroll bar.
+ */
+
+typedef sal_uInt32		ControlPart;
+
+#define PART_ENTIRE_CONTROL		1
+#define PART_WINDOW             5       // the static listbox window containing the list
+#define PART_BUTTON				100
+#define PART_BUTTON_UP			101
+#define PART_BUTTON_DOWN			102	// Also for ComboBoxes/ListBoxes
+#define PART_BUTTON_LEFT			103
+#define PART_BUTTON_RIGHT		104
+#define PART_ALL_BUTTONS    		105
+#define PART_TRACK_HORZ_LEFT		200
+#define PART_TRACK_VERT_UPPER		201
+#define PART_TRACK_HORZ_RIGHT		202
+#define PART_TRACK_VERT_LOWER		203
+#define PART_THUMB_HORZ			210
+#define PART_THUMB_VERT			211
+
+/** The edit field part of a control, e.g. of the combo box.
+
+    Currently used just for combo boxes and just for GetNativeControlRegion().
+    It is valid only if GetNativeControlRegion() supports PART_BUTTON_DOWN as
+    well.
+*/
+#define PART_SUB_EDIT           300
+
+// For controls that require the entire background
+// to be drawn first, and then other pieces over top.
+// (GTK+ scrollbars for example).  Control region passed
+// in to draw this part is expected to be the entire
+// area of the control.
+// A control may respond to one or both.
+#define PART_DRAW_BACKGROUND_HORZ		1000
+#define PART_DRAW_BACKGROUND_VERT		1001
+
+// GTK+ also draws tabs right->left since there is a 
+// hardcoded 2 pixel overlap between adjacent tabs
+#define PART_TABS_DRAW_RTL			3000
+
+// For themes that do not want to have the focus
+// rectangle part drawn by VCL but take care of the
+// whole inner control part by themselves
+// eg, listboxes or comboboxes or spinbuttons
+#define HAS_BACKGROUND_TEXTURE  4000
+
+// For scrollbars that have 3 buttons (most KDE themes)
+#define HAS_THREE_BUTTONS       5000
+
+/* Control State:
+ *
+ *   Specify how a particular part of the control
+ *   is to be drawn.  Constants are bitwise OR-ed
+ *   together to compose a final drawing state.
+ *   A _disabled_ state is assumed by the drawing
+ *   functions until an ENABLED or HIDDEN is passed
+ *   in the ControlState.
+ */
+
+typedef sal_uInt32		ControlState;
+
+#define CTRL_STATE_ENABLED		0x0001
+#define CTRL_STATE_FOCUSED		0x0002
+#define CTRL_STATE_PRESSED		0x0004
+#define CTRL_STATE_ROLLOVER		0x0008
+#define CTRL_STATE_HIDDEN		0x0010
+#define CTRL_STATE_DEFAULT		0x0020
+#define CTRL_STATE_SELECTED		0x0040
+
+/* ButtonValue:
+ *
+ *   Identifies the tri-state value options
+ *   that buttons allow
+ */
+
+enum ButtonValue {
+	BUTTONVALUE_DONTKNOW,
+	BUTTONVALUE_ON,
+	BUTTONVALUE_OFF,
+	BUTTONVALUE_MIXED
+};
+
+
+#ifdef __cplusplus
+
+
+/*
+ * One-time initialization/destruction routines for Native
+ * Widget code.
+ */
+void VCLInitNativeWidgets( void );
+void VCLDeinitNativeWidgets( void );
+
+
+/* ScrollbarValue:
+ *
+ *   Value container for scrollbars.
+ */
+class ScrollbarValue
+{
+	public:
+		long			mnMin;
+		long			mnMax;
+		long			mnCur;
+		long			mnVisibleSize;
+		Rectangle		maThumbRect;
+		Rectangle		maButton1Rect;
+		Rectangle		maButton2Rect;
+		ControlState	mnButton1State;
+		ControlState	mnButton2State;
+		ControlState	mnThumbState;
+		ControlState	mnPage1State;
+		ControlState	mnPage2State;
+
+		inline ScrollbarValue()
+				{
+					mnMin = 0; mnMax = 0; mnCur = 0; mnVisibleSize = 0;
+					mnButton1State = 0; mnButton2State = 0;
+					mnThumbState = 0; mnPage1State = 0; mnPage2State = 0;
+				};
+		inline ~ScrollbarValue() {};
+};
+
+/* TabitemValue:
+ *
+ *   Value container for tabitems.
+ */
+
+/* TABITEM constants are OR-ed together */
+#define TABITEM_NOTALIGNED     0x000   // the tabitem is an inner item
+#define TABITEM_LEFTALIGNED    0x001   // the tabitem is aligned with the left  border of the TabControl
+#define TABITEM_RIGHTALIGNED   0x002   // the tabitem is aligned with the right border of the TabControl
+#define TABITEM_FIRST_IN_GROUP 0x004   // the tabitem is the first in group of tabitems
+#define TABITEM_LAST_IN_GROUP  0x008   // the tabitem is the last in group of tabitems
+
+class TabitemValue
+{
+	public:
+        unsigned int    mnAlignment;
+
+		inline TabitemValue()
+				{
+					mnAlignment = 0;
+				};
+		inline ~TabitemValue() {};
+
+        BOOL isLeftAligned()  { return (mnAlignment & TABITEM_LEFTALIGNED) != 0; }
+        BOOL isRightAligned() { return (mnAlignment & TABITEM_RIGHTALIGNED) != 0; }
+        BOOL isBothAligned()  { return isLeftAligned() && isRightAligned(); }
+        BOOL isNotAligned()   { return (mnAlignment & (TABITEM_LEFTALIGNED | TABITEM_RIGHTALIGNED)) == 0; }
+        BOOL isFirst()        { return (mnAlignment & TABITEM_FIRST_IN_GROUP) != 0; }
+        BOOL isLast()         { return (mnAlignment & TABITEM_LAST_IN_GROUP) != 0; }
+};
+
+
+/* SpinbuttonValue:
+ *
+ *   Value container for spinbuttons to paint both buttons at once.
+ *   Note: the other parameters of DrawNativeControl will have no meaning
+ *         all parameters for spinbuttons are carried here
+ */
+class SpinbuttonValue
+{
+	public:
+		Rectangle		maUpperRect;
+		Rectangle		maLowerRect;
+		ControlState	mnUpperState;
+		ControlState	mnLowerState;
+		int			mnUpperPart;
+		int			mnLowerPart;
+
+		inline SpinbuttonValue()
+				{
+					mnUpperState = mnLowerState = 0;
+				};
+		inline ~SpinbuttonValue() {};
+};
+
+/* ImplControlValue:
+ *
+ *   Generic value container for all control parts.
+ */
+
+class ImplControlValue
+{
+	friend class SalFrame;
+	
+	private:
+		ButtonValue	mTristate;	// Tristate value: on, off, mixed
+		rtl::OUString	mString;		// string value
+		long			mNumber;		// numeric value
+		void *		mOptionalVal;	// optional control-specific value
+
+	public:
+		inline ImplControlValue( ButtonValue nTristate, rtl::OUString sString, long nNumeric, void * aOptVal ) \
+								{ mTristate = nTristate; mString = sString; mNumber = nNumeric; mOptionalVal = aOptVal; };
+		inline ImplControlValue( ButtonValue nTristate, rtl::OUString sString, long nNumeric ) \
+								{ mTristate = nTristate; mString = sString; mNumber = nNumeric; mOptionalVal = NULL; };
+		inline ImplControlValue( ButtonValue nTristate )	{ mTristate = nTristate; mOptionalVal = NULL; };
+		inline ImplControlValue( rtl::OUString sString )	{ mString = sString; mOptionalVal = NULL; };
+		inline ImplControlValue( long nNumeric )		{ mNumber = nNumeric; mOptionalVal = NULL; };
+		inline ImplControlValue( void * aOptVal ) 		{ mOptionalVal = aOptVal; };
+		inline ImplControlValue() { mTristate = BUTTONVALUE_DONTKNOW; mNumber = 0; mOptionalVal = NULL; };
+		inline ~ImplControlValue() { mOptionalVal = NULL; };
+
+		inline ButtonValue		getTristateVal( void ) const { return mTristate; }
+		inline void			setTristateVal( ButtonValue nTristate ) { mTristate = nTristate; }
+
+		inline const rtl::OUString&	getStringVal( void ) const { return mString; }
+		inline void			setStringVal( rtl::OUString sString ) { mString = sString; }
+
+		inline long			getNumericVal( void ) const { return mNumber; }
+		inline void			setNumericVal( long nNumeric ) { mNumber = nNumeric; }
+
+		inline void *			getOptionalVal( void ) const { return mOptionalVal; }
+		inline void			setOptionalVal( void * aOptVal ) { mOptionalVal = aOptVal; }
+};
+
+#endif	/* __cplusplus */
+
+#endif
+
+
+
+
+
+
+
diff -u vcl/source/window/window3.cxx vcl/source/window/window3.cxx
--- vcl/source/window/window3.cxx	2004-03-03 15:32:34.000000000 +0100
+++ vcl/source/window/window3.cxx	2004-03-17 17:25:30.000000000 +0100
@@ -0,0 +1,264 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#define _SV_WINDOW_CXX
+
+#ifndef _SV_SVSYS_HXX
+#include <svsys.h>
+#endif
+
+#ifndef _SV_WINDOW_HXX
+#include <window.hxx>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+#ifndef _SV_SALCTRLHANDLE_HXX
+#include <salctrlhandle.hxx>
+#endif
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
+using namespace rtl;
+
+// -----------------------------------------------------------------------
+// These functions are mainly passthrough functions that allow access to
+// the SalFrame behind a Window object for native widget rendering purposes.
+// -----------------------------------------------------------------------
+
+void Window::ImplInitSalControlHandle()
+{
+    // create SalControlHandle on demand
+    // not needed for ordinary windows
+    if( !mpSalControlHandle )
+        mpSalControlHandle = new SalControlHandle;
+}
+
+// -----------------------------------------------------------------------
+
+BOOL Window::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    return( mpGraphics->IsNativeControlSupported(nType, nPart) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::HitTestNativeControl( ControlType nType,
+                              ControlPart nPart,
+                              const Region& rControlRegion,
+                              const Point& aPos,
+                              BOOL& rIsInside )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    ImplInitSalControlHandle();
+    return( mpGraphics->HitTestNativeControl(nType, nPart, rControlRegion, aPos, *mpSalControlHandle, rIsInside, this ) );
+}
+
+// -----------------------------------------------------------------------
+
+BOOL Window::DrawNativeControl( ControlType nType,
+                            ControlPart nPart,
+                            const Region& rControlRegion,
+                            ControlState nState,
+                            const ImplControlValue& aValue,
+                            OUString aCaption )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if( rControlRegion.IsEmpty() )
+        return TRUE;
+
+    if( !IsInPaint() && IsPaintTransparent() )
+    {
+        // only required if called directly (ie, we're not in Paint() ):
+        // force redraw (Paint()) for transparent controls
+        // to trigger a repaint of the background
+        Region aClipRgn( GetClipRegion() );
+            aClipRgn.Intersect( rControlRegion );
+        Invalidate( aClipRgn, INVALIDATE_UPDATE );
+        return TRUE;
+    }
+
+    ImplInitSalControlHandle();
+
+    // make sure the current clip region is initialized correctly
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    if ( mbInitClipRegion )
+        ImplInitClipRegion();
+    if ( mbOutputClipped )
+        return TRUE;
+
+    if ( mbInitLineColor )
+        ImplInitLineColor();
+    if ( mbInitFillColor )
+        ImplInitFillColor();
+
+    // Convert the coordinates from relative to Window-absolute, so we draw
+    // in the correct place in platform code
+    Point aWinOffs;
+    aWinOffs = OutputToScreenPixel( aWinOffs );
+    Region screenRegion( rControlRegion );
+    screenRegion.Move( aWinOffs.X(), aWinOffs.Y());
+
+    return( mpGraphics->DrawNativeControl(nType, nPart, screenRegion, nState, aValue, *mpSalControlHandle, aCaption, this ) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::DrawNativeControlText(ControlType nType,
+                            ControlPart nPart,
+                            const Region& rControlRegion,
+                            ControlState nState,
+                            const ImplControlValue& aValue,
+                            OUString aCaption )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    ImplInitSalControlHandle();
+
+    // make sure the current clip region is initialized correctly
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return false;
+
+    if ( mbInitClipRegion )
+        ImplInitClipRegion();
+    if ( mbOutputClipped )
+        return true;
+
+    if ( mbInitLineColor )
+        ImplInitLineColor();
+    if ( mbInitFillColor )
+        ImplInitFillColor();
+
+    // Convert the coordinates from relative to Window-absolute, so we draw
+    // in the correct place in platform code
+    Point aWinOffs;
+    aWinOffs = OutputToScreenPixel( aWinOffs );
+    Region screenRegion( rControlRegion );
+    screenRegion.Move( aWinOffs.X(), aWinOffs.Y());
+
+    return( mpGraphics->DrawNativeControlText(nType, nPart, screenRegion, nState, aValue, *mpSalControlHandle, aCaption, this ) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::GetNativeControlRegion(  ControlType nType,
+                                ControlPart nPart,
+                                const Region& rControlRegion,
+                                ControlState nState,
+                                const ImplControlValue& aValue,
+                                OUString aCaption,
+                                Region &rNativeBoundingRegion,
+                                Region &rNativeContentRegion )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    ImplInitSalControlHandle();
+    return( mpGraphics->GetNativeControlRegion(nType, nPart, rControlRegion, nState, aValue,
+                                *mpSalControlHandle, aCaption, rNativeBoundingRegion,
+                                rNativeContentRegion, this ) );
+}
+
+
+// -----------------------------------------------------------------------
+
+SalControlHandle::SalControlHandle()
+{
+}
+
+
+// -----------------------------------------------------------------------
+
+SalControlHandle::~SalControlHandle()
+{
+}
unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/unx/inc/salnativewidgets.h	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,92 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_NATIVEWIDGETS_H
+#define _SV_NATIVEWIDGETS_H
+
+#ifdef WIDGETSET_GTK
+#include <gtk/gtk.h>
+#endif
+
+#ifdef __cplusplus
+
+
+/* SalControlHandleData:
+ * 
+ *   Holds platform specific theming data.
+ */
+
+class SalControlHandleData
+{
+	public:
+		SalControlHandleData( void );
+		~SalControlHandleData( void );
+
+	public:
+	  #ifdef WIDGETSET_GTK
+		GtkWidget	*widget;
+	  #endif
+};
+
+
+#endif	/* __cplusplus */
+
+#endif
unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/unx/source/gdi/salnativewidgets-gtk.cxx	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,2326 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_CXX
+
+#include <cstdio>
+#include <cmath>
+#include <vector>
+#include <algorithm>
+#include <hash_map>
+
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#ifndef _OSL_CONDITN_HXX_
+#include <osl/mutex.hxx>
+#endif
+
+#include <salgdi.hxx>
+
+//-------------------------------------
+// GTK+/GDK specific includes
+//-------------------------------------
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+#include <pango/pango.h>
+
+#undef _PREX_H
+#undef _POSTX_H
+#include <prex.h>
+#include <gdk/gdkx.h>
+#include <postx.h>
+
+using namespace rtl;
+
+
+#define CTRL_CACHING_ALLOWED	0x8000  // set when the control is completely visible (i.e. not clipped)
+
+
+/*************************************
+ * Cached native widget objects
+ *************************************/
+static GtkWidget *	gCacheWindow = NULL;
+static GtkWidget *	gDumbContainer = NULL;
+
+static GtkWidget *	gBtnWidget 			= NULL;
+static GtkWidget *	gRadioWidget			= NULL;
+static GtkWidget *	gCheckWidget			= NULL;
+static GtkWidget *	gScrollHorizWidget		= NULL;
+static GtkWidget *	gScrollVertWidget		= NULL;
+static GtkWidget *	gArrowWidget			= NULL;
+static GtkWidget *	gDropdownWidget		= NULL;
+static GtkWidget *	gEditBoxWidget			= NULL;
+static GtkWidget *	gSpinButtonWidget		= NULL;
+static GtkWidget *	gNotebookWidget		= NULL;
+static GtkWidget *	gOptionMenuWidget		= NULL;
+static GtkWidget *	gComboWidget			= NULL;
+static GtkWidget *	gScrolledWindowWidget	= NULL;
+
+osl::Mutex	* pWidgetMutex;
+
+class NWPixmapCacheList;
+static NWPixmapCacheList* gNWPixmapCacheList = NULL;
+
+// Keep a hash table of Widgets->default flags so that we can
+// easily and quickly reset each to a default state before using
+// them
+static std::hash_map<long, guint>	gWidgetDefaultFlags;
+
+static const GtkBorder aDefDefBorder		= { 1, 1, 1, 1 };
+static const GtkBorder aDefDefOutsideBorder	= { 0, 0, 0, 0 };
+
+// Some GTK defaults
+#define MIN_ARROW_SIZE					11
+#define BTN_CHILD_SPACING				1
+#define MIN_SPIN_ARROW_WIDTH				6
+
+
+static void NWEnsureGTKRadio			( void );
+static void NWEnsureGTKButton			( void );
+static void NWEnsureGTKCheck			( void );
+static void NWEnsureGTKScrollbars		( void );
+static void NWEnsureGTKArrow			( void );
+static void NWEnsureGTKEditBox		( void );
+static void NWEnsureGTKSpinButton		( void );
+static void NWEnsureGTKNotebook		( void );
+static void NWEnsureGTKOptionMenu		( void );
+static void NWEnsureGTKCombo			( void );
+static void NWEnsureGTKScrolledWindow	( void );
+
+static void NWConvertVCLStateToGTKState( ControlState nVCLState, GtkStateType* nGTKState, GtkShadowType* nGTKShadow );
+static void NWAddWidgetToCacheWindow( GtkWidget* widget );
+static void NWSetWidgetState( GtkWidget* widget, ControlState nState, GtkStateType nGtkState );
+
+
+/*
+ * Convenience functions to shuttle data back and forth from screen to 
+ * pixmap and pixmap to screen.
+ *
+ */
+
+static GdkPixmap * NWGetPixmapFromScreen(	Display *		pXlibDisplay,
+									Drawable		xlibWindow,
+									Rectangle		srcRect,
+									int			nDepth );
+
+static BOOL NWRenderPixmapToScreen(	GdkPixmap *	pPixmap,
+								Display *		pXlibDisplay,
+								Drawable		xlibWindow,
+								GC			gc,
+								Rectangle		dstRect,
+								int			nDepth );
+
+
+/*
+ * Individual control painting functions
+ *
+ */
+
+//---
+static BOOL NWPaintGTKButton( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+static Rectangle NWGetButtonArea( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+								const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+static BOOL NWPaintGTKRadio( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+static BOOL NWPaintGTKCheck( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+static BOOL NWPaintGTKScrollbar( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+//---
+static BOOL NWPaintGTKEditBox( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+static Rectangle NWGetEditBoxPixmapRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static void NWPaintOneEditBox( GdkPixmap * pixmap, ControlType nType, ControlPart nPart, Rectangle aEditBoxRect,
+							ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+static BOOL NWPaintGTKSpinBox( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+static Rectangle NWGetSpinButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static void NWPaintOneSpinButton( GdkPixmap * pixmap, ControlType nType, ControlPart nPart, Rectangle aAreaRect,
+							ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+							OUString aCaption );
+//---
+
+static BOOL NWPaintGTKComboBox( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+static Rectangle NWGetComboBoxButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+
+static BOOL NWPaintGTKTabItem( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+//---
+
+static BOOL NWPaintGTKListBox( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+							const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle, OUString aCaption, int nDepth );
+
+static Rectangle NWGetListBoxButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static Rectangle NWGetListBoxIndicatorRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+//---
+
+
+/*********************************************************
+ * PixmapCache
+ *********************************************************/
+
+// as some native widget drawing operations are pretty slow
+// with certain themes (eg tabpages)
+// this cache can be used to cache the corresponding pixmap
+// see NWPaintGTKTabItem
+
+class NWPixmapCacheData
+{
+public:
+    ControlType m_nType;
+    ControlState m_nState;
+    Rectangle   m_pixmapRect;
+    GdkPixmap*  m_pixmap;
+    
+    NWPixmapCacheData()
+        { m_pixmap = NULL; };
+    ~NWPixmapCacheData()
+        { SetPixmap( NULL ); };
+    void SetPixmap( GdkPixmap* pPixmap );
+};
+
+class NWPixmapCache
+{
+    int m_size;
+    int m_idx;
+    NWPixmapCacheData* pData;
+public:
+    NWPixmapCache();
+    ~NWPixmapCache();
+    
+    void SetSize( int n)
+        { delete [] pData; m_idx = 0; m_size = n; pData = new NWPixmapCacheData[m_size]; }
+    int GetSize() { return m_size; }
+    
+    BOOL Find( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap** pPixmap );
+    void Fill( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap* pPixmap );
+    
+    void ThemeChanged();    
+};
+
+class NWPixmapCacheList
+{
+public:
+    ::std::vector< NWPixmapCache* > mCaches;
+
+    void AddCache( NWPixmapCache *pCache );
+    void RemoveCache( NWPixmapCache *pCache );
+    void ThemeChanged();
+};
+
+// --- implementation ---
+
+void NWPixmapCacheData::SetPixmap( GdkPixmap* pPixmap )
+{
+    if( m_pixmap )
+        g_object_unref( m_pixmap );
+    
+    m_pixmap = pPixmap;
+    
+    if( m_pixmap )
+        g_object_ref( m_pixmap );
+}
+
+
+NWPixmapCache::NWPixmapCache()
+{
+    m_idx = 0;
+    m_size = 0;
+    pData = NULL;
+    gNWPixmapCacheList->AddCache(this);
+} 
+NWPixmapCache::~NWPixmapCache()
+{
+    gNWPixmapCacheList->RemoveCache(this);
+    delete[] pData;
+}
+void NWPixmapCache::ThemeChanged()
+{
+    // throw away cached pixmaps
+    int i;
+    for(i=0; i<m_size; i++)
+        pData[i].SetPixmap( NULL );
+}
+
+BOOL  NWPixmapCache::Find( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap** pPixmap )
+{
+    aState &= ~CTRL_CACHING_ALLOWED; // mask clipping flag
+    int i;
+    for(i=0; i<m_size; i++)
+    {
+        if( pData[i].m_nType == aType &&
+            pData[i].m_nState == aState &&    
+            pData[i].m_pixmapRect.getWidth() == r_pixmapRect.getWidth() &&    
+            pData[i].m_pixmapRect.getHeight() == r_pixmapRect.getHeight() &&    
+            pData[i].m_pixmap != NULL )
+        {
+            *pPixmap = pData[i].m_pixmap;
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+void NWPixmapCache::Fill( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap* pPixmap )
+{
+    if( !(aState & CTRL_CACHING_ALLOWED) )
+        return; 
+
+    aState &= ~CTRL_CACHING_ALLOWED; // mask clipping flag
+    m_idx = (m_idx+1) % m_size; // just wrap
+    pData[m_idx].m_nType = aType;
+    pData[m_idx].m_nState = aState;
+    pData[m_idx].m_pixmapRect = r_pixmapRect;
+    pData[m_idx].SetPixmap( pPixmap );
+}
+
+
+void NWPixmapCacheList::AddCache( NWPixmapCache* pCache )
+{
+    mCaches.push_back( pCache );
+}
+void NWPixmapCacheList::RemoveCache( NWPixmapCache* pCache )
+{
+    ::std::vector< NWPixmapCache* >::iterator p;
+    p = ::std::find( mCaches.begin(), mCaches.end(), pCache );
+    if( p != mCaches.end() )
+        mCaches.erase( p );
+}
+void NWPixmapCacheList::ThemeChanged( )
+{
+    ::std::vector< NWPixmapCache* >::iterator p = mCaches.begin();
+    while( p != mCaches.end() )
+    {
+        (*p)->ThemeChanged();
+        p++;
+    }
+}
+
+
+/*********************************************************
+ * Make border manipulation easier
+ *********************************************************/
+inline void NW_gtk_border_set_from_border( GtkBorder& aDst, const GtkBorder * pSrc )
+{
+	aDst.left		= pSrc->left;
+	aDst.top		= pSrc->top;
+	aDst.right	= pSrc->right;
+	aDst.bottom	= pSrc->bottom;
+}
+
+
+/*********************************************************
+ * Initialize GTK and local stuff                         
+ *********************************************************/
+void VCLInitNativeWidgets( void )
+{
+	pWidgetMutex = new osl::Mutex;
+	gNWPixmapCacheList = new NWPixmapCacheList;
+}
+
+
+/*********************************************************
+ * Release GTK and local stuff                         
+ *********************************************************/
+void VCLDeinitNativeWidgets( void )
+{
+	delete pWidgetMutex;
+	delete gNWPixmapCacheList;
+}
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+	if (
+		((nType==CTRL_PUSHBUTTON)  && (nPart==PART_ENTIRE_CONTROL)) 	||
+ 		((nType==CTRL_RADIOBUTTON) && (nPart==PART_ENTIRE_CONTROL))		||
+		((nType==CTRL_CHECKBOX)    && (nPart==PART_ENTIRE_CONTROL))		||
+		((nType==CTRL_SCROLLBAR) &&
+				(  (nPart==PART_DRAW_BACKGROUND_HORZ)
+				|| (nPart==PART_DRAW_BACKGROUND_VERT)
+				|| (nPart==PART_ENTIRE_CONTROL) )				)	||
+		((nType==CTRL_EDITBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) ) 			)	||
+		((nType==CTRL_SPINBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_ALL_BUTTONS)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) )			)	||
+		((nType==CTRL_SPINBUTTONS) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_ALL_BUTTONS)	)				)	||
+		((nType==CTRL_COMBOBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==HAS_BACKGROUND_TEXTURE)	)			)	||
+		(((nType==CTRL_TAB_ITEM) || (nType==CTRL_TAB_PANE) ||
+		  (nType==CTRL_TAB_BODY) || (nType==CTRL_FIXEDBORDER)) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_TABS_DRAW_RTL) )				)	||
+		((nType==CTRL_LISTBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_WINDOW)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) )			)
+	   )
+		return( TRUE );
+
+	return( FALSE );
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  bIsInside is set to TRUE if aPos is contained within the
+ *  given part of the control, whose bounding region is
+ *  given by rControlRegion (in VCL frame coordinates).
+ *
+ *  returns whether bIsInside was really set.
+ */
+BOOL SalGraphics::HitTestNativeControl( ControlType		nType,
+								ControlPart		nPart,
+								const Region&		rControlRegion,
+								const Point&		aPos,
+								SalControlHandle&	rControlHandle,
+								BOOL&			rIsInside,
+								const			OutputDevice* )
+{
+	if( IsNativeControlSupported(nType, nPart) )
+	{
+		rIsInside = rControlRegion.IsInside( aPos );
+		return( TRUE );
+	}
+	else
+	{
+		return( FALSE );
+	}
+}
+
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::DrawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption,
+							const OutputDevice* )
+{
+	BOOL			returnVal = FALSE;
+	int			nDepth = maGraphicsData.GetDisplay()->GetVisual()->GetDepth();
+
+	// get a GC with current clipping region set
+	GC			gc = maGraphicsData.SelectFont();
+    
+	if ( pWidgetMutex->acquire() )
+	{
+		if ( (nType==CTRL_PUSHBUTTON) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKButton( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+		else if ( (nType==CTRL_RADIOBUTTON) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKRadio( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+		else if ( (nType==CTRL_CHECKBOX) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKCheck( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+		else if ( (nType==CTRL_SCROLLBAR) && ((nPart==PART_DRAW_BACKGROUND_HORZ) || (nPart==PART_DRAW_BACKGROUND_VERT)) )
+		{
+			returnVal = NWPaintGTKScrollbar( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+		else if ( ((nType==CTRL_EDITBOX) && ((nPart==PART_ENTIRE_CONTROL) || (nPart==HAS_BACKGROUND_TEXTURE)) )
+				|| ((nType==CTRL_SPINBOX) && (nPart==HAS_BACKGROUND_TEXTURE))
+				|| ((nType==CTRL_COMBOBOX) && (nPart==HAS_BACKGROUND_TEXTURE))
+				|| ((nType==CTRL_LISTBOX) && (nPart==HAS_BACKGROUND_TEXTURE)) )
+		{
+			returnVal = NWPaintGTKEditBox( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+		else if ( ((nType==CTRL_SPINBOX) || (nType==CTRL_SPINBUTTONS))
+				&& ((nPart==PART_ENTIRE_CONTROL) || (nPart==PART_ALL_BUTTONS)) )
+		{
+			returnVal = NWPaintGTKSpinBox( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+		else if ( (nType == CTRL_COMBOBOX) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKComboBox( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+		else if ( (nType==CTRL_TAB_ITEM) || (nType==CTRL_TAB_PANE) || (nType==CTRL_TAB_BODY) || (nType==CTRL_FIXEDBORDER) )
+		{
+			if ( nType == CTRL_TAB_BODY )
+				returnVal = TRUE;
+			else
+				returnVal = NWPaintGTKTabItem( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+		else if ( (nType==CTRL_LISTBOX) && ((nPart==PART_ENTIRE_CONTROL) || (nPart==PART_WINDOW)) )
+		{
+			returnVal = NWPaintGTKListBox( maGraphicsData.GetDrawable(), maGraphicsData.GetXDisplay(), gc, nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, nDepth );
+		}
+
+		pWidgetMutex->release();
+	}
+
+	return( returnVal );
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::DrawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								const OutputDevice* )
+{
+	return( FALSE );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the TRUE bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::GetNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion,
+								const OutputDevice* )
+{
+	BOOL returnVal = FALSE;
+
+	if ( pWidgetMutex->acquire() )
+	{
+		if ( (nType==CTRL_PUSHBUTTON) && (nPart==PART_ENTIRE_CONTROL)
+				&& (rControlRegion.GetBoundRect().GetWidth() > 16)
+				&& (rControlRegion.GetBoundRect().GetHeight() > 16) )
+		{
+			rNativeBoundingRegion = NWGetButtonArea( nType, nPart, rControlRegion.GetBoundRect(),
+									 nState, aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rControlRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_SPINBOX) && ((nPart==PART_BUTTON_UP) || (nPart==PART_BUTTON_DOWN)) )
+		{
+			rNativeBoundingRegion = NWGetSpinButtonRect( nType, nPart, rControlRegion.GetBoundRect(),
+										nState, aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_COMBOBOX) && (nPart==PART_BUTTON_DOWN) )
+		{
+			rNativeBoundingRegion = NWGetComboBoxButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+										aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_SPINBOX) && ((nPart==PART_BUTTON_UP) || (nPart==PART_BUTTON_DOWN)) )
+		{
+			SpinbuttonValue *	pSpinVal = (SpinbuttonValue *)(aValue.getOptionalVal());
+
+			rNativeBoundingRegion = NWGetSpinButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+									aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_LISTBOX) && ((nPart==PART_BUTTON_DOWN) || (nPart==PART_SUB_EDIT)) )
+		{
+			rNativeBoundingRegion = NWGetListBoxButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+										aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+
+		pWidgetMutex->release();
+	}
+
+	return( returnVal );
+}
+
+
+/************************************************************************
+ * Individual control drawing functions
+ ************************************************************************/
+static BOOL NWPaintGTKButton( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		buttonRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+	BOOL			bDrawFocus = TRUE;
+	gint			x, y, w, h;
+	GtkBorder		aDefBorder;
+	GtkBorder		aDefOutsideBorder;
+	GtkBorder*		pBorder;
+	GtkBorder*		pOutBorder;
+    
+	NWEnsureGTKButton();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	x = y = 0;
+	w = pixmapRect.getWidth();
+	h = pixmapRect.getHeight();
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gBtnWidget,	"focus-line-width",	&focusWidth,
+								"focus-padding", 	&focusPad,
+					 			"interior_focus",	&interiorFocus,
+								"default_border",	&pBorder,
+								"default_outside_border", &pOutBorder, NULL );
+
+	// Make sure the border values exist, otherwise use some defaults
+	if ( pBorder )
+	{
+		NW_gtk_border_set_from_border( aDefBorder, pBorder );
+		gtk_border_free( pBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefBorder, &aDefDefBorder );
+
+	if ( pOutBorder )
+	{
+		NW_gtk_border_set_from_border( aDefOutsideBorder, pOutBorder );
+		gtk_border_free( pOutBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefOutsideBorder, &aDefDefOutsideBorder );
+
+	// If the button is too small, don't ever draw focus or grab more space
+	if ( (w < 16) || (h < 16) )
+		bDrawFocus = FALSE;
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+	// set up references to correct drawable and cliprect
+	GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( pixmap );
+	GdkRectangle* const &gdkRect    = NULL;
+
+	NWSetWidgetState( gBtnWidget, nState, stateType );
+
+	// Buttons must paint opaque since some themes have alpha-channel enabled buttons
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "base", x, y, w, h );
+
+	if ( (nState & CTRL_STATE_DEFAULT) && (GTK_BUTTON(gBtnWidget)->relief == GTK_RELIEF_NORMAL) )
+	{
+		gtk_paint_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_IN, 
+                       gdkRect, gBtnWidget, "buttondefault", x, y, w, h );
+	}
+
+	if ( (nState & CTRL_STATE_DEFAULT) && bDrawFocus )
+	{
+		x += aDefBorder.left;
+		y += aDefBorder.top;
+		w -= aDefBorder.left + aDefBorder.right;
+		h -= aDefBorder.top + aDefBorder.bottom;
+	}
+
+	if ( !interiorFocus && bDrawFocus )
+	{
+		x += focusWidth + focusPad;
+		y += focusWidth + focusPad;
+		w -= 2 * (focusWidth + focusPad);
+		h -= 2 * (focusWidth + focusPad);
+	}
+
+	if ( (GTK_BUTTON(gBtnWidget)->relief != GTK_RELIEF_NONE)
+		|| (nState & CTRL_STATE_PRESSED)
+		|| (nState & CTRL_STATE_ROLLOVER) )
+	{
+		gtk_paint_box( gBtnWidget->style, gdkDrawable, stateType, shadowType,
+                       gdkRect, gBtnWidget, "button", x, y, w, h );
+	}
+
+	// Draw focus rect
+#if 0 // VCL draws focus rects
+	if ( (nState & CTRL_STATE_FOCUSED) && (nState & CTRL_STATE_ENABLED) && bDrawFocus )
+	{
+		if (interiorFocus)
+		{
+			x += gBtnWidget->style->xthickness + focusPad;
+			y += gBtnWidget->style->ythickness + focusPad;
+			w -= 2 * (gBtnWidget->style->xthickness + focusPad);
+			h -=  2 * (gBtnWidget->style->xthickness + focusPad);
+		}
+		else
+		{
+			x -= focusWidth + focusPad;
+			y -= focusWidth + focusPad;
+			w += 2 * (focusWidth + focusPad);
+			h += 2 * (focusWidth + focusPad);
+		}
+		if ( !interiorFocus )
+			gtk_paint_focus( gBtnWidget->style, gdkDrawable, stateType, gdkRect,
+                             gBtnWidget, "button", x, y, w, h );
+	}
+#endif
+
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+ 	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+static Rectangle NWGetButtonArea( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption )
+{
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+	GtkBorder		aDefBorder;
+	GtkBorder		aDefOutsideBorder;
+	GtkBorder *	pBorder;
+	GtkBorder *	pOutBorder;
+	BOOL			bDrawFocus = TRUE;
+	Rectangle		aRect;
+	gint			x, y, w, h;
+
+	NWEnsureGTKButton();
+	gtk_widget_style_get( gBtnWidget,	"focus-line-width",	&focusWidth,
+								"focus-padding", 	&focusPad,
+					 			"interior_focus",	&interiorFocus,
+								"default_border",	&pBorder,
+								"default_outside_border", &pOutBorder, NULL );
+
+	// Make sure the border values exist, otherwise use some defaults
+	if ( pBorder )
+	{
+		NW_gtk_border_set_from_border( aDefBorder, pBorder );
+		gtk_border_free( pBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefBorder, &aDefDefBorder );
+
+	if ( pOutBorder )
+	{
+		NW_gtk_border_set_from_border( aDefOutsideBorder, pOutBorder );
+		gtk_border_free( pOutBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefOutsideBorder, &aDefDefOutsideBorder );
+
+	x = aAreaRect.getX();
+	y = aAreaRect.getY();
+	w = aAreaRect.getWidth();
+	h = aAreaRect.getHeight();
+
+	// If the button is too small, don't ever draw focus or grab more space
+	if ( (w < 16) || (h < 16) )
+		bDrawFocus = FALSE;
+
+	if ( (nState & CTRL_STATE_DEFAULT) && bDrawFocus )
+	{
+		x -= aDefBorder.left;
+		y -= aDefBorder.top;
+		w += aDefBorder.left + aDefBorder.right;
+		h += aDefBorder.top + aDefBorder.bottom;
+	}
+
+	aRect.setX( x );
+	aRect.setY( y );
+	aRect.setWidth( w );
+	aRect.setHeight( h );
+
+	return( aRect );
+}
+
+//-------------------------------------
+
+static BOOL NWPaintGTKRadio( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+#define	RADIO_BUTTON_MINIMUMSIZE   14 // found by experiment, TODO: should be checked at runtime if possible 
+
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	BOOL			isChecked = (aValue.getTristateVal()==BUTTONVALUE_ON);
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+	gint			x, y;
+   
+	NWEnsureGTKButton();
+	NWEnsureGTKRadio();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+	x = y = 0;
+    
+	// assure minimum button size required by gtk+ to avoid clipping
+	if( pixmapRect.getWidth() < RADIO_BUTTON_MINIMUMSIZE )
+		pixmapRect.setWidth( RADIO_BUTTON_MINIMUMSIZE );
+	if( pixmapRect.getHeight() < RADIO_BUTTON_MINIMUMSIZE )
+		pixmapRect.setHeight( RADIO_BUTTON_MINIMUMSIZE );
+
+	// Set the shadow based on if checked or not so we get a freakin checkmark.
+	shadowType = isChecked ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
+	NWSetWidgetState( gRadioWidget, nState, stateType );
+	gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(gRadioWidget), isChecked );
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+
+	// set up references to correct drawable and cliprect
+	GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( pixmap );
+	GdkRectangle* const &gdkRect    = NULL;
+
+	x = y = 0;
+	gtk_paint_option( gRadioWidget->style, gdkDrawable, stateType, shadowType, 
+					gdkRect, gRadioWidget, "radiobutton",
+					x, y, pixmapRect.getWidth(), pixmapRect.getHeight() );
+
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+ 	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//-------------------------------------
+
+static BOOL NWPaintGTKCheck( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+#define	CHECKBOX_MINIMUMSIZE   14 // found by experiment, TODO: should be checked at runtime if possible 
+    
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		btnBoundRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	BOOL			isChecked = (aValue.getTristateVal()==BUTTONVALUE_ON) ? TRUE : FALSE;
+	gint			ctrlSize;
+	gint			x,y;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKCheck();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+    
+	// assure minimum button size required by gtk+ to avoid clipping
+	if( pixmapRect.getWidth() < CHECKBOX_MINIMUMSIZE )
+		pixmapRect.setWidth( CHECKBOX_MINIMUMSIZE );
+	if( pixmapRect.getHeight() < CHECKBOX_MINIMUMSIZE )
+		pixmapRect.setHeight( CHECKBOX_MINIMUMSIZE );
+    
+	btnBoundRect = pixmapRect;
+
+	// Set the shadow based on if checked or not so we get a checkmark.
+	shadowType = isChecked ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
+	NWSetWidgetState( gCheckWidget, nState, stateType );
+	gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(gCheckWidget), isChecked );
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+
+	// set up references to correct drawable and cliprect
+	GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( pixmap );
+	GdkRectangle* const &gdkRect    = NULL;
+
+	x = btnBoundRect.getX() - pixmapRect.getX();
+	y = btnBoundRect.getY() - pixmapRect.getY();
+	gtk_paint_check( gCheckWidget->style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, gCheckWidget, "checkbutton",
+                     x, y, btnBoundRect.getWidth(), btnBoundRect.getHeight() );
+
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+ 	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//-------------------------------------
+
+static BOOL NWPaintGTKScrollbar( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+	ScrollbarValue* pScrollbarVal = (ScrollbarValue *)(aValue.getOptionalVal());
+	GdkPixmap	*	pixmap = NULL;
+	Rectangle		pixmapRect;
+	Rectangle		scrollbarRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	GtkScrollbar *	scrollbarWidget;
+	GtkStyle *	style;
+	GtkAdjustment* scrollbarValues = NULL;
+	GtkOrientation	scrollbarOrientation;
+	Rectangle		thumbRect = pScrollbarVal->maThumbRect;
+	Rectangle		button1BoundRect = pScrollbarVal->maButton1Rect;
+	Rectangle		button2BoundRect = pScrollbarVal->maButton2Rect;
+	GtkArrowType	button1Type;
+	GtkArrowType	button2Type;
+	gint			nButton1Extra = 0;
+	gint			nButton2Extra = 0;
+	gchar *		scrollbarTagH = (gchar *) "hscrollbar";
+	gchar *		scrollbarTagV = (gchar *) "vscrollbar";
+	gchar *		scrollbarTag = NULL;
+	Rectangle		arrow1Rect;
+	Rectangle		arrow2Rect;
+	gint			slider_width = 0;
+	gint			stepper_size = 0;
+	gint			stepper_spacing = 0;
+	gint			trough_border = 0;
+	gint			min_slider_length = 0;
+	gint			vShim = 0;
+	gint			hShim = 0;
+	gint			x,y;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKScrollbars();
+	NWEnsureGTKArrow();
+
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+	pixmapRect.setWidth( pixmapRect.getWidth() + 1 );
+	pixmapRect.setHeight( pixmapRect.getHeight() + 1 );
+	scrollbarRect = pixmapRect;
+	if ( (scrollbarRect.getWidth() <= 1) || (scrollbarRect.getHeight() <= 1) )
+		return( TRUE );
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gScrollHorizWidget, "slider_width", &slider_width,
+									  "stepper_size", &stepper_size,
+									  "trough_border", &trough_border,
+									  "stepper_spacing", &stepper_spacing,
+									  "min_slider_length", &min_slider_length, NULL );
+
+	if ( nPart == PART_DRAW_BACKGROUND_HORZ )
+	{
+		unsigned int	sliderHeight = slider_width + (trough_border * 2);
+		vShim = (pixmapRect.getHeight() - sliderHeight) / 2;
+
+		if ( sliderHeight < scrollbarRect.getHeight() );
+		{
+			scrollbarRect.Move( 0, vShim );
+			scrollbarRect.setHeight( sliderHeight );
+		}
+
+		scrollbarWidget = GTK_SCROLLBAR( gScrollHorizWidget );
+		scrollbarOrientation = GTK_ORIENTATION_HORIZONTAL;
+		scrollbarTag = scrollbarTagH;
+		button1Type = GTK_ARROW_LEFT;
+		button2Type = GTK_ARROW_RIGHT;
+
+		button1BoundRect.setX( (button1BoundRect.getWidth()-stepper_size) / 2 );
+		button1BoundRect.setY( ((button1BoundRect.getHeight()-vShim)-slider_width) / 2 );
+		button1BoundRect.setHeight( slider_width );
+		button1BoundRect.setWidth( stepper_size );
+		nButton1Extra = (pScrollbarVal->maButton1Rect.getX() + pScrollbarVal->maButton1Rect.getWidth()) - 
+				(button1BoundRect.getX() + button1BoundRect.getWidth());
+
+		button2BoundRect.setX( scrollbarRect.getWidth() - button2BoundRect.getWidth() + ((button2BoundRect.getWidth()-stepper_size) / 2) );
+		button2BoundRect.setY( ((button2BoundRect.getHeight()-vShim)-slider_width) / 2 );
+		button2BoundRect.setHeight( slider_width );
+		button2BoundRect.setWidth( stepper_size );
+		nButton2Extra =  button2BoundRect.getX() - pScrollbarVal->maButton2Rect.getX();
+
+		thumbRect.setHeight( slider_width );
+		// Make sure the thumb is at least the default width (so we don't get tiny thumbs),
+		// but if the VCL gives us a size smaller than the theme's default thumb size,
+		// honor the VCL size
+#if 0
+		if ( (thumbRect.getWidth() < min_slider_length)
+			&& ((scrollbarRect.getWidth()-button1BoundRect.getWidth()-button2BoundRect.getWidth()) > min_slider_length) )
+			thumbRect.setWidth( min_slider_length );
+#endif
+
+		// Center vertically in the track
+		thumbRect.Move( 0, (scrollbarRect.getHeight() - slider_width) / 2 );
+
+		// Themes may have a different idea of what the scrollbar stepper button
+		// size should be, so we have to adjust the Thumbs rectangle to account
+		// for the difference between OOo's idea and the theme's
+		thumbRect.Move( -nButton1Extra, 0 );
+		thumbRect.setWidth( thumbRect.getWidth() + nButton1Extra + nButton2Extra );
+	}
+	else
+	{
+		unsigned int	sliderWidth = slider_width + (trough_border * 2);
+		hShim = (pixmapRect.getWidth() - sliderWidth) / 2;
+
+		if ( sliderWidth < scrollbarRect.getWidth() );
+		{
+			scrollbarRect.Move( hShim, 0 );
+			scrollbarRect.setWidth( sliderWidth );
+		}
+
+		scrollbarWidget = GTK_SCROLLBAR( gScrollVertWidget );
+		scrollbarOrientation = GTK_ORIENTATION_VERTICAL;
+		scrollbarTag = scrollbarTagV;
+		button1Type = GTK_ARROW_UP;
+		button2Type = GTK_ARROW_DOWN;
+
+		button1BoundRect.setX( ((button1BoundRect.getWidth()-hShim)-slider_width) / 2 );
+		button1BoundRect.setY( (button1BoundRect.getHeight()-stepper_size) / 2 );
+		button1BoundRect.setHeight( stepper_size );
+		button1BoundRect.setWidth( slider_width );
+		nButton1Extra = (pScrollbarVal->maButton1Rect.getY() + pScrollbarVal->maButton1Rect.getHeight()) - 
+				(button1BoundRect.getY() + button1BoundRect.getHeight());
+
+		button2BoundRect.setX( ((button2BoundRect.getWidth()-hShim)-slider_width) / 2 );
+		button2BoundRect.setY( scrollbarRect.getHeight() - button2BoundRect.getHeight() + ((button2BoundRect.getHeight()-stepper_size) / 2) );
+		button2BoundRect.setHeight( stepper_size );
+		button2BoundRect.setWidth( slider_width );
+		nButton2Extra =  button2BoundRect.getY() - pScrollbarVal->maButton2Rect.getY();
+
+		thumbRect.setWidth( slider_width );
+#if 0
+		// Make sure the thumb is at least the default width (so we don't get tiny thumbs),
+		// but if the VCL gives us a size smaller than the theme's default thumb size,
+		// honor the VCL size
+		if ( (thumbRect.getHeight() < min_slider_length)
+			&& ((scrollbarRect.getHeight()-button1BoundRect.getHeight()-button2BoundRect.getHeight()) > min_slider_length) )
+			thumbRect.setHeight( min_slider_length );
+#endif
+
+		// Center horizontally in the track
+		thumbRect.Move( (scrollbarRect.getWidth() - slider_width) / 2, 0 );
+
+		// Themes may have a different idea of what the scrollbar stepper button
+		// size should be, so we have to adjust the Thumbs rectangle to account
+		// for the difference between OOo's idea and the theme's
+		thumbRect.Move( 0, -nButton1Extra );
+		thumbRect.setHeight( thumbRect.getHeight() + nButton1Extra + nButton2Extra );
+	}
+
+	scrollbarValues = gtk_range_get_adjustment( GTK_RANGE(scrollbarWidget) );
+	if ( scrollbarValues == NULL )
+		scrollbarValues = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+	if ( nPart == PART_DRAW_BACKGROUND_HORZ )
+	{
+		scrollbarValues->lower = pScrollbarVal->mnMin;
+		scrollbarValues->upper = pScrollbarVal->mnMax;
+		scrollbarValues->value = pScrollbarVal->mnCur;
+		scrollbarValues->page_size = scrollbarRect.getWidth() / 2;
+	}
+	else
+	{
+		scrollbarValues->lower = pScrollbarVal->mnMin;
+		scrollbarValues->upper = pScrollbarVal->mnMax;
+		scrollbarValues->value = pScrollbarVal->mnCur;
+		scrollbarValues->page_size = scrollbarRect.getHeight() / 2;
+	}
+	gtk_adjustment_changed( scrollbarValues );
+
+	// Size the arrow appropriately
+	arrow1Rect.setWidth ( button1BoundRect.getWidth()  / 2 );
+	arrow1Rect.setHeight( button1BoundRect.getHeight() / 2 );
+	arrow2Rect.setWidth ( button2BoundRect.getWidth()  / 2 );
+	arrow2Rect.setHeight( button2BoundRect.getHeight() / 2 );
+
+	arrow1Rect.setX( button1BoundRect.getX() + (button1BoundRect.getWidth()  - arrow1Rect.getWidth() ) / 2 );
+	arrow1Rect.setY( button1BoundRect.getY() + (button1BoundRect.getHeight() - arrow1Rect.getHeight()) / 2 );
+	arrow2Rect.setX( button2BoundRect.getX() + (button2BoundRect.getWidth()  - arrow2Rect.getWidth() ) / 2 );
+	arrow2Rect.setY( button2BoundRect.getY() + (button2BoundRect.getHeight() - arrow2Rect.getHeight()) / 2 );
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+
+	// set up references to correct drawable and cliprect
+	GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( pixmap );
+	GdkRectangle* const &gdkRect    = NULL;
+
+	x = y = 0;
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+	NWSetWidgetState( GTK_WIDGET(scrollbarWidget), nState, stateType );
+	NWSetWidgetState( gBtnWidget, nState, stateType );
+	style = GTK_WIDGET( scrollbarWidget )->style;
+
+	// ----------------- TROUGH
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, 
+                        GTK_STATE_NORMAL, GTK_SHADOW_NONE, gdkRect,
+                        gBtnWidget, "base", x, y, 
+                        pixmapRect.getWidth(), pixmapRect.getHeight() );
+	gtk_paint_box( style, gdkDrawable, GTK_STATE_ACTIVE, GTK_SHADOW_IN, 
+                   gdkRect, GTK_WIDGET(scrollbarWidget), "trough",
+                   x+(scrollbarRect.getX() - pixmapRect.getX()), 
+                   y+(scrollbarRect.getY()-pixmapRect.getY()),
+                   scrollbarRect.getWidth(), scrollbarRect.getHeight() );
+
+	if ( nState & CTRL_STATE_FOCUSED )
+	{
+		gtk_paint_focus( style, gdkDrawable, GTK_STATE_ACTIVE, 
+                         gdkRect, GTK_WIDGET(scrollbarWidget), "trough",
+                         x+(scrollbarRect.getX() - pixmapRect.getX()), 
+                         y+(scrollbarRect.getY()-pixmapRect.getY()),
+                         scrollbarRect.getWidth(), scrollbarRect.getHeight() );
+	}
+
+	// ----------------- THUMB
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnThumbState, &stateType, &shadowType );
+	if ( pScrollbarVal->mnThumbState & CTRL_STATE_PRESSED )  stateType = GTK_STATE_PRELIGHT;
+	gtk_paint_slider( style, gdkDrawable, stateType, GTK_SHADOW_OUT, 
+                      gdkRect, GTK_WIDGET(scrollbarWidget), "slider",
+                      x+hShim+thumbRect.getX(), y+vShim+thumbRect.getY(), 
+                      thumbRect.getWidth(), thumbRect.getHeight(), scrollbarOrientation );
+
+	// ----------------- BUTTON 1
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnButton1State, &stateType, &shadowType );
+	if ( stateType == GTK_STATE_INSENSITIVE )	stateType = GTK_STATE_NORMAL;
+	gtk_paint_box( style, gdkDrawable, stateType, shadowType, 
+                   gdkRect, GTK_WIDGET(scrollbarWidget), "stepper",
+                   x+hShim+button1BoundRect.getX(), y+vShim+button1BoundRect.getY(), 
+                   button1BoundRect.getWidth(), button1BoundRect.getHeight() );
+	// ----------------- ARROW 1
+	gtk_paint_arrow( style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, GTK_WIDGET(scrollbarWidget), scrollbarTag, button1Type, TRUE,
+                     x+hShim+arrow1Rect.getX(), y+vShim+arrow1Rect.getY(), 
+                     arrow1Rect.getWidth(), arrow1Rect.getHeight() );
+
+	// ----------------- BUTTON 2
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnButton2State, &stateType, &shadowType );
+	if ( stateType == GTK_STATE_INSENSITIVE )	stateType = GTK_STATE_NORMAL;
+	gtk_paint_box( style, gdkDrawable, stateType, shadowType, gdkRect, 
+                   GTK_WIDGET(scrollbarWidget), "stepper",
+                   x+hShim+button2BoundRect.getX(), y+vShim+button2BoundRect.getY(), 
+                   button2BoundRect.getWidth(), button2BoundRect.getHeight() );
+	// ----------------- ARROW 2
+	gtk_paint_arrow( style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, GTK_WIDGET(scrollbarWidget), scrollbarTag, button2Type, TRUE,
+                     x+hShim+arrow2Rect.getX(), y+vShim+arrow2Rect.getY(), 
+                     arrow2Rect.getWidth(), arrow2Rect.getHeight() );
+
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+ 	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//-------------------------------------
+
+static BOOL NWPaintGTKEditBox( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = NWGetEditBoxPixmapRect( nType, nPart, rControlRegion.GetBoundRect(),
+					nState, aValue, rControlHandle, aCaption );
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+
+	// NWPaintOneEditBox() requires pixmap local
+	Rectangle		aEditBoxRect = rControlRegion.GetBoundRect();
+	aEditBoxRect.setX( rControlRegion.GetBoundRect().getX() - pixmapRect.getX() );
+	aEditBoxRect.setY( rControlRegion.GetBoundRect().getY() - pixmapRect.getY() );
+
+	NWPaintOneEditBox( pixmap, nType, nPart, aEditBoxRect, nState, aValue, rControlHandle, aCaption );
+
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+
+/* Take interior/exterior focus into account and return
+ * the bounding rectangle of the edit box including
+ * any focus requirements.
+ */
+static Rectangle NWGetEditBoxPixmapRect(ControlType			nType,
+								ControlPart			nPart,
+								Rectangle				aAreaRect,
+								ControlState			nState,
+								const ImplControlValue&	aValue,
+								SalControlHandle&		rControlHandle,
+								OUString				aCaption )
+{
+	Rectangle		pixmapRect = aAreaRect;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+
+	NWEnsureGTKEditBox();
+
+	// Grab some entry style attributes
+	gtk_widget_style_get( gEditBoxWidget,	"focus-line-width",	&focusWidth,
+					 				"interior-focus",	&interiorFocus, NULL );
+
+	if ( !interiorFocus )
+	{
+		pixmapRect.Move( -(focusWidth), -(focusWidth) );
+		pixmapRect.setWidth( pixmapRect.getWidth() + (2*(focusWidth)) );
+		pixmapRect.setHeight( pixmapRect.getHeight() + (2*(focusWidth)) );
+	}
+
+	return( pixmapRect );
+}
+
+
+/* Paint a GTK Entry widget into the specified GdkPixmap.
+ * All coordinates should be local to the Pixmap, NOT
+ * screen/window coordinates.
+ */
+static void NWPaintOneEditBox(	GdkPixmap *			pixmap,
+							ControlType			nType,
+							ControlPart			nPart,
+							Rectangle				aEditBoxRect,
+							ControlState			nState,
+							const ImplControlValue&	aValue,
+							SalControlHandle&		rControlHandle,
+							OUString				aCaption )
+{
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	GtkWidget *	widget;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKEditBox();
+	NWEnsureGTKSpinButton();
+	NWEnsureGTKCombo();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	switch ( nType )
+	{
+		case CTRL_COMBOBOX:
+		case CTRL_SPINBOX:
+			widget = gSpinButtonWidget;
+			break;
+
+//		case CTRL_COMBOBOX:
+//			widget = gComboWidget;
+//			break;
+
+		default:
+			widget = gEditBoxWidget;
+			break;
+	}
+
+	NWSetWidgetState( gBtnWidget, nState, stateType );
+	NWSetWidgetState( widget, nState, stateType );
+
+	// set up references to correct drawable and cliprect
+	GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( pixmap );
+	GdkRectangle* const &gdkRect    = NULL;
+
+	// Blueprint needs to paint entry_bg with a Button widget, not an Entry widget to get
+	// a nice white (or whatever default color) background
+	if ( stateType == GTK_STATE_PRELIGHT )
+		stateType = GTK_STATE_NORMAL;
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, stateType, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "entry_bg",
+                        aEditBoxRect.getX(), aEditBoxRect.getY(), 
+                        aEditBoxRect.getWidth(), aEditBoxRect.getHeight() );
+
+	gtk_paint_shadow( widget->style, gdkDrawable, GTK_STATE_NORMAL, shadowType, 
+                      gdkRect, widget, "entry",
+                      aEditBoxRect.getX(), aEditBoxRect.getY(), 
+                      aEditBoxRect.getWidth(), aEditBoxRect.getHeight() );
+
+	// Grab some entry style attributes
+	gtk_widget_style_get( gEditBoxWidget,	"focus-line-width",	&focusWidth,
+					 				"interior-focus",	&interiorFocus, NULL );
+	// Draw focus rect
+#if 0   // vcl draws focus rects
+	if ( nState & CTRL_STATE_FOCUSED )
+	{
+		if ( !interiorFocus )
+		{
+			Rectangle aFocusRect = aEditBoxRect;
+
+			aFocusRect.Move( -(focusWidth), -(focusWidth) );
+			aFocusRect.setWidth( aFocusRect.getWidth() + (2*(focusWidth)) );
+			aFocusRect.setHeight( aFocusRect.getHeight() + (2*(focusWidth)) );
+
+			gtk_paint_focus( widget->style, gdkDrawable, stateType, gdkRect, widget, "entry", 
+				aFocusRect.getX(), aFocusRect.getY(), aFocusRect.getWidth(), aFocusRect.getHeight() );
+		}
+	}
+#endif
+}
+
+
+
+//-------------------------------------
+
+static BOOL NWPaintGTKSpinBox( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+	GdkPixmap	*		pixmap;
+	Rectangle			pixmapRect;
+	GtkStateType		stateType;
+	GtkShadowType		shadowType;
+	SpinbuttonValue *	pSpinVal = (SpinbuttonValue *)(aValue.getOptionalVal());
+	Rectangle			upBtnRect;
+	ControlPart		upBtnPart = PART_BUTTON_UP;
+	ControlState		upBtnState = CTRL_STATE_ENABLED;
+	Rectangle			downBtnRect;
+	ControlPart		downBtnPart = PART_BUTTON_DOWN;
+	ControlState		downBtnState = CTRL_STATE_ENABLED;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKSpinButton();
+	NWEnsureGTKArrow();
+
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	if ( pSpinVal )
+	{
+		upBtnPart = pSpinVal->mnUpperPart;
+		upBtnState = pSpinVal->mnUpperState;
+
+		downBtnPart = pSpinVal->mnLowerPart;
+		downBtnState = pSpinVal->mnLowerState;
+	}
+
+	// CTRL_SPINBUTTONS pass their area in pSpinVal, not in rControlRegion
+	if ( nType == CTRL_SPINBUTTONS )
+	{
+		if ( !pSpinVal )
+		{
+			fprintf( stderr, "Tried to draw CTRL_SPINBUTTONS, but the SpinButtons data structure didn't exist!\n" );
+			return( false );
+		}
+		pixmapRect = pSpinVal->maUpperRect;
+		pixmapRect.Union( pSpinVal->maLowerRect );
+	}
+	else
+		pixmapRect = rControlRegion.GetBoundRect();
+
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+
+	upBtnRect = NWGetSpinButtonRect( nType, upBtnPart, pixmapRect, upBtnState, aValue, rControlHandle, aCaption );
+	downBtnRect = NWGetSpinButtonRect( nType, downBtnPart, pixmapRect, downBtnState, aValue, rControlHandle, aCaption );
+
+	if ( (nType==CTRL_SPINBOX) && (nPart!=PART_ALL_BUTTONS) )
+	{
+		// Draw an edit field for SpinBoxes and ComboBoxes
+		Rectangle aEditBoxRect( pixmapRect );
+		aEditBoxRect.setWidth( upBtnRect.getX() - pixmapRect.getX() );
+		aEditBoxRect.setX( 0 );
+		aEditBoxRect.setY( 0 );
+
+		NWPaintOneEditBox( pixmap, nType, nPart, aEditBoxRect, nState, aValue, rControlHandle, aCaption );
+	}
+
+	NWSetWidgetState( gSpinButtonWidget, nState, stateType );
+	gtk_widget_style_get( gSpinButtonWidget, "shadow_type", &shadowType, NULL );
+
+	if ( shadowType != GTK_SHADOW_NONE )
+	{
+		Rectangle		shadowRect( upBtnRect );
+
+		shadowRect.Union( downBtnRect );
+		gtk_paint_box( gSpinButtonWidget->style, pixmap, GTK_STATE_NORMAL, shadowType, NULL,
+			gSpinButtonWidget, "spinbutton",
+			(shadowRect.getX() - pixmapRect.getX()), (shadowRect.getY() - pixmapRect.getY()),
+			shadowRect.getWidth(), shadowRect.getHeight() );
+	}
+
+	NWPaintOneSpinButton( pixmap, nType, upBtnPart, pixmapRect, upBtnState, aValue, rControlHandle, aCaption );
+	NWPaintOneSpinButton( pixmap, nType, downBtnPart, pixmapRect, downBtnState, aValue, rControlHandle, aCaption );
+
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//---
+
+static Rectangle NWGetSpinButtonRect(	ControlType			nType,
+								ControlPart			nPart,
+								Rectangle 			aAreaRect,
+								ControlState			nState,
+								const ImplControlValue&	aValue,
+								SalControlHandle&		rControlHandle,
+								OUString				aCaption )
+{
+	gint			buttonSize;
+	Rectangle		buttonRect;
+
+	NWEnsureGTKSpinButton();
+
+	buttonSize = MAX( PANGO_PIXELS( pango_font_description_get_size(GTK_WIDGET(gSpinButtonWidget)->style->font_desc) ),
+				   MIN_SPIN_ARROW_WIDTH );
+	buttonSize -= buttonSize % 2 - 1; /* force odd */
+	buttonRect.setWidth( buttonSize + 2 * gSpinButtonWidget->style->xthickness );
+	buttonRect.setX( aAreaRect.getX() + (aAreaRect.getWidth() - buttonRect.getWidth()) );
+	if ( nPart == PART_BUTTON_UP )
+	{
+		buttonRect.Top() = aAreaRect.getY();
+		buttonRect.Bottom() = buttonRect.Top() + (aAreaRect.getHeight() / 2);
+	}
+	else
+	{
+		buttonRect.Top() = aAreaRect.getY() + (aAreaRect.getHeight() / 2);
+		buttonRect.Bottom() = aAreaRect.Bottom(); // cover area completely
+	}
+
+	return( buttonRect );
+}
+
+//---
+
+static void NWPaintOneSpinButton(	GdkPixmap	*			pixmap,
+							ControlType			nType,
+							ControlPart			nPart,
+							Rectangle				aAreaRect,
+							ControlState			nState,
+							const ImplControlValue&	aValue,
+							SalControlHandle&		rControlHandle,
+							OUString				aCaption )
+{
+	Rectangle			buttonRect;
+	GtkStateType		stateType;
+	GtkShadowType		shadowType;
+	Rectangle			arrowRect;
+	gint				arrowSize;
+
+	NWEnsureGTKSpinButton();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	buttonRect = NWGetSpinButtonRect( nType, nPart, aAreaRect, nState, aValue, rControlHandle, aCaption );
+
+	NWSetWidgetState( gSpinButtonWidget, nState, stateType );
+	gtk_paint_box( gSpinButtonWidget->style, pixmap, stateType, shadowType, NULL, gSpinButtonWidget,
+			(nPart == PART_BUTTON_UP) ? "spinbutton_up" : "spinbutton_down",
+			(buttonRect.getX() - aAreaRect.getX()), (buttonRect.getY() - aAreaRect.getY()),
+			buttonRect.getWidth(), buttonRect.getHeight() );
+
+	arrowSize = (buttonRect.getWidth() - (2 * gSpinButtonWidget->style->xthickness)) - 4;
+	arrowSize -= arrowSize % 2 - 1; /* force odd */
+	arrowRect.setWidth( arrowSize );
+	arrowRect.setHeight( arrowRect.getWidth() );
+	arrowRect.setX( buttonRect.getX() + (buttonRect.getWidth() - arrowRect.getWidth()) / 2 );
+	if ( nPart == PART_BUTTON_UP )
+		arrowRect.setY( buttonRect.getY() + (buttonRect.getHeight() - arrowRect.getHeight()) / 2 + 1);
+	else
+		arrowRect.setY( buttonRect.getY() + (buttonRect.getHeight() - arrowRect.getHeight()) / 2 - 1);
+
+	gtk_paint_arrow( gSpinButtonWidget->style, pixmap, GTK_STATE_NORMAL, GTK_SHADOW_OUT, NULL, gSpinButtonWidget,
+			"spinbutton", (nPart == PART_BUTTON_UP) ? GTK_ARROW_UP : GTK_ARROW_DOWN, TRUE,
+			(arrowRect.getX() - aAreaRect.getX()), (arrowRect.getY() - aAreaRect.getY()),
+			arrowRect.getWidth(), arrowRect.getHeight() );
+}
+
+
+//-------------------------------------
+
+static BOOL NWPaintGTKComboBox( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+	GdkPixmap	*	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		buttonRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	Rectangle		arrowRect;
+	gint			arrowSize;
+	gint			x,y;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKArrow();
+	NWEnsureGTKCombo();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+
+	// set up references to correct drawable and cliprect
+	GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( pixmap );
+	GdkRectangle* const &gdkRect    = NULL;
+
+	x = y = 0;
+	buttonRect = NWGetComboBoxButtonRect( nType, nPart, pixmapRect, nState, aValue, rControlHandle, aCaption );
+
+	Rectangle		aEditBoxRect( pixmapRect );
+	aEditBoxRect.setWidth( pixmapRect.getWidth() - buttonRect.getWidth() );
+	aEditBoxRect.setX( x );
+	aEditBoxRect.setY( y );
+
+	NWPaintOneEditBox( gdkDrawable, nType, nPart, aEditBoxRect, 
+                       nState, aValue, rControlHandle, aCaption );
+
+	NWSetWidgetState( gBtnWidget, nState, stateType );
+	NWSetWidgetState( gComboWidget, nState, stateType );
+	NWSetWidgetState( gArrowWidget, nState, stateType );
+
+	// Buttons must paint opaque since some themes have alpha-channel enabled buttons
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "base", 
+                        x+(buttonRect.getX() - pixmapRect.getX()), 
+                        y+(buttonRect.getY() - pixmapRect.getY()),
+                        buttonRect.getWidth(), buttonRect.getHeight() );
+
+	gtk_paint_box( GTK_COMBO(gComboWidget)->button->style, gdkDrawable, stateType, shadowType,
+                   gdkRect, GTK_COMBO(gComboWidget)->button, "button",
+                   x+(buttonRect.getX() - pixmapRect.getX()), 
+                   y+(buttonRect.getY() - pixmapRect.getY()),
+                   buttonRect.getWidth(), buttonRect.getHeight() );
+
+#define ARROW_EXTENT		0.7
+	arrowRect.setWidth( (gint)(MIN_ARROW_SIZE * ARROW_EXTENT) );
+	arrowRect.setHeight( (gint)(MIN_ARROW_SIZE * ARROW_EXTENT) );
+	arrowRect.setX( buttonRect.getX() + (gint)((buttonRect.getWidth() - arrowRect.getWidth()) / 2)  );
+	arrowRect.setY( buttonRect.getY() + (gint)((buttonRect.getHeight() - arrowRect.getHeight()) / 2)  );
+
+	gtk_paint_arrow( gArrowWidget->style, gdkDrawable, stateType, shadowType,
+			gdkRect, gArrowWidget, "arrow", GTK_ARROW_DOWN, TRUE,
+			x+(arrowRect.getX() - pixmapRect.getX()), y+(arrowRect.getY() - pixmapRect.getY()),
+			arrowRect.getWidth(), arrowRect.getHeight() );
+
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+ 	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//----
+
+static Rectangle NWGetComboBoxButtonRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle	aButtonRect;
+	gint		nArrowWidth;
+	gint		nFocusWidth;
+	gint		nFocusPad;
+
+	NWEnsureGTKArrow();
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gDropdownWidget,	"focus-line-width",	&nFocusWidth,
+									"focus-padding", 	&nFocusPad, NULL );
+
+	nArrowWidth = MIN_ARROW_SIZE + (GTK_MISC(gArrowWidget)->xpad * 2);
+	aButtonRect.setY( aAreaRect.getY() );
+	aButtonRect.setHeight( aAreaRect.getHeight() );
+	aButtonRect.setWidth( nArrowWidth + ((BTN_CHILD_SPACING + gDropdownWidget->style->xthickness) * 2)
+						+ (2 * (nFocusWidth+nFocusPad)) );
+	aButtonRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - aButtonRect.getWidth() );
+
+	return( aButtonRect );
+}
+
+//-------------------------------------
+
+static BOOL NWPaintGTKTabItem( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	TabitemValue *	pTabitemValue = (TabitemValue *)(aValue.getOptionalVal());
+#if 0
+	TabpaneValue * pTabpaneValue = (TabpaneValue *)(aValue.getOptionalVal());
+#endif
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	gint			gap_left = 0;
+	gint			gap_width = 0;
+	static NWPixmapCache aCacheItems;
+	static NWPixmapCache aCachePage;
+
+	if( !aCacheItems.GetSize() )
+ 		aCacheItems.SetSize( 20 );
+ 	if( !aCachePage.GetSize() )
+		aCachePage.SetSize( 1 );
+    
+	if ( !pTabitemValue && (nType==CTRL_TAB_ITEM) )
+	{
+		fprintf( stderr, "NWPaintGTKTabItem() received a NULL TabitemValue.  Cannot draw native tab\n" );
+		return( false );
+	}
+
+	NWEnsureGTKButton();
+	NWEnsureGTKNotebook();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	if ( nType == CTRL_TAB_ITEM )
+	{
+		if ( !pTabitemValue->isFirst() )
+		{
+			// GTK+ tabs overlap on the right edge (the top tab obscures the
+			// left edge of the tab right "below" it, so adjust the rectangle
+			// to draw tabs slightly large so the overlap happens
+			pixmapRect.Left() -= 2;
+			pixmapRect.Right() += 2;
+		}
+		if ( nState & CTRL_STATE_SELECTED )
+		{
+			// In GTK+, the selected tab is 2px taller than all other tabs
+			pixmapRect.Top() -= 2;
+			pixmapRect.Bottom()++;
+		}
+
+		// Allow the tab to draw a right border if needed
+		pixmapRect.Right()--;
+	}
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+
+	if( nType == CTRL_TAB_ITEM )
+	{
+		if( aCacheItems.Find( nType, nState, pixmapRect, &pixmap ) )
+			return NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth);
+	}
+	else
+	{
+		if( aCachePage.Find( nType, nState, pixmapRect, &pixmap ) )
+			return NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth);
+	}
+
+	NWSetWidgetState( gNotebookWidget, nState, stateType );
+	switch( nType )
+	{
+		case CTRL_TAB_BODY:
+			break;
+
+		case CTRL_FIXEDBORDER:
+		case CTRL_TAB_PANE:
+#if 0
+			if ( pTabpaneValue != NULL )
+			{
+				gap_left = pTabpaneValue->maCurItemRect.Left();
+				gap_width = pTabpaneValue->maCurItemRect.getWidth();
+			}
+#endif
+			gtk_paint_box_gap( gNotebookWidget->style, pixmap, GTK_STATE_NORMAL, GTK_SHADOW_OUT, NULL, gNotebookWidget,
+				"notebook", 0, 0, pixmapRect.getWidth(), pixmapRect.getHeight(), GTK_POS_TOP, gap_left, gap_width );
+			break;
+
+		case CTRL_TAB_ITEM:
+			stateType = ( nState & CTRL_STATE_SELECTED ) ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE;
+
+			gtk_paint_extension( gNotebookWidget->style, pixmap, stateType, GTK_SHADOW_OUT, NULL, gNotebookWidget,
+				"tab", 0, 0,
+				pixmapRect.getWidth(), pixmapRect.getHeight(), GTK_POS_BOTTOM );
+			break;
+
+		default:
+			break;
+	}
+
+	// Crux seems to think it can make the pane without a left edge
+	if ( nType == CTRL_FIXEDBORDER )
+		pixmapRect.Move( 1, 0 );
+
+#if 0
+	// cache data
+	if( GetGtkFrame()->getVisibilityState() == GDK_VISIBILITY_UNOBSCURED ) 
+#endif
+	{
+		if( nType == CTRL_TAB_ITEM )
+			aCacheItems.Fill( nType, nState, pixmapRect, pixmap );
+		else
+			aCachePage.Fill( nType, nState, pixmapRect, pixmap );
+	}
+        
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+    
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//-------------------------------------
+
+static BOOL NWPaintGTKListBox( XLIB_Window xlibWindow, Display* xlibDisplay, GC gc, ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption, int nDepth )
+{
+	GdkPixmap	*	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		widgetRect;
+	Rectangle		aIndicatorRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	gint			bInteriorFocus;
+	gint			nFocusLineWidth;
+	gint			nFocusPadding;
+	gint			x,y;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKOptionMenu();
+	NWEnsureGTKScrolledWindow();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	if ( nPart == PART_WINDOW )
+	{
+		// Make the widget a _bit_ bigger
+		pixmapRect.setX( pixmapRect.getX() - 1 );
+		pixmapRect.setY( pixmapRect.getY() - 1 );
+		pixmapRect.setWidth( pixmapRect.getWidth() + 2 );
+		pixmapRect.setHeight( pixmapRect.getHeight() + 2 );
+	}
+
+	widgetRect = pixmapRect;
+
+	pixmap = NWGetPixmapFromScreen( xlibDisplay, xlibWindow, pixmapRect, nDepth );
+	if ( !pixmap )
+		return( FALSE );
+
+	// set up references to correct drawable and cliprect
+	GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( pixmap );
+	GdkRectangle* const &gdkRect    = NULL;
+
+	x = y = 0;
+	NWSetWidgetState( gBtnWidget, nState, stateType );
+	NWSetWidgetState( gOptionMenuWidget, nState, stateType );
+	NWSetWidgetState( gScrolledWindowWidget, nState, stateType );
+
+	if ( nPart != PART_WINDOW )
+	{
+		gtk_widget_style_get( gOptionMenuWidget,
+			"interior_focus",	&bInteriorFocus,
+			"focus_line_width",	&nFocusLineWidth,
+			"focus_padding",	&nFocusPadding,
+			NULL);
+
+		// Listboxes must paint opaque since some themes have alpha-channel enabled bodies
+		gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                            gdkRect, gBtnWidget, "base", x, y, 
+                            pixmapRect.getWidth(), pixmapRect.getHeight() );
+
+		gtk_paint_box( gOptionMenuWidget->style, gdkDrawable, stateType, shadowType, gdkRect,
+                       gOptionMenuWidget, "optionmenu",
+                       x+(widgetRect.getX() - pixmapRect.getX()), 
+                       y+(widgetRect.getY() - pixmapRect.getY()),
+                       widgetRect.getWidth(), widgetRect.getHeight() );
+
+		aIndicatorRect = NWGetListBoxIndicatorRect( nType, nPart, widgetRect, nState, 
+                                                    aValue, rControlHandle, aCaption );
+		gtk_paint_tab( gOptionMenuWidget->style, gdkDrawable, stateType, shadowType, gdkRect,
+                       gOptionMenuWidget, "optionmenutab",
+                       x+(aIndicatorRect.getX() - pixmapRect.getX()), 
+                       y+(aIndicatorRect.getY() - pixmapRect.getY()),
+                       aIndicatorRect.getWidth(), aIndicatorRect.getHeight() );
+	}
+	else
+	{
+		gtk_paint_shadow( gScrolledWindowWidget->style, gdkDrawable, GTK_STATE_NORMAL, shadowType,
+			gdkRect, gScrolledWindowWidget, "scrolled_window",
+			x+(widgetRect.getX() - pixmapRect.getX()), y+(widgetRect.getY() - pixmapRect.getY()),
+			widgetRect.getWidth(), widgetRect.getHeight() );
+	}
+
+	if( !NWRenderPixmapToScreen(pixmap, xlibDisplay, xlibWindow, gc, pixmapRect, nDepth) )
+ 	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//----
+
+static Rectangle NWGetListBoxButtonRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle 		aPartRect;
+	GtkRequisition *	pIndicatorSize;
+	GtkBorder *		pIndicatorSpacing;
+	gint				width = 13;	// GTK+ default
+	gint				left  = 7;	// GTK+ default
+	gint				right = 5;	// GTK+ default
+	gint				nButtonAreaWidth = 0;
+
+	NWEnsureGTKOptionMenu();
+
+	gtk_widget_style_get( gOptionMenuWidget,
+			"indicator_size",	&pIndicatorSize,
+			"indicator_spacing",&pIndicatorSpacing, NULL);
+	
+	if ( pIndicatorSize && ((pIndicatorSize->width < 20) || (pIndicatorSize->width >= 0)) )
+		width = pIndicatorSize->width;
+
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->right < 20) || (pIndicatorSpacing->right >= 0)) )
+		right = pIndicatorSpacing->right;
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->left < 20) || (pIndicatorSpacing->left >= 0)) )
+		left = pIndicatorSpacing->left;
+
+	aPartRect.setHeight( aAreaRect.getHeight() );
+	aPartRect.setY( aAreaRect.getY() );
+
+	nButtonAreaWidth = width + right + (gOptionMenuWidget->style->xthickness * 2);
+	switch( nPart )
+	{
+		case PART_BUTTON_DOWN:
+			aPartRect.setWidth( nButtonAreaWidth );
+			aPartRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - aPartRect.getWidth() );
+			break;
+
+		case PART_SUB_EDIT:
+			aPartRect.setWidth( aAreaRect.getWidth() - nButtonAreaWidth );
+			aPartRect.setX( aAreaRect.getX() );
+			break;
+
+		default:
+			aPartRect.setWidth( aAreaRect.getWidth() );	
+			aPartRect.setX( aAreaRect.getX() );
+			break;
+	}
+
+	if ( pIndicatorSize )
+		g_free( pIndicatorSize );
+	if ( pIndicatorSpacing )
+		g_free( pIndicatorSpacing );
+
+	return( aPartRect );
+}
+
+//----
+
+static Rectangle NWGetListBoxIndicatorRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle 		aIndicatorRect;
+	GtkRequisition *	pIndicatorSize;
+	GtkBorder *		pIndicatorSpacing;
+	gint				width = 7;	// GTK+ default
+	gint				height = 13;	// GTK+ default
+	gint				right = 5;	// GTK+ default
+
+	NWEnsureGTKOptionMenu();
+
+	gtk_widget_style_get( gOptionMenuWidget,
+			"indicator_size",	&pIndicatorSize,
+			"indicator_spacing",&pIndicatorSpacing, NULL);
+	
+	if ( pIndicatorSize && ((pIndicatorSize->width < 20) && (pIndicatorSize->width >= 0)) )
+		width = pIndicatorSize->width;
+	if ( pIndicatorSize && ((pIndicatorSize->height < 20) && (pIndicatorSize->height >= 0)) )
+		height = pIndicatorSize->height;
+
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->right < 20) && (pIndicatorSpacing->right >= 0)) )
+		right = pIndicatorSpacing->right;
+
+	aIndicatorRect.setWidth( width );
+	aIndicatorRect.setHeight( height );
+	aIndicatorRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - width - right - gOptionMenuWidget->style->xthickness );
+	aIndicatorRect.setY( aAreaRect.getY() + ((aAreaRect.getHeight() - height) / 2) );
+
+	// If height is odd, move the indicator down 1 pixel
+	if ( aIndicatorRect.getHeight() % 2 )
+		aIndicatorRect.setY( aIndicatorRect.getY() + 1 );
+
+	if ( pIndicatorSize )
+		g_free( pIndicatorSize );
+	if ( pIndicatorSpacing )
+		g_free( pIndicatorSpacing );
+
+	return( aIndicatorRect );
+}
+
+
+/************************************************************************
+ * Create a GdkPixmap filled with the contents of an area of an Xlib window
+ ************************************************************************/
+
+static GdkPixmap * NWGetPixmapFromScreen(	Display *		pXlibDisplay,
+									Drawable		xlibWindow,
+									Rectangle		srcRect,
+									int			nDepth )
+{
+    // Create a new pixmap to hold the composite of the window background and the control
+    GdkPixmap * pPixmap		= gdk_pixmap_new( NULL, srcRect.getWidth(), srcRect.getHeight(), nDepth );
+    GdkGC *	 pPixmapGC	= gdk_gc_new( pPixmap );
+
+    if( !pPixmap || !pPixmapGC )
+    {
+        if ( pPixmap )
+            g_object_unref( pPixmap );
+        if ( pPixmapGC )
+            g_object_unref( pPixmapGC );
+        fprintf( stderr, "salnativewidgets-gtk.cxx: could not get valid pixmap from screen\n" );
+        return( NULL );
+    }
+
+    // Copy the background of the screen into a composite pixmap
+    XCopyArea( pXlibDisplay, xlibWindow, gdk_x11_drawable_get_xid(pPixmap), gdk_x11_gc_get_xgc(pPixmapGC),
+               srcRect.getX(), srcRect.getY(), srcRect.getWidth(), srcRect.getHeight(), 0, 0 );
+
+    g_object_unref( pPixmapGC );
+    return( pPixmap );
+}
+
+
+
+
+/************************************************************************
+ * Copy an alpha pixmap to screen using a gc with clipping
+ ************************************************************************/
+
+static BOOL NWRenderPixmapToScreen(	GdkPixmap *	pPixmap,
+								Display *		pXlibDisplay,
+								Drawable		xlibWindow,
+								GC			gc, 
+								Rectangle		dstRect,
+								int			nDepth )
+{
+    // The GC can't be null, otherwise we'd have no clip region
+    if( gc == NULL )
+    {
+        fprintf(stderr, "salnativewidgets.cxx: no valid GC\n" );
+        return( FALSE );
+    }
+
+    if ( !pPixmap )
+        return( FALSE );
+
+    // Copy the background of the screen into a composite pixmap
+    XCopyArea( pXlibDisplay, GDK_DRAWABLE_XID(pPixmap), xlibWindow, gc,
+               0, 0, dstRect.getWidth(), dstRect.getHeight(), dstRect.getX(), dstRect.getY() );
+    
+    return( TRUE );
+}
+
+
+/************************************************************************
+ * State conversion
+ ************************************************************************/
+static void NWConvertVCLStateToGTKState( ControlState nVCLState,
+			GtkStateType* nGTKState, GtkShadowType* nGTKShadow )
+{
+	*nGTKShadow = GTK_SHADOW_OUT;
+	*nGTKState = GTK_STATE_INSENSITIVE;
+
+	if ( nVCLState & CTRL_STATE_ENABLED )
+	{
+		if ( nVCLState & CTRL_STATE_PRESSED )
+		{
+			*nGTKState = GTK_STATE_ACTIVE;
+			*nGTKShadow = GTK_SHADOW_IN;
+		}
+		else if ( nVCLState & CTRL_STATE_ROLLOVER )
+		{
+			*nGTKState = GTK_STATE_PRELIGHT;
+			*nGTKShadow = GTK_SHADOW_OUT;
+		}
+		else
+		{
+			*nGTKState = GTK_STATE_NORMAL;
+			*nGTKShadow = GTK_SHADOW_OUT;
+		}
+	}
+}
+
+/************************************************************************
+ * Set widget flags
+ ************************************************************************/
+static void NWSetWidgetState( GtkWidget* widget, ControlState nState, GtkStateType nGtkState )
+{
+	// Set to default state, then build up from there
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_HAS_DEFAULT );
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_HAS_FOCUS );
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_SENSITIVE );
+	GTK_WIDGET_SET_FLAGS( widget, gWidgetDefaultFlags[(long)widget] );
+
+	if ( nState & CTRL_STATE_DEFAULT )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_HAS_DEFAULT );
+	if ( !GTK_IS_TOGGLE_BUTTON(widget) && (nState & CTRL_STATE_FOCUSED) )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_HAS_FOCUS );
+	if ( nState & CTRL_STATE_ENABLED )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_SENSITIVE );
+	gtk_widget_set_state( widget, nGtkState );
+}
+
+/************************************************************************
+ * Widget ensure functions - make sure cached objects are valid
+ ************************************************************************/
+
+//-------------------------------------
+
+static void NWAddWidgetToCacheWindow( GtkWidget* widget )
+{
+	if ( !gCacheWindow || !gDumbContainer )
+	{
+		if ( !gCacheWindow )
+			gCacheWindow = gtk_window_new( GTK_WINDOW_TOPLEVEL );
+		if ( !gDumbContainer )
+			gDumbContainer = gtk_fixed_new();
+		gtk_container_add( GTK_CONTAINER(gCacheWindow), gDumbContainer );
+		gtk_widget_realize( gDumbContainer );
+		gtk_widget_realize( gCacheWindow );
+	}
+
+	gtk_container_add( GTK_CONTAINER(gDumbContainer), widget );
+	gtk_widget_realize( widget );
+	gtk_widget_ensure_style( widget );
+
+	// Store widget's default flags
+	gWidgetDefaultFlags[ (long)widget ] = GTK_WIDGET_FLAGS( widget );
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKButton( void )
+{
+	if ( !gBtnWidget )
+	{
+		gBtnWidget = gtk_button_new_with_label( "" );
+		NWAddWidgetToCacheWindow( gBtnWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKRadio( void )
+{
+	if ( !gRadioWidget )
+	{
+		gRadioWidget = gtk_radio_button_new( NULL );
+		NWAddWidgetToCacheWindow( gRadioWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKCheck( void )
+{
+	if ( !gCheckWidget )
+	{
+		gCheckWidget = gtk_check_button_new();
+		NWAddWidgetToCacheWindow( gCheckWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKScrollbars( void )
+{
+	if ( !gScrollHorizWidget )
+	{
+		gScrollHorizWidget = gtk_hscrollbar_new( NULL );
+		NWAddWidgetToCacheWindow( gScrollHorizWidget );
+	}
+
+	if ( !gScrollVertWidget )
+	{
+		gScrollVertWidget = gtk_vscrollbar_new( NULL );
+		NWAddWidgetToCacheWindow( gScrollVertWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKArrow( void )
+{
+	if ( !gArrowWidget || !gDropdownWidget )
+	{
+		gDropdownWidget = gtk_toggle_button_new();
+		NWAddWidgetToCacheWindow( gDropdownWidget );
+		gArrowWidget = gtk_arrow_new( GTK_ARROW_DOWN, GTK_SHADOW_OUT );
+		gtk_container_add( GTK_CONTAINER(gDropdownWidget), gArrowWidget );
+		gtk_widget_set_rc_style( gArrowWidget );
+		gtk_widget_realize( gArrowWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKEditBox( void )
+{
+	if ( !gEditBoxWidget )
+	{
+		gEditBoxWidget = gtk_entry_new();
+		NWAddWidgetToCacheWindow( gEditBoxWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKSpinButton( void )
+{
+	if ( !gSpinButtonWidget )
+	{
+		GtkAdjustment *adj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+		gSpinButtonWidget = gtk_spin_button_new( adj, 1, 2 );
+		NWAddWidgetToCacheWindow( gSpinButtonWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKNotebook( void )
+{
+	if ( !gNotebookWidget )
+	{
+		gNotebookWidget = gtk_notebook_new();
+		NWAddWidgetToCacheWindow( gNotebookWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKOptionMenu( void )
+{
+	if ( !gOptionMenuWidget )
+	{
+		gOptionMenuWidget = gtk_option_menu_new();
+		NWAddWidgetToCacheWindow( gOptionMenuWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKCombo( void )
+{
+	if ( !gComboWidget )
+	{
+		gComboWidget = gtk_combo_new();
+		NWAddWidgetToCacheWindow( gComboWidget );
+		// Must realize the ComboBox's button widget, since GTK
+		// does not do this for us in GtkCombo::gtk_widget_realize()
+		gtk_widget_realize( GTK_COMBO(gComboWidget)->button );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKScrolledWindow( void )
+{
+	if ( !gScrolledWindowWidget )
+	{
+		GtkAdjustment *hadj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+		GtkAdjustment *vadj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+
+		gScrolledWindowWidget = gtk_scrolled_window_new( hadj, vadj );
+		NWAddWidgetToCacheWindow( gScrolledWindowWidget );
+	}
+}
+
+
+/************************************************************************
+ * SalControlHandleData stuff
+ ************************************************************************/
+SalControlHandleData::SalControlHandleData( void )
+{
+}
+
+
+SalControlHandleData::~SalControlHandleData( void )
+{
+}
+
+
unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/unx/source/gdi/salnativewidgets-kde.cxx	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,1632 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *                  Jan Holesovsky <kendy@artax.karlin.mff.cuni.cz>
+ *                  Lukas Tinkl <lukas@kde.org>
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_KDE_CXX
+
+// Hack, but needed because of conflicting types...
+#define Region QtXRegion
+
+#include <qcheckbox.h>
+#include <qcombobox.h>
+#include <qframe.h>
+#include <qlineedit.h>
+#include <qlistview.h>
+#include <qpainter.h>
+#include <qpushbutton.h>
+#include <qradiobutton.h>
+#include <qrangecontrol.h>
+#include <qtabbar.h>
+#include <qtabwidget.h>
+#include <qwidget.h>
+
+#include <kaboutdata.h>
+#include <kapplication.h>
+#include <kcmdlineargs.h>
+#include <kconfig.h>
+#include <kglobal.h>
+#include <kmainwindow.h>
+#include <kmenubar.h>
+#include <kstyle.h>
+
+#undef Region
+
+#include <salunx.h>
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+
+#ifndef _SV_KDEINT_HXX
+#include <kdeint.hxx>
+#endif
+
+#ifndef _SV_SETTINGS_HXX
+#include <settings.hxx>
+#endif
+
+#include <iostream>
+
+using namespace ::rtl;
+
+/** Cached native widgets.
+ 
+    A class which caches and paints the native widgets.
+*/
+class WidgetPainter
+{
+    protected:
+	/** Cached push button.
+
+	    It is necessary for the QStyle::drawControl(). The buttons are created
+	    on demand and they are still hidden (no QWidget::show() is called).
+	*/
+	QPushButton  *m_pPushButton;
+
+	/** Cached radio button.
+
+	    @see m_pPushButton
+	*/
+	QRadioButton *m_pRadioButton;
+
+	/** Cached check box.
+
+	    @see m_pPushButton
+	*/
+	QCheckBox    *m_pCheckBox;
+
+	/** Cached combo box.
+
+	    @see m_pPushButton
+	*/
+	QComboBox    *m_pComboBox;
+
+	/** Cached editable combo box.
+
+	    Needed, because some styles do not like dynamic changes
+	    (QComboBox::setEditable()).
+
+	    @see m_pPushButton
+	*/
+	QComboBox    *m_pEditableComboBox;
+
+	/** Cached line edit box.
+
+	    @see m_pPushButton
+	*/
+	QLineEdit    *m_pLineEdit;
+
+	/** Cached spin box.
+
+	    @see m_pPushButton
+	*/
+	QSpinWidget  *m_pSpinWidget;
+
+	/** Cached spin box'es line edit.
+
+	    @see m_pPushButton
+	*/
+	QLineEdit    *m_pSpinEdit;
+
+	/** Cached tab.
+
+	    Left, middle, right tab and a tab which is alone.
+
+	    @see m_pPushButton
+	*/
+	QTab         *m_pTabLeft, *m_pTabMiddle, *m_pTabRight, *m_pTabAlone;
+
+	/** Cached tab bar's parent widget.
+
+	    Needed, because the Qt windows style checks for the availability
+	    of tab bar's parent. We cannot use m_pTabWidget, because
+	    TabWidget::setTabBar() and TabWidget::tabBar() methods are
+	    protected.
+
+	    @see m_pPushButton, m_pTabWidget
+	*/
+	QWidget      *m_pTabBarParent;
+
+	/** Cached tab bar widget.
+
+	    @see m_pPushButton
+	*/
+	QTabBar      *m_pTabBar;
+
+	/** Cached tab widget.
+
+	    We need it to draw the tab page. It cannot be used to draw the
+	    tabs themselves, because the drawing has to be tweaked a little
+	    due to not enough information from VCL.
+
+	    @see m_pPushButton, m_pTabBarParent
+	*/
+	QTabWidget   *m_pTabWidget;
+
+	/** Cached list view.
+
+	    @see m_pPushButton
+	*/
+	QListView    *m_pListView;
+
+	/** Cached scroll bar.
+
+	    @see m_pPushButton
+	*/
+	QScrollBar   *m_pScrollBar;
+
+	// TODO other widgets
+
+    public:
+	/** Implicit constructor.
+
+	    It creates an empty WidgetPainter with all the cached widgets initialized
+	    to NULL. The widgets are created on demand and they are still hidden
+	    (no QWidget::show()), because they are needed just as a parameter for
+	    QStyle::drawControl().
+
+	    @see m_pPushButton
+	*/
+	WidgetPainter( void );
+
+	/** Destructor.
+
+	    Destruct all the cached widgets.
+	*/
+	virtual ~WidgetPainter( void );
+
+	/** Paints the specified widget to the X window.
+
+	    Use X calls to bitblt (bit block transfer) the widget qWidget to
+	    the window specified by drawable with the style defined by nStyle.
+
+	    @param qWidget
+	    A pointer to the cached widget.
+
+	    @param nState
+	    The state of the control (focused, on/off, ...)
+
+	    @param aValue
+	    The value (true/false, ...)
+
+	    @param dpy
+	    The display to be used by the X calls.
+
+	    @param drawable
+	    The destination X window.
+
+	    @param gc
+	    The graphics context.
+	*/
+	BOOL drawStyledWidget( QWidget *pWidget,
+		ControlState nState, const ImplControlValue& aValue,
+		Display *dpy, XLIB_Window drawable, GC gc );
+
+	/** 'Get' method for push button.
+
+	    The method returns the cached push button. It is constructed if it
+	    does not exist. It has NULL as a parent and it stays hidden, but it
+	    is necessary for the drawStyledWidget() method.
+
+	    @return valid push button.
+	*/
+	QPushButton  *pushButton( const Region& rControlRegion, BOOL bDefault );
+
+	/** 'Get' method for radio button.
+
+	    @see pushButton()
+	*/
+	QRadioButton *radioButton( const Region& rControlRegion );
+
+	/** 'Get' method for check box.
+
+	    @see pushButton()
+	*/
+	QCheckBox    *checkBox( const Region& rControlRegion );
+
+	/** 'Get' method for combo box.
+
+	    It returns m_pComboBox or m_pEditableComboBox according to
+	    bEditable.
+
+	    @see pushButton(), m_pEditableComboBox
+	*/
+	QComboBox    *comboBox( const Region& rControlRegion, BOOL bEditable );
+
+	/** 'Get' method for line edit box.
+
+	    @see pushButton()
+	*/
+	QLineEdit    *lineEdit( const Region& rControlRegion );
+
+	/** 'Get' method for spin box.
+
+	    @see pushButton()
+	*/
+	QSpinWidget  *spinWidget( const Region& rControlRegion );
+
+	/** 'Get' method for tab bar.
+
+	    @see pushButton()
+	*/
+	QTabBar      *tabBar( const Region& rControlRegion );
+
+	/** 'Get' method for tab widget.
+
+	    @see pushButton()
+	*/
+	QTabWidget   *tabWidget( const Region& rControlRegion );
+
+	/** 'Get' method for list view.
+
+	    @see pushButton()
+	*/
+	QListView    *listView( const Region& rControlRegion );
+
+	/** 'Get' method for scroll bar.
+
+	    @see pushButton()
+	*/
+	QScrollBar   *scrollBar( const Region& rControlRegion,
+		BOOL bHorizontal, const ImplControlValue& aValue );
+
+	// TODO other widgets
+
+    protected:
+	/** Style conversion function.
+
+	    Conversion function between VCL ControlState together with
+	    ImplControlValue and Qt state flags.
+
+	    @param nState
+	    State of the widget (default, focused, ...) as defined in Native
+	    Widget Framework.
+
+	    @param aValue
+	    Value held by the widget (on, off, ...)
+	*/
+	QStyle::SFlags vclStateValue2SFlags( ControlState nState, const ImplControlValue& aValue );
+
+    public:
+	/** Convert VCL Region to QRect.
+
+	    @param rControlRegion
+	    The region to convert.
+
+	    @return
+	    The bounding box of the region.
+	*/
+	static QRect region2QRect( const Region& rControlRegion );
+};
+
+WidgetPainter::WidgetPainter( void )
+    : m_pPushButton( NULL ),
+      m_pRadioButton( NULL ),
+      m_pCheckBox( NULL ),
+      m_pComboBox( NULL ),
+      m_pEditableComboBox( NULL ),
+      m_pLineEdit( NULL ),
+      m_pSpinWidget( NULL ),
+      m_pSpinEdit( NULL ),
+      m_pTabLeft( NULL ),
+      m_pTabMiddle( NULL ),
+      m_pTabRight( NULL ),
+      m_pTabAlone( NULL ),
+      m_pTabBarParent( NULL ),
+      m_pTabBar( NULL ),
+      m_pTabWidget( NULL ),
+      m_pListView( NULL ),
+      m_pScrollBar( NULL )
+{
+}
+
+WidgetPainter::~WidgetPainter( void )
+{
+    delete m_pPushButton, m_pPushButton = NULL;
+    delete m_pRadioButton, m_pRadioButton = NULL;
+    delete m_pCheckBox, m_pCheckBox = NULL;
+    delete m_pComboBox, m_pComboBox = NULL;
+    delete m_pEditableComboBox, m_pEditableComboBox = NULL;
+    delete m_pLineEdit, m_pLineEdit = NULL;
+    delete m_pSpinWidget, m_pSpinWidget = NULL;
+    delete m_pSpinEdit, m_pSpinEdit = NULL;
+    delete m_pTabLeft, m_pTabLeft = NULL;
+    delete m_pTabMiddle, m_pTabMiddle = NULL;
+    delete m_pTabRight, m_pTabRight = NULL;
+    delete m_pTabAlone, m_pTabAlone = NULL;
+    delete m_pTabBarParent, m_pTabBarParent = NULL;
+    delete m_pTabBar, m_pTabBar = NULL;
+    delete m_pTabWidget, m_pTabWidget = NULL;
+    delete m_pListView, m_pListView = NULL;
+    delete m_pScrollBar, m_pScrollBar = NULL;
+}
+
+BOOL WidgetPainter::drawStyledWidget( QWidget *pWidget,
+	ControlState nState, const ImplControlValue& aValue,
+	Display *dpy, XLIB_Window drawable, GC gc )
+{
+    if ( !pWidget )
+	return FALSE;
+
+    // Normalize the widget
+    QPoint   qWidgetPos( pWidget->pos() );
+    pWidget->move( 0, 0 );
+
+    // Enable/disable the widget
+    pWidget->setEnabled( nState & CTRL_STATE_ENABLED );
+
+    // Create pixmap to paint to
+    QPixmap  qPixmap( pWidget->width(), pWidget->height() );
+    QPainter qPainter( &qPixmap );
+    QRect    qRect( 0, 0, pWidget->width(), pWidget->height() );
+
+    // Use the background of the widget
+    qPixmap.fill( pWidget, QPoint(0, 0) );
+    
+    // Convert the flags
+    QStyle::SFlags nStyle = vclStateValue2SFlags( nState, aValue );
+    
+    // Store the widget class
+    const char *pClassName = pWidget->className();
+    
+    // Draw the widget to the pixmap
+    if ( strcmp( "QPushButton", pClassName ) == 0 )
+    {
+	// Workaround for the Platinum style.
+	// Platinum takes the state directly from the widget, not from SFlags.
+	QPushButton *pPushButton = static_cast<QPushButton *>( pWidget->qt_cast( "QPushButton" ) );
+	if ( pPushButton )
+	{
+	    pPushButton->setDown   ( nStyle & QStyle::Style_Down );
+	    pPushButton->setOn     ( nStyle & QStyle::Style_On );
+	    pPushButton->setEnabled( nStyle & QStyle::Style_Enabled );
+	}
+	
+	kapp->style().drawControl( QStyle::CE_PushButton,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QRadioButton", pClassName ) == 0 )
+    {
+	// Bitblt from the screen, because the radio buttons are usually not
+	// rectangular, and there could be a bitmap under them
+	GC aTmpGC = XCreateGC( dpy, qPixmap.handle(), 0, NULL );
+	XCopyArea( dpy,
+		drawable, qPixmap.handle(),
+		aTmpGC,
+		qWidgetPos.x(), qWidgetPos.y(), qRect.width(), qRect.height(),
+		0, 0 );
+	XFreeGC( dpy, aTmpGC );
+
+	kapp->style().drawControl( QStyle::CE_RadioButton,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QCheckBox", pClassName ) == 0 )
+    {
+	kapp->style().drawControl( QStyle::CE_CheckBox,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QComboBox", pClassName ) == 0 )
+    {
+	kapp->style().drawComplexControl( QStyle::CC_ComboBox,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+	
+	// Editable combo box uses the background of the associated edit box
+	QComboBox *pComboBox = static_cast<QComboBox *>( pWidget->qt_cast( "QComboBox" ) );
+	if ( pComboBox && pComboBox->editable() && pComboBox->lineEdit() )
+	{
+	    QColorGroup::ColorRole eColorRole = ( pComboBox->isEnabled() )?
+		QColorGroup::Base: QColorGroup::Background;
+	    qPainter.fillRect( 
+		    kapp->style().querySubControlMetrics( QStyle::CC_ComboBox, 
+			pComboBox, QStyle::SC_ComboBoxEditField ),
+		    pComboBox->lineEdit()->colorGroup().brush( eColorRole ) );
+	}
+    }
+    else if ( strcmp( "QLineEdit", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_PanelLineEdit,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle | QStyle::Style_Sunken );
+    }
+    else if ( strcmp( "QSpinWidget", pClassName ) == 0 )
+    {
+	SpinbuttonValue *pValue = static_cast<SpinbuttonValue *> ( aValue.getOptionalVal() );
+	
+	// Is any of the buttons pressed?
+	QStyle::SCFlags eActive = QStyle::SC_None;
+	if ( pValue )
+	{
+	    if ( pValue->mnUpperState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_SpinWidgetUp;
+	    else if ( pValue->mnLowerState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_SpinWidgetDown;
+
+	    // Update the enable/disable state of the widget
+	    if ( ( nState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnUpperState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnLowerState & CTRL_STATE_ENABLED ) )
+	    {
+		pWidget->setEnabled( true );
+		nStyle |= QStyle::Style_Enabled;
+	    }
+	    else
+		pWidget->setEnabled( false );
+
+	    // Mouse-over effect
+	    if ( (pValue->mnUpperState & CTRL_STATE_ROLLOVER) ||
+		    (pValue->mnLowerState & CTRL_STATE_ROLLOVER) )
+		nStyle |= QStyle::Style_MouseOver;
+	}
+
+	// Spin widget uses the background of the associated edit box
+	QSpinWidget *pSpinWidget = static_cast<QSpinWidget *>( pWidget->qt_cast( "QSpinWidget" ) );
+	if ( pSpinWidget && pSpinWidget->editWidget() )
+	{
+	    QColorGroup::ColorRole eColorRole = ( pSpinWidget->isEnabled() )?
+		QColorGroup::Base: QColorGroup::Background;
+	    qPainter.fillRect( 
+		    kapp->style().querySubControlMetrics( QStyle::CC_SpinWidget, 
+			pSpinWidget, QStyle::SC_SpinWidgetEditField ),
+		    pSpinWidget->editWidget()->colorGroup().brush( eColorRole ) );
+	}
+
+	// Adjust the frame (needed for Motif Plus style)
+	QRect qFrameRect = kapp->style().querySubControlMetrics( QStyle::CC_SpinWidget,
+		pWidget, QStyle::SC_SpinWidgetFrame );
+	
+	kapp->style().drawComplexControl( QStyle::CC_SpinWidget,
+		&qPainter, pWidget, qFrameRect,
+		pWidget->colorGroup(), nStyle,
+		QStyle::SC_All, eActive );
+    }
+    else if ( strcmp( "QTabBar", pClassName ) == 0 )
+    {
+	TabitemValue *pValue = static_cast<TabitemValue *> ( aValue.getOptionalVal() );
+	
+	QTab *pTab = NULL;
+	if ( pValue )
+	{
+	    if ( ( pValue->isFirst() || pValue->isLeftAligned() ) && ( pValue->isLast() || pValue->isRightAligned() ) )
+		pTab = m_pTabAlone;
+	    else if ( pValue->isFirst() || pValue->isLeftAligned() )
+		pTab = m_pTabLeft;
+	    else if ( pValue->isLast() || pValue->isRightAligned() )
+		pTab = m_pTabRight;
+	    else
+		pTab = m_pTabMiddle;
+	}
+	if ( !pTab )
+	    return FALSE;
+	
+	pTab->setRect( qRect );
+	
+	kapp->style().drawControl( QStyle::CE_TabBarTab,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle,
+		QStyleOption( pTab ) );
+    }
+    else if ( strcmp( "QTabWidget", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_PanelTabWidget,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QListView", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_Panel,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle | QStyle::Style_Sunken );
+    }
+    else if ( strcmp( "QScrollBar", pClassName ) == 0 )
+    {
+	ScrollbarValue *pValue = static_cast<ScrollbarValue *> ( aValue.getOptionalVal() );
+
+	QStyle::SCFlags eActive = QStyle::SC_None;
+	if ( pValue )
+	{
+	    // Workaround for Style_MouseOver-aware themes.
+	    // Quite ugly, but I do not know about a better solution.
+	    const char *pStyleName = kapp->style().className();
+	    if ( strcmp( "QMotifPlusStyle", pStyleName ) == 0 )
+	    {
+		nStyle |= QStyle::Style_MouseOver;
+		if ( pValue->mnThumbState & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSlider;
+	    }
+	    else if ( strcmp( "QSGIStyle", pStyleName ) == 0 )
+	    {
+		nStyle |= QStyle::Style_MouseOver;
+		if ( pValue->mnButton1State & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSubLine;
+		else if ( pValue->mnButton2State & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarAddLine;
+		else if ( pValue->mnThumbState & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSlider;
+	    }
+
+	    if ( pValue->mnButton1State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSubLine;
+	    else if ( pValue->mnButton2State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarAddLine;
+	    else if ( pValue->mnThumbState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSlider;
+	    else if ( pValue->mnPage1State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSubPage;
+	    else if ( pValue->mnPage2State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarAddPage;
+
+	    // Update the enable/disable state of the widget
+	    if ( ( nState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnButton1State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnButton2State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnThumbState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnPage1State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnPage2State & CTRL_STATE_ENABLED ) )
+	    {
+		pWidget->setEnabled( true );
+		nStyle |= QStyle::Style_Enabled;
+	    }
+	    else
+		pWidget->setEnabled( false );
+	}
+	
+	// Is it a horizontal scroll bar?
+	QScrollBar *pScrollBar = static_cast<QScrollBar *> ( pWidget->qt_cast( "QScrollBar" ) );
+	QStyle::StyleFlags eHoriz = QStyle::Style_Default;
+	if ( pScrollBar && pScrollBar->orientation() == Qt::Horizontal )
+	    eHoriz = QStyle::Style_Horizontal;
+
+	kapp->style().drawComplexControl( QStyle::CC_ScrollBar,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle | eHoriz,
+		QStyle::SC_All, eActive );
+    }
+    else
+	return FALSE;
+
+    // Bitblt it to the screen
+    XCopyArea( dpy,
+	       qPixmap.handle(), drawable,
+	       gc,
+	       0, 0, qRect.width(), qRect.height(),
+	       qWidgetPos.x(), qWidgetPos.y() );
+
+    // Restore widget's position
+    pWidget->move( qWidgetPos );
+
+    return TRUE;
+}
+
+QPushButton *WidgetPainter::pushButton( const Region& rControlRegion,
+	BOOL bDefault )
+{
+    if ( !m_pPushButton )
+	m_pPushButton = new QPushButton( NULL, "push_button" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken styles which do not add
+    // QStyle::PM_ButtonDefaultIndicator to the size of the default button
+    // (for example Keramik)
+    // FIXME Fix Keramik style to be consistant with Qt built-in styles. Aargh!
+    if ( bDefault )
+    {
+	QSize qContentsSize( 50, 50 );
+	m_pPushButton->setDefault( false );
+	QSize qNormalSize = kapp->style().sizeFromContents( QStyle::CT_PushButton,
+		m_pPushButton, qContentsSize );
+	m_pPushButton->setDefault( true );
+	QSize qDefSize = kapp->style().sizeFromContents( QStyle::CT_PushButton,
+		m_pPushButton, qContentsSize );
+	
+	int nIndicatorSize = kapp->style().pixelMetric(
+		QStyle::PM_ButtonDefaultIndicator, m_pPushButton );
+	if ( qNormalSize.width() == qDefSize.width() )
+	    qRect.addCoords( nIndicatorSize, 0, -nIndicatorSize, 0 );
+	if ( qNormalSize.height() == qDefSize.height() )
+	    qRect.addCoords( 0, nIndicatorSize, 0, -nIndicatorSize );
+    }
+    
+    m_pPushButton->move( qRect.topLeft() );
+    m_pPushButton->resize( qRect.size() );
+    m_pPushButton->setDefault( bDefault );
+
+    return m_pPushButton;
+}
+
+QRadioButton *WidgetPainter::radioButton( const Region& rControlRegion )
+{
+    if ( !m_pRadioButton )
+	m_pRadioButton = new QRadioButton( NULL, "radio_button" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken themes which do not honor the given size.
+    // Quite ugly, but I do not know about a better solution.
+    const char *pStyleName = kapp->style().className();
+    if ( strcmp( "KThemeStyle", pStyleName ) == 0 )
+    {
+	QRect qOldRect( qRect );
+	
+	qRect.setWidth( kapp->style().pixelMetric(
+		QStyle::PM_ExclusiveIndicatorWidth, m_pRadioButton ) );
+	qRect.setHeight( kapp->style().pixelMetric(
+		QStyle::PM_ExclusiveIndicatorHeight, m_pRadioButton ) );
+	
+	qRect.moveBy( ( qOldRect.width() - qRect.width() ) / 2,
+		( qOldRect.height() - qRect.height() ) / 2 );
+    }
+
+    m_pRadioButton->move( qRect.topLeft() );
+    m_pRadioButton->resize( qRect.size() );
+    
+    return m_pRadioButton;
+}
+
+QCheckBox *WidgetPainter::checkBox( const Region& rControlRegion )
+{
+    if ( !m_pCheckBox )
+	m_pCheckBox = new QCheckBox( NULL, "check_box" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken themes which do not honor the given size.
+    // Quite ugly, but I do not know about a better solution.
+    const char *pStyleName = kapp->style().className();
+    if ( strcmp( "KThemeStyle", pStyleName ) == 0 )
+    {
+	QRect qOldRect( qRect );
+	
+	qRect.setWidth( kapp->style().pixelMetric(
+		QStyle::PM_IndicatorWidth, m_pCheckBox ) );
+	qRect.setHeight( kapp->style().pixelMetric(
+		QStyle::PM_IndicatorHeight, m_pCheckBox ) );
+	
+	qRect.moveBy( ( qOldRect.width() - qRect.width() ) / 2,
+		( qOldRect.height() - qRect.height() ) / 2 );
+    }
+
+    m_pCheckBox->move( qRect.topLeft() );
+    m_pCheckBox->resize( qRect.size() );
+
+    return m_pCheckBox;
+}
+
+QComboBox *WidgetPainter::comboBox( const Region& rControlRegion,
+	BOOL bEditable )
+{
+    QComboBox *pComboBox = NULL;
+    if ( bEditable )
+    {
+	if ( !m_pEditableComboBox )
+	    m_pEditableComboBox = new QComboBox( true, NULL, "combo_box_edit" );
+	pComboBox = m_pEditableComboBox;
+    }
+    else
+    {
+	if ( !m_pComboBox )
+	    m_pComboBox = new QComboBox( false, NULL, "combo_box" );
+	pComboBox = m_pComboBox;
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    pComboBox->move( qRect.topLeft() );
+    pComboBox->resize( qRect.size() );
+
+    return pComboBox;
+}
+
+QLineEdit *WidgetPainter::lineEdit( const Region& rControlRegion )
+{
+    if ( !m_pLineEdit )
+	m_pLineEdit = new QLineEdit( NULL, "line_edit" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pLineEdit->move( qRect.topLeft() );
+    m_pLineEdit->resize( qRect.size() );
+
+    return m_pLineEdit;
+}
+
+QSpinWidget *WidgetPainter::spinWidget( const Region& rControlRegion )
+{
+    if ( !m_pSpinWidget )
+    {
+	m_pSpinWidget = new QSpinWidget( NULL, "spin_widget" );
+	
+	m_pSpinEdit = new QLineEdit( NULL, "line_edit_spin" );
+	m_pSpinWidget->setEditWidget( m_pSpinEdit );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pSpinWidget->move( qRect.topLeft() );
+    m_pSpinWidget->resize( qRect.size() );
+    m_pSpinWidget->arrange();
+
+    return m_pSpinWidget;
+}
+
+QTabBar *WidgetPainter::tabBar( const Region& rControlRegion )
+{
+    if ( !m_pTabBar )
+    {
+	if ( !m_pTabBarParent )
+	    m_pTabBarParent = new QWidget( NULL, "tab_bar_parent" );
+
+	m_pTabBar = new QTabBar( m_pTabBarParent, "tab_bar" );
+	
+	m_pTabLeft = new QTab();
+	m_pTabMiddle = new QTab();
+	m_pTabRight = new QTab();
+	m_pTabAlone = new QTab();
+
+	m_pTabBar->addTab( m_pTabLeft );
+	m_pTabBar->addTab( m_pTabMiddle );
+	m_pTabBar->addTab( m_pTabRight );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    m_pTabBar->move( qRect.topLeft() );
+    m_pTabBar->resize( qRect.size() );
+    
+    m_pTabBar->setShape( QTabBar::RoundedAbove );
+
+    return m_pTabBar;
+}
+
+QTabWidget *WidgetPainter::tabWidget( const Region& rControlRegion )
+{
+    if ( !m_pTabWidget )
+	m_pTabWidget = new QTabWidget( NULL, "tab_widget" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    --qRect.rTop();
+    
+    m_pTabWidget->move( qRect.topLeft() );
+    m_pTabWidget->resize( qRect.size() );
+    
+    return m_pTabWidget;
+}
+
+QListView *WidgetPainter::listView( const Region& rControlRegion )
+{
+    if ( !m_pListView )
+	m_pListView = new QListView( NULL, "list_view" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pListView->move( qRect.topLeft() );
+    m_pListView->resize( qRect.size() );
+
+    return m_pListView;
+}
+
+QScrollBar *WidgetPainter::scrollBar( const Region& rControlRegion,
+	BOOL bHorizontal, const ImplControlValue& aValue )
+{
+    if ( !m_pScrollBar )
+    {
+	m_pScrollBar = new QScrollBar( NULL, "scroll_bar" );
+	m_pScrollBar->setTracking( false );
+	m_pScrollBar->setLineStep( 1 );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pScrollBar->move( qRect.topLeft() );
+    m_pScrollBar->resize( qRect.size() );
+    m_pScrollBar->setOrientation( bHorizontal? Qt::Horizontal: Qt::Vertical );
+
+    ScrollbarValue *pValue = static_cast<ScrollbarValue *> ( aValue.getOptionalVal() );
+    if ( pValue )
+    {
+	m_pScrollBar->setMinValue( pValue->mnMin );
+	m_pScrollBar->setMaxValue( pValue->mnMax - pValue->mnVisibleSize );
+	m_pScrollBar->setValue( pValue->mnCur );
+	m_pScrollBar->setPageStep( pValue->mnVisibleSize );
+    }
+
+    return m_pScrollBar;
+}
+
+QStyle::SFlags WidgetPainter::vclStateValue2SFlags( ControlState nState,
+	const ImplControlValue& aValue )
+{
+    QStyle::SFlags nStyle =
+	( (nState & CTRL_STATE_DEFAULT)?  QStyle::Style_ButtonDefault: QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_ENABLED)?  QStyle::Style_Enabled:       QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_FOCUSED)?  QStyle::Style_HasFocus:      QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_PRESSED)?  QStyle::Style_Down:          QStyle::Style_Raised )  |
+	( (nState & CTRL_STATE_SELECTED)? QStyle::Style_Selected :     QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_ROLLOVER)? QStyle::Style_MouseOver:     QStyle::Style_Default );
+	//TODO ( (nState & CTRL_STATE_HIDDEN)?   QStyle::Style_: QStyle::Style_Default ) |
+
+    switch ( aValue.getTristateVal() )
+    {
+	case BUTTONVALUE_ON:    nStyle |= QStyle::Style_On;       break;
+	case BUTTONVALUE_OFF:   nStyle |= QStyle::Style_Off;      break;
+	case BUTTONVALUE_MIXED: nStyle |= QStyle::Style_NoChange; break;
+    }
+
+    return nStyle;
+}
+
+QRect WidgetPainter::region2QRect( const Region& rControlRegion )
+{
+    Rectangle aRect = rControlRegion.GetBoundRect();
+
+    return QRect( QPoint( aRect.Left(), aRect.Top() ),
+		  QPoint( aRect.Right(), aRect.Bottom() ) );
+}
+
+/** Instance of WidgetPainter.
+
+    It is used to paint the widgets requested by NWF.
+*/
+static WidgetPainter widgetPainter;
+
+
+/** Initialization of KDE and local stuff.
+
+    It creates an instance of KApplication.
+*/
+void VCLInitNativeWidgets( void )
+{/* The initialization is done in vcl/unx/source/app/saldata.cxx now...
+    KAboutData *kAboutData = new KAboutData( "OpenOffice.org",
+	    I18N_NOOP( "OpenOffice.org" ),
+	    "1.1.0",
+	    I18N_NOOP( "OpenOffice.org with KDE Native Widget Support." ),
+	    KAboutData::License_LGPL,
+	    "(c) 2003, Jan Holesovsky",
+	    I18N_NOOP( "OpenOffice.org is an office suite.\n" ),
+	    "http://kde.openoffice.org/index.html",
+	    "dev@kde.openoffice.org");
+    kAboutData->addAuthor( "Jan Holesovsky",
+	    I18N_NOOP( "Original author and maintainer of the KDE NWF." ),
+	    "kendy@artax.karlin.mff.cuni.cz",
+	    "http://artax.karlin.mff.cuni.cz/~kendy" );
+
+    // We ignore the arguments, KApplication has to be initialized according
+    // to the OOo's display.
+    int argc = 1;
+    char *argv[20] = { "soffice.bin", 0 };
+    //KCmdLineArgs::init( argc, argv, kAboutData );
+
+    // Get display
+    SalDisplay *pSalDisplay = GetSalData()->GetCurDisp();
+    if ( !pSalDisplay )
+	::std::cerr << "Cannot get current display!" << ::std::endl;
+    else
+	new KApplication( pSalDisplay->GetDisplay(), argc, argv, "soffice.bin" );
+*/}
+
+/** Release KDE and local stuff
+
+    No operation for KDE.
+*/
+void VCLDeinitNativeWidgets( void )
+{
+}
+
+/** What widgets can be drawn the native way.
+
+    @param nType
+    Type of the widget.
+    
+    @param nPart
+    Specification of the widget's part if it consists of more than one.
+  
+    @return TRUE if the platform supports native drawing of the widget nType
+    defined by nPart.
+*/
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    return
+	( (nType == CTRL_PUSHBUTTON)  && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_RADIOBUTTON) && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_CHECKBOX)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_COMBOBOX)    && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	( (nType == CTRL_EDITBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	( (nType == CTRL_LISTBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW) ) ||
+	( (nType == CTRL_SPINBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	// no CTRL_SPINBUTTONS for KDE
+	( (nType == CTRL_TAB_ITEM)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_TAB_PANE)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	// no CTRL_TAB_BODY for KDE
+	( (nType == CTRL_SCROLLBAR)   && (nPart == PART_ENTIRE_CONTROL || nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT) ) ||
+	( (nType == CTRL_SCROLLBAR)   && (nPart == HAS_THREE_BUTTONS) ); // TODO small optimization is possible here: return this only if the style really has 3 buttons
+	// CTRL_GROUPBOX not supported
+	// CTRL_FIXEDLINE not supported
+	// CTRL_FIXEDBORDER not supported
+}
+
+
+/** Test whether the position is in the native widget.
+
+    If the return value is TRUE, bIsInside contains information whether
+    aPos was or was not inside the native widget specified by the
+    nType/nPart combination.
+*/
+BOOL SalGraphics::HitTestNativeControl( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, const Point& aPos,
+	SalControlHandle& rControlHandle, BOOL& rIsInside,
+	const OutputDevice* )
+{
+    if ( nType == CTRL_SCROLLBAR )
+    {
+	rIsInside = FALSE;
+
+	BOOL bHorizontal = ( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT );
+	
+	QScrollBar *pScrollBar = widgetPainter.scrollBar( rControlRegion,
+		bHorizontal, ImplControlValue() );
+	QRect qRectSubLine = kapp->style().querySubControlMetrics(
+		QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubLine );
+	QRect qRectAddLine = kapp->style().querySubControlMetrics(
+		QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarAddLine );
+
+	// There are 2 buttons on the right/bottom side of the scrollbar
+	BOOL bTwoSubButtons = FALSE;
+
+	// It is a Platinum style scroll bar
+	BOOL bPlatinumStyle = FALSE;
+
+	// Workaround for Platinum and 3 button style scroll bars.
+	// It makes the right/down button bigger.
+	if ( bHorizontal )
+	{
+	    qRectAddLine.setLeft( kapp->style().querySubControlMetrics(
+			QStyle::CC_ScrollBar, pScrollBar,
+			QStyle::SC_ScrollBarAddPage ).right() + 1 );
+	    if ( qRectAddLine.width() > qRectSubLine.width() )
+		bTwoSubButtons = TRUE;
+	    if ( qRectSubLine.left() > kapp->style().querySubControlMetrics( QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubPage ).left() )
+		bPlatinumStyle = TRUE;
+	}
+	else
+	{
+	    qRectAddLine.setTop( kapp->style().querySubControlMetrics(
+			QStyle::CC_ScrollBar, pScrollBar,
+			QStyle::SC_ScrollBarAddPage ).bottom() + 1 );
+	    if ( qRectAddLine.height() > qRectSubLine.height() )
+		bTwoSubButtons = TRUE;
+	    if ( qRectSubLine.top() > kapp->style().querySubControlMetrics( QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubPage ).top() )
+		bPlatinumStyle = TRUE;
+	}
+
+	switch ( nPart )
+	{
+	    case PART_BUTTON_LEFT:
+		if ( !bPlatinumStyle && qRectSubLine.contains( aPos.getX(), aPos.getY() ) )
+		    rIsInside = TRUE;
+		else if ( bTwoSubButtons )
+		{
+		    qRectAddLine.setWidth( qRectAddLine.width() / 2 );
+		    rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		}
+		break;
+		
+	    case PART_BUTTON_UP:
+		if ( !bPlatinumStyle && qRectSubLine.contains( aPos.getX(), aPos.getY() ) )
+		    rIsInside = TRUE;
+		else if ( bTwoSubButtons )
+		{
+		    qRectAddLine.setHeight( qRectAddLine.height() / 2 );
+		    rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		}
+		break;
+		
+	    case PART_BUTTON_RIGHT:
+		if ( bTwoSubButtons )
+		    qRectAddLine.setLeft( qRectAddLine.left() + qRectAddLine.width() / 2 );
+
+		rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		break;
+		
+	    case PART_BUTTON_DOWN:
+		if ( bTwoSubButtons )
+		    qRectAddLine.setTop( qRectAddLine.top() + qRectAddLine.height() / 2 );
+
+		rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		break;
+	}
+
+	return TRUE;
+    }
+
+    return FALSE;
+}
+
+
+/** Draw the requested control described by nPart/nState.
+ 
+    @param rControlRegion
+    The bounding region of the complete control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string).
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::DrawNativeControl( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption, const OutputDevice* )
+{
+    BOOL bReturn = FALSE;
+
+    Display *dpy = maGraphicsData.GetXDisplay();
+    XLIB_Window drawable = maGraphicsData.GetDrawable();
+    GC gc = maGraphicsData.SelectFont(); // GC with current clipping region set
+	
+    if ( (nType == CTRL_PUSHBUTTON) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.pushButton( rControlRegion, (nState & CTRL_STATE_DEFAULT) ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_RADIOBUTTON) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.radioButton( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_CHECKBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.checkBox( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_COMBOBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.comboBox( rControlRegion, TRUE ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_EDITBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.lineEdit( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_LISTBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.comboBox( rControlRegion, FALSE ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_LISTBOX) && (nPart == PART_WINDOW) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.listView( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_SPINBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.spinWidget( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType==CTRL_TAB_ITEM) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.tabBar( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType==CTRL_TAB_PANE) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.tabWidget( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_SCROLLBAR) && (nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.scrollBar( rControlRegion, nPart == PART_DRAW_BACKGROUND_HORZ, aValue ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+
+    return bReturn;
+}
+
+
+/** Draw text on the widget.
+ 
+    OPTIONAL. Draws the requested text for the control described by nPart/nState.
+    Used if text is not drawn by DrawNativeControl().
+ 
+    @param rControlRegion
+    The bounding region of the complete control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string)
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::DrawNativeControlText( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption, const OutputDevice* )
+{
+    return FALSE;
+}
+
+/** Check if the bounding regions match.
+
+    If the return value is TRUE, rNativeBoundingRegion
+    contains the true bounding region covered by the control
+    including any adornment, while rNativeContentRegion contains the area
+    within the control that can be safely drawn into without drawing over
+    the borders of the control.
+
+    @param rControlRegion
+    The bounding region of the control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string)
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::GetNativeControlRegion( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption,
+	Region &rNativeBoundingRegion, Region &rNativeContentRegion,
+	const OutputDevice* )
+{
+    BOOL bReturn = FALSE;
+    QRect qBoundingRect = WidgetPainter::region2QRect( rControlRegion );
+    QRect qRect;
+    
+    QWidget *pWidget = NULL;
+    switch ( nType )
+    {
+	// Metrics of the push button
+	case CTRL_PUSHBUTTON:
+	    pWidget = widgetPainter.pushButton( rControlRegion, ( nState & CTRL_STATE_DEFAULT ) );
+
+	    switch ( nPart )
+	    {
+		case PART_ENTIRE_CONTROL:
+		    qRect = qBoundingRect;
+
+		    if ( nState & CTRL_STATE_DEFAULT )
+		    {
+			int nIndicatorSize = kapp->style().pixelMetric(
+				QStyle::PM_ButtonDefaultIndicator, pWidget );
+			qBoundingRect.addCoords( -nIndicatorSize, -nIndicatorSize,
+				nIndicatorSize, nIndicatorSize );
+			bReturn = TRUE;
+		    }
+		    break;
+	    }
+	    break;
+
+	// Metrics of the combo box
+	case CTRL_COMBOBOX:
+	case CTRL_LISTBOX:
+	    pWidget = widgetPainter.comboBox( rControlRegion, ( nType == CTRL_COMBOBOX ) );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget, QStyle::SC_ComboBoxArrow );
+		    qRect.setLeft( kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget,
+			    QStyle::SC_ComboBoxEditField ).right() + 1 );
+		    bReturn = TRUE;
+		    break;
+
+		case PART_SUB_EDIT:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget, QStyle::SC_ComboBoxEditField );
+		    bReturn = TRUE;
+		    break;
+	    }
+	    break;
+
+	// Metrics of the spin box
+	case CTRL_SPINBOX:
+	    pWidget = widgetPainter.spinWidget( rControlRegion );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_UP:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_SpinWidget, pWidget, QStyle::SC_SpinWidgetUp );
+		    bReturn = TRUE;
+		    break;
+
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_SpinWidget, pWidget, QStyle::SC_SpinWidgetDown );
+		    bReturn = TRUE;
+		    break;
+	    }
+	    break;
+
+	// Metrics of the scroll bar
+	case CTRL_SCROLLBAR:
+	    pWidget = widgetPainter.scrollBar( rControlRegion,
+		    ( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT ),
+		    ImplControlValue() );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_LEFT:
+		case PART_BUTTON_UP:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ScrollBar, pWidget, QStyle::SC_ScrollBarSubLine );
+
+		    // Workaround for Platinum style scroll bars. It makes the
+		    // left/up button invisible.
+		    if ( nPart == PART_BUTTON_LEFT )
+		    {
+			if ( qRect.left() > kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarSubPage ).left() )
+			{
+			    qRect.setLeft( 0 );
+			    qRect.setRight( 0 );
+			}
+		    }
+		    else
+		    {
+			if ( qRect.top() > kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarSubPage ).top() )
+			{
+			    qRect.setTop( 0 );
+			    qRect.setBottom( 0 );
+			}
+		    }
+
+		    bReturn = TRUE;
+		    break;
+
+		case PART_BUTTON_RIGHT:
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ScrollBar, pWidget, QStyle::SC_ScrollBarAddLine );
+
+		    // Workaround for Platinum and 3 button style scroll bars.
+		    // It makes the right/down button bigger.
+		    if ( nPart == PART_BUTTON_RIGHT )
+			qRect.setLeft( kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarAddPage ).right() + 1 );
+		    else
+			qRect.setTop( kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarAddPage ).bottom() + 1 );
+
+		    bReturn = TRUE;
+		    break;
+	    }
+    }
+
+    // Fill rNativeBoundingRegion and rNativeContentRegion
+    if ( bReturn )
+    {
+	// Bounding region
+	Point aBPoint( qBoundingRect.x(), qBoundingRect.y() );
+	Size aBSize( qBoundingRect.width(), qBoundingRect.height() );
+	rNativeBoundingRegion = Region( Rectangle( aBPoint, aBSize ) );
+
+	// Region of the content
+	Point aPoint( qRect.x(), qRect.y() );
+	Size  aSize( qRect.width(), qRect.height() );
+	rNativeContentRegion = Region( Rectangle( aPoint, aSize ) );
+    }
+    
+    return bReturn;
+}
+
+/** Constructor.
+*/
+SalControlHandleData::SalControlHandleData( void )
+{
+}
+
+/** Destructor.
+*/
+SalControlHandleData::~SalControlHandleData( void )
+{
+}
+
+// -----------------------------------------------------------------------
+// KDEIntegrator implementation
+// -----------------------------------------------------------------------
+
+/** Constructor of the KDE integrator.
+*/
+KDEIntegrator::KDEIntegrator( SalFrame* pFrame ) :
+    DtIntegrator( pFrame )
+{
+    meType = DtKDE;
+}
+
+/** Destructor of the KDE integrator.
+*/
+KDEIntegrator::~KDEIntegrator()
+{
+}
+
+/** Helper function to convert colors.
+*/
+Color toColor( const QColor &rColor )
+{
+    return Color( rColor.red(), rColor.green(), rColor.blue() );
+}
+
+/** Helper function to read color from KConfig configuration repository.
+*/
+Color readColor( KConfig *pConfig, const char *pKey )
+{
+    return toColor( pConfig->readColorEntry( pKey ) );
+}
+
+/** Helper function to add information to Font from QFont.
+*/
+void modifyFont( Font &rFont, const QFont &rQFont )
+{
+    QFontInfo qFontInfo( rQFont );
+    
+    rFont.SetName( String( qFontInfo.family().utf8(), RTL_TEXTENCODING_UTF8 ) );
+    
+    rFont.SetHeight( qFontInfo.pointSize() );
+    
+    rFont.SetItalic( qFontInfo.italic()? ITALIC_NORMAL: ITALIC_NONE );
+    
+    FontWeight eWeight = WEIGHT_DONTKNOW;
+    int nWeight = qFontInfo.weight();
+    if ( nWeight <= QFont::Light )
+        eWeight = WEIGHT_LIGHT;
+    else if ( nWeight <= QFont::Normal )
+        eWeight = WEIGHT_NORMAL;
+    else if ( nWeight <= QFont::DemiBold )
+        eWeight = WEIGHT_SEMIBOLD;
+    else if ( nWeight <= QFont::Bold )
+        eWeight = WEIGHT_BOLD;
+    else
+        eWeight = WEIGHT_BLACK;
+    rFont.SetWeight( eWeight );
+}
+
+/** Implementation of KDE integration's main method.
+*/
+void KDEIntegrator::GetSystemLook( AllSettings& rSettings )
+{
+    StyleSettings aStyleSettings( rSettings.GetStyleSettings() );
+
+    // WM settings
+    KConfig *pConfig = KGlobal::config();
+    if ( pConfig )
+    {
+        pConfig->setGroup( "WM" );
+        const char *pKey;
+
+        pKey = "activeBackground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveColor( readColor( pConfig, pKey ) );
+
+        pKey = "activeBlend";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveColor2( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveBackground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveColor( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveBlend";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveColor2( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveForeground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveTextColor( readColor( pConfig, pKey ) );
+
+        pKey = "activeForeground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveTextColor( readColor( pConfig, pKey ) );
+
+        pKey = "titleFont";
+        if ( pConfig->hasKey( pKey ) )
+        {
+            Font aFont= aStyleSettings.GetTitleFont();
+            modifyFont( aFont, pConfig->readFontEntry( pKey ) );
+            aStyleSettings.SetTitleFont( aFont );
+        }
+    }
+
+    // General settings
+    QColorGroup qColorGroup = kapp->palette().active();
+    
+    // Foreground
+    Color aFore = toColor( qColorGroup.foreground() );
+    aStyleSettings.SetRadioCheckTextColor( aFore );
+    aStyleSettings.SetLabelTextColor( aFore );
+    aStyleSettings.SetInfoTextColor( aFore );
+    aStyleSettings.SetDialogTextColor( aFore );
+    aStyleSettings.SetGroupTextColor( aFore );
+
+    // Input boxes, list boxes
+    aStyleSettings.SetFieldColor( toColor( qColorGroup.base() ) );
+    aStyleSettings.SetFieldTextColor( toColor( qColorGroup.text() ) );
+    
+    // Buttons
+    aStyleSettings.SetButtonTextColor( toColor( qColorGroup.buttonText() ) );
+
+    // Disable color
+    aStyleSettings.SetDisableColor( toColor( qColorGroup.mid() ) );
+
+    // Background
+    Color aBack = toColor( qColorGroup.background() );
+    aStyleSettings.Set3DColors( aBack );
+    aStyleSettings.SetFaceColor( aBack );
+    aStyleSettings.SetDialogColor( aBack );
+    if( aBack == COL_LIGHTGRAY )
+        aStyleSettings.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
+    else
+    {
+        Color aColor2 = aStyleSettings.GetLightColor();
+        aStyleSettings.
+            SetCheckedColor( Color( (BYTE)(((USHORT)aBack.GetRed()+(USHORT)aColor2.GetRed())/2),
+                        (BYTE)(((USHORT)aBack.GetGreen()+(USHORT)aColor2.GetGreen())/2),
+                        (BYTE)(((USHORT)aBack.GetBlue()+(USHORT)aColor2.GetBlue())/2)
+                        ) );
+    }
+
+    // Selection
+    aStyleSettings.SetHighlightColor( toColor( qColorGroup.highlight() ) );
+    aStyleSettings.SetHighlightTextColor( toColor( qColorGroup.highlightedText() ) );
+
+    // Font
+    Font aFont= aStyleSettings.GetAppFont();
+    modifyFont( aFont, kapp->font() );
+
+    aStyleSettings.SetAppFont( aFont );
+    aStyleSettings.SetHelpFont( aFont );
+    aStyleSettings.SetMenuFont( aFont ); // will be changed according to pMenuBar
+    aStyleSettings.SetToolFont( aFont ); // will be changed according to pToolBar
+    aStyleSettings.SetLabelFont( aFont );
+    aStyleSettings.SetInfoFont( aFont );
+    aStyleSettings.SetRadioCheckFont( aFont );
+    aStyleSettings.SetPushButtonFont( aFont );
+    aStyleSettings.SetFieldFont( aFont );
+    aStyleSettings.SetIconFont( aFont );
+    aStyleSettings.SetGroupFont( aFont );
+
+    // Menu
+    KMainWindow qMainWindow;
+    qMainWindow.createGUI( "/dev/null" ); // hack
+
+    KMenuBar *pMenuBar = qMainWindow.menuBar();
+    if ( pMenuBar )
+    {
+        // Color
+        QColorGroup qMenuCG = pMenuBar->colorGroup();
+        aStyleSettings.SetMenuTextColor( toColor( qMenuCG.buttonText() ) );
+        aStyleSettings.SetMenuColor( toColor( qMenuCG.button() ) );
+        aStyleSettings.SetMenuBarColor( toColor( qMenuCG.button() ) );
+        aStyleSettings.SetMenuHighlightColor( toColor ( qMenuCG.highlight() ) );
+        aStyleSettings.SetMenuHighlightTextColor( toColor ( qMenuCG.highlightedText() ) );
+
+        // Font
+        Font aFont= aStyleSettings.GetMenuFont();
+        modifyFont( aFont, pMenuBar->font() );
+        aStyleSettings.SetMenuFont( aFont );
+    }
+
+    // Tool bar
+    KToolBar *pToolBar = qMainWindow.toolBar();
+    if ( pToolBar )
+    {
+        Font aFont= aStyleSettings.GetToolFont();
+        modifyFont( aFont, pToolBar->font() );
+        aStyleSettings.SetToolFont( aFont );
+    }
+
+    // Scroll bar size
+    aStyleSettings.SetScrollBarSize( kapp->style().pixelMetric( QStyle::PM_ScrollBarExtent ) );
+
+    rSettings.SetStyleSettings( aStyleSettings );
+}
+
+/* vim: set tabstop=8 shiftwidth=4: */
unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/unx/source/gdi/salnativewidgets-none.cxx	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,218 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_CXX
+
+#include <stdio.h>
+#include <salunx.h>
+
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+
+using namespace rtl;
+
+/****************************************************************
+ *  Placeholder for no native widgets
+ ***************************************************************/
+
+
+/*********************************************************
+ * Initialize GTK and local stuff                         
+ *********************************************************/
+void VCLInitNativeWidgets( void )
+{
+}
+
+
+/*********************************************************
+ * Release GTK and local stuff                         
+ *********************************************************/
+void VCLDeinitNativeWidgets( void )
+{
+}
+
+
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+	return( FALSE );
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  If the return value is TRUE, bIsInside contains information whether
+ *  aPos was or was not inside the native widget specified by the
+ *  nType/nPart combination.
+ */
+BOOL SalGraphics::HitTestNativeControl( ControlType nType,
+							  ControlPart nPart,
+							  const Region& rControlRegion,
+							  const Point& aPos,
+							  SalControlHandle& rControlHandle,
+							  BOOL& rIsInside,
+                              const OutputDevice* )
+{
+	return( FALSE );
+}
+
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::DrawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption,
+                            const OutputDevice* )
+{
+	return( FALSE );
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::DrawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+                                const OutputDevice* )
+{
+	return( FALSE );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the TRUE bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::GetNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion,
+                                const OutputDevice* )
+{
+	return( FALSE );
+}
+
+
+/************************************************************************/
+/* SalControlHandleData stuff */
+/************************************************************************/
+SalControlHandleData::SalControlHandleData( void )
+{
+}
+
+
+SalControlHandleData::~SalControlHandleData( void )
+{
+}
+
+
unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/win/inc/salnativewidgets.h	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,90 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_NATIVEWIDGETS_H
+#define _SV_NATIVEWIDGETS_H
+
+
+#ifdef __cplusplus
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+
+/* SalControlHandleData:
+ * 
+ *   Holds platform specific theming data.
+ */
+
+class SalControlHandleData
+{
+	public:
+		SalControlHandleData( void );
+		~SalControlHandleData( void );
+
+	public:
+        // nothing needed on Win32
+};
+
+
+#endif	/* __cplusplus */
+
+#endif
unchanged:
--- /dev/null	2003-09-23 19:59:22.000000000 +0200
+++ vcl/win/source/gdi/salnativewidgets-luna.cxx	2004-03-03 15:32:34.000000000 +0100
@@ -0,0 +1,996 @@
+/*************************************************************************
+ *
+ *  $RCSfile: nativewidgets-vcl.diff,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: suka $ $Date: 2004/06/30 15:14:10 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_CXX
+
+#ifndef _SV_SVSYS_H
+#include <svsys.h>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#include "uxtheme.h"
+#include "tmschema.h"
+
+#include <map>
+#include <string>
+
+using namespace rtl;
+using namespace std;
+
+typedef map< wstring, HTHEME > ThemeMap;
+static ThemeMap aThemeMap;
+
+
+/****************************************************
+ wrap visual styles API to avoid linking against it
+ it is not available on all Windows platforms
+*****************************************************/
+
+class VisualStylesAPI
+{
+private:
+    typedef HTHEME  (WINAPI * OpenThemeData_Proc_T) ( HWND hwnd, LPCWSTR pszClassList );
+    typedef HRESULT (WINAPI * CloseThemeData_Proc_T) ( HTHEME hTheme );
+    typedef HRESULT (WINAPI * GetThemeBackgroundContentRect_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
+    typedef HRESULT (WINAPI * DrawThemeBackground_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
+    typedef HRESULT (WINAPI * DrawThemeText_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
+    typedef HRESULT (WINAPI * GetThemePartSize_Proc_T) ( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz );
+
+    OpenThemeData_Proc_T                    lpfnOpenThemeData;
+    CloseThemeData_Proc_T                   lpfnCloseThemeData;
+    GetThemeBackgroundContentRect_Proc_T    lpfnGetThemeBackgroundContentRect;
+    DrawThemeBackground_Proc_T              lpfnDrawThemeBackground;
+    DrawThemeText_Proc_T                    lpfnDrawThemeText;
+    GetThemePartSize_Proc_T                 lpfnGetThemePartSize;
+
+    HMODULE mhModule;
+
+public:
+    VisualStylesAPI();
+    ~VisualStylesAPI();
+    BOOL IsAvailable()  { return (mhModule != NULL); }
+
+    HTHEME OpenThemeData( HWND hwnd, LPCWSTR pszClassList );
+    HRESULT CloseThemeData( HTHEME hTheme );
+    HRESULT GetThemeBackgroundContentRect( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect );
+    HRESULT DrawThemeBackground( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect );
+    HRESULT DrawThemeText( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect );
+    HRESULT GetThemePartSize( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz );
+};
+
+static VisualStylesAPI vsAPI;
+
+VisualStylesAPI::VisualStylesAPI()
+{
+    mhModule = LoadLibraryA("uxtheme.dll");
+
+    lpfnOpenThemeData = (OpenThemeData_Proc_T) GetProcAddress( mhModule, "OpenThemeData" );
+    lpfnCloseThemeData = (CloseThemeData_Proc_T) GetProcAddress( mhModule, "CloseThemeData" );
+    lpfnGetThemeBackgroundContentRect = (GetThemeBackgroundContentRect_Proc_T) GetProcAddress( mhModule, "GetThemeBackgroundContentRect" );
+    lpfnDrawThemeBackground = (DrawThemeBackground_Proc_T) GetProcAddress( mhModule, "DrawThemeBackground" );
+    lpfnDrawThemeText = (DrawThemeText_Proc_T) GetProcAddress( mhModule, "DrawThemeText" );
+    lpfnGetThemePartSize = (GetThemePartSize_Proc_T) GetProcAddress( mhModule, "GetThemePartSize" );
+}
+VisualStylesAPI::~VisualStylesAPI()
+{
+    if( mhModule )
+        FreeLibrary( mhModule );
+}
+HTHEME VisualStylesAPI::OpenThemeData( HWND hwnd, LPCWSTR pszClassList )
+{
+    if(lpfnOpenThemeData)
+        return (*lpfnOpenThemeData) (hwnd, pszClassList);
+    else
+        return NULL;
+}
+
+HRESULT VisualStylesAPI::CloseThemeData( HTHEME hTheme )
+{
+    if(lpfnCloseThemeData)
+        return (*lpfnCloseThemeData) (hTheme);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::GetThemeBackgroundContentRect( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pBoundingRect, RECT *pContentRect )
+{
+    if(lpfnGetThemeBackgroundContentRect)
+        return (*lpfnGetThemeBackgroundContentRect) ( hTheme, hdc, iPartId, iStateId, pBoundingRect, pContentRect );
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::DrawThemeBackground( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, const RECT *pClipRect )
+{
+    if(lpfnDrawThemeBackground)
+        return (*lpfnDrawThemeBackground) (hTheme, hdc, iPartId, iStateId, pRect, pClipRect);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::DrawThemeText( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, const RECT *pRect )
+{
+    if(lpfnDrawThemeText)
+        return (*lpfnDrawThemeText) (hTheme, hdc, iPartId, iStateId, pszText, iCharCount, dwTextFlags, dwTextFlags2, pRect);
+    else
+        return S_FALSE;
+}
+HRESULT VisualStylesAPI::GetThemePartSize( HTHEME hTheme, HDC hdc, int iPartId, int iStateId, RECT *prc, THEMESIZE eSize, SIZE *psz )
+{
+    if(lpfnGetThemePartSize)
+        return (*lpfnGetThemePartSize) (hTheme, hdc, iPartId, iStateId, prc, eSize, psz);
+    else
+        return S_FALSE;
+}
+
+
+/*********************************************************
+ * Initialize XP theming and local stuff                         
+ *********************************************************/
+void VCLInitNativeWidgets( void )
+{
+}
+
+
+/*********************************************************
+ * Release theming handles
+ *********************************************************/
+void VCLDeinitNativeWidgets( void )
+{
+    ThemeMap::iterator iter = aThemeMap.begin();
+    while( iter != aThemeMap.end() )
+    {
+        vsAPI.CloseThemeData(iter->second);
+        iter++;
+    }
+    aThemeMap.clear();
+}
+
+static HTHEME getThemeHandle( HWND hWnd, LPCWSTR name )
+{
+    if( GetSalData()->mbThemeChanged )
+    {
+        // throw away invalid theme handles
+        VCLDeinitNativeWidgets();
+        GetSalData()->mbThemeChanged = FALSE;
+    }
+
+    ThemeMap::iterator iter;
+    if( (iter = aThemeMap.find( name )) != aThemeMap.end() )
+        return iter->second;
+    // theme not found -> add it to map
+    HTHEME hTheme = vsAPI.OpenThemeData( hWnd, name );
+    if( hTheme != NULL )
+        aThemeMap[name] = hTheme;
+    return hTheme;
+}
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    HTHEME hTheme = NULL;
+
+    switch( nType )
+    {
+        case CTRL_PUSHBUTTON:
+        case CTRL_RADIOBUTTON:
+        case CTRL_CHECKBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Button");
+            break;
+        case CTRL_SCROLLBAR:
+            if( nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT )
+                return FALSE;   // no background painting needed
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Scrollbar");
+            break;
+        case CTRL_COMBOBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Combobox");
+            break;
+        case CTRL_SPINBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            else if( nPart == PART_ALL_BUTTONS || 
+                nPart == PART_BUTTON_UP || nPart == PART_BUTTON_DOWN || 
+                nPart == PART_BUTTON_LEFT|| nPart == PART_BUTTON_RIGHT )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Spin");
+            break;
+        case CTRL_SPINBUTTONS:
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_ALL_BUTTONS )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Spin");
+            break;
+        case CTRL_EDITBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+                //return TRUE;
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            break;
+        case CTRL_LISTBOX:
+            if( nPart == HAS_BACKGROUND_TEXTURE )
+                return FALSE;   // we do not paint the inner part (ie the selection background/focus indication)
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Listview");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Combobox");
+            break;
+        case CTRL_TAB_PANE:
+        case CTRL_TAB_BODY:
+        case CTRL_TAB_ITEM:
+        case CTRL_FIXEDBORDER:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Tab");
+            break;
+        default:
+            hTheme = NULL;
+            break;
+    }
+
+    return (hTheme != NULL);
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  If the return value is TRUE, bIsInside contains information whether
+ *  aPos was or was not inside the native widget specified by the
+ *  nType/nPart combination.
+ */
+BOOL SalGraphics::HitTestNativeControl( ControlType nType,
+							  ControlPart nPart,
+							  const Region& rControlRegion,
+							  const Point& aPos,
+							  SalControlHandle& rControlHandle,
+							  BOOL& rIsInside,
+                              const OutputDevice*)
+{
+    return FALSE;
+}
+
+BOOL ImplDrawTheme( HTHEME hTheme, HDC hDC, int iPart, int iState, RECT rc, const OUString& aStr)
+{
+    HRESULT hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+
+    if( aStr.getLength() )
+    {
+        RECT rcContent;
+        hr = vsAPI.GetThemeBackgroundContentRect( hTheme, hDC, iPart, iState, &rc, &rcContent);
+        hr = vsAPI.DrawThemeText( hTheme, hDC, iPart, iState,
+            aStr.getStr(), -1,
+            DT_CENTER | DT_VCENTER | DT_SINGLELINE,
+            0, &rcContent);
+    }
+    return (hr == S_OK);
+}
+
+
+// Helper functions
+// ----
+
+void ImplConvertSpinbuttonValues( int nControlPart, const ControlState& rState, const Rectangle& rRect, 
+                                 int* pLunaPart, int *pLunaState, RECT *pRect )
+{
+    if( nControlPart == PART_BUTTON_DOWN )
+    {
+        *pLunaPart = SPNP_DOWN;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = DNS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = DNS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = DNS_HOT;
+        else
+            *pLunaState = DNS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_UP )
+    {
+        *pLunaPart = SPNP_UP;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = UPS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = UPS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = UPS_HOT;
+        else
+            *pLunaState = UPS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_RIGHT )
+    {
+        *pLunaPart = SPNP_UPHORZ;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = DNHZS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = DNHZS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = DNHZS_HOT;
+        else
+            *pLunaState = DNHZS_NORMAL;
+    }
+    if( nControlPart == PART_BUTTON_LEFT )
+    {
+        *pLunaPart = SPNP_DOWNHORZ;
+        if( rState & CTRL_STATE_PRESSED )
+            *pLunaState = UPHZS_PRESSED;
+        else if( !(rState & CTRL_STATE_ENABLED) )
+            *pLunaState = UPHZS_DISABLED;
+        else if( rState & CTRL_STATE_ROLLOVER )
+            *pLunaState = UPHZS_HOT;
+        else
+            *pLunaState = UPHZS_NORMAL;
+    }
+
+    pRect->left   = rRect.Left();
+    pRect->right  = rRect.Right()+1;
+    pRect->top    = rRect.Top();
+    pRect->bottom = rRect.Bottom()+1;
+}
+
+// ----
+
+BOOL ImplDrawNativeControl(	HDC hDC, HTHEME hTheme, RECT rc,
+                            ControlType nType,
+							ControlPart nPart,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+    // a listbox dropdown is actually a combobox dropdown
+    if( nType == CTRL_LISTBOX )
+        if( nPart == PART_BUTTON_DOWN )
+            nType = CTRL_COMBOBOX;
+
+    // draw entire combobox as a large edit box
+    if( nType == CTRL_COMBOBOX )
+        if( nPart == PART_ENTIRE_CONTROL )
+            nType = CTRL_EDITBOX;
+
+    // draw entire spinbox as a large edit box
+    if( nType == CTRL_SPINBOX )
+        if( nPart == PART_ENTIRE_CONTROL )
+            nType = CTRL_EDITBOX;
+
+    int iPart(0), iState(0);
+    if( nType == CTRL_SCROLLBAR )
+    {
+        HRESULT hr;
+        if( nPart == PART_BUTTON_UP )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_UPPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_UPDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_UPHOT;
+            else
+                iState = ABS_UPNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_DOWNPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_DOWNDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_DOWNHOT;
+            else
+                iState = ABS_DOWNNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_LEFT )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_LEFTPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_LEFTDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_LEFTHOT;
+            else
+                iState = ABS_LEFTNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_BUTTON_RIGHT )
+        {
+            iPart = SBP_ARROWBTN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = ABS_RIGHTPRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = ABS_RIGHTDISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = ABS_RIGHTHOT;
+            else
+                iState = ABS_RIGHTNORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+        if( nPart == PART_THUMB_HORZ || nPart == PART_THUMB_VERT )
+        {
+            iPart = (nPart == PART_THUMB_HORZ) ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = SCRBS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = SCRBS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = SCRBS_HOT;
+            else
+                iState = SCRBS_NORMAL;
+
+            SIZE sz;
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_MIN, &sz);
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_TRUE, &sz);
+            vsAPI.GetThemePartSize(hTheme, hDC, iPart, iState, NULL, TS_DRAW, &sz);
+
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            // paint gripper on thumb if enough space
+            if( ( (nPart == PART_THUMB_VERT) && (rc.bottom-rc.top > 12) ) ||
+                ( (nPart == PART_THUMB_HORZ) && (rc.right-rc.left > 12) ) )
+            {
+                iPart = (nPart == PART_THUMB_HORZ) ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
+                iState = 0;
+                vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            }
+            return (hr == S_OK);
+        }
+        if( nPart == PART_TRACK_HORZ_LEFT || nPart == PART_TRACK_HORZ_RIGHT || nPart == PART_TRACK_VERT_UPPER || nPart == PART_TRACK_VERT_LOWER )
+        {
+            switch( nPart )
+            {
+                case PART_TRACK_HORZ_LEFT:  iPart = SBP_UPPERTRACKHORZ; break;
+                case PART_TRACK_HORZ_RIGHT: iPart = SBP_LOWERTRACKHORZ; break;
+                case PART_TRACK_VERT_UPPER: iPart = SBP_UPPERTRACKVERT; break;
+                case PART_TRACK_VERT_LOWER: iPart = SBP_LOWERTRACKVERT; break;
+            }
+
+            if( nState & CTRL_STATE_PRESSED )
+                iState = SCRBS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = SCRBS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = SCRBS_HOT;
+            else
+                iState = SCRBS_NORMAL;
+            hr = vsAPI.DrawThemeBackground( hTheme, hDC, iPart, iState, &rc, 0);
+            return (hr == S_OK);
+        }
+    }
+    if( nType == CTRL_SPINBUTTONS && nPart == PART_ALL_BUTTONS )
+    {
+        SpinbuttonValue *pValue = (SpinbuttonValue*) aValue.getOptionalVal();
+        if( pValue )
+        {
+            BOOL bOk = FALSE;
+
+            RECT rect;
+            ImplConvertSpinbuttonValues( pValue->mnUpperPart, pValue->mnUpperState, pValue->maUpperRect, &iPart, &iState, &rect );
+            bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+
+            if( bOk )
+            {
+                ImplConvertSpinbuttonValues( pValue->mnLowerPart, pValue->mnLowerState, pValue->maLowerRect, &iPart, &iState, &rect );
+                bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+            }
+
+            return bOk;
+        }
+    }
+    if( nType == CTRL_SPINBOX )
+    {
+        // decrease spinbutton rects a little
+        //rc.right--;
+        //rc.bottom--;
+        if( nPart == PART_ALL_BUTTONS )
+        {
+            SpinbuttonValue *pValue = (SpinbuttonValue*) aValue.getOptionalVal();
+            if( pValue )
+            {
+                BOOL bOk = FALSE;
+
+                RECT rect;
+                ImplConvertSpinbuttonValues( pValue->mnUpperPart, pValue->mnUpperState, pValue->maUpperRect, &iPart, &iState, &rect );
+                bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+
+                if( bOk )
+                {
+                    ImplConvertSpinbuttonValues( pValue->mnLowerPart, pValue->mnLowerState, pValue->maLowerRect, &iPart, &iState, &rect );
+                    bOk = ImplDrawTheme( hTheme, hDC, iPart, iState, rect, aCaption);
+                }
+
+                return bOk;
+            }
+        }
+
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = SPNP_DOWN;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = DNS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = DNS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = DNS_HOT;
+            else
+                iState = DNS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_UP )
+        {
+            iPart = SPNP_UP;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = UPS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = UPS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = UPS_HOT;
+            else
+                iState = UPS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_RIGHT )
+        {
+            iPart = SPNP_DOWNHORZ;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = DNHZS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = DNHZS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = DNHZS_HOT;
+            else
+                iState = DNHZS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_LEFT )
+        {
+            iPart = SPNP_UPHORZ;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = UPHZS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = UPHZS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = UPHZS_HOT;
+            else
+                iState = UPHZS_NORMAL;
+        }
+        if( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT || nPart == PART_BUTTON_UP || nPart == PART_BUTTON_DOWN )
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+    if( nType == CTRL_COMBOBOX )
+    {
+        if( nPart == PART_BUTTON_DOWN )
+        {
+            iPart = CP_DROPDOWNBUTTON;
+            if( nState & CTRL_STATE_PRESSED )
+                iState = CBXS_PRESSED;
+            else if( !(nState & CTRL_STATE_ENABLED) )
+                iState = CBXS_DISABLED;
+            else if( nState & CTRL_STATE_ROLLOVER )
+                iState = CBXS_HOT;
+            else
+                iState = CBXS_NORMAL;
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+        }
+    }
+    if( nType == CTRL_PUSHBUTTON )
+    {
+        iPart = BP_PUSHBUTTON;
+        if( nState & CTRL_STATE_PRESSED )
+            iState = PBS_PRESSED;
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = PBS_DISABLED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = PBS_HOT;
+        else if( nState & CTRL_STATE_DEFAULT )
+            iState = PBS_DEFAULTED;
+        //else if( nState & CTRL_STATE_FOCUSED )
+        //    iState = PBS_DEFAULTED;    // may need to draw focus rect 
+        else
+            iState = PBS_NORMAL;
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_RADIOBUTTON )
+    {
+        iPart = BP_RADIOBUTTON;
+        BOOL bChecked = ( aValue.getTristateVal() == BUTTONVALUE_ON );
+
+        if( nState & CTRL_STATE_PRESSED )
+            iState = bChecked ? RBS_CHECKEDPRESSED : RBS_UNCHECKEDPRESSED;
+        else if( !(nState & CTRL_STATE_ENABLED) )
+            iState = bChecked ? RBS_CHECKEDDISABLED : RBS_UNCHECKEDDISABLED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = bChecked ? RBS_CHECKEDHOT : RBS_UNCHECKEDHOT;
+        else
+            iState = bChecked ? RBS_CHECKEDNORMAL : RBS_UNCHECKEDNORMAL;
+
+        //if( nState & CTRL_STATE_FOCUSED )
+        //    iState |= PBS_DEFAULTED;    // may need to draw focus rect 
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_CHECKBOX )
+    {
+        iPart = BP_CHECKBOX;
+        ButtonValue v = aValue.getTristateVal();
+
+        iState |= (v == BUTTONVALUE_ON)  ? CBS_CHECKEDNORMAL : 
+                ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDNORMAL : CBS_MIXEDNORMAL );
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState |= (v == BUTTONVALUE_ON)  ? CBS_CHECKEDDISABLED : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDDISABLED : CBS_MIXEDDISABLED );
+        if( nState & CTRL_STATE_PRESSED )
+            iState |= (v == BUTTONVALUE_ON)  ? CBS_CHECKEDPRESSED : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDPRESSED : CBS_MIXEDPRESSED );
+        if( nState & CTRL_STATE_ROLLOVER )
+            iState |= (v == BUTTONVALUE_ON)  ? CBS_CHECKEDHOT : 
+                    ( (v == BUTTONVALUE_OFF) ? CBS_UNCHECKEDHOT : CBS_MIXEDHOT );
+
+        //if( nState & CTRL_STATE_FOCUSED )
+        //    iState |= PBS_DEFAULTED;    // may need to draw focus rect 
+
+        SIZE sz;
+        THEMESIZE eSize = TS_DRAW; // TS_MIN, TS_TRUE, TS_DRAW
+        vsAPI.GetThemePartSize( hTheme, hDC, iPart, iState, &rc, eSize, &sz);
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_EDITBOX )
+    {
+        iPart = EP_EDITTEXT;
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = ETS_DISABLED;
+        else if( nState & CTRL_STATE_FOCUSED )
+            iState = ETS_FOCUSED;
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = ETS_HOT;
+        else
+            iState = ETS_NORMAL;
+
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_LISTBOX )
+    {
+        if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+        {
+            iPart = LVP_EMPTYTEXT; // ??? no idea which part to choose here
+            return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+        }
+    }
+
+    if( nType == CTRL_TAB_PANE )
+    {
+        iPart = TABP_PANE;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_FIXEDBORDER )
+    {
+        /*
+        iPart = BP_GROUPBOX;
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = GBS_DISABLED;
+        else
+            iState = GBS_NORMAL;
+            */
+        // The fixed border is only used around the tools->options tabpage where
+        // TABP_PANE fits best
+        iPart = TABP_PANE;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_TAB_BODY )
+    {
+        iPart = TABP_BODY;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+
+    if( nType == CTRL_TAB_ITEM )
+    {
+        iPart = TABP_TABITEMLEFTEDGE;
+        rc.bottom--;
+
+        TabitemValue *pValue = (TabitemValue*) aValue.getOptionalVal();
+        if( pValue )
+        {
+            if( pValue->isBothAligned() )
+            {
+                iPart = TABP_TABITEMLEFTEDGE;
+                rc.right--;
+            }
+            else if( pValue->isLeftAligned() )
+                iPart = TABP_TABITEMLEFTEDGE;
+            else if( pValue->isRightAligned() )
+                iPart = TABP_TABITEMRIGHTEDGE;
+            else iPart = TABP_TABITEM;
+        }
+ 
+        if( !(nState & CTRL_STATE_ENABLED) )
+            iState = TILES_DISABLED;
+        else if( nState & CTRL_STATE_SELECTED )
+        {
+            iState = TILES_SELECTED;
+            // increase the selected tab
+            rc.left-=2;
+            if( pValue && !pValue->isBothAligned() )
+            {
+                if( pValue->isLeftAligned() || pValue->isNotAligned() )
+                    rc.right+=2;
+                if( pValue->isRightAligned() )
+                    rc.right+=1;
+            }
+            rc.top-=2;
+            rc.bottom+=2;
+        }
+        else if( nState & CTRL_STATE_ROLLOVER )
+            iState = TILES_HOT;
+        else if( nState & CTRL_STATE_FOCUSED )
+            iState = TILES_FOCUSED;    // may need to draw focus rect 
+        else
+            iState = TILES_NORMAL;
+        return ImplDrawTheme( hTheme, hDC, iPart, iState, rc, aCaption);
+    }
+    return false;
+}
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalGraphics implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::DrawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption,
+                            const OutputDevice*)
+{
+    BOOL bOk = false;
+    HTHEME hTheme;
+
+    switch( nType )
+    {
+        case CTRL_PUSHBUTTON:
+        case CTRL_RADIOBUTTON:
+        case CTRL_CHECKBOX:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Button");
+            break;
+        case CTRL_SCROLLBAR:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Scrollbar");
+            break;
+        case CTRL_COMBOBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Combobox");
+            break;
+        case CTRL_SPINBOX:
+            if( nPart == PART_ENTIRE_CONTROL )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            else
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Spin");
+            break;
+        case CTRL_SPINBUTTONS:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Spin");
+            break;
+        case CTRL_EDITBOX:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Edit");
+            break;
+        case CTRL_LISTBOX:
+            if( nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Listview");
+            else if( nPart == PART_BUTTON_DOWN )
+                hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Combobox");
+            break;
+        case CTRL_TAB_PANE:
+        case CTRL_TAB_BODY:
+        case CTRL_TAB_ITEM:
+        case CTRL_FIXEDBORDER:
+            hTheme = getThemeHandle( maGraphicsData.mhWnd, L"Tab");
+            break;
+        default:
+            hTheme = NULL;
+    }
+
+    if( !hTheme )
+        return false;
+
+	Rectangle buttonRect = rControlRegion.GetBoundRect();
+    RECT rc;
+    rc.left   = buttonRect.Left();
+    rc.right  = buttonRect.Right()+1;
+    rc.top    = buttonRect.Top();
+    rc.bottom = buttonRect.Bottom()+1;
+
+    HDC hDC = GetDC( maGraphicsData.mhWnd );
+
+    // set default text alignment
+    int ta = SetTextAlign( hDC, TA_LEFT|TA_TOP|TA_NOUPDATECP );
+
+    OUString aCaptionStr( aCaption.replace('~', '&') ); // translate mnemonics
+    bOk = ImplDrawNativeControl(hDC, hTheme, rc,
+                            nType, nPart, nState, aValue,
+							rControlHandle, aCaptionStr );
+
+    // restore alignment
+    SetTextAlign( hDC, ta );
+   
+    ReleaseDC( maGraphicsData.mhWnd, hDC );
+
+    //GdiFlush();
+
+	return bOk;
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalGraphics implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::DrawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+                                const OutputDevice*)
+{
+	return( false );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the true bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalGraphics implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::GetNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion,
+                                const OutputDevice*)
+{
+    BOOL bRet = FALSE;
+    /*
+    if( nType == CTRL_PUSHBUTTON && nPart == PART_ENTIRE_CONTROL )
+    {
+        if( nState & CTRL_STATE_DEFAULT )
+        {
+            // make default button bigger
+            rNativeContentRegion = rControlRegion;
+            Rectangle aBoundRect = rControlRegion.GetBoundRect();
+            aBoundRect.Top() -= 5;
+            aBoundRect.Bottom() += 5;
+            aBoundRect.Left() -= 8;
+            aBoundRect.Right() += 8;
+            rNativeBoundingRegion = Region( aBoundRect );
+            bRet = TRUE;
+        }
+    }
+*/
+	return( bRet );
+}
+
+
+/************************************************************************/
+/* SalControlHandleData stuff */
+/************************************************************************/
+SalControlHandleData::SalControlHandleData( void )
+{
+}
+
+
+SalControlHandleData::~SalControlHandleData( void )
+{
+}
+
+
+void SalControlHandle::ThemeChanged( void )
+{
+}
