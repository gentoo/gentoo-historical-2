--- vcl/unx/gtk/window/gtkframe.cxx
+++ vcl/unx/gtk/window/gtkframe.cxx
@@ -185,8 +184,9 @@
 void GtkSalFrame::doKeyCallback( guint state,
                                  guint keyval,
                                  guint16 hardware_keycode,
                                  guint8 group,
                                  guint32 time,
+                                 sal_Unicode aOrigCode,
                                  bool bDown,
                                  bool bSendRelease
                                  )
@@ -208,20 +226,21 @@
     SalKeyEvent aEvent;
     
     aEvent.mnTime			= time;    
-    aEvent.mnCode			= GetKeyCode( keyval ) | GetModCode( state );
-    aEvent.mnCharCode		= (USHORT)gdk_keyval_to_unicode( keyval );
+    aEvent.mnCode			= GetKeyCode( keyval ) | GetModCode( state );
+    aEvent.mnCharCode		= aOrigCode;
     aEvent.mnRepeat			= 0;
     
 	vcl::DeletionListener aDel( this );
-    bool bHandled = CallCallback( bDown ? SALEVENT_KEYINPUT : SALEVENT_KEYUP, &aEvent );
-    if( bDown && ! aDel.isDeleted() )
+    if( bDown )
     {
-        /* #i42122# if application cannot handle the event (e.g. for a shortcut key)
-        *  then try the same key with the default keymap in group 0, so e.g. cyrillic
-        *  keys get translated to the english keyboard layout and can be recognized
-        *  as shortcuts (see also generic plugin)
+        /* #i42122# translate all keys with Ctrl and/or Alt to group 0
+        *  else shortcuts (e.g. Ctrl-o) will not work but be inserted by
+        *  the application
         */
-        if( ! bHandled && group != 0)
+        bool bHandled = false;
+        if( (aEvent.mnCode & (KEY_MOD1|KEY_MOD2)) == 0 || group == 0 )
+            bHandled = CallCallback( SALEVENT_KEYINPUT, &aEvent );
+        else
         {
             // check other mapping
             gint eff_group, level;
@@ -236,9 +255,9 @@
                                                      &level,
                                                      &consumed ) )
             {
-                aEvent.mnCode	= GetKeyCode( updated_keyval ) | GetModCode( state );
+                aEvent.mnCode	= GetKeyCode( updated_keyval ) | GetModCode( state );
                 aEvent.mnCharCode = (USHORT)gdk_keyval_to_unicode( updated_keyval );
-                CallCallback( SALEVENT_KEYINPUT, &aEvent );
+                bHandled = CallCallback( SALEVENT_KEYINPUT, &aEvent );
             }
         }
         if( bSendRelease && ! aDel.isDeleted() )
@@ -246,6 +277,8 @@
             CallCallback( SALEVENT_KEYUP, &aEvent );
         }
     }
+    else
+        CallCallback( SALEVENT_KEYUP, &aEvent );
 }
 
 GtkSalFrame::GraphicsHolder::~GraphicsHolder()
@@ -352,6 +394,7 @@
     m_pIMContext		= NULL;
     m_bWasPreedit		= false;
     m_bIgnoreCommit     = false;
+    m_bIgnorePreedit    = false;
     m_aPrevKeyPresses.clear();
     m_nPrevKeyPresses = 0;
     
@@ -1071,7 +1454,8 @@
 void GtkSalFrame::createIMContext()
 {
     if( ! m_pIMContext )
     {
+        m_bIgnorePreedit = true;
         m_pIMContext = gtk_im_multicontext_new ();
         g_signal_connect( m_pIMContext, "commit",
                           G_CALLBACK (signalIMCommit), this );
@@ -1102,6 +1488,7 @@
         gtk_im_context_set_client_window( m_pIMContext, GTK_WIDGET(m_pWindow)->window );
 		gtk_im_context_focus_in( m_pIMContext );
         m_bWasPreedit = false;
+        m_bIgnorePreedit = false;
     }
 }
 
@@ -2006,7 +2262,14 @@
     }
     else
     {
-        pThis->doKeyCallback( pEvent->state, pEvent->keyval, pEvent->hardware_keycode, pEvent->group, pEvent->time, (pEvent->type == GDK_KEY_PRESS), false );
+        pThis->doKeyCallback( pEvent->state,
+                              pEvent->keyval,
+                              pEvent->hardware_keycode,
+                              pEvent->group,
+                              pEvent->time,
+                              sal_Unicode(gdk_keyval_to_unicode( pEvent->keyval )),
+                              (pEvent->type == GDK_KEY_PRESS),
+                              false );
 		if( ! aDel.isDeleted() )
 		{
 			pThis->m_bSendModChangeOnRelease = false;
@@ -2068,7 +2341,34 @@
     return FALSE;
 }
 
+/* FIXME:
+* #122282# still more hacking: some IMEs never start a preedit but simply commit
+* in this case we cannot commit a single character. Workaround: do not do the
+* single key hack for enter or space if the unicode commited does not match
+*/
+
+static bool checkSinkleKeyCommitHack( guint keyval, sal_Unicode cCode )
+{
+    bool bRet = true;
+    switch( keyval )
+    {
+        case GDK_KP_Enter:
+        case GDK_Return:
+            if( cCode != '\n' && cCode != '\r' )
+                bRet = false;
+            break;
+        case GDK_space:
+        case GDK_KP_Space:
+            if( cCode != ' ' )
+                bRet = false;
+            break;
+        default:
+            break;
+    }
+    return bRet;
+}
+
 void GtkSalFrame::signalIMCommit( GtkIMContext* pContext, gchar* pText, gpointer frame )
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
 
@@ -2109,11 +2405,18 @@
         )
     {
         const PreviousKeyPress& rKP = pThis->m_aPrevKeyPresses.back();
+        sal_Unicode aOrigCode = aTextEvent.maText.GetChar(0);
 
+        if( checkSinkleKeyCommitHack( rKP.keyval, aOrigCode ) )
+        {
+            #if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, ":signalIMCommit (as key): '%s'\n", pText );
+            #endif
        pThis->m_bWasPreedit = false;
-        pThis->doKeyCallback( rKP.state, rKP.keyval, rKP.hardware_keycode, rKP.group, rKP.time, true, true );
+            pThis->doKeyCallback( rKP.state, rKP.keyval, rKP.hardware_keycode, rKP.group, rKP.time, aOrigCode, true, true );
        return;
     }
+    }
 
     #if OSL_DEBUG_LEVEL > 1
     fprintf( stderr, ":signalIMCommit '%s'\n", pText );
@@ -2128,6 +2431,8 @@
 void GtkSalFrame::signalIMPreeditChanged( GtkIMContext* pContext, gpointer frame )
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    if( pThis->m_bIgnorePreedit )
+        return;
 
     char*			pText			= NULL;
     PangoAttrList*	pAttrs		    = NULL;
@@ -2221,18 +2526,27 @@
 
 void GtkSalFrame::signalIMPreeditStart( GtkIMContext* pContext, gpointer frame )
 {
-//    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    if( ! pThis->m_bIgnorePreedit )
+    {
+        #if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, ":signalImPreeditStart\n" );
+        #endif
+    }
 }
 
 void GtkSalFrame::signalIMPreeditEnd( GtkIMContext* pContext, gpointer frame )
 {
     GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    if( ! pThis->m_bIgnorePreedit )
+    {
 #if OSL_DEBUG_LEVEL > 1
 	fprintf( stderr, ":signalImPreeditEnd\n" );
 #endif
     GTK_YIELD_GRAB();
 	pThis->CallCallback( SALEVENT_ENDEXTTEXTINPUT, NULL );
 }
+}
 
 gboolean GtkSalFrame::signalIMRetrieveSurrounding( GtkIMContext* pContext, gpointer frame )
 {
--- /opt/OpenOffice/DEVEL/ooo-build/build/OOO_1_1_4/vcl/unx/inc/plugins/gtk/gtkframe.hxx	2005-06-15 15:05:25.000000000 +0100
+++ vcl/unx/inc/plugins/gtk/gtkframe.hxx	2005-06-28 15:05:42.664084120 +0100
@@ -183,6 +183,7 @@
     bool					m_bSendModChangeOnRelease;
     bool					m_bWasPreedit;
     bool                            m_bIgnoreCommit;
+    bool                            m_bIgnorePreedit;
     
     Size                            m_aMaxSize;
     Size                            m_aMinSize;
@@ -234,6 +235,7 @@
                                    guint16 hardware_keycode,
                                    guint8 group,
                                    guint32 time,
+                                   sal_Unicode aOrigCode,
                                    bool bDown,
                                    bool bSendRelease
                                    );
