To: vim-dev@vim.org
Subject: Patch 6.0.031
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
MIME-Version: 1.0
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 8bit
------------

Patch 6.0.031
Problem:    Nextstep doesn't have setenv() or putenv().  (John Beppu)
Solution:   Move putenv() from pty.c to misc2.c
Files:      src/misc2.c, src/pty.c


*** ../vim60.30/src/misc2.c	Sun Sep 30 10:53:07 2001
--- src/misc2.c	Sun Oct 28 21:49:00 2001
***************
*** 5186,5188 ****
--- 5187,5364 ----
  
  
  #endif /*FEAT_PRINTER*/
+ 
+ /*
+  * The putenv() implementation below comes from the "screen" program.
+  * Included with permission from Juergen Weigert.
+  * See pty.c for the copyright notice.
+  */
+ 
+ /*
+  *  putenv  --	put value into environment
+  *
+  *  Usage:  i = putenv (string)
+  *    int i;
+  *    char  *string;
+  *
+  *  where string is of the form <name>=<value>.
+  *  Putenv returns 0 normally, -1 on error (not enough core for malloc).
+  *
+  *  Putenv may need to add a new name into the environment, or to
+  *  associate a value longer than the current value with a particular
+  *  name.  So, to make life simpler, putenv() copies your entire
+  *  environment into the heap (i.e. malloc()) from the stack
+  *  (i.e. where it resides when your process is initiated) the first
+  *  time you call it.
+  *
+  *  (history removed, not very interesting.  See the "screen" sources.)
+  */
+ 
+ #if !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)
+ 
+ #define EXTRASIZE 5		/* increment to add to env. size */
+ 
+ static int  envsize = -1;	/* current size of environment */
+ #ifndef MACOS
+ extern
+ #endif
+        char **environ;		/* the global which is your env. */
+ 
+ static int  findenv __ARGS((char *name)); /* look for a name in the env. */
+ static int  newenv __ARGS((void));	/* copy env. from stack to heap */
+ static int  moreenv __ARGS((void));	/* incr. size of env. */
+ 
+     int
+ putenv(string)
+     const char *string;
+ {
+     int	    i;
+     char    *p;
+ 
+     if (envsize < 0)
+     {				/* first time putenv called */
+ 	if (newenv() < 0)	/* copy env. to heap */
+ 	    return -1;
+     }
+ 
+     i = findenv((char *)string); /* look for name in environment */
+ 
+     if (i < 0)
+     {				/* name must be added */
+ 	for (i = 0; environ[i]; i++);
+ 	if (i >= (envsize - 1))
+ 	{			/* need new slot */
+ 	    if (moreenv() < 0)
+ 		return -1;
+ 	}
+ 	p = (char *)alloc((unsigned)(strlen(string) + 1));
+ 	if (p == NULL)		/* not enough core */
+ 	    return -1;
+ 	environ[i + 1] = 0;	/* new end of env. */
+     }
+     else
+     {				/* name already in env. */
+ 	p = vim_realloc(environ[i], strlen(string) + 1);
+ 	if (p == NULL)
+ 	    return -1;
+     }
+     sprintf(p, "%s", string);	/* copy into env. */
+     environ[i] = p;
+ 
+     return 0;
+ }
+ 
+     static int
+ findenv(name)
+     char *name;
+ {
+     char    *namechar, *envchar;
+     int	    i, found;
+ 
+     found = 0;
+     for (i = 0; environ[i] && !found; i++)
+     {
+ 	envchar = environ[i];
+ 	namechar = name;
+ 	while (*namechar && *namechar != '=' && (*namechar == *envchar))
+ 	{
+ 	    namechar++;
+ 	    envchar++;
+ 	}
+ 	found = ((*namechar == '\0' || *namechar == '=') && *envchar == '=');
+     }
+     return found ? i - 1 : -1;
+ }
+ 
+     static int
+ newenv()
+ {
+     char    **env, *elem;
+     int	    i, esize;
+ 
+ #ifdef MACOS
+     /* for Mac a new, empty environment is created */
+     i = 0;
+ #else
+     for (i = 0; environ[i]; i++)
+ 	;
+ #endif
+     esize = i + EXTRASIZE + 1;
+     env = (char **)alloc((unsigned)(esize * sizeof (elem)));
+     if (env == NULL)
+ 	return -1;
+ 
+ #ifndef MACOS
+     for (i = 0; environ[i]; i++)
+     {
+ 	elem = (char *)alloc((unsigned)(strlen(environ[i]) + 1));
+ 	if (elem == NULL)
+ 	    return -1;
+ 	env[i] = elem;
+ 	strcpy(elem, environ[i]);
+     }
+ #endif
+ 
+     env[i] = 0;
+     environ = env;
+     envsize = esize;
+     return 0;
+ }
+ 
+     static int
+ moreenv()
+ {
+     int	    esize;
+     char    **env;
+ 
+     esize = envsize + EXTRASIZE;
+     env = (char **)vim_realloc((char *)environ, esize * sizeof (*env));
+     if (env == 0)
+ 	return -1;
+     environ = env;
+     envsize = esize;
+     return 0;
+ }
+ 
+ # ifdef USE_VIMPTY_GETENV
+     char_u *
+ vimpty_getenv(string)
+     const char_u *string;
+ {
+     int i;
+     char_u *p;
+ 
+     if (envsize < 0)
+ 	return NULL;
+ 
+     i = findenv((char *)string);
+ 
+     if (i < 0)
+ 	return NULL;
+ 
+     p = vim_strchr((char_u *)environ[i], '=');
+     return (p + 1);
+ }
+ # endif
+ 
+ #endif /* !defined(HAVE_SETENV) && !defined(HAVE_PUTENV) */
*** ../vim60.30/src/pty.c	Sat Jul 28 12:34:41 2001
--- src/pty.c	Sun Oct 28 21:46:44 2001
***************
*** 9,15 ****
  /*
   * The stuff in this file mostly comes from the "screen" program.
   * Included with permission from Juergen Weigert.
!  * Copied from "pty.c" and "putenv.c".
   *
   * It has been modified to work better with Vim.
   * The parts that are not used in Vim have been deleted.
--- 9,15 ----
  /*
   * The stuff in this file mostly comes from the "screen" program.
   * Included with permission from Juergen Weigert.
!  * Copied from "pty.c".  "putenv.c" was used for putenv() in misc2.c.
   *
   * It has been modified to work better with Vim.
   * The parts that are not used in Vim have been deleted.
***************
*** 423,597 ****
      return -1;
  }
  #endif
- 
- /* putenv.c */
- 
- /*
-  *  putenv  --	put value into environment
-  *
-  *  Usage:  i = putenv (string)
-  *    int i;
-  *    char  *string;
-  *
-  *  where string is of the form <name>=<value>.
-  *  Putenv returns 0 normally, -1 on error (not enough core for malloc).
-  *
-  *  Putenv may need to add a new name into the environment, or to
-  *  associate a value longer than the current value with a particular
-  *  name.  So, to make life simpler, putenv() copies your entire
-  *  environment into the heap (i.e. malloc()) from the stack
-  *  (i.e. where it resides when your process is initiated) the first
-  *  time you call it.
-  *
-  *  (history removed, not very interesting.  See the "screen" sources.)
-  */
- /* RCS_ID("$Id: 6.0.031,v 1.1 2002/01/06 22:32:01 agriffis Exp $ FAU") */
- 
- #if !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)
- 
- #define EXTRASIZE 5		/* increment to add to env. size */
- 
- static int  envsize = -1;	/* current size of environment */
- #ifndef MACOS
- extern
- #endif
-        char **environ;		/* the global which is your env. */
- 
- static int  findenv __ARGS((char *name)); /* look for a name in the env. */
- static int  newenv __ARGS((void));	/* copy env. from stack to heap */
- static int  moreenv __ARGS((void));	/* incr. size of env. */
- 
-     int
- putenv(string)
-     const char *string;
- {
-     int	    i;
-     char    *p;
- 
-     if (envsize < 0)
-     {				/* first time putenv called */
- 	if (newenv() < 0)	/* copy env. to heap */
- 	    return -1;
-     }
- 
-     i = findenv((char *)string); /* look for name in environment */
- 
-     if (i < 0)
-     {				/* name must be added */
- 	for (i = 0; environ[i]; i++);
- 	if (i >= (envsize - 1))
- 	{			/* need new slot */
- 	    if (moreenv() < 0)
- 		return -1;
- 	}
- 	p = (char *)alloc((unsigned)(strlen(string) + 1));
- 	if (p == NULL)		/* not enough core */
- 	    return -1;
- 	environ[i + 1] = 0;	/* new end of env. */
-     }
-     else
-     {				/* name already in env. */
- 	p = vim_realloc(environ[i], strlen(string) + 1);
- 	if (p == NULL)
- 	    return -1;
-     }
-     sprintf(p, "%s", string);	/* copy into env. */
-     environ[i] = p;
- 
-     return 0;
- }
- 
-     static int
- findenv(name)
-     char *name;
- {
-     char    *namechar, *envchar;
-     int	    i, found;
- 
-     found = 0;
-     for (i = 0; environ[i] && !found; i++)
-     {
- 	envchar = environ[i];
- 	namechar = name;
- 	while (*namechar && *namechar != '=' && (*namechar == *envchar))
- 	{
- 	    namechar++;
- 	    envchar++;
- 	}
- 	found = ((*namechar == '\0' || *namechar == '=') && *envchar == '=');
-     }
-     return found ? i - 1 : -1;
- }
- 
-     static int
- newenv()
- {
-     char    **env, *elem;
-     int	    i, esize;
- 
- #ifdef MACOS
-     /* for Mac a new, empty environment is created */
-     i = 0;
- #else
-     for (i = 0; environ[i]; i++)
- 	;
- #endif
-     esize = i + EXTRASIZE + 1;
-     env = (char **)alloc((unsigned)(esize * sizeof (elem)));
-     if (env == NULL)
- 	return -1;
- 
- #ifndef MACOS
-     for (i = 0; environ[i]; i++)
-     {
- 	elem = (char *)alloc((unsigned)(strlen(environ[i]) + 1));
- 	if (elem == NULL)
- 	    return -1;
- 	env[i] = elem;
- 	strcpy(elem, environ[i]);
-     }
- #endif
- 
-     env[i] = 0;
-     environ = env;
-     envsize = esize;
-     return 0;
- }
- 
-     static int
- moreenv()
- {
-     int	    esize;
-     char    **env;
- 
-     esize = envsize + EXTRASIZE;
-     env = (char **)vim_realloc((char *)environ, esize * sizeof (*env));
-     if (env == 0)
- 	return -1;
-     environ = env;
-     envsize = esize;
-     return 0;
- }
- 
- # ifdef USE_VIMPTY_GETENV
-     char_u *
- vimpty_getenv(string)
-     const char_u *string;
- {
-     int i;
-     char_u *p;
- 
-     if (envsize < 0)
- 	return NULL;
- 
-     i = findenv((char *)string);
- 
-     if (i < 0)
- 	return NULL;
- 
-     p = vim_strchr((char_u *)environ[i], '=');
-     return (p + 1);
- }
- # endif
- 
- #endif /* !defined(HAVE_SETENV) && !defined(HAVE_PUTENV) */
--- 423,425 ----
*** ../vim60.30/src/version.c	Sun Oct 28 21:23:45 2001
--- src/version.c	Sun Oct 28 21:51:26 2001
***************
*** 608,609 ****
--- 608,611 ----
  {   /* Add new patch number below this line */
+ /**/
+     31,
  /**/

-- 
-rwxr-xr-x  1 root          24 Oct 29  1929 /bin/ed
-rwxr-xr-t  4 root      131720 Jan  1  1970 /usr/ucb/vi
-rwxr-xr-x  1 root  5.89824e37 Oct 22  1990 /usr/bin/emacs

 ///  Bram Moolenaar -- Bram@moolenaar.net -- http://www.moolenaar.net  \\\
(((   Creator of Vim -- http://vim.sf.net -- ftp://ftp.vim.org/pub/vim   )))
 \\\  Help me helping AIDS orphans in Uganda - http://iccf-holland.org  ///
