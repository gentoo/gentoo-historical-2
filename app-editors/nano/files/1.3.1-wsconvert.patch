diff -ur nano-1.3.1.orig/doc/nanorc.sample nano-1.3.1/doc/nanorc.sample
--- nano-1.3.1.orig/doc/nanorc.sample	2004-01-10 03:04:04.105882992 -0500
+++ nano-1.3.1/doc/nanorc.sample	2004-01-10 03:04:29.507021432 -0500
@@ -86,6 +86,16 @@
 ## Use this tab size instead of the default; it must be greater than 0
 # set tabsize 8
 
+## Use this tab char instead of the default space; it can either be the
+## ascii value of the character you wish to see (refer to ascii(7)) or
+## it can be a single character.  187 seems to be a 'good' value.
+# set tabconvert 32
+## Same as tabconverting above, but applied to spaces.
+## it can be a single character.  183 seems to be a 'good' value.
+# set spaceconvert 32
+## Finally, you can toggle whitespace converting with this
+# set wsconvert
+
 ## Save automatically on exit, don't prompt
 # set tempfile
 
diff -ur nano-1.3.1.orig/src/global.c nano-1.3.1/src/global.c
--- nano-1.3.1.orig/src/global.c	2004-01-10 03:04:04.115881472 -0500
+++ nano-1.3.1/src/global.c	2004-01-10 03:05:01.991083104 -0500
@@ -84,6 +84,9 @@
 int tabsize = -1;		/* Our internal tabsize variable.  The
 				   default value 8 is set in main(). */
 
+int tabconvert = ' ';
+int spaceconvert = ' ';
+
 char *hblank = NULL;		/* A horizontal blank line */
 #ifndef DISABLE_HELP
 char *help_text;		/* The text in the help window */
@@ -227,7 +230,7 @@
     char *toggle_const_msg, *toggle_autoindent_msg, *toggle_suspend_msg,
 	*toggle_nohelp_msg, *toggle_cuttoend_msg,
 	*toggle_noconvert_msg, *toggle_dos_msg, *toggle_mac_msg,
-	*toggle_backup_msg, *toggle_smooth_msg;
+	*toggle_backup_msg, *toggle_smooth_msg, *toggle_wsconvert_msg;
 #ifndef DISABLE_MOUSE
     char *toggle_mouse_msg;
 #endif
@@ -259,6 +262,7 @@
     toggle_mac_msg = _("Writing file in Mac format");
     toggle_backup_msg = _("Backing up file");
     toggle_smooth_msg = _("Smooth scrolling");
+    toggle_wsconvert_msg = _("Whitespace converting");
 #ifdef ENABLE_COLOR
     toggle_syntax_msg = _("Color syntax highlighting");
 #endif
@@ -275,6 +279,7 @@
 #endif
     toggle_init_one(TOGGLE_CONST_KEY, toggle_const_msg, CONSTUPDATE);
     toggle_init_one(TOGGLE_AUTOINDENT_KEY, toggle_autoindent_msg, AUTOINDENT);
+    toggle_init_one(TOGGLE_WSCONVERT_KEY, toggle_wsconvert_msg, WS_CONVERT);
 #ifndef DISABLE_WRAPPING
     toggle_init_one(TOGGLE_WRAP_KEY, toggle_wrap_msg, NO_WRAP);
 #endif
diff -ur nano-1.3.1.orig/src/nano.c nano-1.3.1/src/nano.c
--- nano-1.3.1.orig/src/nano.c	2004-01-10 03:04:04.140877672 -0500
+++ nano-1.3.1/src/nano.c	2004-01-10 03:04:29.511020824 -0500
@@ -3035,6 +3035,9 @@
 	edit_refresh();
 	break;
 #endif
+	case TOGGLE_WSCONVERT_KEY:
+	edit_refresh();
+	break;
     }
 
     /* We are assuming here that shortcut_init() above didn't free and
diff -ur nano-1.3.1.orig/src/nano.h nano-1.3.1/src/nano.h
--- nano-1.3.1.orig/src/nano.h	2004-01-10 03:04:04.139877824 -0500
+++ nano-1.3.1/src/nano.h	2004-01-10 03:04:29.512020672 -0500
@@ -289,6 +289,7 @@
 #define HISTORY_CHANGED		(1<<28)
 #define HISTORYLOG		(1<<29)
 #define JUSTIFY_MODE		(1<<30)
+#define WS_CONVERT		(1<<31)
 
 /* Control key sequences, changing these would be very very bad. */
 #define NANO_CONTROL_SPACE 0
@@ -451,6 +452,7 @@
 #define TOGGLE_MAC_KEY		NANO_ALT_O
 #define TOGGLE_SMOOTH_KEY	NANO_ALT_S
 #define TOGGLE_NOCONVERT_KEY	NANO_ALT_N
+#define TOGGLE_WSCONVERT_KEY	NANO_ALT_E
 #define TOGGLE_BACKUP_KEY	NANO_ALT_B
 #define TOGGLE_SYNTAX_KEY	NANO_ALT_Y
 #endif /* !NANO_SMALL */
diff -ur nano-1.3.1.orig/src/proto.h nano-1.3.1/src/proto.h
--- nano-1.3.1.orig/src/proto.h	2004-01-10 03:04:04.140877672 -0500
+++ nano-1.3.1/src/proto.h	2004-01-10 03:04:29.513020520 -0500
@@ -41,7 +41,7 @@
 extern long totsize;
 extern int temp_opt;
 extern int flags;
-extern int tabsize;
+extern int tabsize, tabconvert, spaceconvert;
 extern int search_last_line;
 extern int search_offscreen;
 extern int currslen;
diff -ur nano-1.3.1.orig/src/rcfile.c nano-1.3.1/src/rcfile.c
--- nano-1.3.1.orig/src/rcfile.c	2004-01-10 03:04:04.140877672 -0500
+++ nano-1.3.1/src/rcfile.c	2004-01-10 03:04:29.514020368 -0500
@@ -60,6 +60,7 @@
 #endif
 #ifndef NANO_SMALL
     {"noconvert", NO_CONVERT},
+    {"wsconvert", WS_CONVERT},
 #endif
     {"nofollow", NOFOLLOW_SYMLINKS},
     {"nohelp", NO_HELP},
@@ -85,6 +86,8 @@
 #endif
     {"suspend", SUSPEND},
     {"tabsize", 0},
+    {"tabconvert", ' '},
+    {"spaceconvert", ' '},
     {"tempfile", TEMP_OPT},
     {"view", VIEW_MODE},
     {NULL, 0}
@@ -531,6 +534,8 @@
 #endif
 		    if (set == 1) {
 			if (!strcasecmp(rcopts[i].name, "tabsize")
+				|| !strcasecmp(rcopts[i].name, "tabconvert")
+				|| !strcasecmp(rcopts[i].name, "spaceconvert")
 #ifndef DISABLE_OPERATINGDIR
 				|| !strcasecmp(rcopts[i].name, "operatingdir")
 #endif
@@ -594,12 +599,30 @@
 				 * accept 0 while checking other
 				 * errors. */
 				j = (int)strtol(option, &first_error, 10);
-				if (errno == ERANGE || *option == '\0' || *first_error != '\0')
-				    rcfile_error(_("Requested tab size %d invalid"),
-						 j);
-				else
-				    tabsize = j;
-			    }
+				if (!strcasecmp(rcopts[i].name, "tabconvert")) {
+					if (errno == ERANGE || *first_error != '\0') {
+						if (*option == '\0')
+							rcfile_error(_("requested tab convert is invalid"));
+						else
+							tabconvert = option[0];
+					} else
+						tabconvert = j;
+				} else if (!strcasecmp(rcopts[i].name, "spaceconvert")) {
+					if (errno == ERANGE || *first_error != '\0') {
+						if (*option == '\0')
+							rcfile_error(_("requested space convert is invalid"));
+						else
+							spaceconvert = option[0];
+					} else
+						spaceconvert = j;
+				} else {
+					if (errno == ERANGE || *option == '\0' || *first_error != '\0')
+						rcfile_error(_("requested tab size %d invalid"),
+						             j);
+					else
+						tabsize = j;
+				}
+				}
 			} else
 			    SET(rcopts[i].flag);
 #ifdef DEBUG
diff -ur nano-1.3.1.orig/src/winio.c nano-1.3.1/src/winio.c
--- nano-1.3.1.orig/src/winio.c	2004-01-10 03:04:04.138877976 -0500
+++ nano-1.3.1/src/winio.c	2004-01-10 03:04:29.516020064 -0500
@@ -773,11 +773,12 @@
     index = 0;
 
     for (; index < alloc_len; buf++) {
-	if (*buf == '\t')
-	    do {
+	if (*buf == '\t') {
+	    converted[index++] = (ISSET(WS_CONVERT) ? tabconvert : ' ');
+	    while ((column + index) % tabsize) {
 		converted[index++] = ' ';
-	    } while ((column + index) % tabsize);
-	else if (is_cntrl_char(*buf)) {
+	    }
+	} else if (is_cntrl_char(*buf)) {
 	    converted[index++] = '^';
 	    if (*buf == '\n')
 		/* Treat newlines embedded in a line as encoded nulls;
@@ -789,7 +790,7 @@
 	    else
 		converted[index++] = *buf + 64;
 	} else
-	    converted[index++] = *buf;
+	    converted[index++] = (*buf==' '&&ISSET(WS_CONVERT)) ? spaceconvert : *buf;
     }
     assert(len <= alloc_len + column - start_col);
     charmove(converted, converted + start_col - column, len);
