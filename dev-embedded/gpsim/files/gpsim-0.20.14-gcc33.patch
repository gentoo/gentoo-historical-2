diff -ur gpsim-0.20.14.old/cli/cmd_attach.cc gpsim-0.20.14/cli/cmd_attach.cc
--- gpsim-0.20.14.old/cli/cmd_attach.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_attach.cc	2003-10-20 11:14:16.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 #include <vector>
 
@@ -42,15 +42,14 @@
 
     brief_doc = string("Attach stimuli to nodes");
 
-    long_doc = string ("attach node1 stimulus1 [stimulus2 stimulu_N]\
-\n\t  attach is used to define the connections between stimuli and nodes.\
-\n\tAt least one node and one stimulus must be specified. If more stimuli\
-\n\tare specified then they will all be attached to the node.\
-\n\n\texamples:
-\n\n\tnode pin2pin_test                  // Define a new node.\
-\n\tattach pin2pin_test porta4 portb0  // Connect two I/O pins to the node.\
-\n\tnode                               // Display the new \"net list\".\
-\n");
+    long_doc = string ("attach node1 stimulus1 [stimulus2 stimulu_N]\n\
+\t  attach is used to define the connections between stimuli and nodes.\n\
+\tAt least one node and one stimulus must be specified. If more stimuli\n\
+\tare specified then they will all be attached to the node.\n\n\
+\texamples:\n\n\
+\tnode pin2pin_test                  // Define a new node.\n\
+\tattach pin2pin_test porta4 portb0  // Connect two I/O pins to the node.\n\
+\tnode                               // Display the new \"net list\".\n");
 
   op = cmd_attach_options; 
 }
diff -ur gpsim-0.20.14.old/cli/cmd_break.cc gpsim-0.20.14/cli/cmd_break.cc
--- gpsim-0.20.14.old/cli/cmd_break.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_break.cc	2003-10-20 11:15:21.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 
 #include "command.h"
@@ -73,7 +73,7 @@
 \t\tso  - stack over flow\n\
 \t\tsu  - stack under flow\n\
 \t\twdt - wdt timeout\n\
-\t\t    - no argument, display the break points that are set.
+\t\t    - no argument, display the break points that are set.\n\
 \texamples:\n\
 \t\tbreak e 0x20       // set an execution break point at address 0x20\n\
 \t\tbreak wv 0x30 0    // break if a zero is written to register 0x30\n\
diff -ur gpsim-0.20.14.old/cli/cmd_bus.cc gpsim-0.20.14/cli/cmd_bus.cc
--- gpsim-0.20.14.old/cli/cmd_bus.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_bus.cc	2003-10-20 11:16:29.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 
 #include "command.h"
@@ -43,15 +43,14 @@
 
   brief_doc = string("Add or display node busses");
 
-  long_doc = string ("bus [new_bus1 new_bus2 ...]\
-\n\t If no new_bus is specified then all of the busses that have been\
-\n\tdefined are displayed. If a new_bus is specified then it will be\
-\n\tadded to the bus list. See the \"attach\" and \"stimulus\" commands\
-\n\tto see how stimuli are added to the busses.\
-\n\n\texamples:
-\n\n\tbus              // display the bus list\
-\n\tbus b1 b2 b3     // create and add 3 new busses to the list\
-\n");
+  long_doc = string ("bus [new_bus1 new_bus2 ...]\n\
+\t If no new_bus is specified then all of the busses that have been\n\
+\tdefined are displayed. If a new_bus is specified then it will be\n\
+\tadded to the bus list. See the \"attach\" and \"stimulus\" commands\n\
+\tto see how stimuli are added to the busses.\n\n\
+\texamples:\n\n\
+\tbus              // display the bus list\n\
+\tbus b1 b2 b3     // create and add 3 new busses to the list\n");
 
   op = cmd_bus_options; 
 }
diff -ur gpsim-0.20.14.old/cli/cmd_dump.cc gpsim-0.20.14/cli/cmd_dump.cc
--- gpsim-0.20.14.old/cli/cmd_dump.cc	2001-12-31 12:22:16.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_dump.cc	2003-10-20 11:17:46.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 #include <stdio.h>
 
@@ -54,13 +54,12 @@
 
     brief_doc = string("Display either the RAM or EEPROM");
 
-    long_doc = string ("dump [r | e | s]\n
+    long_doc = string ("dump [r | e | s]\n\
 \tdump r or dump with no options will display all of the file\n\
 \t       registers and special function registers.\n\
-\tdump e will display the contents of the eeprom (if the pic
+\tdump e will display the contents of the eeprom (if the pic\n\
 \t       being simulated contains any)\n\
-\tdump s will display only the special function registers.
-\n");
+\tdump s will display only the special function registers.\n");
 
   op = cmd_dump_options; 
 }
diff -ur gpsim-0.20.14.old/cli/cmd_frequency.cc gpsim-0.20.14/cli/cmd_frequency.cc
--- gpsim-0.20.14.old/cli/cmd_frequency.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_frequency.cc	2003-10-20 11:18:39.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 #include <vector>
 
@@ -40,13 +40,12 @@
   brief_doc = string("Set the clock frequency");
 
   long_doc = string ("\nfrequency [value]\n\
-\tThis command sets the clock frequency. By default gpsim uses 4 MHz
-\tas clock. The clock frequency is used to compute time in seconds.
-\tUse this command to adjust this value.
-\tIf no value is provided this command prints the current clock.
-\tNote that PICs have an instruction clock that's a forth of the
-\texternal clock. This value is the external clock.
-\n");
+\tThis command sets the clock frequency. By default gpsim uses 4 MHz\n\
+\tas clock. The clock frequency is used to compute time in seconds.\n\
+\tUse this command to adjust this value.\n\
+\tIf no value is provided this command prints the current clock.\n\
+\tNote that PICs have an instruction clock that's a forth of the\n\
+\texternal clock. This value is the external clock.\n");
 
   op = cmd_frequency_options;
 }
diff -ur gpsim-0.20.14.old/cli/cmd_list.cc gpsim-0.20.14/cli/cmd_list.cc
--- gpsim-0.20.14.old/cli/cmd_list.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_list.cc	2003-10-20 11:20:18.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 
 #include "command.h"
@@ -44,24 +44,22 @@
 
   brief_doc = string("Display source and list files");
 
-  long_doc = string("list [[s | l] [*pc] [line_number1 [,line_number2]]]\
-\n\n\tDisplay the contents of source and list files.\
-\n\tWithout any options, list will use the last specified options.\
-\n\tlist s will display lines in the source (or .asm) file.\
-\n\tlist l will display lines in the .lst file\
-\n\tlist *pc will display either .asm or .lst lines around the\
-\n\t   value specified by pc (e.g. list *20 will list lines around\
-\n\t   address 20)\
-\n\tline_number1, line_number2 - specify the list range.\
-\n\n\tExamples:\
-\n\tlist s *0x3a -5 5\
-\n\t  will list 11 lines (5 before, 5 after, & 1 at) around addr 3a\
-\n\tlist\
-\n\t  repeat the last list except use the current pc as the reference.\
-\n\tlist l\
-\n\t  will list lines from .lst file around the current pc.\
-\n
-");
+  long_doc = string("list [[s | l] [*pc] [line_number1 [,line_number2]]]\n\n\
+\tDisplay the contents of source and list files.\n\
+\tWithout any options, list will use the last specified options.\n\
+\tlist s will display lines in the source (or .asm) file.\n\
+\tlist l will display lines in the .lst file\n\
+\tlist *pc will display either .asm or .lst lines around the\n\
+\t   value specified by pc (e.g. list *20 will list lines around\n\
+\t   address 20)\n\
+\tline_number1, line_number2 - specify the list range.\n\n\
+\tExamples:\n\
+\tlist s *0x3a -5 5\n\
+\t  will list 11 lines (5 before, 5 after, & 1 at) around addr 3a\n\
+\tlist\n\
+\t  repeat the last list except use the current pc as the reference.\n\
+\tlist l\n\
+\t  will list lines from .lst file around the current pc.\n");
 
   op = cmd_list_options; 
 
diff -ur gpsim-0.20.14.old/cli/cmd_module.cc gpsim-0.20.14/cli/cmd_module.cc
--- gpsim-0.20.14.old/cli/cmd_module.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_module.cc	2003-10-20 11:44:50.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 
 #include "command.h"
@@ -62,33 +62,32 @@
 
   long_doc = string (
 "module [ [load module_type [module_name]] | [lib lib_name] | [list] | \n\
-[[dump | pins] module_name] ] | [set module_name attribute value]\
-\n\tIf no options are specified, then the currently defined module(s)\
-\n\twill be displayed. This is the same as the `module list' command.\
-\n\tThe `module load lib_name' tells gpsim to search for the module\
-\n\tlibrary called `lib_name' and to load it. (Note that the format of\
-\n\tmodule libraries is exactly the same as a Linux shared library. This\
-\n\tmeans that the module library should reside in a path available to\
-\n\tdlopen(). Please see the README.MODULES in the gpsim distribution.\
-\n\tTo instantiate a new module, then type\
-\n\t  module module_type module_name\
-\n\twhere module_type refers to a specific module in a module library\
-\n\tand module_name is the user name assigned to it.\
-\n\tInformation about a module can be displayed by the command\
-\n\t  module module_name [dump | pins]
-\n\twhere module_name is the name that you assigned when the module\
-\n\twas instantiated. The optional dump and pins identifiers specify\
-\n\tthe information you wish to display (dump is the default).\
-\n\n\texamples:
-\n\n\tmodule                      // Display the modules you've already defined.\
-\n\tmodule lib my_mods.so       // Load the module library called my_mods.\
-\n\tmodule list                 // Display the list of modules supported.\
-\n\tmodule load lcd my_lcd      // Create an instance of an 'lcd'\
-\n\tmodule pins my_lcd          // Display the pin states of an instantiated module\
-\n\tmodule load lcd lcd2x20     // Create a new module.\
-\n\tmodule load pullup R1       // and another.\
-\n\tmodule set R1 resistance 10e3 // change an attribute.
-\n");
+[[dump | pins] module_name] ] | [set module_name attribute value]\n\
+\tIf no options are specified, then the currently defined module(s)\n\
+\twill be displayed. This is the same as the `module list' command.\n\
+\tThe `module load lib_name' tells gpsim to search for the module\n\
+\tlibrary called `lib_name' and to load it. (Note that the format of\n\
+\tmodule libraries is exactly the same as a Linux shared library. This\n\
+\tmeans that the module library should reside in a path available to\n\
+\tdlopen(). Please see the README.MODULES in the gpsim distribution.\n\
+\tTo instantiate a new module, then type\n\
+\t  module module_type module_name\n\
+\twhere module_type refers to a specific module in a module library\n\
+\tand module_name is the user name assigned to it.\n\
+\tInformation about a module can be displayed by the command\n\
+\t  module module_name [dump | pins]\n\
+\twhere module_name is the name that you assigned when the module\n\
+\twas instantiated. The optional dump and pins identifiers specify\n\
+\tthe information you wish to display (dump is the default).\n\n\
+\texamples:\n\
+\tmodule                      // Display the modules you've already defined.\n\
+\tmodule lib my_mods.so       // Load the module library called my_mods.\n\
+\tmodule list                 // Display the list of modules supported.\n\
+\tmodule load lcd my_lcd      // Create an instance of an 'lcd'\n\
+\tmodule pins my_lcd          // Display the pin states of an instantiated module\n\
+\tmodule load lcd lcd2x20     // Create a new module.\n\
+\tmodule load pullup R1       // and another.\n\
+\tmodule set R1 resistance 10e3 // change an attribute.\n");
 
   op = cmd_module_options; 
 }
diff -ur gpsim-0.20.14.old/cli/cmd_node.cc gpsim-0.20.14/cli/cmd_node.cc
--- gpsim-0.20.14.old/cli/cmd_node.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_node.cc	2003-10-20 11:26:32.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 
 #include "command.h"
@@ -43,15 +43,14 @@
 
   brief_doc = string("Add or display stimulus nodes");
 
-  long_doc = string ("node [new_node1 new_node2 ...]\
-\n\t If no new_node is specified then all of the nodes that have been\
-\n\tdefined are displayed. If a new_node is specified then it will be\
-\n\tadded to the node list. See the \"attach\" and \"stimulus\" commands\
-\n\tto see how stimuli are added to the nodes.\
-\n\n\texamples:
-\n\n\tnode              // display the node list\
-\n\tnode n1 n2 n3     // create and add 3 new nodes to the list\
-\n");
+  long_doc = string ("node [new_node1 new_node2 ...]\n\
+\t If no new_node is specified then all of the nodes that have been\n\
+\tdefined are displayed. If a new_node is specified then it will be\n\
+\tadded to the node list. See the \"attach\" and \"stimulus\" commands\n\
+\tto see how stimuli are added to the nodes.\n\n\
+\texamples:\n\
+\tnode              // display the node list\n\
+\tnode n1 n2 n3     // create and add 3 new nodes to the list\n");
 
   op = cmd_node_options; 
 }
diff -ur gpsim-0.20.14.old/cli/cmd_processor.cc gpsim-0.20.14/cli/cmd_processor.cc
--- gpsim-0.20.14.old/cli/cmd_processor.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_processor.cc	2003-10-20 11:31:19.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 
 #include "command.h"
@@ -121,7 +121,7 @@
 \n\ttype 'processor list'.  To define a new processor, specify the processor\
 \n\ttype and name. To display the state of the I/O processor, type 'processor\
 \n\tdump' (For now, this will display the pin numbers and their current state.\
-\n\n\texamples:
+\n\n\texamples:\
 \n\n\tprocessor               // Display the processors you've already defined.\
 \n\tprocessor list          // Display the list of processors supported.\
 \n\tprocessor pins          // Display the processor package and pin state\
diff -ur gpsim-0.20.14.old/cli/cmd_set.cc gpsim-0.20.14/cli/cmd_set.cc
--- gpsim-0.20.14.old/cli/cmd_set.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_set.cc	2003-10-20 11:43:51.000000000 -0700
@@ -59,7 +59,7 @@
 
     brief_doc = string("display and control gpsim behavior flags");
 
-    long_doc = string ("set\n
+    long_doc = string ("set\n\
 \twith no options, set will display the state of all of gpsim's\n\
 \tbehavior flags. Use this to determine the flags that may be\n\
 \tmodified.\n\
diff -ur gpsim-0.20.14.old/cli/cmd_stimulus.cc gpsim-0.20.14/cli/cmd_stimulus.cc
--- gpsim-0.20.14.old/cli/cmd_stimulus.cc	2002-01-03 06:19:30.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_stimulus.cc	2003-10-20 11:45:45.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 #include <vector>
 
@@ -95,8 +95,8 @@
     brief_doc = string("Create a stimulus");
 
     long_doc = string ("\nstimulus [[type] options]\n\
-\tstimulus will create a signal that can be tied to an io port.
-\tNote that in most cases it is easier to create a stimulus
+\tstimulus will create a signal that can be tied to an io port.\n\
+\tNote that in most cases it is easier to create a stimulus\n\
 \tfile then to type all this junk by hand.\n\n\
 \t  Supported stimuli:\n\n\
 \tsquare_wave | sqw  [period p] [high_time h] [phase ph] [initial_state i]\n\
@@ -106,18 +106,17 @@
 \t\t  the square wave will be high.\n\
 \t\t  The phase is with respect to the cpu's cycle counter.\n\
 \t\t  The \"port_name\" and \"bit_pos\" describe where the stimulus\n\
-\t\t  will be attached.
-\tasynchronous_stimulus | asy  [period p] [phase ph]  [initial_state i]
+\t\t  will be attached.\n\
+\tasynchronous_stimulus | asy  [period p] [phase ph]  [initial_state i]\n\
 \t  d0 [d1 d2 ... dn] port port_name bit_pos end\n\
-\t\t  creates an asynchronous square wave with a period of \"p\" cpu
+\t\t  creates an asynchronous square wave with a period of \"p\" cpu\n\
 \t\t  cycles.  The phase is with respect to the cpu's cycle counter.\n\
 \t\t  The \"port_name\" and \"bit_pos\" describe where the stimulus\n\
-\t\t  will be attached.
-
-\n\texamples:\n\n\
-\t  stimulus sqw period 200 high_time 20 phase 60 port portb 0 end 
-\t  create a square wave stimulus that repeats every 200 cpu cycles, 
-\t  is high for 20 cpu cycles (and low for 200-20=180 cycles). The 
+\t\t  will be attached.\n\n\
+\texamples:\n\n\
+\t  stimulus sqw period 200 high_time 20 phase 60 port portb 0 end \n\
+\t  create a square wave stimulus that repeats every 200 cpu cycles, \n\
+\t  is high for 20 cpu cycles (and low for 200-20=180 cycles). The \n\
 \t  first rising edge will occur at cycle\n\
 \t  60, the second at 260, . . . Bit 0 of portb will receive the stimulus.\n\
 \n");
diff -ur gpsim-0.20.14.old/cli/cmd_symbol.cc gpsim-0.20.14/cli/cmd_symbol.cc
--- gpsim-0.20.14.old/cli/cmd_symbol.cc	2001-11-27 21:08:43.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_symbol.cc	2003-10-20 11:46:49.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 
 #include "command.h"
@@ -50,7 +50,7 @@
 \n\n\tValid symbol types:\
 \n\t  ioport | iop, constant\
 \n\nExamples:\
-\n\tsymbol            // display the symbol table
+\n\tsymbol            // display the symbol table\
 \n\tsymbol george constant 42  // create a new constant symbol\
 \n\t                           // named george and equal to 42\
 \n");
diff -ur gpsim-0.20.14.old/cli/cmd_trace.cc gpsim-0.20.14/cli/cmd_trace.cc
--- gpsim-0.20.14.old/cli/cmd_trace.cc	2001-12-23 13:03:28.000000000 -0800
+++ gpsim-0.20.14/cli/cmd_trace.cc	2003-10-20 11:47:39.000000000 -0700
@@ -19,8 +19,8 @@
 Boston, MA 02111-1307, USA.  */
 
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 
 #include "command.h"
@@ -52,8 +52,7 @@
     long_doc = string ("\ntrace [dump_amount]\n\
 \ttrace will print out the most recent \"dump_amount\" traces.\n\
 \tIf no dump_amount is specified, then the entire trace buffer\n\
-\twill be displayed.
-");
+\twill be displayed.\n");
 
   op = cmd_trace_options; 
 }
diff -ur gpsim-0.20.14.old/cli/parse.cc gpsim-0.20.14/cli/parse.cc
--- gpsim-0.20.14.old/cli/parse.cc	2002-01-04 15:40:25.000000000 -0800
+++ gpsim-0.20.14/cli/parse.cc	2003-10-20 11:12:43.000000000 -0700
@@ -1,46 +1,137 @@
+/* A Bison parser, made by GNU Bison 1.875.  */
 
-/*  A Bison parser, made from parse.yy
-    by GNU Bison version 1.28  */
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
 
-#define YYBISON 1  /* Identify Bison output.  */
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ABORT = 258,
+     ATTACH = 259,
+     BREAK = 260,
+     BUS = 261,
+     CLEAR = 262,
+     DISASSEMBLE = 263,
+     DUMP = 264,
+     FREQUENCY = 265,
+     HELP = 266,
+     LOAD = 267,
+     LOG = 268,
+     LIST = 269,
+     NODE = 270,
+     MODULE = 271,
+     PROCESSOR = 272,
+     QUIT = 273,
+     RESET = 274,
+     RUN = 275,
+     SET = 276,
+     STEP = 277,
+     STIMULUS = 278,
+     SYMBOL = 279,
+     TRACE = 280,
+     gpsim_VERSION = 281,
+     X = 282,
+     END_OF_COMMAND = 283,
+     IGNORED = 284,
+     SPANNING_LINES = 285,
+     STRING = 286,
+     INDIRECT = 287,
+     END_OF_INPUT = 288,
+     BIT_FLAG = 289,
+     NUMERIC_OPTION = 290,
+     STRING_OPTION = 291,
+     NUMBER = 292,
+     FLOAT_NUMBER = 293
+   };
+#endif
+#define ABORT 258
+#define ATTACH 259
+#define BREAK 260
+#define BUS 261
+#define CLEAR 262
+#define DISASSEMBLE 263
+#define DUMP 264
+#define FREQUENCY 265
+#define HELP 266
+#define LOAD 267
+#define LOG 268
+#define LIST 269
+#define NODE 270
+#define MODULE 271
+#define PROCESSOR 272
+#define QUIT 273
+#define RESET 274
+#define RUN 275
+#define SET 276
+#define STEP 277
+#define STIMULUS 278
+#define SYMBOL 279
+#define TRACE 280
+#define gpsim_VERSION 281
+#define X 282
+#define END_OF_COMMAND 283
+#define IGNORED 284
+#define SPANNING_LINES 285
+#define STRING 286
+#define INDIRECT 287
+#define END_OF_INPUT 288
+#define BIT_FLAG 289
+#define NUMERIC_OPTION 290
+#define STRING_OPTION 291
+#define NUMBER 292
+#define FLOAT_NUMBER 293
 
-#define	ABORT	257
-#define	ATTACH	258
-#define	BREAK	259
-#define	BUS	260
-#define	CLEAR	261
-#define	DISASSEMBLE	262
-#define	DUMP	263
-#define	FREQUENCY	264
-#define	HELP	265
-#define	LOAD	266
-#define	LOG	267
-#define	LIST	268
-#define	NODE	269
-#define	MODULE	270
-#define	PROCESSOR	271
-#define	QUIT	272
-#define	RESET	273
-#define	RUN	274
-#define	SET	275
-#define	STEP	276
-#define	STIMULUS	277
-#define	SYMBOL	278
-#define	TRACE	279
-#define	gpsim_VERSION	280
-#define	X	281
-#define	END_OF_COMMAND	282
-#define	IGNORED	283
-#define	SPANNING_LINES	284
-#define	STRING	285
-#define	INDIRECT	286
-#define	END_OF_INPUT	287
-#define	BIT_FLAG	288
-#define	NUMERIC_OPTION	289
-#define	STRING_OPTION	290
-#define	NUMBER	291
-#define	FLOAT_NUMBER	292
 
+
+
+/* Copy the first part of user declarations.  */
 #line 2 "parse.yy"
 
 /* Parser for gpsim
@@ -64,12 +155,13 @@
 Boston, MA 02111-1307, USA.  */
 
 #include <stdio.h>
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include <string>
 #include <vector>
 #include <unistd.h>
 #include <glib.h>
+using namespace std;
 
 #include "misc.h"
 #include "command.h"
@@ -120,8 +212,23 @@
 void free_char_list(char_list *);
 
 
-#line 83 "parse.yy"
-typedef union {
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+#line 84 "parse.yy"
+typedef union YYSTYPE {
   guint32              i;
   guint64             li;
   float                f;
@@ -131,562 +238,850 @@
   cmd_options_float *cof;
   cmd_options_str   *cos;
 } YYSTYPE;
-#ifndef YYDEBUG
-#define YYDEBUG 1
-#endif
-
-#include <stdio.h>
+/* Line 191 of yacc.c.  */
+#line 242 "y.tab.c"
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 214 of yacc.c.  */
+#line 254 "y.tab.c"
+
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC malloc
+#  define YYSTACK_FREE free
+# endif
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
 
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
 #endif
-#endif
-
 
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short yysigned_char;
+#endif
 
-#define	YYFINAL		139
-#define	YYFLAG		-32768
-#define	YYNTBASE	39
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 292 ? yytranslate[x] : 75)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
-    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,
-    37,    38
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  98
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   122
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  39
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  37
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  129
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  139
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   293
+
+#define YYTRANSLATE(YYX) 						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38
 };
 
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     2,     4,     6,     8,    10,    12,    14,    16,    18,
-    20,    22,    24,    26,    28,    30,    32,    34,    36,    38,
-    40,    42,    44,    46,    48,    50,    52,    54,    56,    58,
-    60,    62,    65,    67,    70,    74,    79,    85,    89,    94,
-   100,   102,   105,   108,   110,   113,   117,   119,   122,   124,
-   127,   129,   132,   134,   137,   140,   144,   146,   149,   152,
-   156,   161,   167,   171,   176,   182,   184,   187,   189,   192,
-   195,   199,   204,   209,   214,   216,   219,   222,   226,   228,
-   231,   233,   235,   237,   240,   244,   247,   249,   252,   255,
-   257,   260,   264,   267,   271,   274,   277,   281,   282,   285,
-   288,   291,   294,   297,   300,   303,   306,   308,   311,   316,
-   318,   321,   324,   327,   330,   332,   334,   337,   341,   344,
-   348,   351,   353,   355,   358,   361,   364,   366
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned short yyprhs[] =
+{
+       0,     0,     3,     5,     7,     9,    11,    13,    15,    17,
+      19,    21,    23,    25,    27,    29,    31,    33,    35,    37,
+      39,    41,    43,    45,    47,    49,    51,    53,    55,    57,
+      59,    61,    63,    65,    68,    70,    73,    77,    82,    88,
+      92,    97,   103,   105,   108,   111,   113,   116,   120,   122,
+     125,   127,   130,   132,   135,   137,   140,   143,   147,   149,
+     152,   155,   159,   164,   170,   174,   179,   185,   187,   190,
+     192,   195,   198,   202,   207,   212,   217,   219,   222,   225,
+     229,   231,   234,   236,   238,   240,   243,   247,   250,   252,
+     255,   258,   260,   263,   267,   270,   274,   277,   280,   284,
+     285,   288,   291,   294,   297,   300,   303,   306,   309,   311,
+     314,   319,   321,   324,   327,   330,   333,   335,   337,   340,
+     344,   347,   351,   354,   356,   358,   361,   364,   367,   369
 };
 
-static const short yyrhs[] = {    40,
-     0,    42,     0,    43,     0,    44,     0,    45,     0,    46,
-     0,    47,     0,    48,     0,    49,     0,    50,     0,    51,
-     0,    53,     0,    52,     0,    54,     0,    55,     0,    56,
-     0,    57,     0,    58,     0,    59,     0,    60,     0,    61,
-     0,    62,     0,    64,     0,    65,     0,    66,     0,    67,
-     0,    41,     0,    33,     0,    29,     0,    30,     0,     3,
-     0,     4,    74,     0,     5,     0,     5,    70,     0,     5,
-    70,    69,     0,     5,    70,    69,    37,     0,     5,    70,
-    69,    37,    37,     0,     5,    70,    31,     0,     5,    70,
-    31,    37,     0,     5,    70,    31,    37,    37,     0,     6,
-     0,     6,    74,     0,     7,    37,     0,     8,     0,     8,
-    37,     0,     8,    37,    37,     0,     9,     0,     9,    70,
-     0,    10,     0,    10,    37,     0,    11,     0,    11,    31,
-     0,    14,     0,    14,    68,     0,    14,    70,     0,    12,
-    70,    31,     0,    13,     0,    13,    37,     0,    13,    70,
-     0,    13,    70,    31,     0,    13,    70,    31,    37,     0,
-    13,    70,    31,    37,    37,     0,    13,    70,    37,     0,
-    13,    70,    37,    37,     0,    13,    70,    37,    37,    37,
-     0,    15,     0,    15,    74,     0,    16,     0,    16,    70,
-     0,    16,    73,     0,    16,    73,    31,     0,    16,    73,
-    31,    31,     0,    16,    73,    31,    37,     0,    16,    73,
-    31,    38,     0,    17,     0,    17,    70,     0,    17,    31,
-     0,    17,    31,    31,     0,    18,     0,    18,    37,     0,
-    19,     0,    20,     0,    21,     0,    21,    70,     0,    21,
-    70,    37,     0,    21,    71,     0,    22,     0,    22,    37,
-     0,    22,    70,     0,    23,     0,    23,    37,     0,    23,
-    63,    30,     0,    23,    30,     0,    23,    63,    29,     0,
-    23,    29,     0,    23,    38,     0,    23,    63,    28,     0,
-     0,    63,    30,     0,    63,    29,     0,    63,    70,     0,
-    63,    71,     0,    63,    72,     0,    63,    73,     0,    63,
-    37,     0,    63,    38,     0,    24,     0,    24,    31,     0,
-    24,    31,    31,    37,     0,    25,     0,    25,    37,     0,
-    25,    71,     0,    25,    73,     0,    25,    70,     0,    26,
-     0,    27,     0,    27,    37,     0,    27,    69,    37,     0,
-    27,    31,     0,    27,    31,    37,     0,    32,    69,     0,
-    37,     0,    34,     0,    35,    37,     0,    35,    38,     0,
-    36,    31,     0,    31,     0,    74,    31,     0
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      40,     0,    -1,    41,    -1,    43,    -1,    44,    -1,    45,
+      -1,    46,    -1,    47,    -1,    48,    -1,    49,    -1,    50,
+      -1,    51,    -1,    52,    -1,    54,    -1,    53,    -1,    55,
+      -1,    56,    -1,    57,    -1,    58,    -1,    59,    -1,    60,
+      -1,    61,    -1,    62,    -1,    63,    -1,    65,    -1,    66,
+      -1,    67,    -1,    68,    -1,    42,    -1,    33,    -1,    29,
+      -1,    30,    -1,     3,    -1,     4,    75,    -1,     5,    -1,
+       5,    71,    -1,     5,    71,    70,    -1,     5,    71,    70,
+      37,    -1,     5,    71,    70,    37,    37,    -1,     5,    71,
+      31,    -1,     5,    71,    31,    37,    -1,     5,    71,    31,
+      37,    37,    -1,     6,    -1,     6,    75,    -1,     7,    37,
+      -1,     8,    -1,     8,    37,    -1,     8,    37,    37,    -1,
+       9,    -1,     9,    71,    -1,    10,    -1,    10,    37,    -1,
+      11,    -1,    11,    31,    -1,    14,    -1,    14,    69,    -1,
+      14,    71,    -1,    12,    71,    31,    -1,    13,    -1,    13,
+      37,    -1,    13,    71,    -1,    13,    71,    31,    -1,    13,
+      71,    31,    37,    -1,    13,    71,    31,    37,    37,    -1,
+      13,    71,    37,    -1,    13,    71,    37,    37,    -1,    13,
+      71,    37,    37,    37,    -1,    15,    -1,    15,    75,    -1,
+      16,    -1,    16,    71,    -1,    16,    74,    -1,    16,    74,
+      31,    -1,    16,    74,    31,    31,    -1,    16,    74,    31,
+      37,    -1,    16,    74,    31,    38,    -1,    17,    -1,    17,
+      71,    -1,    17,    31,    -1,    17,    31,    31,    -1,    18,
+      -1,    18,    37,    -1,    19,    -1,    20,    -1,    21,    -1,
+      21,    71,    -1,    21,    71,    37,    -1,    21,    72,    -1,
+      22,    -1,    22,    37,    -1,    22,    71,    -1,    23,    -1,
+      23,    37,    -1,    23,    64,    30,    -1,    23,    30,    -1,
+      23,    64,    29,    -1,    23,    29,    -1,    23,    38,    -1,
+      23,    64,    28,    -1,    -1,    64,    30,    -1,    64,    29,
+      -1,    64,    71,    -1,    64,    72,    -1,    64,    73,    -1,
+      64,    74,    -1,    64,    37,    -1,    64,    38,    -1,    24,
+      -1,    24,    31,    -1,    24,    31,    31,    37,    -1,    25,
+      -1,    25,    37,    -1,    25,    72,    -1,    25,    74,    -1,
+      25,    71,    -1,    26,    -1,    27,    -1,    27,    37,    -1,
+      27,    70,    37,    -1,    27,    31,    -1,    27,    31,    37,
+      -1,    32,    70,    -1,    37,    -1,    34,    -1,    35,    37,
+      -1,    35,    38,    -1,    36,    31,    -1,    31,    -1,    75,
+      31,    -1
 };
 
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-   150,   151,   152,   153,   154,   155,   156,   157,   158,   159,
-   160,   161,   162,   163,   164,   165,   166,   167,   168,   169,
-   170,   171,   172,   173,   174,   175,   176,   177,   189,   206,
-   216,   223,   234,   236,   241,   245,   248,   252,   256,   260,
-   266,   270,   279,   283,   285,   287,   291,   293,   297,   299,
-   303,   305,   309,   311,   313,   321,   334,   338,   342,   346,
-   350,   354,   358,   362,   366,   372,   376,   385,   390,   392,
-   399,   407,   415,   423,   444,   446,   448,   450,   458,   464,
-   472,   476,   480,   484,   488,   492,   498,   500,   502,   506,
-   513,   520,   527,   534,   541,   549,   557,   567,   573,   580,
-   586,   592,   598,   604,   610,   616,   624,   628,   632,   639,
-   643,   647,   651,   655,   661,   667,   671,   675,   679,   683,
-   694,   702,   709,   716,   727,   738,   749,   758
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned short yyrline[] =
+{
+       0,   151,   151,   152,   153,   154,   155,   156,   157,   158,
+     159,   160,   161,   162,   163,   164,   165,   166,   167,   168,
+     169,   170,   171,   172,   173,   174,   175,   176,   177,   178,
+     190,   207,   217,   224,   235,   237,   242,   246,   249,   253,
+     257,   261,   267,   271,   280,   284,   286,   288,   292,   294,
+     298,   300,   304,   306,   310,   312,   314,   322,   335,   339,
+     343,   347,   351,   355,   359,   363,   367,   373,   377,   386,
+     391,   393,   400,   408,   416,   424,   445,   447,   449,   451,
+     459,   465,   473,   477,   481,   485,   489,   493,   499,   501,
+     503,   507,   514,   521,   528,   535,   542,   550,   558,   569,
+     574,   581,   587,   593,   599,   605,   611,   617,   625,   629,
+     633,   640,   644,   648,   652,   656,   662,   668,   672,   676,
+     680,   684,   695,   703,   710,   717,   728,   739,   750,   759
 };
 #endif
 
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","ABORT",
-"ATTACH","BREAK","BUS","CLEAR","DISASSEMBLE","DUMP","FREQUENCY","HELP","LOAD",
-"LOG","LIST","NODE","MODULE","PROCESSOR","QUIT","RESET","RUN","SET","STEP","STIMULUS",
-"SYMBOL","TRACE","gpsim_VERSION","X","END_OF_COMMAND","IGNORED","SPANNING_LINES",
-"STRING","INDIRECT","END_OF_INPUT","BIT_FLAG","NUMERIC_OPTION","STRING_OPTION",
-"NUMBER","FLOAT_NUMBER","cmd","ignored","spanning_lines","aborting","attach_cmd",
-"break_cmd","bus_cmd","clear_cmd","disassemble_cmd","dump_cmd","frequency_cmd",
-"help_cmd","list_cmd","load_cmd","log_cmd","node_cmd","module_cmd","processor_cmd",
-"quit_cmd","reset_cmd","run_cmd","set_cmd","step_cmd","stimulus_cmd","stimulus_opt",
-"symbol_cmd","trace_cmd","version_cmd","x_cmd","indirect","_register","bit_flag",
-"numeric_option","numeric_float_option","string_option","string_list", NULL
+#if YYDEBUG || YYERROR_VERBOSE
+/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "ABORT", "ATTACH", "BREAK", "BUS", "CLEAR", 
+  "DISASSEMBLE", "DUMP", "FREQUENCY", "HELP", "LOAD", "LOG", "LIST", 
+  "NODE", "MODULE", "PROCESSOR", "QUIT", "RESET", "RUN", "SET", "STEP", 
+  "STIMULUS", "SYMBOL", "TRACE", "gpsim_VERSION", "X", "END_OF_COMMAND", 
+  "IGNORED", "SPANNING_LINES", "STRING", "INDIRECT", "END_OF_INPUT", 
+  "BIT_FLAG", "NUMERIC_OPTION", "STRING_OPTION", "NUMBER", "FLOAT_NUMBER", 
+  "$accept", "cmd", "ignored", "spanning_lines", "aborting", "attach_cmd", 
+  "break_cmd", "bus_cmd", "clear_cmd", "disassemble_cmd", "dump_cmd", 
+  "frequency_cmd", "help_cmd", "list_cmd", "load_cmd", "log_cmd", 
+  "node_cmd", "module_cmd", "processor_cmd", "quit_cmd", "reset_cmd", 
+  "run_cmd", "set_cmd", "step_cmd", "stimulus_cmd", "stimulus_opt", 
+  "symbol_cmd", "trace_cmd", "version_cmd", "x_cmd", "indirect", 
+  "_register", "bit_flag", "numeric_option", "numeric_float_option", 
+  "string_option", "string_list", 0
 };
 #endif
 
-static const short yyr1[] = {     0,
-    39,    39,    39,    39,    39,    39,    39,    39,    39,    39,
-    39,    39,    39,    39,    39,    39,    39,    39,    39,    39,
-    39,    39,    39,    39,    39,    39,    39,    39,    40,    41,
-    42,    43,    44,    44,    44,    44,    44,    44,    44,    44,
-    45,    45,    46,    47,    47,    47,    48,    48,    49,    49,
-    50,    50,    51,    51,    51,    52,    53,    53,    53,    53,
-    53,    53,    53,    53,    53,    54,    54,    55,    55,    55,
-    55,    55,    55,    55,    56,    56,    56,    56,    57,    57,
-    58,    59,    60,    60,    60,    60,    61,    61,    61,    62,
-    62,    62,    62,    62,    62,    62,    62,    63,    63,    63,
-    63,    63,    63,    63,    63,    63,    64,    64,    64,    65,
-    65,    65,    65,    65,    66,    67,    67,    67,    67,    67,
-    68,    69,    70,    71,    72,    73,    74,    74
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293
 };
+# endif
 
-static const short yyr2[] = {     0,
-     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
-     1,     2,     1,     2,     3,     4,     5,     3,     4,     5,
-     1,     2,     2,     1,     2,     3,     1,     2,     1,     2,
-     1,     2,     1,     2,     2,     3,     1,     2,     2,     3,
-     4,     5,     3,     4,     5,     1,     2,     1,     2,     2,
-     3,     4,     4,     4,     1,     2,     2,     3,     1,     2,
-     1,     1,     1,     2,     3,     2,     1,     2,     2,     1,
-     2,     3,     2,     3,     2,     2,     3,     0,     2,     2,
-     2,     2,     2,     2,     2,     2,     1,     2,     4,     1,
-     2,     2,     2,     2,     1,     1,     2,     3,     2,     3,
-     2,     1,     1,     2,     2,     2,     1,     2
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    39,    40,    40,    40,    40,    40,    40,    40,    40,
+      40,    40,    40,    40,    40,    40,    40,    40,    40,    40,
+      40,    40,    40,    40,    40,    40,    40,    40,    40,    40,
+      41,    42,    43,    44,    45,    45,    45,    45,    45,    45,
+      45,    45,    46,    46,    47,    48,    48,    48,    49,    49,
+      50,    50,    51,    51,    52,    52,    52,    53,    54,    54,
+      54,    54,    54,    54,    54,    54,    54,    55,    55,    56,
+      56,    56,    56,    56,    56,    56,    57,    57,    57,    57,
+      58,    58,    59,    60,    61,    61,    61,    61,    62,    62,
+      62,    63,    63,    63,    63,    63,    63,    63,    63,    64,
+      64,    64,    64,    64,    64,    64,    64,    64,    65,    65,
+      65,    66,    66,    66,    66,    66,    67,    68,    68,    68,
+      68,    68,    69,    70,    71,    72,    73,    74,    75,    75
 };
 
-static const short yydefact[] = {     0,
-    31,     0,    33,    41,     0,    44,    47,    49,    51,     0,
-    57,    53,    66,    68,    75,    79,    81,    82,    83,    87,
-    98,   107,   110,   115,   116,    29,    30,    28,     1,    27,
-     2,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-    13,    12,    14,    15,    16,    17,    18,    19,    20,    21,
-    22,    23,    24,    25,    26,   127,    32,   123,    34,    42,
-    43,    45,    48,    50,    52,     0,    58,    59,     0,    54,
-    55,    67,     0,    69,    70,    77,    76,    80,     0,    84,
-    86,    88,    89,    95,    93,    91,    96,     0,   108,   111,
-   114,   112,   113,   119,   117,     0,   128,    38,   122,    35,
-    46,    56,    60,    63,   121,   126,    71,    78,   124,    85,
-    97,   100,    99,     0,   105,   106,   101,   102,   103,   104,
-     0,   120,   118,    39,    36,    61,    64,    72,    73,    74,
-   125,   109,    40,    37,    62,    65,     0,     0,     0
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     2,     1,     2,     3,     4,     5,     3,
+       4,     5,     1,     2,     2,     1,     2,     3,     1,     2,
+       1,     2,     1,     2,     1,     2,     2,     3,     1,     2,
+       2,     3,     4,     5,     3,     4,     5,     1,     2,     1,
+       2,     2,     3,     4,     4,     4,     1,     2,     2,     3,
+       1,     2,     1,     1,     1,     2,     3,     2,     1,     2,
+       2,     1,     2,     3,     2,     3,     2,     2,     3,     0,
+       2,     2,     2,     2,     2,     2,     2,     2,     1,     2,
+       4,     1,     2,     2,     2,     2,     1,     1,     2,     3,
+       2,     3,     2,     1,     1,     2,     2,     2,     1,     2
 };
 
-static const short yydefgoto[] = {   137,
-    29,    30,    31,    32,    33,    34,    35,    36,    37,    38,
-    39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
-    49,    50,    51,    88,    52,    53,    54,    55,    70,    96,
-    59,    81,   119,    75,    57
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+       0,    32,     0,    34,    42,     0,    45,    48,    50,    52,
+       0,    58,    54,    67,    69,    76,    80,    82,    83,    84,
+      88,    99,   108,   111,   116,   117,    30,    31,    29,     0,
+       2,    28,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    14,    13,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,   128,    33,   124,
+      35,    43,    44,    46,    49,    51,    53,     0,    59,    60,
+       0,    55,    56,    68,     0,    70,    71,    78,    77,    81,
+       0,    85,    87,    89,    90,    96,    94,    92,    97,     0,
+     109,   112,   115,   113,   114,   120,   118,     0,     1,   129,
+      39,   123,    36,    47,    57,    61,    64,   122,   127,    72,
+      79,   125,    86,    98,   101,   100,     0,   106,   107,   102,
+     103,   104,   105,     0,   121,   119,    40,    37,    62,    65,
+      73,    74,    75,   126,   110,    41,    38,    63,    66
 };
 
-static const short yypact[] = {    79,
--32768,   -16,   -25,   -16,    -3,     4,   -25,    14,    24,   -25,
-   -23,     8,   -16,    20,    18,    25,-32768,-32768,    23,    16,
-     6,    30,    11,-32768,     0,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,    32,-32768,     1,    32,
--32768,    27,-32768,-32768,-32768,    34,-32768,     2,    31,-32768,
--32768,    32,    38,-32768,    39,    40,-32768,-32768,    35,    36,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,   -11,    43,-32768,
--32768,-32768,-32768,    41,    42,    70,-32768,    73,-32768,    74,
--32768,-32768,    76,    77,-32768,-32768,    -9,-32768,-32768,-32768,
--32768,    75,    80,    22,-32768,-32768,-32768,-32768,-32768,-32768,
-    78,-32768,-32768,    81,    82,    83,    84,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,   116,   117,-32768
+/* YYDEFGOTO[NTERM-NUM]. */
+static const yysigned_char yydefgoto[] =
+{
+      -1,    29,    30,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    41,    42,    43,    44,    45,    46,    47,
+      48,    49,    50,    51,    52,    89,    53,    54,    55,    56,
+      71,    97,    60,    82,   121,    76,    58
 };
 
-static const short yypgoto[] = {-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
--32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,   -49,
-    -7,   -22,-32768,   -21,    17
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -51
+static const yysigned_char yypact[] =
+{
+      80,   -51,   -16,   -25,   -16,    -3,     4,   -25,    14,    24,
+     -25,   -23,     8,   -16,    20,    18,    25,   -51,   -51,    23,
+      16,     6,    30,    11,   -51,     0,   -51,   -51,   -51,    63,
+     -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,
+     -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,
+     -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,    33,   -51,
+       1,    33,   -51,    28,   -51,   -51,   -51,    35,   -51,     2,
+      32,   -51,   -51,    33,    39,   -51,    40,    41,   -51,   -51,
+      36,    37,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -11,
+      44,   -51,   -51,   -51,   -51,    42,    43,    71,   -51,   -51,
+      74,   -51,    75,   -51,   -51,    77,    78,   -51,   -51,    -9,
+     -51,   -51,   -51,   -51,    76,    81,    22,   -51,   -51,   -51,
+     -51,   -51,   -51,    79,   -51,   -51,    82,    83,    84,    85,
+     -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51
 };
 
-
-#define	YYLAST		121
-
-
-static const short yytable[] = {    63,
-    92,    93,    66,    68,    71,   -90,    74,    77,    58,   100,
-    58,    80,    83,    67,    56,    91,   111,   112,   113,   105,
-    60,   128,    58,   114,    73,   115,   116,   129,   130,    72,
-    94,    98,   103,    61,    84,    85,    95,    99,   104,    69,
-    62,    58,    86,    87,    58,    79,    73,    90,    76,    58,
-    64,    58,    82,    58,    65,    73,    58,    79,   109,   131,
-    89,    78,    97,   101,   102,   118,   120,    99,   106,   107,
-   108,   109,   110,   121,   -94,     0,     0,   122,  -122,   -92,
-   117,     1,     2,     3,     4,     5,     6,     7,     8,     9,
-    10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
-    20,    21,    22,    23,    24,    25,   123,    26,    27,   124,
-   125,    28,   126,   127,   132,   138,   139,   133,   134,   135,
-   136
+/* YYPGOTO[NTERM-NUM].  */
+static const yysigned_char yypgoto[] =
+{
+     -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,
+     -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,
+     -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,   -51,
+     -51,   -50,    -7,   -22,   -51,   -21,    17
 };
 
-static const short yycheck[] = {     7,
-    23,    23,    10,    11,    12,     0,    14,    15,    34,    59,
-    34,    19,    20,    37,    31,    23,    28,    29,    30,    69,
-     4,    31,    34,    35,    36,    37,    38,    37,    38,    13,
-    31,    31,    31,    37,    29,    30,    37,    37,    37,    32,
-    37,    34,    37,    38,    34,    35,    36,    37,    31,    34,
-    37,    34,    37,    34,    31,    36,    34,    35,    37,    38,
-    31,    37,    31,    37,    31,    88,    88,    37,    31,    31,
-    31,    37,    37,    31,     0,    -1,    -1,    37,    37,     0,
-    88,     3,     4,     5,     6,     7,     8,     9,    10,    11,
-    12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
-    22,    23,    24,    25,    26,    27,    37,    29,    30,    37,
-    37,    33,    37,    37,    37,     0,     0,    37,    37,    37,
-    37
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -124
+static const short yytable[] =
+{
+      64,    93,    94,    67,    69,    72,   -91,    75,    78,    59,
+     102,    59,    81,    84,    68,    57,    92,   113,   114,   115,
+     107,    61,   130,    59,   116,    74,   117,   118,   131,   132,
+      73,    95,   100,   105,    62,    85,    86,    96,   101,   106,
+      70,    63,    59,    87,    88,    59,    80,    74,    91,    77,
+      59,    65,    59,    83,    59,    66,    74,    59,    80,   111,
+     133,    90,    79,    98,    99,   103,   104,   120,   122,   101,
+     108,   109,   110,   111,   112,   123,   -95,     0,     0,   124,
+    -123,   -93,   119,     1,     2,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,   125,    26,
+      27,   126,   127,    28,   128,   129,   134,     0,     0,   135,
+     136,   137,   138
 };
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/lib/bison.simple"
-/* This file comes from bison-1.28.  */
-
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
 
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+static const yysigned_char yycheck[] =
+{
+       7,    23,    23,    10,    11,    12,     0,    14,    15,    34,
+      60,    34,    19,    20,    37,    31,    23,    28,    29,    30,
+      70,     4,    31,    34,    35,    36,    37,    38,    37,    38,
+      13,    31,    31,    31,    37,    29,    30,    37,    37,    37,
+      32,    37,    34,    37,    38,    34,    35,    36,    37,    31,
+      34,    37,    34,    37,    34,    31,    36,    34,    35,    37,
+      38,    31,    37,     0,    31,    37,    31,    89,    89,    37,
+      31,    31,    31,    37,    37,    31,     0,    -1,    -1,    37,
+      37,     0,    89,     3,     4,     5,     6,     7,     8,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    37,    29,
+      30,    37,    37,    33,    37,    37,    37,    -1,    -1,    37,
+      37,    37,    37
+};
 
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    29,    30,    33,    40,
+      41,    42,    43,    44,    45,    46,    47,    48,    49,    50,
+      51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
+      61,    62,    63,    65,    66,    67,    68,    31,    75,    34,
+      71,    75,    37,    37,    71,    37,    31,    71,    37,    71,
+      32,    69,    71,    75,    36,    71,    74,    31,    71,    37,
+      35,    71,    72,    37,    71,    29,    30,    37,    38,    64,
+      31,    37,    71,    72,    74,    31,    37,    70,     0,    31,
+      31,    37,    70,    37,    31,    31,    37,    70,    31,    31,
+      31,    37,    37,    28,    29,    30,    35,    37,    38,    71,
+      72,    73,    74,    31,    37,    37,    37,    37,    37,    37,
+      31,    37,    38,    38,    37,    37,    37,    37,    37
+};
 
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
 #endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
+#define YYEMPTY		(-2)
 #define YYEOF		0
+
 #define YYACCEPT	goto yyacceptlab
-#define YYABORT 	goto yyabortlab
+#define YYABORT		goto yyabortlab
 #define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
+
 #define YYFAIL		goto yyerrlab
+
 #define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
+
+#define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
       YYPOPSTACK;						\
       goto yybackup;						\
     }								\
   else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+    { 								\
+      yyerror ("syntax error: cannot back up");\
+      YYERROR;							\
+    }								\
 while (0)
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).  */
 
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)         \
+  Current.first_line   = Rhs[1].first_line;      \
+  Current.first_column = Rhs[1].first_column;    \
+  Current.last_line    = Rhs[N].last_line;       \
+  Current.last_column  = Rhs[N].last_column;
 #endif
-#else /* not YYLSP_NEEDED */
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
 #ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+# define YYLEX yylex (YYLEX_PARAM)
 #else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
+# define YYLEX yylex ()
 #endif
 
-/* If nonreentrant, generate the variables here */
+/* Enable debugging if requested.  */
+#if YYDEBUG
 
-#ifndef YYPURE
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+# define YYDSYMPRINT(Args)			\
+do {						\
+  if (yydebug)					\
+    yysymprint Args;				\
+} while (0)
+
+# define YYDSYMPRINTF(Title, Token, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr, 					\
+                  Token, Value);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
 
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (cinluded).                                                   |
+`------------------------------------------------------------------*/
 
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_stack_print (short *bottom, short *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    short *bottom;
+    short *top;
 #endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
 
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
 
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_reduce_print (int yyrule)
+#else
+static void
+yy_reduce_print (yyrule)
+    int yyrule;
 #endif
+{
+  int yyi;
+  unsigned int yylineno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
+             yyrule - 1, yylineno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
+  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YYDSYMPRINT(Args)
+# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
 
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
 
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
+# define YYINITDEPTH 200
 #endif
 
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
 
 #if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
+# undef YYMAXDEPTH
 #endif
 
 #ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
+# define YYMAXDEPTH 10000
 #endif
+
 
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
 
-  while (i-- > 0)
-    *t++ = *f++;
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
 }
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+#endif /* !YYERROR_VERBOSE */
 
-#else /* __cplusplus */
+
+
+#if YYDEBUG
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
+#else
 static void
-__yy_memcpy (char *to, char *from, unsigned int count)
+yysymprint (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
 {
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (yytype < YYNTOKENS)
+    {
+      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+# ifdef YYPRINT
+      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+    }
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
 
-  while (i-- > 0)
-    *t++ = *f++;
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+  YYFPRINTF (yyoutput, ")");
 }
 
+#endif /* ! YYDEBUG */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yydestruct (int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yytype, yyvaluep)
+    int yytype;
+    YYSTYPE *yyvaluep;
 #endif
-#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  switch (yytype)
+    {
+
+      default:
+        break;
+    }
+}
 
-#line 217 "/usr/lib/bison.simple"
 
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
+/* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM);
+# else
+int yyparse ();
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
 
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
 #ifdef YYPARSE_PARAM
-int yyparse (void *);
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM)
+# else
+int yyparse (YYPARSE_PARAM)
+  void *YYPARSE_PARAM;
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int
+yyparse (void)
 #else
-int yyparse (void);
+int
+yyparse ()
+
 #endif
 #endif
-
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
 {
+  
   register int yystate;
   register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
   register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
 
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  register YYSTYPE *yyvsp;
 
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
 
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
 
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
 #define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
 
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
+  YYSIZE_T yystacksize = YYINITDEPTH;
 
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
 
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
 
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
   int yylen;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
+  YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
@@ -698,110 +1093,96 @@
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
 
-  yyssp = yyss - 1;
+  yyssp = yyss;
   yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
 
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
+  goto yysetstate;
 
-  *++yyssp = yystate;
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
 
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
+ yysetstate:
+  *yyssp = yystate;
 
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
       /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
+      YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
 #else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
       /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyoverflowlab;
       yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
+      if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
 #endif /* no yyoverflow */
 
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
 
-      if (yyssp >= yyss + yystacksize - 1)
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
 	YYABORT;
     }
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   goto yybackup;
- yybackup:
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
 
 /* Do appropriate processing given the current state.  */
 /* Read a lookahead token if we need one and don't already have one.  */
@@ -810,135 +1191,99 @@
   /* First try to decide what to do without reference to lookahead token.  */
 
   yyn = yypact[yystate];
-  if (yyn == YYFLAG)
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
   if (yychar == YYEMPTY)
     {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
+      YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
+  if (yychar <= YYEOF)
     {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
+      yytoken = YYTRANSLATE (yychar);
+      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
-
   yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
+  if (yyn <= 0)
     {
-      if (yyn == YYFLAG)
+      if (yyn == 0 || yyn == YYTABLE_NINF)
 	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrlab;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
   /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
+  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
 
   /* Discard the token being shifted unless it is eof.  */
   if (yychar != YYEOF)
     yychar = YYEMPTY;
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
 
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
 
   yystate = yyn;
   goto yynewstate;
 
-/* Do the default action for the current state.  */
-yydefault:
 
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
+  goto yyreduce;
+
 
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
 
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
 
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
 
-  switch (yyn) {
 
-case 28:
-#line 178 "parse.yy"
-{
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 29:
+#line 179 "parse.yy"
+    {
        if((verbose&2) && DEBUG_PARSER)
          cout << "got an END_OF_INPUT\n";
         /* If we're processing a command file then quit parsing 
@@ -946,11 +1291,12 @@
        if(Gcmd_file_ref_count)
        	 quit_parse = 1;
        YYABORT;
-     ;
-    break;}
-case 29:
-#line 190 "parse.yy"
-{
+     }
+    break;
+
+  case 30:
+#line 191 "parse.yy"
+    {
             //if(parser_warnings || (verbose & 2 ))
             if((verbose & 2) && DEBUG_PARSER)
               cout << "parser is ignoring input\n";
@@ -963,157 +1309,184 @@
             } else {
 	      YYACCEPT;
             }
-          ;
-    break;}
-case 30:
-#line 207 "parse.yy"
-{
+          }
+    break;
+
+  case 31:
+#line 208 "parse.yy"
+    {
             if((verbose) && DEBUG_PARSER)
               cout << "parser is spanning lines\n";
 
             parser_spanning_lines = 1;
 	    YYACCEPT;
-          ;
-    break;}
-case 31:
-#line 217 "parse.yy"
-{
+          }
+    break;
+
+  case 32:
+#line 218 "parse.yy"
+    {
        	  abort_gpsim = 1;
 	  quit_parse = 1;
 	  YYABORT;
-	  ;
-    break;}
-case 32:
-#line 224 "parse.yy"
-{
+	  }
+    break;
+
+  case 33:
+#line 225 "parse.yy"
+    {
             if((verbose&2) && DEBUG_PARSER)
 	      cout << "attach command with a string list\n";
 	    attach.attach(str_list_head);
 	    free_char_list(str_list_head);
             YYABORT;
 
-	  ;
-    break;}
-case 33:
-#line 235 "parse.yy"
-{ c_break.list(); YYABORT;;
-    break;}
-case 34:
-#line 237 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 34:
+#line 236 "parse.yy"
+    { c_break.list(); YYABORT;}
+    break;
+
+  case 35:
+#line 238 "parse.yy"
+    { 
 	    cmd_options *opt = yyvsp[0].co;
 	    c_break.set_break(opt->value); YYABORT;
-	  ;
-    break;}
-case 35:
-#line 242 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 36:
+#line 243 "parse.yy"
+    { 
              c_break.set_break(yyvsp[-1].co->value,yyvsp[0].li); YYABORT;
-          ;
-    break;}
-case 36:
-#line 246 "parse.yy"
-{ 
-	     c_break.set_break(yyvsp[-2].co->value,yyvsp[-1].li,yyvsp[0].li,0); YYABORT;;
-    break;}
-case 37:
-#line 249 "parse.yy"
-{ 
+          }
+    break;
+
+  case 37:
+#line 247 "parse.yy"
+    { 
+	     c_break.set_break(yyvsp[-2].co->value,yyvsp[-1].li,yyvsp[0].li,0); YYABORT;}
+    break;
+
+  case 38:
+#line 250 "parse.yy"
+    { 
 	    c_break.set_break(yyvsp[-3].co->value,yyvsp[-2].li,yyvsp[-1].li,yyvsp[0].li); YYABORT;
-          ;
-    break;}
-case 38:
-#line 253 "parse.yy"
-{ 
+          }
+    break;
+
+  case 39:
+#line 254 "parse.yy"
+    { 
             c_break.set_break(yyvsp[-1].co->value,yyvsp[0].s); YYABORT;
-          ;
-    break;}
-case 39:
-#line 257 "parse.yy"
-{ 
+          }
+    break;
+
+  case 40:
+#line 258 "parse.yy"
+    { 
 	    c_break.set_break(yyvsp[-2].co->value,yyvsp[-1].s,yyvsp[0].li, 0); YYABORT;
-          ;
-    break;}
-case 40:
-#line 261 "parse.yy"
-{ 
+          }
+    break;
+
+  case 41:
+#line 262 "parse.yy"
+    { 
 	    c_break.set_break(yyvsp[-3].co->value,yyvsp[-2].s,yyvsp[-1].li,yyvsp[0].li); YYABORT;
-          ;
-    break;}
-case 41:
-#line 267 "parse.yy"
-{ 
+          }
+    break;
+
+  case 42:
+#line 268 "parse.yy"
+    { 
 	    c_bus.list_busses(); YYABORT;
-	  ;
-    break;}
-case 42:
-#line 271 "parse.yy"
-{
+	  }
+    break;
+
+  case 43:
+#line 272 "parse.yy"
+    {
 	    //cout << "bus command with a string list\n";
 	    c_bus.add_busses(str_list_head);
 	    free_char_list(str_list_head);
             YYABORT;
-          ;
-    break;}
-case 43:
-#line 280 "parse.yy"
-{ clear.clear(yyvsp[0].li); YYABORT;;
-    break;}
-case 44:
-#line 284 "parse.yy"
-{ disassemble.disassemble(-10, 5); YYABORT; ;
-    break;}
-case 45:
-#line 286 "parse.yy"
-{ disassemble.disassemble(0, yyvsp[0].li); YYABORT;;
-    break;}
-case 46:
-#line 288 "parse.yy"
-{ disassemble.disassemble(-yyvsp[-1].li,yyvsp[0].li); YYABORT;;
-    break;}
-case 47:
-#line 292 "parse.yy"
-{ dump.dump(2); YYABORT;;
-    break;}
-case 48:
-#line 294 "parse.yy"
-{ dump.dump(yyvsp[0].co->value); YYABORT;;
-    break;}
-case 49:
-#line 298 "parse.yy"
-{ frequency.print(); YYABORT;;
-    break;}
-case 50:
-#line 300 "parse.yy"
-{ frequency.set(yyvsp[0].li); YYABORT;;
-    break;}
-case 51:
-#line 304 "parse.yy"
-{ help.help(); YYABORT;;
-    break;}
-case 52:
-#line 306 "parse.yy"
-{ help.help(yyvsp[0].s); free(yyvsp[0].s); YYABORT;;
-    break;}
-case 53:
-#line 310 "parse.yy"
-{ c_list.list(); YYABORT;;
-    break;}
-case 54:
-#line 312 "parse.yy"
-{ printf("got a list with an indirect reference %d\n",yyvsp[0].li);YYABORT;;
-    break;}
-case 55:
-#line 314 "parse.yy"
-{ 
+          }
+    break;
+
+  case 44:
+#line 281 "parse.yy"
+    { clear.clear(yyvsp[0].li); YYABORT;}
+    break;
+
+  case 45:
+#line 285 "parse.yy"
+    { disassemble.disassemble(-10, 5); YYABORT; }
+    break;
+
+  case 46:
+#line 287 "parse.yy"
+    { disassemble.disassemble(0, yyvsp[0].li); YYABORT;}
+    break;
+
+  case 47:
+#line 289 "parse.yy"
+    { disassemble.disassemble(-yyvsp[-1].li,yyvsp[0].li); YYABORT;}
+    break;
+
+  case 48:
+#line 293 "parse.yy"
+    { dump.dump(2); YYABORT;}
+    break;
+
+  case 49:
+#line 295 "parse.yy"
+    { dump.dump(yyvsp[0].co->value); YYABORT;}
+    break;
+
+  case 50:
+#line 299 "parse.yy"
+    { frequency.print(); YYABORT;}
+    break;
+
+  case 51:
+#line 301 "parse.yy"
+    { frequency.set(yyvsp[0].li); YYABORT;}
+    break;
+
+  case 52:
+#line 305 "parse.yy"
+    { help.help(); YYABORT;}
+    break;
+
+  case 53:
+#line 307 "parse.yy"
+    { help.help(yyvsp[0].s); free(yyvsp[0].s); YYABORT;}
+    break;
+
+  case 54:
+#line 311 "parse.yy"
+    { c_list.list(); YYABORT;}
+    break;
+
+  case 55:
+#line 313 "parse.yy"
+    { printf("got a list with an indirect reference %d\n",yyvsp[0].li);YYABORT;}
+    break;
+
+  case 56:
+#line 315 "parse.yy"
+    { 
 	    cmd_options *opt = yyvsp[0].co;
 	    //cout << "  --- list with bit flag " << opt->name << '\n';
 	    c_list.list(yyvsp[0].co); YYABORT;
-	  ;
-    break;}
-case 56:
-#line 322 "parse.yy"
-{
+	  }
+    break;
+
+  case 57:
+#line 323 "parse.yy"
+    {
 	    c_load.load(yyvsp[-1].co->value,yyvsp[0].s);
 	    //cout << "load completed\n\n";
 	    if(quit_parse)
@@ -1122,743 +1495,792 @@
 		YYABORT;
 	      }
 	     YYABORT;
-	  ;
-    break;}
-case 57:
-#line 335 "parse.yy"
-{
+	  }
+    break;
+
+  case 58:
+#line 336 "parse.yy"
+    {
 	    c_log.log(); YYABORT;
-	  ;
-    break;}
-case 58:
-#line 339 "parse.yy"
-{
+	  }
+    break;
+
+  case 59:
+#line 340 "parse.yy"
+    {
 	    c_log.log(yyvsp[0].li); YYABORT;
-	  ;
-    break;}
-case 59:
-#line 343 "parse.yy"
-{
+	  }
+    break;
+
+  case 60:
+#line 344 "parse.yy"
+    {
 	    c_log.log(yyvsp[0].co); YYABORT;
-	  ;
-    break;}
-case 60:
-#line 347 "parse.yy"
-{
+	  }
+    break;
+
+  case 61:
+#line 348 "parse.yy"
+    {
 	    c_log.log(yyvsp[-1].co,yyvsp[0].s,-1,-1); YYABORT;
-	  ;
-    break;}
-case 61:
-#line 351 "parse.yy"
-{
+	  }
+    break;
+
+  case 62:
+#line 352 "parse.yy"
+    {
 	    c_log.log(yyvsp[-2].co,yyvsp[-1].s,yyvsp[0].li,0); YYABORT;
-	  ;
-    break;}
-case 62:
-#line 355 "parse.yy"
-{
+	  }
+    break;
+
+  case 63:
+#line 356 "parse.yy"
+    {
 	    c_log.log(yyvsp[-3].co,yyvsp[-2].s,yyvsp[-1].li,yyvsp[0].li); YYABORT;
-	  ;
-    break;}
-case 63:
-#line 359 "parse.yy"
-{
+	  }
+    break;
+
+  case 64:
+#line 360 "parse.yy"
+    {
 	    c_log.log(yyvsp[-1].co,yyvsp[0].li,-1,-1); YYABORT;
-	  ;
-    break;}
-case 64:
-#line 363 "parse.yy"
-{
+	  }
+    break;
+
+  case 65:
+#line 364 "parse.yy"
+    {
 	    c_log.log(yyvsp[-2].co,yyvsp[-1].li,yyvsp[0].li,0); YYABORT;
-	  ;
-    break;}
-case 65:
-#line 367 "parse.yy"
-{
+	  }
+    break;
+
+  case 66:
+#line 368 "parse.yy"
+    {
 	    c_log.log(yyvsp[-3].co,yyvsp[-2].li,yyvsp[-1].li,yyvsp[0].li); YYABORT;
-	  ;
-    break;}
-case 66:
-#line 373 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 67:
+#line 374 "parse.yy"
+    { 
 	    c_node.list_nodes(); YYABORT;
-	  ;
-    break;}
-case 67:
-#line 377 "parse.yy"
-{
+	  }
+    break;
+
+  case 68:
+#line 378 "parse.yy"
+    {
 	    //cout << "node command with a string list\n";
 	    c_node.add_nodes(str_list_head);
 	    free_char_list(str_list_head);
             YYABORT;
-          ;
-    break;}
-case 68:
-#line 386 "parse.yy"
-{ 
+          }
+    break;
+
+  case 69:
+#line 387 "parse.yy"
+    { 
             cout << "module command\n";
             c_module.module(); YYABORT;
-          ;
-    break;}
-case 69:
-#line 391 "parse.yy"
-{ c_module.module(yyvsp[0].co->value); YYABORT;;
-    break;}
-case 70:
-#line 393 "parse.yy"
-{ 
+          }
+    break;
+
+  case 70:
+#line 392 "parse.yy"
+    { c_module.module(yyvsp[0].co->value); YYABORT;}
+    break;
+
+  case 71:
+#line 394 "parse.yy"
+    { 
             c_module.module(yyvsp[0].cos);
             delete yyvsp[0].cos;
             YYABORT;
-          ;
-    break;}
-case 71:
-#line 400 "parse.yy"
-{ 
+          }
+    break;
+
+  case 72:
+#line 401 "parse.yy"
+    { 
             c_module.module(yyvsp[-1].cos, yyvsp[0].s);
             delete(yyvsp[-1].cos);
             free(yyvsp[0].s);
             YYABORT;
-          ;
-    break;}
-case 72:
-#line 408 "parse.yy"
-{ 
+          }
+    break;
+
+  case 73:
+#line 409 "parse.yy"
+    { 
             c_module.module(yyvsp[-2].cos, yyvsp[-1].s, yyvsp[0].s);
             delete(yyvsp[-2].cos);
             free(yyvsp[-1].s);
             free(yyvsp[0].s);
             YYABORT;
-          ;
-    break;}
-case 73:
-#line 416 "parse.yy"
-{ 
+          }
+    break;
+
+  case 74:
+#line 417 "parse.yy"
+    { 
             c_module.module(yyvsp[-2].cos, yyvsp[-1].s, double(yyvsp[0].li));
             delete(yyvsp[-2].cos);
             free(yyvsp[-1].s);
             YYABORT;
-          ;
-    break;}
-case 74:
-#line 424 "parse.yy"
-{ 
+          }
+    break;
+
+  case 75:
+#line 425 "parse.yy"
+    { 
             c_module.module(yyvsp[-2].cos, yyvsp[-1].s, yyvsp[0].f);
             delete(yyvsp[-2].cos);
             free(yyvsp[-1].s);
             YYABORT;
-          ;
-    break;}
-case 75:
-#line 445 "parse.yy"
-{ c_processor.processor(); YYABORT;;
-    break;}
-case 76:
-#line 447 "parse.yy"
-{ c_processor.processor(yyvsp[0].co->value); YYABORT;;
-    break;}
-case 77:
-#line 449 "parse.yy"
-{ c_processor.processor(yyvsp[0].s,NULL); YYABORT; ;
-    break;}
-case 78:
-#line 451 "parse.yy"
-{ 
+          }
+    break;
+
+  case 76:
+#line 446 "parse.yy"
+    { c_processor.processor(); YYABORT;}
+    break;
+
+  case 77:
+#line 448 "parse.yy"
+    { c_processor.processor(yyvsp[0].co->value); YYABORT;}
+    break;
+
+  case 78:
+#line 450 "parse.yy"
+    { c_processor.processor(yyvsp[0].s,NULL); YYABORT; }
+    break;
+
+  case 79:
+#line 452 "parse.yy"
+    { 
             c_processor.processor(yyvsp[-1].s,yyvsp[0].s);
             YYABORT;
-          ;
-    break;}
-case 79:
-#line 459 "parse.yy"
-{ 
+          }
+    break;
+
+  case 80:
+#line 460 "parse.yy"
+    { 
             //printf("got a quit\n");
             quit_parse = 1;
 	    YYABORT;
-          ;
-    break;}
-case 80:
-#line 465 "parse.yy"
-{
+          }
+    break;
+
+  case 81:
+#line 466 "parse.yy"
+    {
             quit_parse = 1;
 	    quit_state = yyvsp[0].li;
 	    YYABORT;
-	  ;
-    break;}
-case 81:
-#line 473 "parse.yy"
-{ reset.reset(); YYABORT; ;
-    break;}
-case 82:
-#line 477 "parse.yy"
-{ c_run.run(); YYABORT;;
-    break;}
-case 83:
-#line 481 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 82:
+#line 474 "parse.yy"
+    { reset.reset(); YYABORT; }
+    break;
+
+  case 83:
+#line 478 "parse.yy"
+    { c_run.run(); YYABORT;}
+    break;
+
+  case 84:
+#line 482 "parse.yy"
+    { 
             c_set.set(); YYABORT;
-          ;
-    break;}
-case 84:
-#line 485 "parse.yy"
-{
+          }
+    break;
+
+  case 85:
+#line 486 "parse.yy"
+    {
             c_set.set(yyvsp[0].co->value,1); YYABORT;
-          ;
-    break;}
-case 85:
-#line 489 "parse.yy"
-{
+          }
+    break;
+
+  case 86:
+#line 490 "parse.yy"
+    {
             c_set.set(yyvsp[-1].co->value,yyvsp[0].li);YYABORT;
-          ;
-    break;}
-case 86:
-#line 493 "parse.yy"
-{
+          }
+    break;
+
+  case 87:
+#line 494 "parse.yy"
+    {
 	    c_set.set(yyvsp[0].con); YYABORT;
-	  ;
-    break;}
-case 87:
-#line 499 "parse.yy"
-{ step.step(1); YYABORT;;
-    break;}
-case 88:
-#line 501 "parse.yy"
-{ step.step(yyvsp[0].li); YYABORT;;
-    break;}
-case 89:
-#line 503 "parse.yy"
-{ step.over(); YYABORT;;
-    break;}
-case 90:
-#line 507 "parse.yy"
-{
+	  }
+    break;
+
+  case 88:
+#line 500 "parse.yy"
+    { step.step(1); YYABORT;}
+    break;
+
+  case 89:
+#line 502 "parse.yy"
+    { step.step(yyvsp[0].li); YYABORT;}
+    break;
+
+  case 90:
+#line 504 "parse.yy"
+    { step.over(); YYABORT;}
+    break;
+
+  case 91:
+#line 508 "parse.yy"
+    {
             if(verbose)
               cout << "parser sees stimulus\n";
 	    c_stimulus.stimulus();
 	    YYABORT;
-	  ;
-    break;}
-case 91:
-#line 514 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 92:
+#line 515 "parse.yy"
+    { 
             if(verbose)
               cout << "parser sees stimulus with number: " << yyvsp[0].li << '\n';
 
 	    c_stimulus.stimulus(yyvsp[0].li);
-	  ;
-    break;}
-case 92:
-#line 521 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 93:
+#line 522 "parse.yy"
+    { 
             if(verbose)
               cout << " stimulus cmd is spanning a line\n";
 
 	    //YYACCEPT;
-	  ;
-    break;}
-case 93:
-#line 528 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 94:
+#line 529 "parse.yy"
+    { 
             if(verbose)
               cout << " stimulus cmd is spanning a line\n";
 
 	    //YYACCEPT;
-	  ;
-    break;}
-case 94:
-#line 535 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 95:
+#line 536 "parse.yy"
+    { 
             if(verbose)
               cout << " stimulus cmd is ignoring stuff\n";
 
 	    //YYACCEPT;
-	  ;
-    break;}
-case 95:
-#line 542 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 96:
+#line 543 "parse.yy"
+    { 
             if(verbose)
               cout << " stimulus cmd is ignoring stuff\n";
 
 	    c_stimulus.stimulus();
 	    YYABORT;
-	  ;
-    break;}
-case 96:
-#line 550 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 97:
+#line 551 "parse.yy"
+    { 
             if(verbose)
               cout << "parser sees stimulus with float number: " << yyvsp[0].f << '\n';
 
 	    c_stimulus.stimulus(int(yyvsp[0].f));
-	  ;
-    break;}
-case 97:
-#line 558 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 98:
+#line 559 "parse.yy"
+    { 
             if(verbose)
 	      cout << " end of stimulus command\n";
 	    c_stimulus.end();
             parser_spanning_lines = 0;
 	    YYACCEPT;
-	  ;
-    break;}
-case 98:
-#line 568 "parse.yy"
-{
+	  }
+    break;
+
+  case 99:
+#line 569 "parse.yy"
+    {
             if(verbose)
               cout << "parser sees stimulus(in _opt)\n"; // << $1->value << '\n';
 	    //c_stimulus.stimulus($1->value);
-	  ;
-    break;}
-case 99:
-#line 574 "parse.yy"
-{
+	  }
+    break;
+
+  case 100:
+#line 575 "parse.yy"
+    {
             //if(verbose)
               //cout << "parser is ignoring spanned line in stimulus\n";
             parser_spanning_lines=1;
             //YYACCEPT;
-          ;
-    break;}
-case 100:
-#line 581 "parse.yy"
-{
+          }
+    break;
+
+  case 101:
+#line 582 "parse.yy"
+    {
             //if(verbose)
               //cout << "parser is ignoring garbage in stimulus\n";
             //YYACCEPT;
-          ;
-    break;}
-case 101:
-#line 587 "parse.yy"
-{
+          }
+    break;
+
+  case 102:
+#line 588 "parse.yy"
+    {
             if(verbose)
               cout << "parser sees stimulus with bit flag: " << yyvsp[0].co->value << '\n';
 	    c_stimulus.stimulus(yyvsp[0].co->value);
-	  ;
-    break;}
-case 102:
-#line 593 "parse.yy"
-{
+	  }
+    break;
+
+  case 103:
+#line 594 "parse.yy"
+    {
             if(verbose)
               cout << "parser sees stimulus with numeric option\n";
 	    c_stimulus.stimulus(yyvsp[0].con);
-	  ;
-    break;}
-case 103:
-#line 599 "parse.yy"
-{
+	  }
+    break;
+
+  case 104:
+#line 600 "parse.yy"
+    {
             if(verbose)
               cout << "parser sees stimulus with numeric float option\n";
 	    c_stimulus.stimulus(yyvsp[0].cof);
-	  ;
-    break;}
-case 104:
-#line 605 "parse.yy"
-{
+	  }
+    break;
+
+  case 105:
+#line 606 "parse.yy"
+    {
             if(verbose)
               cout << "parser sees stimulus with string option\n";
 	    c_stimulus.stimulus(yyvsp[0].cos);
-	  ;
-    break;}
-case 105:
-#line 611 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 106:
+#line 612 "parse.yy"
+    { 
             if(verbose)
               cout << "parser sees stimulus with number\n";
 	    c_stimulus.data_point(yyvsp[0].li);
-	  ;
-    break;}
-case 106:
-#line 617 "parse.yy"
-{ 
+	  }
+    break;
+
+  case 107:
+#line 618 "parse.yy"
+    { 
             if(verbose)
               cout << "parser sees stimulus with floating point number\n";
 	    c_stimulus.data_point(yyvsp[0].f);
-	  ;
-    break;}
-case 107:
-#line 625 "parse.yy"
-{
+	  }
+    break;
+
+  case 108:
+#line 626 "parse.yy"
+    {
 	    c_symbol.dump_all(); YYABORT;
-	  ;
-    break;}
-case 108:
-#line 629 "parse.yy"
-{
+	  }
+    break;
+
+  case 109:
+#line 630 "parse.yy"
+    {
 	    c_symbol.dump_one(yyvsp[0].s); YYABORT;
-	  ;
-    break;}
-case 109:
-#line 633 "parse.yy"
-{
+	  }
+    break;
+
+  case 110:
+#line 634 "parse.yy"
+    {
 	    c_symbol.add_one(yyvsp[-2].s,yyvsp[-1].s,yyvsp[0].li); YYABORT;
-	  ;
-    break;}
-case 110:
-#line 640 "parse.yy"
-{
+	  }
+    break;
+
+  case 111:
+#line 641 "parse.yy"
+    {
 	    c_trace.trace(); YYABORT;
-	  ;
-    break;}
-case 111:
-#line 644 "parse.yy"
-{
+	  }
+    break;
+
+  case 112:
+#line 645 "parse.yy"
+    {
 	    c_trace.trace(yyvsp[0].li); YYABORT;
-	  ;
-    break;}
-case 112:
-#line 648 "parse.yy"
-{
+	  }
+    break;
+
+  case 113:
+#line 649 "parse.yy"
+    {
 	    c_trace.trace(yyvsp[0].con); YYABORT;
-	  ;
-    break;}
-case 113:
-#line 652 "parse.yy"
-{
+	  }
+    break;
+
+  case 114:
+#line 653 "parse.yy"
+    {
 	    c_trace.trace(yyvsp[0].cos); YYABORT;
-	  ;
-    break;}
-case 114:
-#line 656 "parse.yy"
-{
+	  }
+    break;
+
+  case 115:
+#line 657 "parse.yy"
+    {
 	    c_trace.trace(yyvsp[0].co); YYABORT;
-	  ;
-    break;}
-case 115:
-#line 662 "parse.yy"
-{
+	  }
+    break;
+
+  case 116:
+#line 663 "parse.yy"
+    {
 	    version.version(); YYABORT;
-	  ;
-    break;}
-case 116:
-#line 668 "parse.yy"
-{
+	  }
+    break;
+
+  case 117:
+#line 669 "parse.yy"
+    {
 	    c_x.x(); YYABORT;
-	  ;
-    break;}
-case 117:
-#line 672 "parse.yy"
-{
+	  }
+    break;
+
+  case 118:
+#line 673 "parse.yy"
+    {
 	    c_x.x(yyvsp[0].li); YYABORT;
-	  ;
-    break;}
-case 118:
-#line 676 "parse.yy"
-{
+	  }
+    break;
+
+  case 119:
+#line 677 "parse.yy"
+    {
 	    c_x.x(yyvsp[-1].li,yyvsp[0].li); YYABORT;
-	  ;
-    break;}
-case 119:
-#line 680 "parse.yy"
-{
+	  }
+    break;
+
+  case 120:
+#line 681 "parse.yy"
+    {
 	    c_x.x(yyvsp[0].s); YYABORT;
-	  ;
-    break;}
-case 120:
-#line 684 "parse.yy"
-{
+	  }
+    break;
+
+  case 121:
+#line 685 "parse.yy"
+    {
 	    c_x.x(yyvsp[-1].s,yyvsp[0].li); YYABORT;
-	  ;
-    break;}
-case 121:
-#line 695 "parse.yy"
-{
+	  }
+    break;
+
+  case 122:
+#line 696 "parse.yy"
+    {
 	  if(verbose)
             printf(" indirect register *%d",yyvsp[0].li);
 	  yyval.li = yyvsp[0].li;
-        ;
-    break;}
-case 122:
-#line 703 "parse.yy"
-{
+        }
+    break;
+
+  case 123:
+#line 704 "parse.yy"
+    {
 	if(verbose)
          printf("  --- register %d\n", yyvsp[0].li);
-       ;
-    break;}
-case 123:
-#line 710 "parse.yy"
-{
+       }
+    break;
+
+  case 124:
+#line 711 "parse.yy"
+    {
 	 yyval.co = yyvsp[0].co;
 	 //cout << "  --- bit_flag " << $$->name << '\n';
-       ;
-    break;}
-case 124:
-#line 717 "parse.yy"
-{ 
+       }
+    break;
+
+  case 125:
+#line 718 "parse.yy"
+    { 
 	  //cout << $1->name;
 	  yyval.con = new cmd_options_num;
 	  yyval.con->co = yyvsp[-1].co;
 	  yyval.con->n  = yyvsp[0].li;
           if(verbose&2)
 	    cout << "name " << yyval.con->co->name << " value " << yyval.con->n << " got a numeric option \n"; 
-	;
-    break;}
-case 125:
-#line 728 "parse.yy"
-{ 
+	}
+    break;
+
+  case 126:
+#line 729 "parse.yy"
+    { 
 	  //cout << $1->name;
 	  yyval.cof = new cmd_options_float;
 	  yyval.cof->co = yyvsp[-1].co;
 	  yyval.cof->f  = yyvsp[0].f;
           if(verbose&2)
 	    cout << "name " << yyval.cof->co->name << " value " << yyval.cof->f << " got a numeric option \n"; 
-	;
-    break;}
-case 126:
-#line 739 "parse.yy"
-{ 
+	}
+    break;
+
+  case 127:
+#line 740 "parse.yy"
+    { 
 	  //cout << $1->name;
 	  yyval.cos = new cmd_options_str;
 	  yyval.cos->co  = yyvsp[-1].co;
 	  yyval.cos->str = strdup(yyvsp[0].s);
           if(verbose&2)
 	    cout << " name " << yyval.cos->co->name << " value " << yyval.cos->str << " got a string option \n"; 
-	;
-    break;}
-case 127:
-#line 750 "parse.yy"
-{
+	}
+    break;
+
+  case 128:
+#line 751 "parse.yy"
+    {
 	  str_list = (char_list *) malloc(sizeof(char_list)); //new(char_list);
 	  str_list_head = str_list;
 	  str_list->name = strdup(yyvsp[0].s);
 	  str_list->next = NULL;
 	  if(verbose&2)
 	    cout << "got a string. added " << str_list->name << '\n';
-	;
-    break;}
-case 128:
-#line 759 "parse.yy"
-{
+	}
+    break;
+
+  case 129:
+#line 760 "parse.yy"
+    {
 	  str_list->next = (char_list *) malloc(sizeof(char_list)); //new(char_list);
 	  str_list = str_list->next;
 	  str_list->name = strdup(yyvsp[0].s);
 	  str_list->next = NULL;
 	  if(verbose&2)
 	    cout << " -- have a list of strings. added " << str_list->name << '\n';
-	;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/lib/bison.simple"
+	}
+    break;
+
+
+    }
+
+/* Line 999 of yacc.c.  */
+#line 2089 "y.tab.c"
 
   yyvsp -= yylen;
   yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
+
+  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
 
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
 
   yyn = yyr1[yyn];
 
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
-    yystate = yydefgoto[yyn - YYNTBASE];
+    yystate = yydefgoto[yyn - YYNTOKENS];
 
   goto yynewstate;
 
-yyerrlab:   /* here on detecting error */
 
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
       ++yynerrs;
-
-#ifdef YYERROR_VERBOSE
+#if YYERROR_VERBOSE
       yyn = yypact[yystate];
 
-      if (yyn > YYFLAG && yyn < YYLAST)
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
 	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
+	  YYSIZE_T yysize = 0;
+	  int yytype = YYTRANSLATE (yychar);
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("syntax error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[yytype]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
 	    {
-	      strcpy(msg, "parse error");
+	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[yytype]);
 
-	      if (count < 5)
+	      if (yycount < 5)
 		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
 		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
 		      }
 		}
-	      yyerror(msg);
-	      free(msg);
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
 	    }
 	  else
-	    yyerror ("parse error; also virtual memory exceeded");
+	    yyerror ("syntax error; also virtual memory exhausted");
 	}
       else
 #endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
+	yyerror ("syntax error");
     }
 
-  goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
+
 
   if (yyerrstatus == 3)
     {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
 
-      /* return failure if at end of input */
+      /* Return failure if at end of input.  */
       if (yychar == YYEOF)
-	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
+        {
+	  /* Pop the error token.  */
+          YYPOPSTACK;
+	  /* Pop the rest of the stack.  */
+	  while (yyss < yyssp)
+	    {
+	      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+	      yydestruct (yystos[*yyssp], yyvsp);
+	      YYPOPSTACK;
+	    }
+	  YYABORT;
+        }
 
+      YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
+      yydestruct (yytoken, &yylval);
       yychar = YYEMPTY;
-    }
-
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
-
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
 
-  goto yyerrhandle;
+    }
 
-yyerrdefault:  /* current state does not do anything special for the error token. */
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
 
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
 
-yyerrpop:   /* pop the current state because it cannot handle the error token */
+/*----------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action.  |
+`----------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
 
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
-
-#if YYDEBUG != 0
-  if (yydebug)
+  for (;;)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
-yyerrhandle:
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
 
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
 
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
+      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
+      yydestruct (yystos[yystate], yyvsp);
+      yyvsp--;
+      yystate = *--yyssp;
 
-  yyn = yytable[yyn];
-  if (yyn < 0)
-    {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
+      YY_STACK_PRINT (yyss, yyssp);
     }
-  else if (yyn == 0)
-    goto yyerrpop;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
+  YYDPRINTF ((stderr, "Shifting error token, "));
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
+
 
   yystate = yyn;
   goto yynewstate;
 
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
 
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*----------------------------------------------.
+| yyoverflowlab -- parser overflow comes here.  |
+`----------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
 #endif
-    }
-  return 1;
+  return yyresult;
 }
-#line 770 "parse.yy"
+
+
+#line 771 "parse.yy"
 
 
        // parsing is over 
@@ -1927,3 +2349,4 @@
     }
 
 }
+
diff -ur gpsim-0.20.14.old/cli/parse.h gpsim-0.20.14/cli/parse.h
--- gpsim-0.20.14.old/cli/parse.h	2001-12-22 14:52:19.000000000 -0800
+++ gpsim-0.20.14/cli/parse.h	2003-10-20 11:12:43.000000000 -0700
@@ -1,4 +1,115 @@
-typedef union {
+/* A Bison parser, made by GNU Bison 1.875.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ABORT = 258,
+     ATTACH = 259,
+     BREAK = 260,
+     BUS = 261,
+     CLEAR = 262,
+     DISASSEMBLE = 263,
+     DUMP = 264,
+     FREQUENCY = 265,
+     HELP = 266,
+     LOAD = 267,
+     LOG = 268,
+     LIST = 269,
+     NODE = 270,
+     MODULE = 271,
+     PROCESSOR = 272,
+     QUIT = 273,
+     RESET = 274,
+     RUN = 275,
+     SET = 276,
+     STEP = 277,
+     STIMULUS = 278,
+     SYMBOL = 279,
+     TRACE = 280,
+     gpsim_VERSION = 281,
+     X = 282,
+     END_OF_COMMAND = 283,
+     IGNORED = 284,
+     SPANNING_LINES = 285,
+     STRING = 286,
+     INDIRECT = 287,
+     END_OF_INPUT = 288,
+     BIT_FLAG = 289,
+     NUMERIC_OPTION = 290,
+     STRING_OPTION = 291,
+     NUMBER = 292,
+     FLOAT_NUMBER = 293
+   };
+#endif
+#define ABORT 258
+#define ATTACH 259
+#define BREAK 260
+#define BUS 261
+#define CLEAR 262
+#define DISASSEMBLE 263
+#define DUMP 264
+#define FREQUENCY 265
+#define HELP 266
+#define LOAD 267
+#define LOG 268
+#define LIST 269
+#define NODE 270
+#define MODULE 271
+#define PROCESSOR 272
+#define QUIT 273
+#define RESET 274
+#define RUN 275
+#define SET 276
+#define STEP 277
+#define STIMULUS 278
+#define SYMBOL 279
+#define TRACE 280
+#define gpsim_VERSION 281
+#define X 282
+#define END_OF_COMMAND 283
+#define IGNORED 284
+#define SPANNING_LINES 285
+#define STRING 286
+#define INDIRECT 287
+#define END_OF_INPUT 288
+#define BIT_FLAG 289
+#define NUMERIC_OPTION 290
+#define STRING_OPTION 291
+#define NUMBER 292
+#define FLOAT_NUMBER 293
+
+
+
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+#line 84 "parse.yy"
+typedef union YYSTYPE {
   guint32              i;
   guint64             li;
   float                f;
@@ -8,42 +119,14 @@
   cmd_options_float *cof;
   cmd_options_str   *cos;
 } YYSTYPE;
-#define	ABORT	257
-#define	ATTACH	258
-#define	BREAK	259
-#define	BUS	260
-#define	CLEAR	261
-#define	DISASSEMBLE	262
-#define	DUMP	263
-#define	FREQUENCY	264
-#define	HELP	265
-#define	LOAD	266
-#define	LOG	267
-#define	LIST	268
-#define	NODE	269
-#define	MODULE	270
-#define	PROCESSOR	271
-#define	QUIT	272
-#define	RESET	273
-#define	RUN	274
-#define	SET	275
-#define	STEP	276
-#define	STIMULUS	277
-#define	SYMBOL	278
-#define	TRACE	279
-#define	gpsim_VERSION	280
-#define	X	281
-#define	END_OF_COMMAND	282
-#define	IGNORED	283
-#define	SPANNING_LINES	284
-#define	STRING	285
-#define	INDIRECT	286
-#define	END_OF_INPUT	287
-#define	BIT_FLAG	288
-#define	NUMERIC_OPTION	289
-#define	STRING_OPTION	290
-#define	NUMBER	291
-#define	FLOAT_NUMBER	292
-
+/* Line 1240 of yacc.c.  */
+#line 123 "y.tab.h"
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
 
 extern YYSTYPE yylval;
+
+
+
diff -ur gpsim-0.20.14.old/gui/gui_menu.c gpsim-0.20.14/gui/gui_menu.c
--- gpsim-0.20.14.old/gui/gui_menu.c	2001-11-27 21:08:49.000000000 -0800
+++ gpsim-0.20.14/gui/gui_menu.c	2003-10-20 11:49:09.000000000 -0700
@@ -134,11 +134,10 @@
 
   gpsim_get_version(&version[strlen(version)], (100 - strlen(version)) );
 
-  show_message(  version, "A simulator for Microchip PIC microcontrollers.
-by T. Scott Dattalo - mailto:scott@dattalo.com
-   Ralf Forsberg - mailto:rfg@home.se
-\ngpsim homepage: http://www.dattalo.com/gnupic/gpsim.html
-");
+  show_message(  version, "A simulator for Microchip PIC microcontrollers.\n\
+by T. Scott Dattalo - mailto:scott@dattalo.com\n\
+   Ralf Forsberg - mailto:rfg@home.se\n\
+gpsim homepage: http://www.dattalo.com/gnupic/gpsim.html\n");
 
 }
 
diff -ur gpsim-0.20.14.old/src/cod.cc gpsim-0.20.14/src/cod.cc
--- gpsim-0.20.14.old/src/cod.cc	2001-12-27 17:10:38.000000000 -0800
+++ gpsim-0.20.14/src/cod.cc	2003-10-20 11:56:35.000000000 -0700
@@ -28,9 +28,10 @@
 // by gpasm (which is written in C). Consequently
 //
 #include <stdio.h>
-#include <iostream.h>
+#include <iostream>
 #include <string>
 #include <string.h>
+#include <assert.h>
 
 #include "../config.h"
 #include "gpsim_def.h"
diff -ur gpsim-0.20.14.old/src/fopen-path.cc gpsim-0.20.14/src/fopen-path.cc
--- gpsim-0.20.14.old/src/fopen-path.cc	2003-10-20 11:10:36.000000000 -0700
+++ gpsim-0.20.14/src/fopen-path.cc	2003-10-20 11:57:12.000000000 -0700
@@ -27,9 +27,10 @@
 // The functions use a C calling convention for compatibility.
 
 #include <stdio.h>
-#include <iostream.h>
+#include <iostream>
 #include <string>
 #include <string.h>
+#include <assert.h>
 
 #include "../config.h"
 #include "gpsim_def.h"
