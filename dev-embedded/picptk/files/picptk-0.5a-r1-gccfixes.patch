diff -Naur --exclude '*.o' --exclude .deps --exclude '*~' --exclude config.cache --exclude config.log --exclude config.status --exclude itclInt.h --exclude picptk --exclude picpwish --exclude Makefile picptk-0.5a/Makefile.am ../../picptk-0.5a-safe/Makefile.am
--- picptk-0.5a/Makefile.am	2006-02-25 03:35:56.583375801 -0800
+++ ../../picptk-0.5a-safe/Makefile.am	2006-02-25 03:35:30.266199861 -0800
@@ -1,6 +1,8 @@
 ## Process this file with automake to produce Makefile.in
 
 bin_PROGRAMS = picpwish
+picpwish_LDADD = -ltcl -ltk -L/usr/lib/itk3.3 
+picpwish_LDFLAGS = -Wl,-rpath,/usr/lib/itk3.3
 picpwish_SOURCES = \
 		IoIntel.C        \
 		PicCore.C	 \
diff -Naur --exclude '*.o' --exclude .deps --exclude '*~' --exclude config.cache --exclude config.log --exclude config.status --exclude itclInt.h --exclude picptk --exclude picpwish --exclude Makefile picptk-0.5a/UiItk.C ../../picptk-0.5a-safe/UiItk.C
--- picptk-0.5a/UiItk.C	2006-02-25 03:35:56.583375801 -0800
+++ ../../picptk-0.5a-safe/UiItk.C	2006-02-25 03:31:37.211800537 -0800
@@ -78,7 +78,7 @@
 int
 Gui::TclExec(ClientData clientData,
 	     Tcl_Interp *interp,
-	     int argc, char *argv[]) {
+	     int argc, const char *argv[]) {
 
   if(argc < 2) {
     Tcl_AppendResult(interp, "Wrong number of args to ", argv[0], 0);
@@ -86,8 +86,8 @@
   }
 
   // TCL guarantees argv[argc] is zero, so this is safe, right?
-  char *obj = argv[0];
-  char *cmd = argv[1];
+  const char *obj = argv[0];
+  const char *cmd = argv[1];
   Gui *me = (Gui *)clientData;
 
   // Search through table of known commands and dispatch...
@@ -102,7 +102,7 @@
       // Called routine returns zero for success, error count
       // otherwise.  Messages are pretty stock...
       try {
-	int errors = cHandlers[i].cProc(me, interp, argc, argv);
+	int errors = cHandlers[i].cProc(me, interp, argc, (const char**)argv);
 	if(errors) {
 	  char tmp[10];
 	  sprintf(tmp, "%d", errors);
@@ -129,10 +129,10 @@
 /* Load PIC RAM image from file...
  *
  */
-int Gui::DoLoad(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
+int Gui::DoLoad(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
   const char *file = argv[2];
   char tmp[20];
-  int bytes = me->cPic.LoadRam(file);
+  int bytes = ((Gui*)me)->cPic.LoadRam(file);
   sprintf(tmp, "%d", bytes);
   Tcl_AppendResult(interp, "Loaded ", tmp, " bytes from '", file, "'\n", 0);
   return(0);
@@ -148,27 +148,27 @@
  * You'll violate encapsulation and likely break something!
  */
 /* Set a preference variable... */
-int Gui::DoSet(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  Tcl_AppendResult(interp, me->cPic.SetPref(argv[2], argv[3]), 0);
+int Gui::DoSet(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  Tcl_AppendResult(interp, ((Gui*)me)->cPic.SetPref(argv[2], argv[3]), 0);
   return(0);
 }
 /* Set a preference variable... */
-int Gui::DoGet(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  const char *val = me->cPic.GetPref(argv[2]);
+int Gui::DoGet(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  const char *val = ((Gui*)me)->cPic.GetPref(argv[2]);
   if(val) Tcl_AppendResult(interp, val, 0);
   return(0);
 }
 /* Save preference file... */
-int Gui::DoSavePrefs(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  char *arg = argv[2];
-  if(!arg[0]) return(!me->cPic.SavePrefs());
-  else return(!me->cPic.SavePrefs(arg));
+int Gui::DoSavePrefs(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  const char *arg = argv[2];
+  if(!arg[0]) return(!((Gui*)me)->cPic.SavePrefs());
+  else return(!((Gui*)me)->cPic.SavePrefs(arg));
 }
 
-int Gui::DoLoadPrefs(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  char *arg = argv[2];
-  if(!arg[0]) return(!me->cPic.LoadPrefs());
-  else return(!me->cPic.LoadPrefs(arg));
+int Gui::DoLoadPrefs(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  const char *arg = argv[2];
+  if(!arg[0]) return(!((Gui*)me)->cPic.LoadPrefs());
+  else return(!((Gui*)me)->cPic.LoadPrefs(arg));
 }
 
 
@@ -180,13 +180,13 @@
  * programming requirements.
  */
 int
-Gui::DoChip(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
+Gui::DoChip(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
   const char *arg = argv[2];		// checked previously
   if(!arg[0]) {
     // Query for default chip query...
-    Tcl_AppendResult(interp, me->cPic.SetChip(), 0);
+    Tcl_AppendResult(interp, ((Gui*)me)->cPic.SetChip(), 0);
   } else {
-    arg = me->cPic.SetChip(arg);
+    arg = ((Gui*)me)->cPic.SetChip(arg);
     Tcl_AppendResult(interp, "PIC type set to ", arg, "\n", 0);
   }
   return(0);
@@ -199,41 +199,41 @@
  * port programmer is currently implemented.
  */
 int
-Gui::DoPort(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
+Gui::DoPort(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
   const char *arg = argv[2];
   if(!arg[0]) {
     // Query for current port...
-    Tcl_AppendResult(interp, me->cPic.SetPort(), 0);
+    Tcl_AppendResult(interp, ((Gui*)me)->cPic.SetPort(), 0);
   } else {
-    arg = me->cPic.SetPort(arg);
+    arg = ((Gui*)me)->cPic.SetPort(arg);
     Tcl_AppendResult(interp, "Port now ", arg, "\n", 0);
   }
   return(0);
 }
 
 /* Read the PIC's memory into ram */
-int Gui::DoRead(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-    return(me->cPic.Read(CollectErrors, interp));
+int Gui::DoRead(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+    return(((Gui*)me)->cPic.Read(CollectErrors, interp));
 }
 
 // Read pic memory into ram (all segments)
-int Gui::DoErase(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  return(me->cPic.Erase(CollectErrors, interp));
+int Gui::DoErase(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  return(((Gui*)me)->cPic.Erase(CollectErrors, interp));
 }
 
 // Verify ram image against PIC memory image
-int Gui::DoVerify(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  return(me->cPic.Verify(CollectErrors, interp));
+int Gui::DoVerify(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  return(((Gui*)me)->cPic.Verify(CollectErrors, interp));
 }
 
 // Burn this pic...
-int Gui::DoBurn(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  return(me->cPic.Write(CollectErrors, interp));
+int Gui::DoBurn(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  return(((Gui*)me)->cPic.Write(CollectErrors, interp));
 }
 
 // Make list of what's available for chips...
-int Gui::DoChips(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  const char **chips = me->cPic.Chips();
+int Gui::DoChips(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  const char **chips = ((Gui*)me)->cPic.Chips();
   for(int i = 0; chips[i]; i++) 
     // #### Blech!  Cast away const! Thank's alot Tcl!
     Tcl_AppendElement(interp, (char *)chips[i]);
@@ -243,8 +243,8 @@
 }
 
 // Make list of pin names for the chosen programmer...
-int Gui::DoPins(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  const char **pins = me->cPic.Pins();
+int Gui::DoPins(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  const char **pins = ((Gui*)me)->cPic.Pins();
   for(int i = 0; pins[i]; i++) 
     // #### Blech!  Cast away const! Thank's alot Tcl!
     Tcl_AppendElement(interp, (char *)pins[i]);
@@ -253,8 +253,8 @@
 }
 
 // Get info on current chip's segments...
-int Gui::DoInfo(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  const char *str = me->cPic.Info();
+int Gui::DoInfo(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  const char *str = ((Gui*)me)->cPic.Info();
   // #### Blech!  Cast away const! Thank's alot Tcl!
   Tcl_SetResult(interp, (char *)str, TCL_VOLATILE);
   delete [] str;
@@ -262,8 +262,8 @@
 }
 
 // Get info on build version
-int Gui::DoVersion(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
-  const char *str = me->cPic.Version();
+int Gui::DoVersion(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
+  const char *str = ((Gui*)me)->cPic.Version();
   // #### Blech!  Cast away const! Thank's alot Tcl!
   Tcl_SetResult(interp, (char *)str, TCL_VOLATILE);
   delete [] str;
@@ -272,9 +272,9 @@
 
 // Dump memory map info...  (could be big!)
 // The C-core attempts to compress this, though...
-int Gui::DoDump(Gui *me, Tcl_Interp *interp, int argc, char *argv[]) {
+int Gui::DoDump(void *me, Tcl_Interp *interp, int argc, const char *argv[]) {
   ostrstream os;
-  me->cPic.DumpRam(os);
+  ((Gui*)me)->cPic.DumpRam(os);
   os << ends;
   char *str = os.str();
   Tcl_AppendResult(interp, str, 0);
@@ -285,12 +285,12 @@
 // Instantiate a new connection object...
 int Gui::TclNew(ClientData clientData, 
 		Tcl_Interp *interp,
-		int argc, char *argv[]) {
+		int argc, const char *argv[]) {
   if(argc != 2) {
     Tcl_AppendResult(interp, "Wrong number of arguments to ", argv[0], "\n", 0);
     return(TCL_ERROR);
   }
-  char *name = argv[1];
+  const char *name = argv[1];
   if(!Tcl_CreateCommand(interp, name, Gui::TclExec,
 			(ClientData) new Gui(), Gui::TclDestroy)) {
     Tcl_AppendResult(interp, "Error creating '", name, "'\n", 0);
diff -Naur --exclude '*.o' --exclude .deps --exclude '*~' --exclude config.cache --exclude config.log --exclude config.status --exclude itclInt.h --exclude picptk --exclude picpwish --exclude Makefile picptk-0.5a/UiItk.h ../../picptk-0.5a-safe/UiItk.h
--- picptk-0.5a/UiItk.h	2006-02-25 03:35:56.583375801 -0800
+++ ../../picptk-0.5a-safe/UiItk.h	2006-02-25 03:30:52.821822767 -0800
@@ -49,27 +49,27 @@
 
   // Bindings that TCL calls more or less directly
   static int TclInit(Tcl_Interp *interp, char *cmd = "Pic");
-  static int TclNew(ClientData, Tcl_Interp *, int argc, char *argv[]);
-  static int TclExec(ClientData, Tcl_Interp *, int argc, char *argv[]);
+  static int TclNew(ClientData, Tcl_Interp *, int argc, const char *argv[]);
+  static int TclExec(ClientData, Tcl_Interp *, int argc, const char *argv[]);
   static void TclDestroy(ClientData);
 
   // Call handlers (dispached by TclExec)
-  static int DoLoad(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoRead(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoVerify(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoBurn(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoChips(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoPins(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoInfo(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoVersion(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoChip(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoPort(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoDump(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoErase(Gui *, Tcl_Interp *, int argc, char *argv[]);
-  static int DoSet(Gui *me, Tcl_Interp *interp, int argc, char *argv[]);
-  static int DoGet(Gui *me, Tcl_Interp *interp, int argc, char *argv[]);
-  static int DoSavePrefs(Gui *me, Tcl_Interp *interp, int argc, char *argv[]);
-  static int DoLoadPrefs(Gui *me, Tcl_Interp *interp, int argc, char *argv[]);
+  static int DoLoad(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoRead(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoVerify(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoBurn(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoChips(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoPins(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoInfo(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoVersion(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoChip(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoPort(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoDump(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoErase(void *, Tcl_Interp *, int argc, const char *argv[]);
+  static int DoSet(void *me, Tcl_Interp *interp, int argc, const char *argv[]);
+  static int DoGet(void *me, Tcl_Interp *interp, int argc, const char *argv[]);
+  static int DoSavePrefs(void *me, Tcl_Interp *interp, int argc, const char *argv[]);
+  static int DoLoadPrefs(void *me, Tcl_Interp *interp, int argc, const char *argv[]);
 
   // Procedure to collect error reports...
   static bool CollectErrors(void *interp, const char *seg, uint size,
