--- src/mutlib/array.hpp.old	2004-11-09 04:53:27.000000000 -0500
+++ src/mutlib/array.hpp	2005-01-24 21:59:12.639686328 -0500
@@ -316,12 +316,12 @@
 template <typename T>
 double NumericArray<T>::Mean() const
 {
-   assert(m_pArray != NULL);
+   assert(this->m_pArray != NULL);
    double acc = 0.0;
-   for( int n=m_nLowerLimit; n<=m_nUpperLimit; n++ )
-      acc += m_pArray[n];
-   return (m_nUpperLimit-m_nLowerLimit+1)
-     ? acc / (m_nUpperLimit-m_nLowerLimit+1)
+   for( int n=this->m_nLowerLimit; n<=this->m_nUpperLimit; n++ )
+      acc += this->m_pArray[n];
+   return (this->m_nUpperLimit - this->m_nLowerLimit+1)
+     ? acc / (this->m_nUpperLimit - this->m_nLowerLimit+1)
      : 0;
 }
 
@@ -334,18 +334,18 @@
 template <typename T>
 double NumericArray<T>::Variance( double* nMean ) const
 {
-   assert(m_pArray != NULL);
+   assert(this->m_pArray != NULL);
    double tmp;
    double acc  = 0.0;
    double mean = nMean ? *nMean : Mean();
-   for( int n=m_nLowerLimit; n<=m_nUpperLimit; n++ )
+   for( int n=this->m_nLowerLimit; n<=this->m_nUpperLimit; n++ )
    {
-      tmp  = double(m_pArray[n]) - mean;
+      tmp  = double(this->m_pArray[n]) - mean;
       tmp *= tmp;
       acc += tmp;
    }
-   assert(m_nUpperLimit-m_nLowerLimit!=0);
-   return acc / static_cast<double>(m_nUpperLimit-m_nLowerLimit);
+   assert(this->m_nUpperLimit - this->m_nLowerLimit!=0);
+   return acc / static_cast<double>(this->m_nUpperLimit - this->m_nLowerLimit);
 }
 
 
@@ -358,10 +358,10 @@
 T NumericArray<T>::Min() const
 {
    T minval = std::numeric_limits<T>::max();
-   for( int n=m_nLowerLimit; n<=m_nUpperLimit; n++ )
+   for( int n=this->m_nLowerLimit; n<=this->m_nUpperLimit; n++ )
    {
-      if( m_pArray[n] < minval )
-         minval = m_pArray[n];
+      if( this->m_pArray[n] < minval )
+         minval = this->m_pArray[n];
    }
    return minval;
 }
@@ -376,10 +376,10 @@
 T NumericArray<T>::Max() const
 {
    T maxval = std::numeric_limits<T>::min();
-   for( int n=m_nLowerLimit; n<=m_nUpperLimit; n++ )
+   for( int n=this->m_nLowerLimit; n<=this->m_nUpperLimit; n++ )
    {
-      if( m_pArray[n] > maxval )
-         maxval = m_pArray[n];
+      if( this->m_pArray[n] > maxval )
+         maxval = this->m_pArray[n];
    }
    return maxval;
 }
@@ -392,14 +392,14 @@
    // Linear interpolation between two points using equation y = mx + c
    assert(x1<x2);
    assert(x1>=0);
-   assert(x2<m_nLength);
+   assert(x2<this->m_nLength);
    if( x2 > x1 )
    {
       int    points = x2 - x1;
-      T      c      = m_pArray[x1];
-      double m      = static_cast<double>(m_pArray[x2] - m_pArray[x1]) / static_cast<double>(points);
+      T      c      = this->m_pArray[x1];
+      double m      = static_cast<double>(this->m_pArray[x2] - this->m_pArray[x1]) / static_cast<double>(points);
       for( int x=0; x<points; x++, x1++ )
-         m_pArray[x1] = static_cast<T>( m*x + c );
+	  this->m_pArray[x1] = static_cast<T>( m*x + c );
   }
 }
 
@@ -436,8 +436,8 @@
 bool DNAArray<CharT>::IsACGT( int nBasePos ) const
 {
     assert(nBasePos>=0);
-    assert(nBasePos<m_nLength);
-    switch( m_pArray[nBasePos] )
+    assert(nBasePos<this->m_nLength);
+    switch( this->m_pArray[nBasePos] )
     {
         case 'A':
         case 'C':
@@ -467,11 +467,11 @@
    Base numbers are assumed to be zero-based.
 */
    assert(nBasePos>=0);
-   assert(nBasePos<m_nLength);
+   assert(nBasePos<this->m_nLength);
    int bp = 0;
-   for( int n=0; n<m_nLength; n++ )
+   for( int n=0; n<this->m_nLength; n++ )
    {
-      if( m_pArray[n] == cPad )
+      if( this->m_pArray[n] == cPad )
          continue;
       if( bp == nBasePos )
          return n;
@@ -493,9 +493,9 @@
     Counts the number of pad characters contained in the current range.
 */
     int nPads = 0;
-    for( int n=m_nLowerLimit; n<=m_nUpperLimit; n++ )
+    for( int n=this->m_nLowerLimit; n<=this->m_nUpperLimit; n++ )
     {
-        if( m_pArray[n] == cPad )
+        if( this->m_pArray[n] == cPad )
             nPads++;
     }
     return nPads;
@@ -519,9 +519,9 @@
     {
         // Scan from left
         i = 0;
-        while( (i<m_nLength) && (n>0) )
+        while( (i<this->m_nLength) && (n>0) )
         {
-            if( m_pArray[i] != cPad )
+            if( this->m_pArray[i] != cPad )
                 n--;
             i++;
         }
@@ -529,10 +529,10 @@
     else
     {
         // Scan from right
-        i = m_nLength - 1;
+        i = this->m_nLength - 1;
         while( (i>=0) && (n>0) )
         {
-            if( m_pArray[i] != cPad )
+            if( this->m_pArray[i] != cPad )
                 n--;
             i--;
         }
@@ -546,12 +546,12 @@
 int DNAArray<CharT>::GetOriginalPosition( int i, bool bLeft, char cPad ) const
 {
     assert(i>=0);
-    assert(i<m_nLength);
+    assert(i<this->m_nLength);
 
 
     // Check input
     int n = -1;
-    if( i >= m_nLength )
+    if( i >= this->m_nLength )
         return n;
 
 
@@ -561,7 +561,7 @@
         // Scan to left
         while( i >= 0 )
         {
-            if( m_pArray[i] != cPad )
+            if( this->m_pArray[i] != cPad )
                 n++;
             i--;
         }
@@ -569,9 +569,9 @@
     else
     {
         // Scan to right
-        while( i < m_nLength )
+        while( i < this->m_nLength )
         {
-            if( m_pArray[i] != cPad )
+            if( this->m_pArray[i] != cPad )
                 n++;
             i++;
         }
