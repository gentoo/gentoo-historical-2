Upstream patches to avoid nested functions (which need exec. stack)
Included in >=0.5.1-r2

--- ./server/parse.c	2006/04/27 15:11:00	1.21
+++ ./server/parse.c	2006/12/09 20:52:44	1.22
@@ -62,18 +62,6 @@
 	int argpos = 0;
 	CommandFunc function = NULL;
 
-	void close_arg() {
-		if (argc >= MAX_ARGUMENTS-1) {
-			error = 1;
-		}
-		else {
-			argv[argc][argpos] = '\0';
-			argv[argc+1] = argv[argc] + argpos + 1;
-			argc++;
-			argpos = 0;
-		}
-	}
-
 	debug( RPT_DEBUG, "%s( str=\"%.120s\", client=[%d] )", __FUNCTION__, str, c->sock );
 
 	/* We will create a list of strings that is shorter or equally long as
@@ -105,7 +93,15 @@
 			if (is_final(ch)) {
 				if (quote)
 					error = 2;
-				close_arg();
+				if (argc >= MAX_ARGUMENTS-1) {
+					error = 1;
+				}
+				else {
+					argv[argc][argpos] = '\0';
+					argv[argc+1] = argv[argc] + argpos + 1;
+					argc++;
+					argpos = 0;
+				}
 				state = ST_FINAL;
 			}
 			else if (ch == '\\') {
@@ -131,7 +127,15 @@
 			 	else {
 			 		error = 2;
 					/* alternative: argv[argc][argpos++] = ch; */
-			 		close_arg();
+					if (argc >= MAX_ARGUMENTS-1) {
+						error = 1;
+					}
+					else {
+						argv[argc][argpos] = '\0';
+						argv[argc+1] = argv[argc] + argpos + 1;
+						argc++;
+						argpos = 0;
+					}
 			 		state = ST_FINAL;
 			 	}
 			}
@@ -140,11 +144,27 @@
 			}	
 			else if (is_closing_quote(ch, quote)) {
 				quote = '\0';
-				close_arg();
+				if (argc >= MAX_ARGUMENTS-1) {
+					error = 1;
+				}
+				else {
+					argv[argc][argpos] = '\0';
+					argv[argc+1] = argv[argc] + argpos + 1;
+					argc++;
+					argpos = 0;
+				}
 				state = ST_WHITESPACE;
 			}
 			else if (is_whitespace(ch) && (quote == '\0')) {
-				close_arg();
+				if (argc >= MAX_ARGUMENTS-1) {
+					error = 1;
+				}
+				else {
+					argv[argc][argpos] = '\0';
+					argv[argc+1] = argv[argc] + argpos + 1;
+					argc++;
+					argpos = 0;
+				}
 				state = ST_WHITESPACE;
 			}	
 			else {
--- ./shared/configfile.c	2006/09/18 10:39:21	1.16
+++ ./shared/configfile.c	2006/12/03 12:04:44	1.17
@@ -49,7 +49,11 @@
 static key *find_key(section *s, const char *keyname, int skip);
 static key *add_key(section *s, const char *keyname, const char *value);
 static char get_next_char_f(FILE *f);
+#if defined(LCDPROC_CONFIG_READ_STRING)
 static int process_config(section **current_section, char(*get_next_char)(), const char *source_descr, FILE *f);
+#else
+static int process_config(section **current_section, const char *source_descr, FILE *f);
+#endif
 
 
 #ifdef WITH_LDAP_SUPPORT
@@ -121,7 +125,11 @@
 		return -1;
 	}
 
+#if defined(LCDPROC_CONFIG_READ_STRING)
 	result = process_config(&curr_section, get_next_char_f, filename, f);
+#else
+	result = process_config(&curr_section, filename, f);
+#endif
 
 	fclose(f);
 
@@ -129,6 +137,7 @@
 }
 
 
+#if defined(LCDPROC_CONFIG_READ_STRING)
 int config_read_string(const char *sectionname, const char *str)
 /* All the config parameters are placed in the given section in memory.*/
 {
@@ -145,6 +154,7 @@
 
 	return process_config(&s, get_next_char, "command line", NULL);
 }
+#endif
 
 
 /** Get string from configuration in memory.
@@ -584,12 +594,14 @@
 }
 
 
+#if defined(LCDPROC_CONFIG_READ_STRING)
 static char get_next_char_f(FILE *f)
 {
 	int c = fgetc(f);
 
 	return((c == EOF) ? '\0' : c);
 }
+#endif
 
 
 /* Parser states */
@@ -614,10 +626,14 @@
 #define MAXVALUELENGTH		200
 
 
+#if defined(LCDPROC_CONFIG_READ_STRING)
 static int process_config(section **current_section, char(*get_next_char)(), const char *source_descr, FILE *f)
+#else
+static int process_config(section **current_section, const char *source_descr, FILE *f)
+#endif
 {
 	int state = ST_INITIAL;
-	char ch;
+	int ch;
 	char sectionname[MAXSECTIONLABELLENGTH+1];
 	int sectionname_pos = 0;
 	char keyname[MAXKEYNAMELENGTH+1];
@@ -629,11 +645,22 @@
 	int line_nr = 1;
 	int error = 0;
 
+#if !defined(LCDPROC_CONFIG_READ_STRING)
+	if (f == NULL)
+		return(0);
+#endif
+
 	while (state != ST_END) {
 
+#if defined(LCDPROC_CONFIG_READ_STRING)
 		ch = (f != NULL)
 			? get_next_char(f)
 			: get_next_char();
+#else
+		ch = fgetc(f);
+		if (ch == EOF)
+			ch = '\0';
+#endif
 
 		/* Secretly keep count of the line numbers */
 		if (ch == '\n')