--- beagle-0.1.1/Util/UriFu.cs.orig	2005-10-24 14:13:05.000000000 +0100
+++ beagle-0.1.1/Util/UriFu.cs	2005-10-24 14:13:18.000000000 +0100
@@ -42,58 +42,35 @@ namespace Beagle.Util {
 
 		static public Uri UriStringToUri (string path)
 		{
-			// Decode our pre-encoded 'odd' characters into their real values
-			int i = 0, pos = 0;
-			while ((i = path.IndexOf ('%', pos)) != -1) {
-				pos = i;
-				char unescaped = UriFu.HexUnescape (path, ref pos);
-				if (unescaped < '!' || unescaped > '~') {
-					path = path.Remove (i, 3);
-					path = path.Insert (i, new String(unescaped, 1));
-					pos -= 2;
-				}
-			}
-		
-			// Paths from the file:// indexer need (re)quoting. For example,
-			// valid characters such as @ need to be converted to their hex
-			// values.
-			if (path.StartsWith ("file://")) {
-				// Remove the file:// prefix
-				path = path.Substring (7);
-
-				return PathToFileUri (path);
-			}
-			
-			// Currently, no other protocols need extra processing
+			// Our current hackery attempts to serialize Uri strings in
+			// escaped and constructable form, so we don't require any
+			// extra processing on deserialization right now.
 			return new Uri (path, true);
 		}
 
 		static public String UriToSerializableString (Uri uri)
 		{
 			int i;
-			string ret;
+			string path;
 			StringBuilder builder = new StringBuilder ();
-			
-			// The ToString() of a file:// URI is not always representative of
-			// what it was constructed from. For example, it will return a
-			// # (which was inputted as %23) as %23, whereas the more standard
-			// behaviour for other escaped-characters is to return them as
-			// their actual character. (e.g. %40 gets returned as @)
-			// On the other hand, the LocalPath of a file:// URI does seem to
-			// return the literal # so we use that instead.
+
 			if (uri.IsFile)
-				ret = Uri.UriSchemeFile + Uri.SchemeDelimiter + uri.LocalPath;
+				path = Uri.UriSchemeFile + Uri.SchemeDelimiter
+					+ StringFu.HexEscape (uri.LocalPath);
 			else
-				ret = uri.ToString ();
+				path = uri.ToString ();
 
 			// XmlSerializer is happy to serialize 'odd' characters, but doesn't
 			// like to deserialize them. So we encode all 'odd' characters now.
-			for (i = 0; i < ret.Length; i++)
-				if ((ret [i] < '!') || (ret [i] > '~' && ret [i] < 256))
-					builder.Append (Uri.HexEscape (ret [i]));
+			for (i = 0; i < path.Length; i++)
+				if ((path [i] < '!') || (path [i] > '~' && path [i] < 256))
+					builder.Append (Uri.HexEscape (path [i]));
 				else
-					builder.Append (ret [i]);
+					builder.Append (path [i]);
 
+			if (uri.IsFile)
+				builder.Append (uri.Fragment);
+			
 			return builder.ToString ();
 		}
 
