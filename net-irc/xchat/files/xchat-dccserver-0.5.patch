diff -ur ../xchat-2.0.9-ori/src/common/cfgfiles.c ./src/common/cfgfiles.c
--- ../xchat-2.0.9-ori/src/common/cfgfiles.c	2004-05-23 07:06:08.000000000 +0200
+++ ./src/common/cfgfiles.c	2004-06-06 17:01:20.000000000 +0200
@@ -378,6 +378,7 @@
 	{"dcc_auto_send", P_OFFINT (autodccsend), TYPE_INT},
 	{"dcc_blocksize", P_OFFINT (dcc_blocksize), TYPE_INT},
 	{"dcc_completed_dir", P_OFFSET (dcc_completed_dir), TYPE_STR},
+	{"dcc_dccserver_port", P_OFFINT (dcc_dccserver_port), TYPE_INT},
 	{"dcc_dir", P_OFFSET (dccdir), TYPE_STR},
 	{"dcc_fast_send", P_OFFINT (fastdccsend), TYPE_BOOL},
 	{"dcc_global_max_get_cps", P_OFFINT (dcc_global_max_get_cps), TYPE_INT},
diff -ur ../xchat-2.0.9-ori/src/common/dcc.c ./src/common/dcc.c
--- ../xchat-2.0.9-ori/src/common/dcc.c	2004-05-29 12:47:19.000000000 +0200
+++ ./src/common/dcc.c	2004-06-06 17:04:06.000000000 +0200
@@ -66,6 +66,16 @@
 	{N_("Aborted"), 4 /*red */ },
 };
 
+static struct
+{
+	int fd;
+	int iotag;
+}
+dccserver =
+{
+	fd: -1
+};
+
 static int dcc_global_throttle;	/* 0x1 = sends, 0x2 = gets */
 static int dcc_sendcpssum, dcc_getcpssum;
 
@@ -818,6 +828,18 @@
 	int ret;
 	char tbuf[400];
 
+	if (dcc->fromdccserver)
+	{
+		/* yet another special case, making cross calls to unrelated functions. fun. */
+		if (dcc->type == TYPE_CHATRECV)
+			snprintf(tbuf, sizeof(tbuf) - 1, "1%c1 %s\n", dcc->dccservchtype, dcc->serv->nick);
+		else	/* TYPE_RECV */
+			snprintf(tbuf, sizeof(tbuf) - 1, "121 %s %i\n", dcc->serv->nick, dcc->resumable);
+		send(dcc->sok, tbuf, strlen(tbuf), 0);
+		dcc_connect_finished(NULL, 0, dcc);
+		return;
+	}
+
 	if (dcc->dccstat == STAT_CONNECTING)
 		return;
 	dcc->dccstat = STAT_CONNECTING;
@@ -1563,6 +1585,12 @@
 {
 	char tbuf[500];
 
+	if (dcc->fromdccserver)
+	{
+		dcc_connect(dcc);
+		return 1;
+	}
+
 	if (dcc->dccstat == STAT_QUEUED && dcc->resumable)
 	{
 		/* filename contains spaces? Quote them! */
@@ -1876,3 +1904,240 @@
 	if (!i)
 		PrintText (sess, _("No active DCCs\n"));
 }
+
+static gboolean
+dccserver_readcmd(GIOChannel *chan, GIOCondition cond, struct DCC *dcc)
+{
+	char line[1024];
+	int ret;
+	char *p, *nick, *filename;
+	int filesize;
+	int linelen;
+	struct stat st;
+	
+	/* too lazy to do buffering */
+	ret = recv(dcc->sok, line, sizeof(line), MSG_PEEK);
+	if (ret <= 0)
+	{
+		if (errno != EWOULDBLOCK && errno != EAGAIN && errno != EINTR)
+			dcc_close(dcc, 0, 1);
+		return TRUE;
+	}
+	
+	p = memchr(line, '\n', ret);
+	if (!p)
+	{
+		/* close if too long a line, otherwise continue to recv */
+		if (ret >= sizeof(line))
+			dcc_close(dcc, 0, 1);
+		return TRUE;
+	}
+	
+	/* discard from recv-q */
+	recv(dcc->sok, line, (p - line) + 1, 0);
+	
+	*p-- = '\0';
+	if (p >= line && *p == '\r')
+		*p = '\0';
+	
+	linelen = strlen(line);
+	if (linelen < 5 || line[3] != ' ' || line[4] == ' ')
+	{
+		dcc_close(dcc, 0, 1);
+		return TRUE;
+	}
+	
+	nick = &line[4];
+	p = strchr(nick, ' ');
+	if (p)
+		*p++ = '\0';
+	
+	/* what follows is a lot of duplicate code from handle_dcc */
+	if (!memcmp(line, "100", 3) || !memcmp(line, "110", 3))
+	{
+		/* dcc chat request */
+		dcc->dccstat = STAT_QUEUED;
+		dcc->nick = strdup(nick);
+		dcc->serv = current_tab->server;	/* ? */
+		time(&dcc->lasttime);
+		dcc->fromdccserver = 1;
+		dcc->dccservchtype = line[1];
+		dcc->type = TYPE_CHATRECV;
+		
+		EMIT_SIGNAL(XP_TE_DCCCHATOFFER, current_tab, nick, NULL, NULL, NULL, 0);
+		if (prefs.autoopendccchatwindow)
+			fe_dcc_open_chat_win (TRUE);
+		if (prefs.autodccchat)
+			dcc_connect (dcc);
+	}
+	else if (!memcmp(line, "120", 3))
+	{
+		/* dcc send req */
+		if (!p)
+		{
+			dcc_close(dcc, 0, 1);
+			return TRUE;
+		}
+		filename = strchr(p, ' ');
+		if (!filename)
+		{
+			dcc_close(dcc, 0, 1);
+			return TRUE;
+		}
+		*filename++ = '\0';
+		filesize = atoi(p);
+		
+		dcc->file = strdup(filename);
+		dcc->destfile = malloc(strlen (prefs.dccdir) + strlen (nick) + strlen (filename) + 4);
+		sprintf(dcc->destfile, "%s/%s%s%s",
+			prefs.dccdir, prefs.dccwithnick ? nick : "", prefs.dccwithnick ? "." : "",
+			filename);
+		dcc->destfile_fs = g_filename_from_utf8 (dcc->destfile, -1, 0, 0, 0);
+
+		dcc->resumable = 0;
+		if (stat (dcc->destfile, &st) != -1)
+		{
+			if (st.st_size < filesize)
+				dcc->resumable = st.st_size;
+		}
+
+		dcc->pos = dcc->resumable;
+		dcc->serv = current_tab->server;
+		dcc->type = TYPE_RECV;
+		dcc->dccstat = STAT_QUEUED;
+		dcc->size = filesize;
+		dcc->nick = strdup (nick);
+		dcc->maxcps = prefs.dcc_max_get_cps;
+		time(&dcc->lasttime);
+		dcc->fromdccserver = 1;
+		if (prefs.autodccsend)
+		{
+			if (prefs.autoresume && dcc->resumable)
+			{
+				/* don't resume the same file from two people! */
+				GSList *list = dcc_list;
+				struct DCC *d;
+				while (list)
+				{
+					d = list->data;
+					if (d->type == TYPE_RECV && d->dccstat != STAT_ABORTED &&
+						 d->dccstat != STAT_DONE && d->dccstat != STAT_FAILED)
+					{
+						if (d != dcc && strcmp (d->destfile, dcc->destfile) == 0)
+							goto dontresume;
+					}
+					list = list->next;
+				}
+				dcc_resume (dcc);
+			} else
+			{
+dontresume:
+				dcc->resumable = 0;
+				dcc->pos = 0;
+				dcc_connect (dcc);
+			}
+		}
+		if (prefs.autoopendccrecvwindow)
+			fe_dcc_open_recv_win (TRUE);
+
+		/* abuse line var */
+		sprintf (line, "%d", filesize);
+		sprintf(line + 30, "%s:%i", net_ip(dcc->addr), dcc->port);
+		EMIT_SIGNAL (XP_TE_DCCSENDOFFER, current_tab->server->front_session, dcc->nick,
+						 dcc->file, line, line + 30, 0);
+	}
+	
+	return TRUE;
+}
+
+static gboolean
+dccserver_accept(GIOChannel *chan, GIOCondition cond, void *ptr)
+{
+	int fd;
+	char msg[1024];
+	struct DCC *dcc;
+	struct sockaddr_in sin;
+	int socklen;
+	
+	socklen = sizeof(sin);
+	fd = accept(dccserver.fd, (struct sockaddr *) &sin, &socklen);
+	if (fd == -1)
+	{
+		if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
+			return TRUE;
+		if (!current_tab)
+			return TRUE;
+		snprintf(msg, sizeof(msg) - 1, "Error accept connection on dcc server socket: %s\n", strerror(errno));
+		PrintText(current_tab, msg);
+		return TRUE;
+	}
+	
+	set_nonblocking(fd);
+	
+	dcc = new_dcc();
+	if (!dcc)
+		return TRUE;
+	
+	dcc->addr = ntohl(sin.sin_addr.s_addr);
+	dcc->port = ntohs(sin.sin_port);
+	dcc->type = TYPE_DCCSERVERCONN;
+	dcc->dccstat = STAT_ACTIVE;
+	dcc->sok = fd;
+	time(&dcc->starttime);
+	dcc->lasttime = dcc->starttime;
+	dcc->iotag = fe_input_add(fd, FIA_READ|FIA_EX, dccserver_readcmd, dcc);
+	
+	return TRUE;
+}
+
+int
+dccserver_update(struct session *sess)
+{
+	int fd;
+	char msg[1024];
+	struct sockaddr_in sin;
+	int ret;
+	
+	if (dccserver.fd != -1)
+	{
+		close(dccserver.fd);
+		fe_input_remove(dccserver.iotag);
+		dccserver.fd = -1;
+	}
+	
+	if (prefs.dcc_dccserver_port <= 0)
+		return TRUE;
+	
+	fd = socket(AF_INET, SOCK_STREAM, 0);
+	if (fd == -1)
+	{
+errout:
+		if (!sess)
+			return FALSE;
+		snprintf(msg, sizeof(msg) - 1, N_("Could not open dccserver listening port on port %u: %s\n"),
+			prefs.dcc_dccserver_port, strerror(errno));
+		PrintText(sess, msg);
+		return FALSE;
+	}
+	
+	ret = 1;
+	setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &ret, sizeof(ret));
+	set_nonblocking(fd);
+	
+	memset(&sin, 0, sizeof(sin));
+	sin.sin_family = AF_INET;
+	sin.sin_port = htons(prefs.dcc_dccserver_port);
+	ret = bind(fd, (struct sockaddr *) &sin, sizeof(sin));
+	if (ret != 0)
+	{
+		close(fd);
+		goto errout;	/* considered harmful! */
+	}
+	
+	listen(fd, 5);
+	
+	dccserver.fd = fd;
+	dccserver.iotag = fe_input_add(fd, FIA_READ|FIA_EX, dccserver_accept, NULL);
+	
+	return TRUE;
+}
diff -ur ../xchat-2.0.9-ori/src/common/dcc.h ./src/common/dcc.h
--- ../xchat-2.0.9-ori/src/common/dcc.h	2004-02-01 10:55:34.000000000 +0100
+++ ./src/common/dcc.h	2004-06-06 17:01:20.000000000 +0200
@@ -16,6 +16,7 @@
 #define TYPE_RECV 1
 #define TYPE_CHATRECV 2
 #define TYPE_CHATSEND 3
+#define TYPE_DCCSERVERCONN 4
 
 #define CPS_AVG_WINDOW 10
 
@@ -51,6 +52,8 @@
 	char *nick;
 	unsigned char type;		  /* 0 = SEND  1 = RECV  2 = CHAT */
 	unsigned char dccstat;	  /* 0 = QUEUED  1 = ACTIVE  2 = FAILED  3 = DONE */
+	char dccservchtype;	/* chat or fserve request? */
+	unsigned int fromdccserver:1;	/* this dcc was opened from a dccserver connection */
 	unsigned int fastsend:1;
 	unsigned int ackoffset:1;	/* is reciever sending acks as an offset from */
 										/* the resume point? */
@@ -88,5 +91,6 @@
 void open_dcc_recv_window (void);
 void open_dcc_send_window (void);
 void open_dcc_chat_window (void);
+int dccserver_update(struct session *);
 
 #endif
diff -ur ../xchat-2.0.9-ori/src/common/outbound.c ./src/common/outbound.c
--- ../xchat-2.0.9-ori/src/common/outbound.c	2004-05-31 15:03:02.000000000 +0200
+++ ./src/common/outbound.c	2004-06-06 17:01:20.000000000 +0200
@@ -762,6 +762,80 @@
 	return TRUE;
 }
 
+int
+cmd_dccserver(struct session *sess, char *tbuf, char *word[], char *word_eol[])
+{
+	int i;
+	char buf[1024];
+	int action;
+	int port;
+	
+	i = 2;
+	if (!*word[i])
+	{
+		if (prefs.dcc_dccserver_port == 0)
+			snprintf(buf, sizeof(buf) - 1, N_("DCC server inactive and no port configured\n"));
+		else if (prefs.dcc_dccserver_port < 0)
+			snprintf(buf, sizeof(buf) - 1, N_("DCC server inactive, configured to port %i\n"), -1 * prefs.dcc_dccserver_port);
+		else
+			snprintf(buf, sizeof(buf) - 1, N_("DCC server active and listening on port %i\n"), prefs.dcc_dccserver_port);
+		PrintText(sess, buf);
+		return TRUE;
+	}
+	
+	action = 0;
+	if (*word[i] == '+' || !strcasecmp(word[i], "on"))
+	{
+		action = 1;
+		i++;
+	}
+	else if (*word[i] == '-' || !strcasecmp(word[i], "off"))
+	{
+		action = -1;
+		i++;
+	}
+	
+	if (*word[i])
+	{
+		port = atoi(word[i]);
+		i++;
+	}
+	else
+		port = prefs.dcc_dccserver_port;
+	
+	if (port > 65535 || port < -65535)
+	{
+		PrintText(sess, N_("Invalid port. Port must be in range 1-65535\n"));
+		return FALSE;
+	}
+	else if (port == 0 && action == 1)
+	{
+		PrintText(sess, N_("Cannot enable dcc server, no port configured. Please specify a valid listening port\n"));
+		return FALSE;
+	}
+	else if (port < 0 && action == 1)
+		port = -1 * port;
+	else if (port > 0 && action == -1)
+		port = -1 * port;
+	
+	prefs.dcc_dccserver_port = port;
+	if (dccserver_update(sess))
+	{
+		if (port > 0)
+			snprintf(buf, sizeof(buf) - 1, N_("Enabled DCC server on port %i\n"), port);
+		else
+			snprintf(buf, sizeof(buf) - 1, N_("Disabled DCC server\n"));
+		PrintText(sess, buf);
+	}
+	else
+	{
+		if (prefs.dcc_dccserver_port > 0)
+			prefs.dcc_dccserver_port = -1 * prefs.dcc_dccserver_port;
+	}
+	
+	return TRUE;
+}
+
 static int
 cmd_debug (struct session *sess, char *tbuf, char *word[], char *word_eol[])
 {
@@ -2623,6 +2697,8 @@
 	 "DCC CHAT <nick>                    - offer DCC CHAT to someone\n"
 	 "DCC CLOSE <type> <nick> <file>         example:\n"
 	 "         /dcc close send johnsmith file.tar.gz")},
+	{"DCCSERVER", cmd_dccserver, 0, 0, 0,
+	 N_("DCCSERVER [+|-|on|off] [port], Enable or disable dcc server on a certain port or reports its status")},
 	{"DEBUG", cmd_debug, 0, 0, 1, 0},
 
 	{"DEHOP", cmd_dehop, 1, 1, 1,
diff -ur ../xchat-2.0.9-ori/src/common/xchat.c ./src/common/xchat.c
--- ../xchat-2.0.9-ori/src/common/xchat.c	2004-05-02 07:00:37.000000000 +0200
+++ ./src/common/xchat.c	2004-06-06 17:01:20.000000000 +0200
@@ -1039,6 +1039,8 @@
 		if (prefs.slist_skip)
 			new_ircwindow (NULL, NULL, SESS_SERVER);
 	}
+
+	dccserver_update(current_tab);
 }
 
 void
diff -ur ../xchat-2.0.9-ori/src/common/xchat.h ./src/common/xchat.h
--- ../xchat-2.0.9-ori/src/common/xchat.h	2004-05-12 06:57:19.000000000 +0200
+++ ./src/common/xchat.h	2004-06-06 17:01:20.000000000 +0200
@@ -174,6 +174,7 @@
 	unsigned long local_ip;
 	unsigned long dcc_ip;
 	char dcc_ip_str[DOMAINLEN + 1];
+	int dcc_dccserver_port;
 
 	unsigned int tab_dnd;
 	unsigned int tab_sort;
