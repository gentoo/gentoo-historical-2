diff -Nur qd-2.3.12.orig/configure.ac qd-2.3.12/configure.ac
--- qd-2.3.12.orig/configure.ac	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/configure.ac	2012-01-12 22:34:18.000000000 +0000
@@ -308,12 +308,11 @@
 AC_SUBST(FFLAGS, $FCFLAGS)
 
 # Add libraries
-LIBS="$LIBS -lm"
+AC_CHECK_LIB(m,sqrt)
 
 # libtool stuff
-# AC_DISABLE_SHARED
-# AC_PROG_LIBTOOL
-AC_PROG_RANLIB
+AC_DISABLE_SHARED
+AC_PROG_LIBTOOL
 
 # Output
 AC_CONFIG_FILES([Makefile config/Makefile src/Makefile include/Makefile 
diff -Nur qd-2.3.12.orig/fortran/Makefile.am qd-2.3.12/fortran/Makefile.am
--- qd-2.3.12.orig/fortran/Makefile.am	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/fortran/Makefile.am	2012-01-12 22:48:19.000000000 +0000
@@ -1,6 +1,6 @@
 if HAVE_FORTRAN
 AM_CPPFLAGS = -I$(top_builddir) -I$(top_builddir)/include -I$(top_srcdir)/include
-LDADD=libqdmod.a libqd_f_main.a $(top_builddir)/src/libqd.a $(FCLIBS)
+LDADD=libqdmod.la libqd_f_main.la $(top_builddir)/src/libqd.la $(FCLIBS)
 
 if UPCASE_MODULE
 DDEXT=DDEXT.$(module_ext)
@@ -14,17 +14,17 @@
 DDMOD=ddmodule.$(module_ext)
 endif
 
-lib_LIBRARIES = libqdmod.a libqd_f_main.a
-libqdmod_a_SOURCES = ddext.f ddmod.f qdext.f qdmod.f f_dd.cpp f_qd.cpp
-libqd_f_main_a_SOURCES = main.cpp
-ddmod.o: ddext.o
-qdmod.o: ddmod.o qdext.o
-$(QDMOD): qdmod.o
-$(DDMOD): ddmod.o
-$(DDEXT): ddext.o
-$(QDEXT): qdext.o
+lib_LTLIBRARIES = libqdmod.la libqd_f_main.la
+libqdmod_la_SOURCES = ddext.f ddmod.f qdext.f qdmod.f f_dd.cpp f_qd.cpp
+libqd_f_main_la_SOURCES = main.cpp
+ddmod.lo: $(DDEXT) ddext.lo
+qdmod.lo: ddmod.lo $(DDMOD) qdext.lo
+$(QDMOD): qdmod.lo $(DDMOD)
+$(DDMOD): ddmod.lo
+$(DDEXT): ddext.lo
+$(QDEXT): qdext.lo $(DDEXT) 
 
-pkglib_DATA = $(QDMOD) $(QDEXT) $(DDMOD) $(DDEXT)
+include_HEADERS = $(QDMOD) $(QDEXT) $(DDMOD) $(DDEXT)
 
 DEMO=quaderq$(EXEEXT) quadgsq2d$(EXEEXT) quadgsq$(EXEEXT) \
      quadtsq$(EXEEXT) quadtsq2d$(EXEEXT)
diff -Nur qd-2.3.12.orig/m4/ax_cxx_clock_gettime.m4 qd-2.3.12/m4/ax_cxx_clock_gettime.m4
--- qd-2.3.12.orig/m4/ax_cxx_clock_gettime.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_cxx_clock_gettime.m4	2012-01-12 22:11:48.000000000 +0000
@@ -3,13 +3,13 @@
 AC_DEFUN([AX_CXX_CLOCK_GETTIME], [
 AC_MSG_CHECKING([for clock_gettime useability])
 AC_LANG_PUSH(C++)
-AC_COMPILE_IFELSE([
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([
 #include <time.h>
 int main() {
   struct timespec tv;
   return clock_gettime(CLOCK_REALTIME, &tv);
 }
-], [ax_cxx_clock_gettime="yes"], [ax_cxx_clock_gettime="no"])
+])], [ax_cxx_clock_gettime="yes"], [ax_cxx_clock_gettime="no"])
 AC_LANG_POP(C++)
 AC_MSG_RESULT([$ax_cxx_clock_gettime])
 ])
diff -Nur qd-2.3.12.orig/m4/ax_cxx_copysign.m4 qd-2.3.12/m4/ax_cxx_copysign.m4
--- qd-2.3.12.orig/m4/ax_cxx_copysign.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_cxx_copysign.m4	2012-01-12 22:12:57.000000000 +0000
@@ -6,19 +6,19 @@
 AC_MSG_CHECKING([for copysign])
 AC_LANG_PUSH(C++)
 ax_cxx_copysign=
-AC_COMPILE_IFELSE([#include <cmath>
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([#include <cmath>
                    int main() {
                      std::copysign(1.0, 1.0);
                      return 0;
-                   }], 
+                   }])], 
                    [AC_MSG_RESULT(std::copysign)
                     ax_cxx_copysign="std::copysign(x, y)"])
 if test "x$ax_cxx_copysign" = "x"; then
-  AC_COMPILE_IFELSE([#include <cmath>
+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([#include <cmath>
                      int main() {
                        ::copysign(1.0, 1.0);
                        return 0;
-                     }], 
+                     }])], 
                      [AC_MSG_RESULT(::copysign)
                       ax_cxx_copysign="::copysign(x, y)"], 
                      [AC_MSG_RESULT(none)
diff -Nur qd-2.3.12.orig/m4/ax_cxx_fma.m4 qd-2.3.12/m4/ax_cxx_fma.m4
--- qd-2.3.12.orig/m4/ax_cxx_fma.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_cxx_fma.m4	2012-01-12 21:58:52.000000000 +0000
@@ -19,14 +19,14 @@
     case $name in
       ibm)
         # IBM VisualAge C++ __fmadd / __fmsub.
-        AC_RUN_IFELSE([#include <cmath>
+        AC_RUN_IFELSE([AC_LANG_SOURCE([#include <cmath>
                        #include <builtins.h>
                        int main() {
                          double d = std::ldexp(1.0, -52);
                          double x = __fmadd(1.0 + d, 1.0 - d, -1.0);
                          double y = __fmsub(1.0 + d, 1.0 - d, 1.0);
                          return (x == -d*d && y == -d*d) ? 0 : 1;
-                       }], 
+                       }])], 
                       [ax_cxx_fma="__fmadd(x,y,z)"
                        ax_cxx_fms="__fmsub(x,y,z)"
                        AC_DEFINE([QD_VACPP_BUILTINS_H], [1], 
@@ -34,11 +34,11 @@
       ;;
       gnu)
         # Later gcc (3.4 and later) have __builtin_fma that seems to work.
-        AC_RUN_IFELSE([#include <cmath>
+        AC_RUN_IFELSE([AC_LANG_SOURCE([#include <cmath>
                        int main() {
                          double d = std::ldexp(1.0, -52);
                          return (__builtin_fma(1.0 + d, 1.0 - d, -1.0) == -d*d ? 0 : 1);
-                       }], 
+                       }])], 
                       [ax_cxx_fma="__builtin_fma(x,y,z)"
                        ax_cxx_fms="__builtin_fma(x,y,-z)"])
       ;;
@@ -46,22 +46,22 @@
         # Intel and HP compilers for IA 64 architecture seems to have 
         # _Asm_fma/fms macros.  Not much documentation is available for 
         # these...
-        AC_RUN_IFELSE([#include <cmath>
+        AC_RUN_IFELSE([AC_LANG_SOURCE([#include <cmath>
                        int main() {
                          double d = std::ldexp(1.0, -52);
                          return (_Asm_fma(2, 1.0 + d, 1.0 - d, -1.0) == -d*d ? 0 : 1);
-                       }], 
+                       }])], 
                       [ax_cxx_fma="_Asm_fma(2, x,y,z)"
                        ax_cxx_fms="_Asm_fms(2, x,y,z)"])
       ;;
       c99)
         # Try C99 fma() function.  Some platforms doesn't seem to implement this
         # correctly (Apple gcc-3.3 for example).
-        AC_RUN_IFELSE([#include <cmath>
+        AC_RUN_IFELSE([AC_LANG_SOURCE([#include <cmath>
                        int main() {
                          double d = std::ldexp(1.0, -52);
                          return (fma(1.0 + d, 1.0 - d, -1.0) == -d*d ? 0 : 1);
-                       }], 
+                       }])], 
                       [ax_cxx_fma="fma(x,y,z)"
                        ax_cxx_fms="fma(x,y,-z)"])
       ;;
@@ -69,11 +69,11 @@
         # Try relying on the compiler to optimize x * y + z into an fma.
         # This method is not recommended since if it is inlined it does not
         # always produce the same correct code.
-        AC_RUN_IFELSE([#include <cmath>
+        AC_RUN_IFELSE([AC_LANG_SOURCE([#include <cmath>
                        int main() {
                          double d = std::ldexp(1.0, -52);
                          return ( (1.0 + d) * (1.0 - d) - 1.0 == -d*d ? 0 : 1);
-                       }],
+                       }])],
                        [ax_cxx_fma="((x)*(y) + (z))"
                         ax_cxx_fms="((x)*(y) - (z))"])
       ;;
diff -Nur qd-2.3.12.orig/m4/ax_cxx_isfinite.m4 qd-2.3.12/m4/ax_cxx_isfinite.m4
--- qd-2.3.12.orig/m4/ax_cxx_isfinite.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_cxx_isfinite.m4	2012-01-12 22:13:36.000000000 +0000
@@ -6,19 +6,19 @@
 AC_MSG_CHECKING([for isfinite])
 AC_LANG_PUSH(C++)
 ax_cxx_isfinite=
-AC_COMPILE_IFELSE([#include <cmath>
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([#include <cmath>
                    int main() {
                      std::isfinite(1.0);
                      return 0;
-                   }], 
+                   }])], 
                    [AC_MSG_RESULT(std::isfinite)
                     ax_cxx_isfinite="std::isfinite(x)"])
 if test "x$ax_cxx_isfinite" = "x"; then
-  AC_COMPILE_IFELSE([#include <cmath>
+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([#include <cmath>
                      int main() {
                        ::isfinite(1.0);
                        return 0;
-                     }], 
+                     }])], 
                      [AC_MSG_RESULT(::isfinite)
                       ax_cxx_isfinite="::isfinite(x)"], 
                      [AC_MSG_RESULT(none)
diff -Nur qd-2.3.12.orig/m4/ax_cxx_isinf.m4 qd-2.3.12/m4/ax_cxx_isinf.m4
--- qd-2.3.12.orig/m4/ax_cxx_isinf.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_cxx_isinf.m4	2012-01-12 22:14:20.000000000 +0000
@@ -6,19 +6,19 @@
 AC_MSG_CHECKING([for isinf])
 AC_LANG_PUSH(C++)
 ax_cxx_isinf=
-AC_COMPILE_IFELSE([#include <cmath>
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([#include <cmath>
                    int main() {
                      std::isinf(1.0);
                      return 0;
-                   }], 
+                   }])], 
                    [AC_MSG_RESULT(std::isinf)
                     ax_cxx_isinf="std::isinf(x)"])
 if test "x$ax_cxx_isinf" = "x"; then
-  AC_COMPILE_IFELSE([#include <cmath>
+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([#include <cmath>
                      int main() {
                        ::isinf(1.0);
                        return 0;
-                     }], 
+                     }])], 
                      [AC_MSG_RESULT(::isinf)
                       ax_cxx_isinf="::isinf(x)"], 
                      [AC_MSG_RESULT(none)
diff -Nur qd-2.3.12.orig/m4/ax_cxx_isnan.m4 qd-2.3.12/m4/ax_cxx_isnan.m4
--- qd-2.3.12.orig/m4/ax_cxx_isnan.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_cxx_isnan.m4	2012-01-12 22:14:58.000000000 +0000
@@ -6,19 +6,19 @@
 AC_MSG_CHECKING([for isnan])
 AC_LANG_PUSH(C++)
 ax_cxx_isnan=
-AC_COMPILE_IFELSE([#include <cmath>
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([#include <cmath>
                    int main() {
                      std::isnan(1.0);
                      return 0;
-                   }], 
+                   }])], 
                    [AC_MSG_RESULT(std::isnan)
                     ax_cxx_isnan="std::isnan(x)"])
 if test "x$ax_cxx_isnan" = "x"; then
-  AC_COMPILE_IFELSE([#include <cmath>
+  AC_COMPILE_IFELSE([AC_LANG_SOURCE([#include <cmath>
                      int main() {
                        ::isnan(1.0);
                        return 0;
-                     }], 
+                     }])], 
                      [AC_MSG_RESULT(::isnan)
                       ax_cxx_isnan="::isnan(x)"], 
                      [AC_MSG_RESULT(none)
diff -Nur qd-2.3.12.orig/m4/ax_f90_module_flag.m4 qd-2.3.12/m4/ax_f90_module_flag.m4
--- qd-2.3.12.orig/m4/ax_f90_module_flag.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_f90_module_flag.m4	2012-01-12 22:28:24.000000000 +0000
@@ -16,7 +16,7 @@
 
 AC_DEFUN([AX_F90_MODULE_FLAG],[
 AC_CACHE_CHECK([fortran 90 modules inclusion flag],
-ax_f90_modflag,
+ax_cv_f90_modflag,
 [AC_LANG_PUSH(Fortran)
 i=0
 while test \( -f tmpdir_$i \) -o \( -d tmpdir_$i \) ; do
@@ -24,24 +24,24 @@
 done
 mkdir tmpdir_$i
 cd tmpdir_$i
-AC_COMPILE_IFELSE([module conftest_module
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([module conftest_module
    contains
    subroutine conftest_routine
    write(*,'(a)') 'gotcha!'
    end subroutine conftest_routine
    end module conftest_module
-  ],[],[])
+  ])],[],[])
 cd ..
 ax_f90_modflag="not found"
 for ax_flag in "-I " "-M" "-p"; do
   if test "$ax_f90_modflag" = "not found" ; then
     ax_save_FCFLAGS="$FCFLAGS"
     FCFLAGS="$ax_save_FCFLAGS ${ax_flag}tmpdir_$i"
-    AC_COMPILE_IFELSE([program conftest_program
+    AC_COMPILE_IFELSE([AC_LANG_SOURCE([program conftest_program
        use conftest_module
        call conftest_routine
        end program conftest_program
-      ],[ax_f90_modflag="$ax_flag"],[])
+      ])],[ax_f90_modflag="$ax_flag"],[])
     FCFLAGS="$ax_save_FCFLAGS"
   fi
 done
diff -Nur qd-2.3.12.orig/m4/ax_f90_module_style.m4 qd-2.3.12/m4/ax_f90_module_style.m4
--- qd-2.3.12.orig/m4/ax_f90_module_style.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_f90_module_style.m4	2012-01-12 22:28:50.000000000 +0000
@@ -21,7 +21,7 @@
 
 AC_DEFUN([AX_F90_MODULE_STYLE],[
 AC_CACHE_CHECK([fortran 90 modules naming style],
-ax_f90_module_style, 
+ax_cv_f90_module_style, 
 [AC_LANG_PUSH(Fortran)
 i=0
 while test \( -f tmpdir_$i \) -o \( -d tmpdir_$i \) ; do
@@ -29,13 +29,13 @@
 done
 mkdir tmpdir_$i
 cd tmpdir_$i
-AC_COMPILE_IFELSE([module conftest_module
+AC_COMPILE_IFELSE([AC_LANG_SOURCE([module conftest_module
    contains
    subroutine conftest_routine
    write(*,'(a)') 'gotcha!'
    end subroutine conftest_routine
    end module conftest_module
-  ],
+  ])],
   [ax_f90_modext=`ls | sed -n 's,conftest_module\.,,p'`
    if test x$ax_f90_modext = x ; then
 dnl Some F90 compilers put module filename in uppercase letters
diff -Nur qd-2.3.12.orig/m4/ax_fc_etime.m4 qd-2.3.12/m4/ax_fc_etime.m4
--- qd-2.3.12.orig/m4/ax_fc_etime.m4	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/m4/ax_fc_etime.m4	2012-01-12 22:42:03.000000000 +0000
@@ -4,9 +4,9 @@
 ax_fc_etime=
 ax_fc_etime_names="etime etime_"
 for name in $ax_fc_etime_names; do
-  AC_LINK_IFELSE([AC_LANG_PROGRAM(, [[
+  AC_LINK_IFELSE([AC_LANG_PROGRAM(, [AC_LANG_SOURCE([
       real*4 t(2), tot
-      tot = $name(t)]])], 
+      tot = $name(t)])])],
     [ax_fc_etime=$name], [])
   if test "x$ax_fc_etime" != "x"; then
     break;
diff -Nur qd-2.3.12.orig/Makefile.am qd-2.3.12/Makefile.am
--- qd-2.3.12.orig/Makefile.am	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/Makefile.am	2012-01-12 20:21:15.000000000 +0000
@@ -1,7 +1,6 @@
 ACLOCAL_AMFLAGS = -I m4
 SUBDIRS = config src include tests fortran
 
-docdir=${datadir}/doc/${PACKAGE}
 BUILT_SOURCES = docs/qd.pdf
 dist_doc_DATA = README docs/qd.pdf
 dist_noinst_DATA = docs/Makefile \
@@ -24,7 +23,7 @@
 doc: docs/qd.pdf
 
 docs/qd.pdf:
-	cd docs && $(MAKE) qd.pdf
+	$(MAKE) -C docsqd.pdf
 
 changelog:
 	git log >ChangeLog
@@ -33,12 +32,12 @@
 	rm -f ${distdir}/ChangeLog && git log >${distdir}/ChangeLog
 
 cpp-demo:
-	cd tests && make demo
+	$(MAKE) -C tests demo
 
 if HAVE_FORTRAN
 
 fortran-demo:
-	cd fortran && make demo
+	$(MAKE) -C fortran demo
 
 demo: cpp-demo fortran-demo
 
@@ -52,7 +51,7 @@
 endif
 
 time:
-	cd tests && make time
+	$(MAKE) -C tests time
 
 bin_SCRIPTS=qd-config
 
diff -Nur qd-2.3.12.orig/README.txt qd-2.3.12/README.txt
--- qd-2.3.12.orig/README.txt	1970-01-01 01:00:00.000000000 +0100
+++ qd-2.3.12/README.txt	2012-01-12 20:17:09.000000000 +0000
@@ -0,0 +1,704 @@
+-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐	  
+QUAD-­‐DOUBLE/DOUBLE-­‐DOUBLE	  COMPUTATION	  PACKAGE	  	  
+	  
+	  
+	  
+	  
+	  
+Copyright	  (c)	  2005-­‐2010	  	  
+	  
+	  
+	  
+	  
+-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐-­‐	  
+	  
+Revision	  date:	  	  2010	  June	  14	  
+	  
+Authors:	  
+Yozo	  Hida	  
+	  
+U.C.	  Berkeley	  	  	  	   	  
+	  
+yozo@cs.berkeley.edu	  
+Xiaoye	  S.	  Li	  	   	  
+Lawrence	  Berkeley	  Natl	  Lab	  	  	   xiaoye@nersc.gov	  
+David	  H.	  Bailey	  	  	  
+Lawrence	  Berkeley	  Natl	  Lab	  	  	   dhbailey@lbl.gov	  
+	  
+C++	  usage	  guide:	  
+Alex	  Kaiser	  	   	  
+Lawrence	  Berkeley	  Natl	  Lab	  	   adkaiser@lbl.gov	  
+	  
+This	  work	  was	  supported	  by	  the	  Director,	  Office	  of	  Science,	  Division	  of	  Mathematical,	  
+Information,	  and	  Computational	  Sciences	  of	  the	  U.S.	  Department	  of	  Energy	  under	  contract	  
+number	  DE-­‐AC02-­‐05CH11231.	  
+	  
+This	  work	  was	  supported	  by	  the	  Director,	  Office	  of	  Science,	  Division	  of	  Mathematical,	  
+Information,	  and	  Computational	  Sciences	  of	  the	  U.S.	  Department	  of	  Energy	  under	  contract	  
+numbers	  DE-­‐AC03-­‐76SF00098	  and	  DE-­‐AC02-­‐05CH11231.	  
+	  
+***	  IMPORTANT	  NOTES:	  
+	  
+See	  the	  file	  COPYING	  for	  modified	  BSD	  license	  information.	  
+See	  the	  file	  INSTALL	  for	  installation	  instructions.	  
+See	  the	  file	  NEWS	  for	  recent	  revisions.	  
+	  
+Outline:	  
+	  
+I.	  	  	  Introduction	  
+II.	  	  Directories	  and	  Files	  
+III.	  C++	  Usage	  
+IV.	  	  Fortran	  Usage	  
+V.	  	  	  Note	  on	  x86-­‐Based	  Processors	  (MOST	  systems	  in	  use	  today)	  
+	  
+	  
+I.	  Introduction	  
+	  
+This	  package	  provides	  numeric	  types	  of	  twice	  the	  precision	  of	  IEEE	  double	  (106	  mantissa	  
+bits,	  or	  approximately	  32	  decimal	  digits)	  and	  four	  times	  the	  precision	  of	  IEEE	  double	  (212	  
+mantissa	  bits,	  or	  approximately	  64	  decimal	  digits).	  	  Due	  to	  features	  such	  as	  operator	  and	  
+function	  overloading,	  these	  facilities	  can	  be	  utilized	  with	  only	  minor	  modifications	  to	  
+conventional	  C++	  and	  Fortran-­‐90	  programs.	  
+	  
+In	  addition	  to	  the	  basic	  arithmetic	  operations	  (add,	  subtract,	  multiply,	  divide,	  square	  root),	  
+common	  transcendental	  functions	  such	  as	  the	  exponential,	  logarithm,	  trigonometric	  and	  
+hyperbolic	  functions	  are	  also	  included.	  	  A	  detailed	  description	  of	  the	  algorithms	  used	  is	  
+
+available	  in	  the	  docs	  subdirectory	  (see	  docs/qd.ps).	  	  An	  abridged	  version	  of	  this	  paper,	  
+which	  was	  presented	  at	  the	  ARITH-­‐15	  conference,	  is	  also	  available	  in	  this	  same	  directory	  
+(see	  docs/arith15.ps).	  
+	  
+II.	  Directories	  and	  Files	  
+	  
+There	  are	  six	  directories	  and	  several	  files	  in	  the	  main	  directory	  of	  this	  distribution,	  
+described	  below	  
+	  
+src	  	  	   This	  contains	  the	  source	  code	  of	  the	  quad-­‐double	  and	  double-­‐double	  
+	  	  
+	  
+library.	  	  This	  source	  code	  does	  not	  include	  inline	  functions,	  
+	  	  
+	  
+which	  are	  found	  in	  the	  header	  files	  in	  the	  include	  directory.	  
+	  
+include	  	  This	  directory	  contains	  the	  header	  files.	  
+	  
+fortran	  	  This	  directory	  contains	  Fortran-­‐90	  files.	  
+	  
+tests	   This	  directory	  contains	  some	  simple	  (not	  comprehensive)	  tests.	  
+	  
+docs	  	   This	  directory	  contains	  two	  papers	  describing	  the	  algorithms.	  
+	  
+config	  	  	  This	  directory	  contains	  various	  scripts	  used	  by	  the	  configure	  
+	  	  
+	  
+script	  and	  the	  Makefile.	  
+	  
+	  
+	  
+	  
+C++	  Usage:	  	  
+	  
+Please	  note	  that	  all	  commands	  refer	  to	  a	  Unix-­‐type	  environment	  such	  as	  Mac	  OSX	  or	  Ubuntu	  
+Linux	  using	  the	  bash	  shell.	  	  
+	  
+	  
+A.	  Building	  
+	  
+To	  build	  the	  library,	  first	  run	  the	  included	  configure	  script	  by	  typing	  	  
+	  
+./configure	  
+	  
+This	  script	  automatically	  generates	  makefiles	  for	  building	  the	  library	  and	  selects	  compilers	  
+and	  necessary	  flags	  and	  libraries	  to	  include.	  If	  the	  user	  wishes	  to	  specify	  compilers	  or	  flags	  
+they	  may	  use	  the	  following	  options.	  	  
+	  
+CXX	  	  	  	  	  	  	  	  
+C++	  compiler	  to	  use	  
+CXXFLAGS	  	  	   C++	  compiler	  flags	  to	  use	  
+CC	  	  	  	  	  	  	  	  	   	  
+C	  compiler	  to	  use	  (for	  C	  demo	  program)	  
+CFLAGS	  	  	  	  	  
+C	  compiler	  flags	  to	  use	  (for	  C	  demo	  program)	  
+FC	  	  	  	  	  	  	  	  	   	  
+Fortran	  90	  compiler	  
+FCFLAGS	  	  	  	  
+Fortran	  90	  compiler	  flags	  to	  use	  
+FCLIBS	  	  	  	  	  
+Fortran	  90	  libraries	  needed	  to	  link	  with	  C++	  code.	  
+	  
+
+For	  example,	  if	  one	  is	  using	  GNU	  compilers,	  configure	  with:	  
+	  
+./configure	  CXX=g++	  FC=gfortran	  
+	  
+The	  Fortran	  and	  C++	  compilers	  must	  produce	  compatible	  binaries.	  On	  some	  systems	  
+additional	  flags	  must	  be	  included	  to	  ensure	  that	  portions	  of	  the	  library	  are	  not	  built	  with	  32	  
+and	  64	  bit	  object	  files.	  For	  example,	  on	  64-­‐Bit	  Mac	  OSX	  10.6	  (Snow	  Leopard)	  the	  correct	  
+configure	  line	  using	  GNU	  compilers	  is:	  	  
+	  
+	  ./configure	  CXX=g++	  FC=gfortran	  FCFLAGS=-­‐m64	  
+	  
+To	  build	  the	  library,	  simply	  type	  	  
+	  
+make	  	  
+	  
+and	  the	  automatically	  generated	  makefiles	  will	  build	  the	  library	  including	  archive	  files.	  	  
+	  
+To	  allow	  for	  easy	  linking	  to	  the	  library,	  the	  user	  may	  also	  wish	  to	  install	  the	  archive	  files	  to	  a	  
+standard	  place.	  To	  do	  this	  type:	  
+	  
+make	  install	  
+	  
+This	  will	  also	  build	  the	  library	  if	  it	  has	  not	  already	  been	  built.	  Many	  systems,	  including	  Mac	  
+and	  Ubuntu	  Linux	  systems,	  require	  administrator	  privileges	  to	  install	  the	  library	  at	  such	  
+standard	  places.	  On	  such	  systems,	  one	  may	  type:	  	  
+	  
+sudo	  make	  install	  	  
+	  
+instead	  if	  one	  has	  sufficient	  access.	  	  
+	  
+The	  directory	  ‘tests’	  contains	  programs	  for	  high	  precision	  quadrature	  and	  integer-­‐relation	  
+detection.	  To	  build	  such	  programs,	  type:	  
+	  
+	  
+make	  demo	  
+	  
+in	  the	  	  ‘tests’	  directory.	  	  
+	  
+B.	  Linking	  	  
+	  
+The	  simplest	  way	  to	  link	  to	  the	  library	  is	  to	  install	  it	  to	  a	  standard	  place	  as	  described	  above,	  
+and	  use	  the	  –l	  option.	  For	  example	  
+	  
+g++	  compileExample.cpp	  -­‐o	  compileExample	  -­‐l	  qd	  
+	  
+One	  can	  also	  use	  this	  method	  to	  build	  with	  make.	  A	  file	  called	  “compileExample.cpp”	  and	  the	  
+associated	  makefile	  “makeCompileExample”	  illustrate	  the	  process.	  	  
+	  
+A	  third	  alternative	  is	  to	  use	  a	  link	  script.	  If	  one	  types	  “make	  demo”	  in	  the	  test	  directory,	  the	  
+output	  produced	  gives	  guidance	  as	  to	  how	  to	  build	  the	  files.	  By	  following	  the	  structure	  of	  
+the	  compiling	  commands	  one	  may	  copy	  the	  appropriate	  portions,	  perhaps	  replacing	  the	  
+
+filename	  with	  an	  argument	  that	  the	  user	  can	  include	  at	  link	  time.	  An	  example	  of	  such	  a	  
+script	  is	  as	  follows:	  
+	  
+g++	  -­‐DHAVE_CONFIG_H	  	  	  -­‐I..	  -­‐I../include	  -­‐I../include	  	  	  -­‐O2	  	  -­‐MT	  $1.o	  -­‐MD	  -­‐MP	  -­‐MF	  
+.deps/qd_test.Tpo	  -­‐c	  -­‐o	  $1.o	  $1.cpp	  
+mv	  -­‐f	  .deps/$1.Tpo	  .deps/$1.Po	  
+g++	  	  -­‐O2	  	  	  	  -­‐o	  $1	  $1.o	  ../src/libqd.a	  –lm	  
+	  
+To	  use	  it,	  make	  the	  link	  script	  executable	  and	  type:	  
+	  
+./link.scr	  compileExample	  
+	  
+Note	  that	  the	  file	  extension	  is	  not	  included	  because	  the	  script	  handles	  all	  extensions,	  
+expecting	  the	  source	  file	  to	  have	  the	  extension	  ‘.cpp’	  .	  	  
+	  
+C.	  Programming	  techniques	  
+	  
+As	  much	  as	  possible,	  operator	  overloading	  is	  included	  to	  make	  basic	  programming	  as	  much	  
+like	  using	  standard	  typed	  floating-­‐point	  arithmetic.	  Changing	  many	  codes	  should	  be	  as	  
+simple	  as	  changing	  type	  statements	  and	  a	  few	  other	  lines.	  	  
+	  
+i.	  Constructors	  
+	  
+To	  create	  dd_real	  and	  qd_real	  variables	  calculated	  to	  the	  proper	  precision,	  one	  must	  use	  
+care	  to	  use	  the	  included	  constructors	  properly.	  Many	  computations	  in	  which	  variables	  are	  
+not	  explicitly	  typed	  to	  multiple-­‐precision	  may	  be	  evaluated	  with	  double-­‐precision	  
+arithmetic.	  The	  user	  must	  take	  care	  to	  ensure	  that	  this	  does	  not	  cause	  errors.	  In	  particular,	  
+an	  expression	  such	  as	  1.0/3.0	  will	  be	  evaluated	  to	  double	  precision	  before	  assignment	  or	  
+further	  arithmetic.	  Upon	  assignment	  to	  a	  multi-­‐precision	  variable,	  the	  value	  will	  be	  zero	  
+padded.	  This	  problem	  is	  serious	  and	  potentially	  difficult	  to	  debug.	  To	  avoid	  this,	  use	  the	  
+included	  constructors	  to	  force	  arithmetic	  to	  be	  performed	  in	  the	  full	  precision	  requested.	  
+Here	  is	  a	  list	  of	  the	  included	  constructors	  with	  brief	  descriptions:	  
+	  
+Type	  dd_real,	  with	  text	  of	  inline	  constructors	  included:	  	  
+	  
+Constructor	  
+Description	  	  
+	  
+	  
+dd_real(double	  hi,	  double	  lo)	  	  
+Initializes	  from	  two	  double	  precision	  values.	  	  
+{	  x[0]	  =	  hi;	  x[1]	  =	  lo;	  }	  
+	  
+	  
+	  
+dd_real()	  {x[0]	  =	  0.0;	  x[1]	  =	  0.0;	  }	  
+Default	  constructor	  initializes	  to	  zero.	  	  
+	  
+	  
+dd_real(double	  h)	  {	  x[0]	  =	  h;	  x[1]	  =	  0.0;	  }	  
+Initializes	  from	  a	  double	  precision	  value,	  
+	  
+setting	  the	  trailing	  part	  to	  zero.	  Use	  care	  to	  
+	  
+ensure	  that	  the	  trailing	  part	  should	  actually	  
+	  
+be	  set	  to	  zero.	  	  
+	  
+	  
+	  
+	  
+	  
+	  
+dd_real(int	  h)	  {	  
+Initializes	  from	  an	  integer	  value,	  setting	  the	  
+
+	  	  	  	  x[0]	  =	  (static_cast<double>(h));	  
+trailing	  part	  to	  zero.	  Use	  care	  to	  ensure	  that	  
+	  	  	  	  x[1]	  =	  0.0;	  
+the	  trailing	  part	  should	  actually	  be	  set	  to	  
+	  	  }	  
+zero.	  	  
+	  
+	  
+dd_real	  (const	  char	  *s);	  
+Initializes	  from	  a	  string.	  	  
+	  
+	  
+explicit	  dd_real	  (const	  double	  *d)	  {	  
+Initializes	  from	  a	  length	  two	  array	  of	  double	  
+	  	  	  	  x[0]	  =	  d[0];	  x[1]	  =	  d[1];	  
+precision	  values.	  	  
+	  	  }	  	  
+	  
+	  
+	  
+	  
+	  
+Type	  qd_real,	  with	  their	  functions	  included	  inline:	  	  
+	  
+Constructor	  	  
+Description	  	  
+	  
+	  
+inline	  qd_real::qd_real	  
+Initializes	  from	  four	  double	  precision	  values.	  	  
+(double	  x0,	  double	  x1,	  double	  x2,	  double	  x3)	   	  
+{	  
+	  
+	  	  	  
+	   x[0]	  =	  x0;	  
+	  
+	  	  	  
+	   x[1]	  =	  x1;	  
+	  
+	  	  	  
+	   x[2]	  =	  x2;	  
+	  
+	  	  	  
+	   x[3]	  =	  x3;	  
+	  
+}	  
+	  
+	  
+	  
+inline	  qd_real::qd_real(const	  double	  *xx)	  {	  
+Initializes	  from	  a	  length	  four	  array	  of	  double	  
+	  	  	  
+	   x[0]	  =	  xx[0];	  
+precision	  values.	  	  
+	  	  	  
+	   x[1]	  =	  xx[1];	  
+	  
+	  	  
+	   x[2]	  =	  xx[2];	  
+	  
+	  	  	  
+	   x[3]	  =	  xx[3];	  
+	  
+	  
+}	  
+	  
+	  
+	  
+inline	  qd_real::qd_real(double	  x0)	  {	  
+Initializes	  from	  a	  double	  precision	  value,	  
+	  	  	  
+	   x[0]	  =	  x0;	  
+setting	  the	  trailing	  part	  to	  zero.	  Use	  care	  to	  
+	  	  	  
+	   x[1]	  =	  x[2]	  =	  x[3]	  =	  0.0;	  
+ensure	  that	  the	  trailing	  part	  should	  actually	  
+}	  
+be	  set	  to	  zero.	  	  
+	  
+	  
+inline	  qd_real::qd_real()	  {	  
+Default	  constructor	  initializes	  to	  zero.	  	  
+	  
+	   x[0]	  =	  0.0;	  	  
+	  
+	  
+	   x[1]	  =	  0.0;	  	  
+	  
+	  
+	   x[2]	  =	  0.0;	  	  
+	  
+	  
+	   x[3]	  =	  0.0;	  	  
+	  
+}	  
+	  
+	  
+	  
+inline	  qd_real::qd_real(const	  dd_real	  &a)	  {	  
+Initializes	  from	  a	  double-­‐double	  value,	  
+	  	  	  
+	   x[0]	  =	  a._hi();	  
+setting	  the	  trailing	  part	  to	  zero.	  
+	  	  	  
+	   x[1]	  =	  a._lo();	  
+	  
+	  	  	  
+	   x[2]	  =	  x[3]	  =	  0.0;	  
+	  
+}	  
+	  
+inline	  qd_real::qd_real(int	  i)	  {	  
+Initializes	  from	  an	  integer	  value,	  setting	  the	  
+
+	  	  	  
+	   x[0]	  =	  static_cast<double>(i);	  
+trailing	  part	  to	  zero.	  Use	  care	  to	  ensure	  that	  
+	  	  	  
+	   x[1]	  =	  x[2]	  =	  x[3]	  =	  0.0;	  
+the	  trailing	  part	  should	  actually	  be	  set	  to	  
+}	  
+zero.	  	  
+	  
+	  
+	  
+	  
+Some	  examples	  of	  initialization	  are	  as	  follows	  
+	  
+	  
+qd_real	  x	  =	  “1.0”	  ;	  	  
+	  
+x	  /=	  3.0	  ;	  	  
+	  
+or	  	  
+	  
+	  
+qd_real	  x	  =	  qd_real(1.0)	  /	  3.0	  ;	  	  
+	  
+	  
+ii.	  Included	  functions	  and	  Constants	  	  
+	  
+Supported	  functions	  include	  assignment	  operators,	  comparisons,	  arithmetic	  and	  
+assignment	  operators,	  and	  increments	  for	  integer	  types.	  Standard	  C	  math	  functions	  such	  as	  
+exponentiation,	  trigonometric,	  logarithmic,	  hyperbolic,	  exponential	  and	  rounding	  functions	  
+are	  included.	  As	  in	  assignment	  statements,	  one	  must	  be	  careful	  with	  implied	  typing	  of	  
+constants	  when	  using	  these	  functions.	  Many	  codes	  need	  particular	  conversion	  for	  the	  power	  
+function,	  which	  is	  frequently	  used	  with	  constants	  that	  must	  be	  explicitly	  typed	  for	  multi-­‐
+precision	  codes.	  	  
+	  
+Many	  constants	  are	  included,	  which	  are	  global	  and	  calculated	  upon	  initialization.	  The	  
+following	  list	  of	  constants	  is	  calculated	  for	  both	  the	  dd_real	  and	  qd_real	  classes	  separately.	  
+Use	  care	  to	  select	  the	  correct	  value.	  The	  variables,	  with	  type	  signatures,	  are:	  
+	  
+Variable	  Name	  
+Explanation	  	  
+static	  const	  qd_real	  _2pi;	  
+Two	  pi.	  	  
+static	  const	  qd_real	  _pi;	  
+Pi.	  	  
+static	  const	  qd_real	  _3pi4;	  
+Three	  pi	  over	  four.	  	  
+static	  const	  qd_real	  _pi2;	  
+Pi	  over	  two.	  	  
+static	  const	  qd_real	  _pi4;	  
+Pi	  over	  four	  
+static	  const	  qd_real	  _e;	  
+e,	  the	  base	  of	  the	  natural	  logarithm.	  	  
+static	  const	  qd_real	  _log2;	  
+Natural	  logarithm	  of	  two.	  	  
+static	  const	  qd_real	  _log10;	  
+Natural	  logarithm	  of	  ten.	  	  
+static	  const	  qd_real	  _nan;	  
+Not	  a	  number.	  Behaves	  like	  a	  double-­‐
+	  
+precision	  nan.	  	  
+static	  const	  qd_real	  _inf;	  
+Infinity.	  Behaves	  like	  a	  double-­‐precision	  inf.	  	  
+static	  const	  double	  _eps;	  
+Estimated	  precision	  for	  dd_real	  or	  qd_real	  
+	  
+data	  type.	  
+static	  const	  double	  _min_normalized;	  
+Minimum	  absolute	  value	  represent	  able	  
+	  
+without	  denormalization.	  	  
+static	  const	  qd_real	  _max;	  
+Maximum	  representable	  value.	  	  
+static	  const	  qd_real	  _safe_max;	  
+Maximum	  safe	  value.	  Slightly	  smaller	  than	  
+	  
+maximum	  representable	  value.	  	  
+static	  const	  int	  _ndigits;	  
+Number	  of	  digits	  available	  for	  dd_real	  or	  
+
+	  
+qd_real	  datatypes.	  
+	  
+	  
+	  
+ii.	  Conversion	  of	  types	  	  
+	  
+Static	  casts	  may	  be	  used	  to	  convert	  constants	  between	  types.	  One	  may	  also	  use	  constructors	  
+to	  return	  temporary	  multi-­‐precision	  types	  within	  expressions,	  but	  should	  be	  careful,	  as	  this	  
+will	  waste	  memory	  if	  done	  repeatedly.	  For	  example:	  	  
+	  
+	  
+	   qd_real	  y	  ;	  	  
+y	  =	  sin(	  qd_real(4.0)	  /	  3.0	  )	  ;	  
+	  
+C–style	  casts	  may	  be	  used,	  but	  are	  not	  recommended.	  	  Dynamic	  and	  reinterpret	  casts	  are	  
+not	  supported	  and	  should	  be	  considered	  unreliable.	  Casting	  between	  multi-­‐precision	  and	  
+standard	  precision	  types	  can	  be	  dangerous,	  and	  care	  must	  be	  taken	  to	  ensure	  that	  programs	  
+are	  working	  properly	  and	  accuracy	  has	  not	  degraded	  by	  use	  of	  a	  misplaced	  type-­‐conversion.	  	  
+	  
+D.	  Available	  precision,	  Control	  of	  Precision	  Levels,	  
+	  
+The	  library	  provides	  greatly	  extended	  accuracy	  when	  compared	  to	  standard	  double	  
+precision.	  The	  type	  dd_real	  provides	  for	  106	  mantissa	  bits,	  or	  about	  32	  decimal	  digits.	  The	  
+type	  qd_real	  provides	  for	  212	  mantissa	  bits,	  or	  about	  64	  decimal	  digits.	  	  
+	  
+Both	  the	  dd_real	  and	  qd_real	  values	  use	  the	  exponent	  from	  the	  highest	  double-­‐precision	  
+word	  for	  arithmetic,	  and	  as	  such	  do	  not	  extend	  the	  total	  range	  of	  values	  available.	  That	  
+means	  that	  the	  maximum	  absolute	  value	  for	  either	  data	  type	  is	  the	  same	  as	  that	  of	  double-­‐
+precision,	  or	  approximately	  10^308.	  The	  precision	  near	  this	  range,	  however,	  is	  greatly	  
+increased.	  	  
+	  
+To	  ensure	  that	  arithmetic	  is	  carried	  out	  with	  proper	  precision	  and	  accuracy,	  one	  must	  call	  
+the	  function	  “fpu_fix_start”	  before	  performing	  any	  double-­‐double	  or	  quad-­‐double	  
+arithmetic.	  This	  forces	  all	  arithmetic	  to	  be	  carried	  out	  in	  64-­‐bit	  double	  precision,	  not	  the	  80-­‐
+bit	  precision	  that	  is	  found	  on	  certain	  compilers	  and	  interferes	  with	  the	  existing	  library.	  	  
+	  
+	  
+	   unsigned	  int	  old_cw;	  
+	  
+fpu_fix_start(&old_cw);	  
+	  
+To	  return	  standard	  settings	  for	  arithmetic	  on	  one’s	  system,	  call	  the	  function	  “fpu_fix_end”.	  
+For	  example:	  
+	  
+	  
+fpu_fix_end(&old_cw);	  
+	  
+	  
+E.	  I/O	  	  
+	  
+The	  standard	  I/O	  stream	  routines	  have	  been	  overloaded	  to	  be	  fully	  compatible	  with	  all	  
+included	  data	  types.	  One	  may	  need	  to	  manually	  reset	  the	  precision	  of	  the	  stream	  to	  obtain	  
+full	  output.	  For	  example,	  if	  60	  digits	  are	  desired,	  use:	  	  
+	  
+cout.precision(60)	  ;	  	  
+
+	  
+When	  reading	  values	  using	  cin,	  each	  input	  numerical	  value	  must	  start	  on	  a	  separate	  
+line.	  	  Two	  formats	  are	  acceptable:	  
+	  
+	  
+1.	  Write	  the	  full	  constant	  	  
+	  
+3.	  Mantissa	  e	  exponent	  
+	  
+Here	  are	  three	  valid	  examples:	  
+	  
+	  
+1.1	  
+	  
+3.14159	  26535	  89793	  
+	  
+123.123123e50	  
+	  
+	  
+When	  read	  using	  cin,	  these	  constants	  will	  be	  converted	  using	  full	  multi-­‐precision	  accuracy.	  
+	  
+	  
+IV.	  Fortran-­‐90	  Usage	  
+	  
+NEW	  (2007-­‐01-­‐10):	  The	  Fortran	  translation	  modules	  now	  support	  the	  complex	  datatypes	  
+"dd_complex"	  and	  "qd_complex".	  
+	  
+Since	  the	  quad-­‐double	  library	  is	  written	  in	  C++,	  it	  must	  be	  linked	  in	  with	  a	  C++	  compiler	  (so	  
+that	  C++	  specific	  things	  such	  as	  static	  initializations	  are	  correctly	  handled).	  	  Thus	  the	  main	  
+program	  must	  be	  written	  in	  C/C++	  and	  call	  the	  Fortran	  90	  subroutine.	  The	  Fortran	  90	  
+subroutine	  should	  be	  called	  f_main.	  
+	  
+Here	  is	  a	  sample	  Fortran-­‐90	  program,	  equivalent	  to	  the	  above	  C++	  program:	  
+	  
+	  	  subroutine	  f_main	  
+	  
+use	  qdmodule	  	  
+	  
+implicit	  none	  
+	  
+type	  (qd_real)	  a,	  b	  
+	  
+integer*4	  old_cw	  
+	  
+	  
+call	  f_fpu_fix_start(old_cw)	  
+	  
+a	  =	  1.d0	  
+	  
+b	  =	  cos(a)**2	  +	  sin(a)**2	  -­‐	  1.d0	  
+	  
+call	  qdwrite(6,	  b)	  
+	  
+stop	  
+	  	  end	  subroutine	  
+	  
+This	  verifies	  that	  cos^2(1)	  +	  sin^2(1)	  =	  1	  to	  64	  digit	  accuracy.	  
+	  
+Most	  operators	  and	  generic	  function	  references,	  including	  many	  mixed-­‐mode	  type	  
+combinations	  with	  double-­‐precision	  (ie	  real*8),	  have	  been	  overloaded	  (extended)	  to	  work	  
+with	  double-­‐double	  and	  quad-­‐double	  data.	  	  It	  is	  important,	  however,	  that	  users	  keep	  in	  
+mind	  the	  fact	  that	  expressions	  are	  evaluated	  strictly	  according	  to	  conventional	  Fortran	  
+operator	  precedence	  rules.	  	  Thus	  some	  subexpressions	  may	  be	  evaluated	  only	  to	  15-­‐digit	  
+accuracy.	  For	  example,	  with	  the	  code	  
+
+	  
+	  	  	  real*8	  d1	  
+	  	  	  type	  (dd_real)	  t1,	  t2	  
+	  	  	  ...	  
+	  	  	  t1	  =	  cos	  (t2)	  +	  d1/3.d0	  
+	  
+the	  expression	  d1/3.d0	  is	  computed	  to	  real*8	  accuracy	  only	  (about	  15	  digits),	  since	  both	  d1	  
+and	  3.d0	  have	  type	  real*8.	  	  This	  result	  is	  then	  converted	  to	  dd_real	  by	  zero	  extension	  before	  
+being	  added	  to	  cos(t2).	  So,	  for	  example,	  if	  d1	  held	  the	  value	  1.d0,	  then	  the	  quotient	  d1/3.d0	  
+would	  only	  be	  accurate	  to	  15	  digits.	  	  If	  a	  fully	  accurate	  double-­‐double	  quotient	  is	  required,	  
+this	  should	  be	  written:	  
+	  
+	  	  real*8	  d1	  
+	  	  type	  (dd_real)	  t1,	  t2	  
+	  	  	  ...	  
+	  	  t1	  =	  cos	  (t2)	  +	  ddreal	  (d1)	  /	  3.d0	  
+	  
+which	  forces	  all	  operations	  to	  be	  performed	  with	  double-­‐double	  arithmetic.	  
+	  
+Along	  this	  line,	  a	  constant	  such	  as	  1.1	  appearing	  in	  an	  expression	  is	  evaluated	  only	  to	  real*4	  
+accuracy,	  and	  a	  constant	  such	  as	  1.1d0	  is	  evaluated	  only	  to	  real*8	  accuracy	  (this	  is	  
+according	  to	  standard	  Fortran	  conventions).	  	  If	  full	  quad-­‐double	  accuracy	  is	  required,	  for	  
+instance,	  one	  should	  write	  
+	  
+	  	  	  type	  (qd_real)	  t1	  
+	  	  	  ...	  
+	  	  	  t1	  =	  '1.1'	  
+	  
+The	  quotes	  enclosing	  1.1	  specify	  to	  the	  compiler	  that	  the	  constant	  is	  to	  be	  converted	  to	  
+binary	  using	  quad-­‐double	  arithmetic,	  before	  assignment	  to	  t1.	  	  Quoted	  constants	  may	  only	  
+appear	  in	  assignment	  statements	  such	  as	  this.	  
+	  
+To	  link	  a	  Fortran-­‐90	  program	  with	  the	  C++	  qd	  library,	  it	  is	  	  recommended	  to	  link	  with	  the	  
+C++	  compiler	  used	  to	  generate	  the	  library.	  	  	  The	  Fortran	  90	  interface	  (along	  with	  a	  C-­‐style	  
+main	  function	  calling	  f_main)	  is	  found	  in	  qdmod	  library.	  	  The	  qd-­‐config	  script	  installed	  
+during	  "make	  install"	  can	  be	  used	  to	  determine	  which	  flags	  to	  pass	  to	  compile	  and	  link	  your	  
+programs:	  
+	  
+	  	  "qd-­‐config	  -­‐-­‐fcflags"	  	  displays	  compiler	  flags	  needed	  to	  compile	  your	  Fortran	  files.	  
+	  	  "qd-­‐config	  -­‐-­‐fclibs"	  	  	  displays	  linker	  flags	  needed	  by	  the	  C++	  linker	  to	  link	  in	  all	  the	  	  
+necessary	  libraries.	  
+	  
+A	  sample	  Makefile	  that	  can	  be	  used	  as	  a	  template	  for	  compiling	  Fortran	  programs	  using	  
+quad-­‐double	  library	  is	  found	  in	  fortran/Makefile.sample.	  
+	  
+F90	  functions	  defined	  with	  dd_real	  arguments:	  
+	  	  Arithmetic:	  	  +	  -­‐	  *	  /	  **	  
+	  	  Comparison	  tests:	  	  ==	  <	  >	  <=	  >=	  /=	  
+	  	  Others:	  abs,	  acos,	  aint,	  anint,	  asin,	  atan,	  atan2,	  cos,	  cosh,	  dble,	  erf,	  
+	  	  erfc,	  exp,	  int,	  log,	  log10,	  max,	  min,	  mod,	  ddcsshf	  (cosh	  and	  sinh),	  
+
+	  	  ddcssnf	  (cos	  and	  sin),	  ddranf	  (random	  number	  generator	  in	  (0,1)),	  	  
+	  	  ddnrtf	  (n-­‐th	  root),	  sign,	  sin,	  sinh,	  sqr,	  sqrt,	  tan,	  tanh	  
+Similar	  functions	  are	  provided	  for	  qd_real	  arguments	  (with	  function	  
+	  	  names	  qdcsshf,	  qdcssnf,	  qdranf	  and	  qdnrtf	  instead	  of	  the	  names	  in	  
+	  	  the	  list	  above).	  
+	  
+Input	  and	  output	  of	  double-­‐double	  and	  quad-­‐double	  data	  is	  done	  using	  the	  special	  
+subroutines	  ddread,	  ddwrite,	  qdread	  and	  qdwrite.	  	  The	  first	  argument	  of	  these	  subroutines	  
+is	  the	  Fortran	  I/O	  unit	  number,	  while	  additional	  arguments	  (as	  many	  as	  needed,	  up	  to	  9	  
+arguments)	  are	  scalar	  variables	  or	  array	  elements	  of	  the	  appropriate	  type.	  	  Example:	  
+	  
+	  	  	  integer	  n	  
+	  	  	  type	  (qd_real)	  qda,	  qdb,	  qdc(n)	  
+	  	  	  ...	  
+	  	  	  call	  qdwrite	  (6,	  qda,	  qdb)	  
+	  	  	  do	  j	  =	  1,	  n	  
+	  
+	  call	  qdwrite	  (6,	  qdc(j))	  
+	  	  	  enddo	  
+	  
+Each	  input	  values	  must	  be	  on	  a	  separate	  line,	  and	  may	  include	  D	  or	  E	  exponents.	  	  Double-­‐
+double	  and	  quad-­‐double	  constants	  may	  also	  be	  specified	  in	  assignment	  statements	  by	  
+enclosing	  them	  in	  quotes,	  as	  in	  
+	  
+	  	  ...	  
+	  	  type	  (qd_real)	  pi	  
+	  	  ...	  
+	  	  pi	  =	  
+"3.14159265358979323846264338327950288419716939937510582097494459230"	  
+	  	  ...	  
+	  
+Sample	  Fortran-­‐90	  programs	  illustrating	  some	  of	  these	  features	  are	  provided	  in	  the	  f90	  
+subdirectory.	  
+	  
+	  
+V.	  Note	  on	  x86-­‐Based	  Processors	  (MOST	  systems	  in	  use	  today)	  
+	  
+The	  algorithms	  in	  this	  library	  assume	  IEEE	  double	  precision	  floating	  point	  arithmetic.	  	  Since	  
+Intel	  x86	  processors	  have	  extended	  (80-­‐bit)	  floating	  point	  registers,	  the	  round-­‐to-­‐double	  
+flag	  must	  be	  enabled	  in	  the	  control	  word	  of	  the	  FPU	  for	  this	  library	  to	  function	  properly	  
+under	  x86	  processors.	  	  The	  following	  functions	  contains	  appropriate	  code	  to	  facilitate	  
+manipulation	  of	  this	  flag.	  	  For	  non-­‐x86	  systems	  these	  functions	  do	  nothing	  (but	  still	  exist).	  
+	  
+fpu_fix_start	   This	  turns	  on	  the	  round-­‐to-­‐double	  bit	  in	  the	  control	  word.	  
+fpu_fix_end	  
+	  	  This	  restores	  the	  control	  flag.	  
+	  
+These	  functions	  must	  be	  called	  by	  the	  main	  program,	  as	  follows:	  
+	  
+	  
+int	  main()	  {	  
+	  
+	  	  unsigned	  int	  old_cw;	  
+	  
+	  	  fpu_fix_start(&old_cw);	  
+
+	  
+	  
+	  	  ...	  user	  code	  using	  quad-­‐double	  library	  ...	  
+	  
+	  
+	  	  fpu_fix_end(&old_cw);	  
+	  
+}	  
+	  
+A	  Fortran-­‐90	  example	  is	  the	  following:	  
+	  
+	  
+subroutine	  f_main	  
+	  
+use	  qdmodule	  
+	  
+implicit	  none	  
+	  
+integer*4	  old_cw	  
+	  
+	  
+call	  f_fpu_fix_start(old_cw)	  
+	  
+	  
+	  	  ...	  user	  code	  using	  quad-­‐double	  library	  ...	  
+	  
+	  
+call	  f_fpu_fix_end(old_cw)	  
+	  
+end	  subroutine	  
+	  
+
+
\ No newline at end of file
diff -Nur qd-2.3.12.orig/src/Makefile.am qd-2.3.12/src/Makefile.am
--- qd-2.3.12.orig/src/Makefile.am	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/src/Makefile.am	2012-01-12 19:49:45.000000000 +0000
@@ -1,9 +1,9 @@
 SRC = c_dd.cpp c_qd.cpp dd_real.cpp dd_const.cpp \
       fpu.cpp qd_real.cpp qd_const.cpp util.cpp bits.cpp util.h
 
-lib_LIBRARIES = libqd.a
+lib_LTLIBRARIES = libqd.la
 
-libqd_a_SOURCES = $(SRC)
+libqd_la_SOURCES = $(SRC)
 
 AM_CPPFLAGS = -I$(top_builddir) -I$(top_builddir)/include -I$(top_srcdir)/include
 
diff -Nur qd-2.3.12.orig/tests/Makefile.am qd-2.3.12/tests/Makefile.am
--- qd-2.3.12.orig/tests/Makefile.am	2012-01-12 19:44:25.000000000 +0000
+++ qd-2.3.12/tests/Makefile.am	2012-01-12 20:06:49.000000000 +0000
@@ -1,4 +1,4 @@
-LDADD = $(top_builddir)/src/libqd.a
+LDADD = $(top_builddir)/src/libqd.la
 AM_CPPFLAGS = -I$(top_builddir) -I$(top_builddir)/include -I$(top_srcdir)/include
 
 TESTS = qd_test pslq_test c_test
@@ -15,9 +15,9 @@
 
 f_test_SOURCES = f_test.f
 f_test_LINK=$(CXXLINK)
-f_test_LDADD = $(top_builddir)/fortran/libqdmod.a \
-               $(top_builddir)/fortran/libqd_f_main.a \
-               $(LDADD) $(top_builddir)/src/libqd.a $(FCLIBS)
+f_test_LDADD = $(top_builddir)/fortran/libqdmod.la \
+               $(top_builddir)/fortran/libqd_f_main.la \
+               $(LDADD) $(top_builddir)/src/libqd.la $(FCLIBS)
 endif
 
 CLEANFILES=qd_timer quadt_test huge
