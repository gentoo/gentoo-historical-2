diff -Naur scipy-0.6.0/scipy/linalg/generic_clapack.pyf scipy-0.6.0-new/scipy/linalg/generic_clapack.pyf
--- scipy-0.6.0/scipy/linalg/generic_clapack.pyf	2007-09-22 03:56:25.000000000 -0400
+++ scipy-0.6.0-new/scipy/linalg/generic_clapack.pyf	2007-10-13 10:13:53.000000000 -0400
@@ -20,7 +20,7 @@
    ! U is unit upper diagonal triangular, L is lower triangular,
    ! piv pivots columns.
 
-     fortranname  clapack_<tchar=s,d,c,z>gesv
+     fortranname  <tchar=s,d,c,z>gesv_
      integer intent(c,hide) ::  <tchar=s,d,c,z>gesv
      callstatement <tchar=s,d,c,z>gesv_return_value = info = (*f2py_func)(102-rowmajor,n,nrhs,a,n,piv,b,n)
      callprotoargument const int,const int,const int,<type_in_c>*,const int,int*,<type_in_c>*,const int
@@ -44,7 +44,7 @@
    ! Compute an LU factorization of a  general  M-by-N  matrix  A.
    ! A * P = L * U
      threadsafe
-     fortranname  clapack_<tchar=s,d,c,z>getrf
+     fortranname  <tchar=s,d,c,z>getrf_
      integer intent(c,hide) ::  <tchar=s,d,c,z>getrf
      callstatement <tchar=s,d,c,z>getrf_return_value = info = (*f2py_func)(102-rowmajor,m,n,a,(rowmajor?n:m),piv)
      callprotoargument const int,const int,const int,<type_in_c>*,const int,int*
@@ -67,7 +67,7 @@
    ! Solve A^H * X = B if trans=2
    ! A * P = L * U
 
-     fortranname  clapack_<tchar=s,d,c,z>getrs
+     fortranname  <tchar=s,d,c,z>getrs_
      integer intent(c,hide) ::  <tchar=s,d,c,z>getrs
      callstatement <tchar=s,d,c,z>getrs_return_value = info = (*f2py_func)(102-rowmajor,111+trans,n,nrhs,lu,n,piv,b,n)
      callprotoargument const int,const int,const int,const int,<type_in_c>*,const int,int*,<type_in_c>*,const int
@@ -91,7 +91,7 @@
    ! Find A inverse A^-1.
    ! A * P = L * U
 
-     fortranname  clapack_<tchar=s,d,c,z>getri
+     fortranname  <tchar=s,d,c,z>getri_
      integer intent(c,hide) ::  <tchar=s,d,c,z>getri
      callstatement <tchar=s,d,c,z>getri_return_value = info = (*f2py_func)(102-rowmajor,n,lu,n,piv)
      callprotoargument const int,const int,<type_in_c>*,const int,const int*
@@ -115,7 +115,7 @@
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
-     fortranname  clapack_<tchar=s,d,c,z>posv
+     fortranname  <tchar=s,d,c,z>posv_
      integer intent(c,hide) ::  <tchar=s,d,c,z>posv
      callstatement <tchar=s,d,c,z>posv_return_value = info = (*f2py_func)(102-rowmajor,121+lower,n,nrhs,a,n,b,n)
      callprotoargument const int,const int,const int,const int,<type_in_c>*,const int,<type_in_c>*,const int
@@ -142,7 +142,7 @@
      ! C is triangular matrix of the corresponding Cholesky decomposition.
      ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
-     fortranname  clapack_<tchar=s,d>potrf
+     fortranname  <tchar=s,d>potrf_
      integer intent(c,hide) ::  <tchar=s,d>potrf
      callstatement <tchar=s,d>potrf_return_value = info = (*f2py_func)(102-rowmajor,121+lower,n,a,n); if(clean){int i,j;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+i*n+j)=0.0;} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) *(a+j*n+i)=0.0;}}
      callprotoargument const int,const int,const int,<type_in_c>*,const int
@@ -167,7 +167,7 @@
      ! C is triangular matrix of the corresponding Cholesky decomposition.
      ! clean==1 zeros strictly lower or upper parts of U or L, respectively
 
-     fortranname  clapack_<tchar=c,z>potrf
+     fortranname  <tchar=c,z>potrf_
      integer intent(c,hide) ::  <tchar=c,z>potrf
      callstatement <tchar=c,z>potrf_return_value = info = (*f2py_func)(102-rowmajor,121+lower,n,a,n); if(clean){int i,j,k;if(lower){for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=i*n+j;(a+k)->r=(a+k)->i=0.0;}} else {for(i=0;i<n;++i) for(j=i+1;j<n;++j) {k=j*n+i;(a+k)->r=(a+k)->i=0.0;}}}
      callprotoargument const int,const int,const int,<type_in_c>*,const int
@@ -193,7 +193,7 @@
    ! A = L * L^T, C = L if lower = 1
    ! C is triangular matrix of the corresponding Cholesky decomposition.
 
-     fortranname  clapack_<tchar=s,d,c,z>potrs
+     fortranname  <tchar=s,d,c,z>potrs_
      integer intent(c,hide) ::  <tchar=s,d,c,z>potrs
      callstatement <tchar=s,d,c,z>potrs_return_value = info = (*f2py_func)(102-rowmajor,121+lower,n,nrhs,c,n,b,n)
      callprotoargument const int,const int,const int,const int,<type_in_c>*,const int,<type_in_c>*,const int
@@ -219,7 +219,7 @@
      ! A = L * L^T, C = L if lower = 1
      ! C is triangular matrix of the corresponding Cholesky decomposition.
 
-     fortranname  clapack_<tchar=s,d,c,z>potri
+     fortranname  <tchar=s,d,c,z>potri_
      integer intent(c,hide) ::  <tchar=s,d,c,z>potri
      callstatement <tchar=s,d,c,z>potri_return_value = info = (*f2py_func)(102-rowmajor,121+lower,n,c,n)
      callprotoargument const int,const int,const int,<type_in_c>*,const int
@@ -243,7 +243,7 @@
      ! L * L^T, C = L if lower = 1
      ! C is triangular matrix of the corresponding Cholesky decomposition.
 
-     fortranname  clapack_<tchar=s,d,c,z>lauum
+     fortranname  <tchar=s,d,c,z>lauum_
      integer intent(c,hide) ::  <tchar=s,d,c,z>lauum
      callstatement <tchar=s,d,c,z>lauum_return_value = info = (*f2py_func)(102-rowmajor,121+lower,n,c,n)
      callprotoargument const int,const int,const int,<type_in_c>*,const int
@@ -267,7 +267,7 @@
      ! C is non-unit triangular matrix if unitdiag = 0
      ! C is unit triangular matrix if unitdiag = 1
 
-     fortranname  clapack_<tchar=s,d,c,z>trtri
+     fortranname  <tchar=s,d,c,z>trtri_
      integer intent(c,hide) ::  <tchar=s,d,c,z>trtri
      callstatement <tchar=s,d,c,z>trtri_return_value = info = (*f2py_func)(102-rowmajor,121+lower,131+unitdiag,n,c,n)
      callprotoargument const int,const int,const int,const int,<type_in_c>*,const int
