#!/sbin/runscript 
# Copyright 1999-2004 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License v2
# $Header: /var/cvsroot/gentoo-x86/net-zope/zope/files/2.6.1/zope.initd,v 1.4 2004/07/18 04:31:00 dragonheart Exp $

python=

depend() 
{
    need net
}

# Since zope doesn't delete its .pid file when done, we have to determine its 
# status. Zope can be shutdown from a browser...this bypasses init.d. 

# Need to export these conf.d variables so that (env) can use them

setup_exports()
{
local EXPORT_LST="INSTANCE_HOME SOFTWARE_HOME ZOPE_HOME FORCE_PRODUCT_LOAD \
PROFILE_PUBLISHER SUPPRESS_ACCESSRULE SUPPRESS_SITEROOT CLIENT_HOME \
ZEO_CLIENT EVENT_LOG_FORMAT EVENT_LOG_FILE EVENT_LOG_SEVERITY ZSYSLOG \
ZSYSLOG_FACILITY ZSYSLOG_SERVER ZSYSLOG_ACCESS ZSYSLOG_ACCESS_FACILITY \
ZSYSLOG_ACCESS_SERVER Z_DEBUG_MODE Z_REALM NO_SECURITY ZOPE_SECURITY_POLICY \
ZSP_OWNEROUS_SKIP ZSP_AUTHENTICATED_SKIP DISALLOW_LOCAL_PRODUCTS \
ZOPE_DATABASE_QUOTA ZOPE_READ_ONLY ZSESSION_ADD_NOTIFY ZSESSION_DEL_NOTIFY \
ZSESSION_TIMEOUT_MINS ZSESSION_OBJECT_LIMIT WEBDAV_SOURCE_PORT_CLIENTS \
STX_DEFAULT_LEVEL ZOPE_DTML_REQUEST_AUTOQUOTE Z_MAX_STACK_SIZE \
FORCE_PRODUCT_RELOAD"

for N in $EXPORT_LST ; do
    if [ -n "${N}" ] ; then export ${N} ; fi
done
}

# Check if the file exist. then send file to stdout.
# Parameters:
#    $1 = /path/to/pid.file
# Outputs:

read_pid()
{
    if [ -f "${1}" ] ; then
	cat ${1}
    fi
}

# Check if we have a living PID, if not delete the PID FILE
# Parameters:
#    $1 = /path/to/pid.file
# Returns:
#    0 if alive pid file remains
#    1 if dead pid file removed
#    2 if no pid file found

check_pid_status()
{
    local RESULT=2   # assume no pid file will be found
    local PID=$(read_pid ${1})

    if [ -n "${PID}" ] ; then
	ps --no-headers ${PID} > /dev/null 2>&1
	if [ "${?}" -eq 0 ] ; then
	    RESULT=0
	else
	    rm -f ${1} 
	    RESULT=1
	fi
    fi

    return ${RESULT}
}

# Parameters: 
#    None
# Returns:
#    0 true 
#    1 false and echos /pathname/to/pid/file

is_zope_dead()
{
    local RESULT=

    if [ -n "${INSTANCE_HOME}" ] ; then
	loc=${INSTANCE_HOME}
    else
	loc=${ZOPE_HOME}
    fi

    check_pid_status ${loc}/var/Z2.pid
    RESULT=${?}
    if [ "${RESULT}" -eq 0 ] ; then 
	echo "${loc}"
	RESULT=10
	break    # found a live pid
    fi

    if [ "${RESULT}" -eq 10 ] ; then
	RESULT=1
    else
	RESULT=0
    fi

    return ${RESULT}
}

status()
{ 

    if is_zope_dead ; then
	eerror "--> Zope is dead."
    else
	einfo "--> Zope is alive."
    fi

    return ${?}
}

# If Zope is dead, remove PID file and start zope.
# The idea with 'env' is that a environment snapshot
# (current vars + /etc/conf.d/zope?) is created for zope to use.

start_zope()
{
    local RESULT=

    is_zope_dead >/dev/null
    RESULT=${?}
    if [ "${RESULT}" -eq 0 ] ; then
	setup_exports
	umask 077    # Recommended by Zope
	env /usr/bin/${python} ${ZOPE_HOME}z2.py ${ZOPE_OPTS} &         
	RESULT=${?}
    else
	echo 'Zope is running independant of RC management.'
	echo 'We are going to try and  kill it.'
	stop_zope
	if [ "${?}" -eq 0 ] ; then
	    echo 'Successfully killed zope. Try to start zope again'
	fi
    fi

    return ${RESULT}
}

# If Zope is alive, kill it.

stop_zope()
{
    local PID=$(is_zope_dead)

    if [ -n "${PID}" ] ; then
	kill $(cat ${PID}/var/Z2.pid)    # Not sure if kill always succeeds, so not removeing .pid file.
    fi
    return $?
}

# 

start()
{
    ebegin "Starting zope"
    start_zope
    eend $? "Failed to start zope"
}

#

stop()
{
    ebegin "Stopping zope"
    stop_zope
    eend $? "Failed to stop zope"
}
