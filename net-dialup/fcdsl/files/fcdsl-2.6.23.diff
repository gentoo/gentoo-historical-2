--- src.fcdsl/driver.h.orig	2007-12-25 17:47:47.000000000 +0100
+++ src.fcdsl/driver.h	2007-12-25 16:01:55.000000000 +0100
@@ -23,7 +23,6 @@
 #ifndef __have_driver_h__
 #define __have_driver_h__
 
-#include <linux/autoconf.h>
 #include <linux/pci.h>
 #include <linux/list.h>
 #include <linux/skbuff.h>
@@ -140,7 +139,7 @@
 /*---------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/
 extern int avm_driver_init (void);
-extern void avm_driver_exit (void);
+extern void driver_exit (void);
 
 #endif
 
--- src.fcdsl/driver.c.orig	2007-12-25 17:47:47.000000000 +0100
+++ src.fcdsl/driver.c	2007-12-25 16:01:55.000000000 +0100
@@ -18,10 +18,6 @@
  * http://www.opensource.org/licenses/lgpl-license.html
  * 
  * Contact: AVM GmbH, Alt-Moabit 95, 10559 Berlin, Germany, email: info@avm.de
- *
- * Mon Oct 20 22:43:31 2003
- * Modified by Joerg Lehrke to improve locking 
- * Fixed for rev 0.4.1 by Stefan Schweizer
  */
 
 #include <asm/io.h>
@@ -61,8 +57,6 @@
 #include "dbgif.h"
 #endif
 
-#undef SINGLE_LOCK
-
 #define	KILOBYTE		1024
 #define	MEGABYTE		(1024*KILOBYTE)
 #define	DMA_BUFFER_SIZE		(9*KILOBYTE)
@@ -108,11 +102,7 @@
 static struct capi_ctr		capi_ctrl[2];
 static int			capi_ctrl_ix		= 0;
 static per_ctrl_t		ctrl_params[2];
-#if defined (SINGLE_LOCK)
-# define stack_lock qt_lock
-#else
 static spinlock_t		stack_lock		= SPIN_LOCK_UNLOCKED;
-#endif
 static atomic_t			rx_flag			= ATOMIC_INIT (0);
 static atomic_t			tx_flag			= ATOMIC_INIT (0);
 static atomic_t			thread_flag		= ATOMIC_INIT (0);
@@ -210,7 +200,7 @@
 		cp->rx_dmabuf = NULL;
 		goto dma_rx_exit;
 	}
-	res = request_irq (cp->irq, &irq_handler, SA_INTERRUPT | SA_SHIRQ, TARGET, cp);
+	res = request_irq (cp->irq, &irq_handler, IRQF_DISABLED | IRQF_SHARED, TARGET, cp);
 	if (res) {
 		LOG("Could not install irq handler.\n");
 		goto dma_tx_exit;
@@ -1157,7 +1147,7 @@
 } /* remove_ctrl */
 
 /*---------------------------------------------------------------------------*\
-\*---------------------------------------------------------------------------*/
+\*-C-------------------------------------------------------------------------*/
 static inline int in_critical (void) {
 	
 	return (0 < atomic_read (&crit_count));
@@ -1316,7 +1306,7 @@
 	capi_ctr_handle_message (ctrl, appl, skb);
 } /* msg2capi */
 
-/*---------------------------------------------------------------------------*\
+/*-S-------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/
 static __attr void __stack scheduler_control (unsigned ena) {
 	int	enabled = (int) ena;
@@ -1334,7 +1324,6 @@
 /*---------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/ 
 static int sched_thread (void * arg) {
-        unsigned long	flags;
 
 	UNUSED_ARG (arg);
 	daemonize (TARGET);
@@ -1368,7 +1357,6 @@
 		}
 
 		/* Body of thread, invoke scheduler */
-		local_irq_save(flags);
 		if (spin_trylock (&stack_lock)) {
 			os_timer_poll ();
 			assert (capi_lib->cm_schedule);
@@ -1377,7 +1365,6 @@
 			}
 			spin_unlock (&stack_lock);
 		}
-		local_irq_restore(flags);
 	}
 	LOG("Scheduler thread stopped.\n");
 	up (&hotplug);
@@ -1483,22 +1470,17 @@
 /*---------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/
 static void tx_task (unsigned long data) {
-        unsigned long	flags;
-
+	
 	UNUSED_ARG (data);
 	if (in_critical ()) {
 		atomic_set (&tx_flag, 1);
 		kick_scheduler ();
+	} else if (spin_trylock (&stack_lock)) {
+		tx_handler (capi_card);
+		spin_unlock (&stack_lock);
 	} else {
-		local_irq_save(flags);
-		if (spin_trylock (&stack_lock)) {
-			tx_handler (capi_card);
-			spin_unlock (&stack_lock);
-		} else {
-			atomic_set (&tx_flag, 1);
-			kick_scheduler ();
-		}
-		local_irq_restore(flags);
+		atomic_set (&tx_flag, 1);
+		kick_scheduler ();
 	}
 } /* tx_task */
 
@@ -1551,22 +1533,17 @@
 /*---------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/
 static void rx_task (unsigned long data) {
-        unsigned long	flags;
 	
 	UNUSED_ARG (data);
 	if (in_critical ()) {
 		atomic_set (&rx_flag, 1);
 		kick_scheduler ();
+	} else if (spin_trylock (&stack_lock)) {
+		rx_handler (capi_card);
+		spin_unlock (&stack_lock);
 	} else {
-		local_irq_save(flags);
-		if (spin_trylock (&stack_lock)) {
-			rx_handler (capi_card);
-			spin_unlock (&stack_lock);
-		} else {
-			atomic_set (&rx_flag, 1);
-			kick_scheduler ();
-		}
-		local_irq_restore(flags);
+		atomic_set (&rx_flag, 1);
+		kick_scheduler ();
 	}
 } /* rx_task */
 
@@ -1584,7 +1561,6 @@
 		return IRQ_NONE;
 	}
 	cp = (card_p) args;
-	spin_lock (&stack_lock);
 	while (0 != ((flags = PEEK (cp->io_base + INT_CTL)) & CARD_PCI_INT_ASSERT)) {
 		++count;
 		assert (count < 3);
@@ -1595,7 +1571,6 @@
 		assert ((PEEK (cp->io_base + INT_CTL) 
 				& ~(CARD_PCI_INT_ASSERT | CARD_PCI_INT_ISASSERTED)) != 0);
 		if (!atomic_read (&link_open)) {
-			spin_unlock (&stack_lock);
 			return IRQ_HANDLED;
 		}
 		tx_flag = PEEK (cp->io_base + XFER_TOTM_STATUS) == TM_READY;
@@ -1610,7 +1585,6 @@
 		}
 	}
 	info (0 == (PEEK (cp->io_base + INT_CTL) & CARD_PCI_INT_ASSERT));
-	spin_unlock (&stack_lock);
 	return IRQ_RETVAL(count > 0);
 } /* irq_handler */
 
@@ -1829,12 +1803,12 @@
 
 /*---------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/
-void avm_driver_exit (void) {
+void driver_exit (void) {
 
 	assert (capi_lib != NULL);
 	free_library ();
 	capi_lib = NULL;
-} /* avm_driver_exit */
+} /* driver_exit */
 
 /*---------------------------------------------------------------------------*\
 \*---------------------------------------------------------------------------*/
--- src.fcdsl/main.c.orig	2007-12-25 17:47:47.000000000 +0100
+++ src.fcdsl/main.c	2007-12-25 17:41:12.000000000 +0100
@@ -23,7 +23,6 @@
 #include <stdarg.h>
 #include <asm/uaccess.h>
 #include <linux/pci.h>
-#include <linux/autoconf.h>
 #include <linux/version.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -72,6 +71,9 @@
 MODULE_PARM_DESC (VPI, "VPI - Virtual Path Identifier");
 MODULE_PARM_DESC (VCI, "VCI - Virtual Channel Identifier");
 
+/* Define new pci initialize, Arnd Feldmueller <arnd.feldmueller@web.de> */ 
+#define pci_module_init	pci_register_driver
+
 MODULE_LICENSE ("Proprietary");
 MODULE_DESCRIPTION ("CAPI4Linux: Driver for " PRODUCT_LOGO);
 
@@ -122,7 +124,9 @@
 	}
 	if (0 != (res = add_card (dev))) {
 		ERROR("Not loaded.\n");
-		avm_driver_exit ();
+		/* avm_driver_exit(); is old function, Arnd Feldmueller
+		   <arnd.feldmueller@web.de> */
+		driver_exit ();
 		return res;
 	}
 	NOTE("Loaded.\n");
@@ -143,7 +147,7 @@
 	NOTE("Removing...\n");
 	remove_ctrls (card);
 	NOTE("Removed.\n");
-	avm_driver_exit ();
+	driver_exit ();
 #ifndef NDEBUG
 	if (hallocated() != 0) {
 		ERROR( "%u bytes leaked.\n", hallocated());
@@ -196,7 +200,7 @@
 		return -ENOSYS;
 	}
 
-	if (0 == (err = pci_register_driver (&fcdsl_driver))) {
+	if (0 == (err = pci_module_init (&fcdsl_driver))) {
 		LOG("PCI driver registered.\n");
 		register_capi_driver (&fcdsl_capi_driver);
 		LOG("CAPI driver registered.\n");
