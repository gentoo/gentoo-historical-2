--- Modules/mmapmodule.c.orig	2005-09-20 21:04:42.000000000 +0200
+++ Modules/mmapmodule.c	2006-02-02 18:50:48.000000000 +0100
@@ -99,6 +99,8 @@
 #endif /* MS_WINDOWS */
 
 #ifdef UNIX
+	if (m_obj->fd >= 0)
+		(void) close(m_obj->fd);
 	if (m_obj->data!=NULL) {
 		msync(m_obj->data, m_obj->size, MS_SYNC);
 		munmap(m_obj->data, m_obj->size);
@@ -136,6 +138,8 @@
 #endif /* MS_WINDOWS */
 
 #ifdef UNIX
+	(void) close(self->fd);
+	self->fd = -1;
 	if (self->data != NULL) {
 		munmap(self->data, self->size);
 		self->data = NULL;
@@ -370,7 +374,7 @@
 {
 	unsigned long new_size;
 	CHECK_VALID(NULL);
-	if (!PyArg_ParseTuple (args, "l:resize", &new_size) || 
+	if (!PyArg_ParseTuple (args, "k:resize", &new_size) || 
 	    !is_resizeable(self)) {
 		return NULL;
 #ifdef MS_WINDOWS
@@ -459,10 +463,10 @@
 static PyObject *
 mmap_flush_method(mmap_object *self, PyObject *args)
 {
-	size_t offset	= 0;
-	size_t size = self->size;
+	unsigned long offset = 0;
+	unsigned long size = self->size;
 	CHECK_VALID(NULL);
-	if (!PyArg_ParseTuple (args, "|ll:flush", &offset, &size)) {
+	if (!PyArg_ParseTuple (args, "|kk:flush", &offset, &size)) {
 		return NULL;
 	} else if ((offset + size) > self->size) {
 		PyErr_SetString (PyExc_ValueError,
@@ -535,7 +539,7 @@
 {
 	unsigned long dest, src, count;
 	CHECK_VALID(NULL);
-	if (!PyArg_ParseTuple (args, "iii:move", &dest, &src, &count) ||
+	if (!PyArg_ParseTuple (args, "kkk:move", &dest, &src, &count) ||
 	    !is_writeable(self)) {
 		return NULL;
 	} else {
@@ -859,23 +863,24 @@
 	PyObject *map_size_obj = NULL;
 	int map_size;
 	int fd, flags = MAP_SHARED, prot = PROT_WRITE | PROT_READ;
-	access_mode access = ACCESS_DEFAULT;
-	char *keywords[] = {"fileno", "length", 
-			    "flags", "prot", 
-			    "access", NULL};
+	int access = (int)ACCESS_DEFAULT;
+	static const char *keywords[] = {"fileno", "length", 
+                                         "flags", "prot", 
+                                         "access", NULL};
 
 	if (!PyArg_ParseTupleAndKeywords(args, kwdict, "iO|iii", keywords, 
-					 &fd, &map_size_obj, &flags, &prot, &access))
+					 &fd, &map_size_obj, &flags, &prot,
+                                         &access))
 		return NULL;
 	map_size = _GetMapSize(map_size_obj);
 	if (map_size < 0)
 		return NULL;
 
-	if ((access != ACCESS_DEFAULT) && 
+	if ((access != (int)ACCESS_DEFAULT) && 
 	    ((flags != MAP_SHARED) || ( prot != (PROT_WRITE | PROT_READ))))
 		return PyErr_Format(PyExc_ValueError, 
 				    "mmap can't specify both access and flags, prot.");
-	switch(access) {
+	switch((access_mode)access) {
 	case ACCESS_READ:
 		flags = MAP_SHARED;
 		prot = PROT_READ;
@@ -901,15 +906,19 @@
 	/* on OpenVMS we must ensure that all bytes are written to the file */
 	fsync(fd);
 #  endif
-	if (fstat(fd, &st) == 0 && S_ISREG(st.st_mode) &&
-	    (size_t)map_size > st.st_size) {
-		PyErr_SetString(PyExc_ValueError, 
-				"mmap length is greater than file size");
-		return NULL;
+	if (fstat(fd, &st) == 0 && S_ISREG(st.st_mode)) {
+		if (map_size == 0) {
+			map_size = (int)st.st_size;
+		} else if ((size_t)map_size > st.st_size) {
+			PyErr_SetString(PyExc_ValueError, 
+					"mmap length is greater than file size");
+			return NULL;
+		}
 	}
 #endif
 	m_obj = PyObject_New (mmap_object, &mmap_object_type);
 	if (m_obj == NULL) {return NULL;}
+	m_obj->data = NULL;
 	m_obj->size = (size_t) map_size;
 	m_obj->pos = (size_t) 0;
 	m_obj->fd = dup(fd);
@@ -927,7 +936,7 @@
 		PyErr_SetFromErrno(mmap_module_error);
 		return NULL;
 	}
-	m_obj->access = access;
+	m_obj->access = (access_mode)access;
 	return (PyObject *)m_obj;
 }
 #endif /* UNIX */
@@ -943,11 +952,11 @@
 	DWORD dwErr = 0;
 	int fileno;
 	HANDLE fh = 0;
-	access_mode   access = ACCESS_DEFAULT;
+	int access = (access_mode)ACCESS_DEFAULT;
 	DWORD flProtect, dwDesiredAccess;
-	char *keywords[] = { "fileno", "length", 
-			     "tagname", 
-			     "access", NULL };
+	static const char *keywords[] = { "fileno", "length", 
+                                          "tagname", 
+                                          "access", NULL };
 
 	if (!PyArg_ParseTupleAndKeywords(args, kwdict, "iO|zi", keywords,
 					 &fileno, &map_size_obj, 
@@ -955,7 +964,7 @@
 		return NULL;
 	}
 
-	switch(access) {
+	switch((access_mode)access) {
 	case ACCESS_READ:
 		flProtect = PAGE_READONLY;
 		dwDesiredAccess = FILE_MAP_READ;
@@ -1040,7 +1049,7 @@
 	else
 		m_obj->tagname = NULL;
 
-	m_obj->access = access;
+	m_obj->access = (access_mode)access;
 	m_obj->map_handle = CreateFileMapping (m_obj->file_handle,
 					       NULL,
 					       flProtect,
