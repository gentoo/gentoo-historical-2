--- ext/curl/interface.c	2005-03-14 10:02:42.000000000 +0100
+++ ext/curl/interface.c	2005-10-31 23:09:15.000000000 +0100
@@ -16,7 +16,7 @@
    +----------------------------------------------------------------------+
 */
 
-/* $Id: interface.c,v 1.46.2.7 2005/03/14 09:02:42 sniper Exp $ */
+/* $Id: interface.c,v 1.46.2.11 2005/10/17 02:42:32 iliaa Exp $ */
 
 #define ZEND_INCLUDE_FULL_WINDOWS_HEADERS
 
@@ -62,7 +62,7 @@
 #define CAAZ(s, v) add_assoc_zval_ex(return_value, s, sizeof(s), (zval *) v);
 
 #define PHP_CURL_CHECK_OPEN_BASEDIR(str, len)													\
-	if (PG(open_basedir) && *PG(open_basedir) &&                                                \
+	if (((PG(open_basedir) && *PG(open_basedir)) || PG(safe_mode)) &&                                                \
 	    strncasecmp(str, "file://", sizeof("file://") - 1) == 0)								\
 	{ 																							\
 		php_url *tmp_url; 																		\
@@ -72,7 +72,7 @@
 			RETURN_FALSE; 																		\
 		} 																						\
 																								\
-		if (php_check_open_basedir(tmp_url->path TSRMLS_CC) || 									\
+		if (tmp_url->query || php_check_open_basedir(tmp_url->path TSRMLS_CC) || 									\
 			(PG(safe_mode) && !php_checkuid(tmp_url->path, "rb+", CHECKUID_CHECK_MODE_PARAM))	\
 		) { 																					\
 			php_url_free(tmp_url); 																\
@@ -484,20 +484,22 @@
 			fci.no_separation = 0;
 			fci.symbol_table = NULL;
 
+			ch->in_callback = 1;
 			error = zend_call_function(&fci, &t->fci_cache TSRMLS_CC);
+			ch->in_callback = 0;
 			if (error == FAILURE) {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not call the CURLOPT_WRITEFUNCTION");
 				length = -1;
-			} else {
+			} else if (retval_ptr) {
 				if (Z_TYPE_P(retval_ptr) != IS_LONG) {
 					convert_to_long_ex(&retval_ptr);
 				}
 				length = Z_LVAL_P(retval_ptr);
+				zval_ptr_dtor(&retval_ptr);
 			}
 
 			zval_ptr_dtor(argv[0]);
 			zval_ptr_dtor(argv[1]);
-			zval_ptr_dtor(&retval_ptr);
 			break;
 		}
 	}
@@ -554,20 +556,22 @@
 			fci.no_separation = 0;
 			fci.symbol_table = NULL;
 
+			ch->in_callback = 1;
 			error = zend_call_function(&fci, &t->fci_cache TSRMLS_CC);
+			ch->in_callback = 0;
 			if (error == FAILURE) {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Cannot call the CURLOPT_READFUNCTION"); 
-			} else {
+			} else if (retval_ptr) {
 				if (Z_TYPE_P(retval_ptr) == IS_STRING) {
 					length = MIN(size * nmemb, Z_STRLEN_P(retval_ptr));
 					memcpy(data, Z_STRVAL_P(retval_ptr), length);
 				}
+				zval_ptr_dtor(&retval_ptr);
 			}
 
 			zval_ptr_dtor(argv[0]);
 			zval_ptr_dtor(argv[1]);
 			zval_ptr_dtor(argv[2]);
-			zval_ptr_dtor(&retval_ptr);
 			break;
 		}
 	}
@@ -625,19 +629,21 @@
 			fci.params = argv;
 			fci.no_separation = 0;
 
+			ch->in_callback = 1;
 			error = zend_call_function(&fci, &t->fci_cache TSRMLS_CC);
+			ch->in_callback = 0;
 			if (error == FAILURE) {
 				php_error_docref(NULL TSRMLS_CC, E_WARNING, "Could not call the CURLOPT_HEADERFUNCTION");
 				length = -1;
-			} else {
+			} else if (retval_ptr) {
 				if (Z_TYPE_P(retval_ptr) != IS_LONG) {
 					convert_to_long_ex(&retval_ptr);
 				}
 				length = Z_LVAL_P(retval_ptr);
+				zval_ptr_dtor(&retval_ptr);
 			}
 			zval_ptr_dtor(argv[0]);
 			zval_ptr_dtor(argv[1]);
-			zval_ptr_dtor(&retval_ptr);
 			break;
 		}
 
@@ -773,6 +779,8 @@
 	(*ch)->handlers->write_header = ecalloc(1, sizeof(php_curl_write));
 	(*ch)->handlers->read         = ecalloc(1, sizeof(php_curl_read));
 
+	(*ch)->in_callback = 0;
+	
 	memset(&(*ch)->err, 0, sizeof((*ch)->err));
 	
 	zend_llist_init(&(*ch)->to_free.str,   sizeof(char *),            (void(*)(void *)) curl_free_string, 0);
@@ -1120,10 +1128,15 @@
 					 * must be explicitly cast to long in curl_formadd
 					 * use since curl needs a long not an int. */
 					if (*postval == '@') {
+						++postval;
+						/* safe_mode / open_basedir check */
+						if (php_check_open_basedir(postval TSRMLS_CC) || (PG(safe_mode) && !php_checkuid(postval, "rb+", CHECKUID_CHECK_MODE_PARAM))) {
+							RETURN_FALSE;
+						}
 						error = curl_formadd(&first, &last, 
 											 CURLFORM_COPYNAME, string_key,
 											 CURLFORM_NAMELENGTH, (long)string_key_len - 1,
-											 CURLFORM_FILE, ++postval, 
+											 CURLFORM_FILE, postval, 
 											 CURLFORM_END);
 					} else {
 						error = curl_formadd(&first, &last, 
@@ -1468,6 +1481,12 @@
 	}
 
 	ZEND_FETCH_RESOURCE(ch, php_curl *, zid, -1, le_curl_name, le_curl);
+
+	if (ch->in_callback) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Attempt to close CURL handle from a callback");
+		return;
+	}
+	
 	if (ch->uses) {	
 		ch->uses--;
 	} else {
--- ext/curl/php_curl.h	2004/03/12 18:37:55	1.41
+++ ext/curl/php_curl.h	2005/06/02 21:04:43	1.41.2.1
@@ -17,7 +17,7 @@
    +----------------------------------------------------------------------+
 */

-/* $Id: php_curl.h,v 1.41 2004/03/12 18:37:55 sterling Exp $ */
+/* $Id: php_curl.h,v 1.41.2.1 2005/06/02 21:04:43 tony2001 Exp $ */

 #ifndef _PHP_CURL_H
 #define _PHP_CURL_H
@@ -121,6 +121,7 @@ typedef struct {
 	php_curl_handlers       *handlers;
 	long                     id;
 	unsigned int             uses;
+	zend_bool                in_callback;
 } php_curl;

 typedef struct {
