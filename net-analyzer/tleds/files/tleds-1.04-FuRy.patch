diff -uNr a/Changes b/Changes
--- a/Changes	2002-07-01 11:35:59.000000000 +0100
+++ b/Changes	2002-07-01 11:22:24.000000000 +0100
@@ -1,4 +1,17 @@
 VERSION	DATE		WHAT WAS FIXED OR WHAT WAS/IS NEW
+
+	22 Jun 2002	Fixed for 2.4 and 2.5 kernels
+
+1.05b11 7 Mar 2002	Support for multiple interfaces
+
+1.05b7	2 Apr 1998	Keeps LEDs deattached also after VT is reset if run
+(beta)			with -c option.
+			eth* default delay changed to 50 ms.
+			Support for 2.1.x kernel added, beta, check Makefile.
+			Before make install installed to /usr/bin, now it
+			installs to /usr/local/bin by default, but is easily
+			configurable in Makefile.
+
 1.04	29 Sep 1997	Now keeps LEDs reattached during the deep sleep.
 
 1.03	27 Sep 1997	-t option removed and -c added. -c Fixes CapsLock
diff -uNr a/Makefile b/Makefile
--- a/Makefile	2002-07-01 11:35:59.000000000 +0100
+++ b/Makefile	1998-04-02 12:04:17.000000000 +0100
@@ -1,40 +1,61 @@
 # Makefile for tleds and xtleds.
-# GPL (c) 1997 Jouni.Lohikoski@iki.fi
+# GNU GPL (c) 1997, 1998 Jouni.Lohikoski@iki.fi
+
+all:	tleds xtleds say_install
+
+# Where to install programs and man pages
+BINDIR	=	/usr/local/bin/
+MANDIR	=	/usr/local/man/
+
+# For 2.1.x kernels, you have to include -DKERNEL2_1 option for gcc
+
+GCCOPTS = -D_GNU_SOURCE -O3 -Wall 
 
-all:	tleds xtleds install
 # The first one is if you want to include X code
-xtleds:	tleds.c
+xtleds:	tleds.c Makefile
 	# Making xtleds
-	gcc -O3 -Wall -o xtleds tleds.c -I /usr/X11R6/include/ -L /usr/X11R6/lib/ -lX11
+	gcc $(GCCOPTS) -o xtleds tleds.c -I /usr/X11R6/include/ -L /usr/X11R6/lib/ -lX11
 
 # This second one works only when started in VT. Check the REMOVE_X_CODE
 # in the source code.
-tleds:	tleds.c
+tleds:	tleds.c Makefile
 	# Making tleds
-	gcc -DNO_X_SUPPORT -O3 -Wall -o tleds tleds.c
+	gcc -DNO_X_SUPPORT $(GCCOPTS) -o tleds tleds.c
 
 help:
 	# make help	-	this.
 	# make tleds	-	makes tleds.
 	# make xtleds	-	makes xtleds.
+	# make strip	-	strips them.
 	# make install	-	installs tleds, xtleds and tleds man page
 	#			if EUID root.
-	# make all	-	make tleds, xtleds, and install if root.
+	# make all	-	make tleds and xtleds
+
+strip:
+	strip --strip-all tleds
+	strip --strip-all xtleds
 	
+say_install:
+	# Now su root and run:  make install
+	# If you want to strip them first, say: make strip install
+
 install: tleds
 	# EUID root needed !
 	# installing ....
-	cp tleds /usr/bin/tleds
-	chgrp users /usr/bin/tleds
-	chmod ug+x /usr/bin/tleds
-	cp tleds.1 /usr/man/man1/tleds.1
-	chmod og-wr /usr/bin/tleds /usr/man/man1/tleds.1
-	chmod og+r /usr/man/man1/tleds.1
-	ln -fs /usr/man/man1/tleds.1 /usr/man/man1/xtleds.1
-	cp xtleds /usr/bin/xtleds
-	chgrp users /usr/bin/xtleds
-	chmod ug+x /usr/bin/xtleds
-	chmod og-wr /usr/bin/xtleds
+	# If you get an error here, you are not root or may have tleds running
+	# on the system. tleds -k  first and then make install again as root. 
+	rm -f /usr/bin/tleds /usr/bin/xtleds /usr/man/man1/tleds.1* /usr/man/man1/xtleds.1
+	cp tleds $(BINDIR)/tleds
+	chgrp users $(BINDIR)/tleds
+	chmod ug+x $(BINDIR)/tleds
+	cp tleds.1.gz $(MANDIR)/man1/tleds.1.gz
+	chmod og-wr $(BINDIR)/tleds $(MANDIR)/man1/tleds.1.gz
+	chmod og+r $(MANDIR)/man1/tleds.1.gz
+	ln -fs $(MANDIR)/man1/tleds.1.gz $(MANDIR)/man1/xtleds.1
+	cp xtleds $(BINDIR)/xtleds
+	chgrp users $(BINDIR)/xtleds
+	chmod ug+x $(BINDIR)/xtleds
+	chmod og-wr $(BINDIR)/xtleds
 	sync
 	# ....Done.
 
diff -uNr a/README b/README
--- a/README	2002-07-01 11:35:59.000000000 +0100
+++ b/README	1998-04-02 12:13:55.000000000 +0100
@@ -1,4 +1,4 @@
-Hello, 
+Hello You, yes _you_, 
 
 Help for making:
 
@@ -7,9 +7,12 @@
 To recompile and install tleds, just cd to the directory where there is
 tleds.c and Makefile, su root, and give command:
 
-	make
+	make all install
 
 If you don't want to recompile just: (install needs EUID root)
+NOTE: the binaries in the tarball are compiled to use glibc. If you need
+to get them working with libc-5, you need to recompile on your machine, or
+email me and I'll will put libc5 versions available or mail back to ya.
 
 	make install
 
@@ -19,11 +22,14 @@
 
 If you want tleds started always in the boot up, do for example:
 
-	echo "/usr/bin/tleds -qd 100 ppp0" >>/etc/rc.d/rc.local
+	echo "/usr/local/bin/tleds -qcd 100 ppp0" >>/etc/rc.d/rc.local
 
-Consider the -c option when running tleds as EUID root.
+Consider the -c option when running tleds as (EUID) root.
 
-Have fun and don't let the Sky Net enter into your puter!
+Some ppl have asked what is EUID...it's Effective User ID. So if
+you make tleds suid root and run it as normal user, your effective
+user ID comes to 0 (= root). I don't recommend making tleds suid root
+though. Just su root and run it or put it in the rc.local file.
 
 --
 	Jouni.Lohikoski@iki.fi
diff -uNr a/tleds.1 b/tleds.1
--- a/tleds.1	2002-07-01 11:35:59.000000000 +0100
+++ b/tleds.1	2002-07-01 11:19:00.000000000 +0100
@@ -1,4 +1,4 @@
-.TH TLEDS 1 "1997 Sep 29"
+.TH TLEDS 1 "2002 Mar 07"
 .SH NAME
 tleds, xtleds \- Blinks keyboard LEDs indicating incoming and outgoing network packets.
 .SH SYNOPSIS
@@ -8,7 +8,7 @@
 .RB [ \-d 
 .B N
 ]
-.B interface_name
+.B interface_name ...
 .br
 .B xtleds
 .RB [ \-bchkqv
@@ -16,7 +16,7 @@
 .RB [ \-d 
 .B N
 ]
-.B interface_name
+.B interface_name ...
 .SH DESCRIPTION
 These programs help you monitor network traffic. They blink Scroll-Lock LED
 (Light Emitting Diode)
@@ -44,12 +44,15 @@
 of /dev/console and therefore can be started for example in boot-up script, eg.
 in
 .IR /etc/rc.d/rc.local
-(see the last EXAMPLE) If you want to have correct CapsLockLED in VTs, use the
+(see the last EXAMPLE)
+.PP
+If you want to have correct CapsLockLED in VTs, or if
+you mainly use Virtual Terminals, use the
 .B -c
-option.
+option. This will keep the LEDs blinking also after the VT is reset.
 .PP
 If you want to use xtleds with XFree v3.2 or v3.3, I suggest you run tleds
-instead as EUID root so you won't have to disable XKEYBOARD extension.
+as EUID root so you won't have to disable XKEYBOARD extension.
 (XkbDisable)
 .SH PARAMETER
 .I interface_name
@@ -59,6 +62,19 @@
 .br
 .B cat
 .B /proc/net/dev
+.br
+It is possible to specify multiple interfaces and to append
+.B ,1
+(for NumLockLED) or
+.B ,2
+(for ScrollLockLED) directly after the respective interface. If this
+is specified, the whole (RX/TX) traffic will be reported on this LED.
+If you specify another appended
+.B ,1
+or
+.B ,2
+the meaning is slightly different: The first number specifies the receive
+LED, the latter the transmit LED. See examples.
 .SH OPTIONS
 .TP
 -b
@@ -69,14 +85,18 @@
 Without this also the CapsLock LED is detached from actual keyboard
 flags (see 
 .IR setleds(1)
-why). Processing CapsLock will take little more CPU time,
-so if you mainly use X, you won't need this.
+why). Processing CapsLock will take little more CPU time.
+If you mainly use X, you won't need this.
+Also when VT is reset, for example when there has been logout and mingetty
+has been restarted, the LEDs get reattached automaticly. With -c option LEDs
+are detached again about after 20 seconds. So if you don't use X, you
+probably want to run tleds as root and use -c option.
 .TP
 -d {N}
 Set update delay in milliseconds. N must be between 1 and 10000 ms.
 Without -d the default for
 .I eth*
-(ethernet) device is 100 ms and 200 ms for
+(ethernet) device is 50 ms and 200 ms for
 others like:
 .I ppp*
 (Point to Point Protocol),
@@ -105,15 +125,26 @@
 tleds -d 100 ppp0
 Starts monitoring the interface ppp0 updating every 100 ms.
 .TP
-tleds -qd 50 eth0
-Blinks LEDs looking what comes and goes from eth0 (ethernet) every 50 ms. Starts
-quietly.
+tleds -qd 100 eth0
+Blinks LEDs looking what comes and goes from eth0 (ethernet) every 100 ms.
+Starts quietly.
 .TP
 tleds -c eth1
-On eth1 and update delay is 100 ms (default). Will be able to indicate 
+On eth1 and update delay is 50 ms (default). Will be able to indicate 
 correct CapsLock state in VTs because the
 .B -c
-flag, IF started as EUID root.
+flag, and keeps LEDs detached even over VT resets, IF started as EUID root.
+.TP
+tleds ippp0 eth0 eth1
+Observes the three specified interfaces
+.TP
+tleds eth0,1 eth1,2
+All the traffic of eth0 (RX/TX) will be monitored with NumLockLED and all the
+traffic of eth1 will be monitored with ScrollLockLED.
+.TP
+tleds ippp0,2,1
+The incoming traffic of the ISDN interface ippp0 will be monitored with the
+ScrollLockLED (2) and the outgoing traffic will be monitored with the NumLockLED (1).
 .TP
 xtleds -vbd 200 lo
 Loopback device (lo) and shows version information, delay 200 ms.
@@ -128,11 +159,11 @@
 tleds -k
 Kills the beast, tleds/xtleds, runnning if there is such.
 .TP
-echo "/usr/bin/tleds -qcd 50 eth0" >>/etc/rc.d/rc.local
+echo "/usr/bin/tleds -qcd 100 eth0" >>/etc/rc.d/rc.local
 (Done as EUID root) Will start tleds in the boot-up, running always in
 the backgroud. Starts quietly.
 Shows correct CapsLock state with CapsLock LED in VTs.
-Will monitor eth0 with 50 ms update delays.
+Will monitor eth0 with 100 ms update delays.
 .SH FILES
 /proc/net/dev
 .br
@@ -143,6 +174,7 @@
 /etc/X11/XF86Config
 .SH AUTHOR
 tleds and xtleds was made by Jouni Lohikoski <Jouni.Lohikoski@iki.fi>.
+Support for multiple devices by Roland Stigge <roland.stigge@epost.de>.
 .SH COPYRIGHT
 Copyrighted and released under GNU General Public License (GPL).
 .SH URL
@@ -154,10 +186,13 @@
 .BR console_ioctl (4)
 .SH BUGS
 I hope not. Please e-mail me when you find them.
-xtleds on XFree v3.2 and v3.3 doesn't work
+xtleds (when run as non root) on XFree v3.2 and v3.3 doesn't work
 unless you put "XkbDisable" in the Keyboard section of XF86Config. 
 Will get SIGSEGV if tried to monitor network device which
 doesn't support /proc filesystem, eg. dummy.
+If you disconnect keyboard and are running tleds, it takes more CPU
+time I've heard. Buy an extra keyboard or email me how to detect this in
+run time.
 .PP
 One comment: kernel should enable deattach LEDs separately. Now it's all
 or none, and these programs has to do some hacks with
diff -uNr a/tleds.LSM b/tleds.LSM
--- a/tleds.LSM	2002-07-01 11:35:59.000000000 +0100
+++ b/tleds.LSM	1998-03-26 23:06:48.000000000 +0000
@@ -1,6 +1,6 @@
 Begin3
 Title:       	tleds xtleds (Network Traffic Monitoring Programs) 
-Version:	1.04       
+Version:	1.04      
 Entered-date:   29SEP97
 Description:    tleds and xtleds are programs which blinks keyboard LEDs
                 (Light Emitting Diode) indicating outgoing and incoming
@@ -9,7 +9,7 @@
 Author:         Jouni.Lohikoski@iki.fi
 Maintained-by:  jlohikos@cc.hut.fi
 Primary-site:   http://www.iki.fi/Jouni.Lohikoski/tleds.html
-Platforms:	Linux
+Platforms:	x86 Linux with keyboard
 Copying-policy: GPL
 End
 
diff -uNr a/tleds.c b/tleds.c
--- a/tleds.c	2002-07-01 11:35:59.000000000 +0100
+++ b/tleds.c	2002-07-01 11:24:03.000000000 +0100
@@ -1,44 +1,46 @@
 /*
-  File: tleds.c
-  (X11) netTrafficLEDS - Copyright (C) 1997  Jouni.Lohikoski@iki.fi
-  This can be run either on VT or in X. Works best when EUID is root.(-c)
-  If you like this alot, and kinda use this daily for months, heh, and would
-  like to send me a postcard or $10 or offer a job, feel free, I don't mind. 
-  
-  <URL:http://www.iki.fi/Jouni.Lohikoski/tleds.html> for more info and for
-  the latest version.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; version 2 of the License.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+File: tleds.c
+(X11) netTrafficLEDS - Copyright (C) 1997,1998  Jouni.Lohikoski@iki.fi
+This can be run either on VT or in X. Works best when EUID is root.(opt -c)
+If you like this alot, and kinda use this daily for months, and would
+like to send me a postcard or $10 or offer a project, feel free to do so. 
+
+<URL: http://www.iki.fi/Jouni.Lohikoski/tleds.html> for more info and for
+the latest version.
+
+* Multiple interfaces support by Roland Stigge <stigge@epost.de>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; version 2 of the License.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
 ---
 Makefile:
 all:	xtleds tleds
 xtleds:	tleds.c
-	gcc -O3 -Wall -o xtleds tleds.c -I /usr/X11R6/include/    \ 
-		-L /usr/X11R6/lib/ -lX11
+gcc -O3 -D_GNU_SOURCE -Wall -o xtleds tleds.c -I /usr/X11R6/include/ \ 
+	-L /usr/X11R6/lib/ -lX11
 tleds:	tleds.c
-	gcc -DNO_X_SUPPORT -O3 -Wall -o tleds tleds.c 
+gcc -DNO_X_SUPPORT -D_GNU_SOURCE -O3 -Wall -o tleds tleds.c 
 ---	
 (x)tleds needs "XkbDisable" on v3.2 and v3.3 XFree, which is no good.
 If you run tleds as root, "XkbDisable" is not needed.
-Put following two lines in your XF86Config if you use this from X.
+Put following two lines in your XF86Config if you use xtleds from X.
 "Xleds 2 3" is needed always when using X with tleds or with xtleds.
 XF86Config:
-	XkbDisable 	# v3.1 Xfree doesn't need this line or if EUID root
-	Xleds 2 3	# This line is a must.
+XkbDisable 	# Needed when EUID non root and Xfree v3.2 or v3.3
+Xleds 2 3	# This line is a must.
 */
-#define VERSION	"1.04"
+#define VERSION	"1.05beta11"
 #define MYNAME	"tleds"
 
 /* If you don't want X stuff. */
@@ -70,6 +72,7 @@
 #include <linux/kd.h>
 #include <linux/vt.h>
 #include <assert.h>
+#include <sys/utsname.h>
 
 #ifndef TRUE
 #define TRUE 1
@@ -81,40 +84,60 @@
 #define MAXVT		12
 #define NETDEVFILENAME	"/proc/net/dev"
 #define TERMINATESTR	"Program (and child) terminated.\n"
-#define FIELDCOUNT 	12
 #define DEEPSLEEP	10
+#define	REMINDVTDELAY	15
 #define DEFPPPDELAY 	200
-#define DEFETHDELAY	100
+#define DEFETHDELAY	50
 #define CAPSLOCKLED	1
 #define NUMLOCKLED	2
 #define SCROLLLOCKLED	3
 typedef enum {CLEAR = 0, SET = 1, TOGGLE = 2} LedMode;
 typedef enum {DELAYED = 0, FINISH = 1, NOW = 2} ActionMode;
+#if KERNEL2_0
+#define FIELDCOUNT 	7	/* 12 really */
+#else
+#define FIELDCOUNT	11	/* 17 really, in v2.1.97 +/- N */
+#endif
+#define INTPARAMS       3
+
+/* Structs */
+struct interfaceList {
+  struct interfaceList* next;   /* it's a chain            */
+  char* interfaceName;          /* e.g. "eth0"             */
+  int rxled, txled;             /* 1 = NUM | 2 = SCROLL   */
+  int row;                      /* position in device file */
+};
 
 /* Function prototypes */
-void		handle_my_argvs (char** interfaceName, int* sleeptime,
-				int argc, char** argv);
 void		check_sanity ();
-void		usage (char* name);
-int		get_sleeptime (int isDefinedByUser, char* interfaceName);
+void		check_kernel_version ();
+ulong		correct_caps (ulong ledVal);
 void		create_pid_file (pid_t pid, const char* name);
-int		kill_old_process ();
-pid_t		get_old_pid ();
-void		parent_wants_me_dead (int);
-void		my_signal_handler (int);
-void		my_exit ();
-void		detach_vt_leds (int wantDetach);
+void		detach_all_vt_leds (int wantDetach);
+ulong		detach_vt_leds (int tty, int wantDetach);
+void            sort_interfaces(struct interfaceList** interfaces);
+FILE*           open_device();
+char*		find_device_line (char* buffer, FILE* devFile, char* netDeviceName);
+int		find_device_row (char* netDeviceName);
 inline int	find_max_VT ();
+pid_t		get_old_pid ();
+int		get_sleeptime (int isDefinedByUser, struct interfaceList* interfaces);
+void		handle_my_argvs (struct interfaceList** interfaces, int* sleeptime,
+			int argc, char** argv);
+inline int	is_on_X (int ttyFd);
+int		kill_old_process ();
 void		led (int what, LedMode mode, ActionMode doAction);
-ulong		correct_caps (ulong ledVal);
-char*		find_device_line (char* buffer, char* netDeviceName);
+void		my_exit ();
+void		my_signal_handler (int);
+inline void	my_sleep (struct timeval sleeptimeval);
+void		parent_wants_me_dead (int);
+void 		report_traffic (long received, long transmitted);
 char**		split_on_blank (char* line);
-void 		report_traffic (char** list);
-inline int	is_on_X (int ttyFd);
+char**		split_on_comma (char* line);
 inline void	clear_led (int what) { led(what, CLEAR, NOW); }
 inline void	set_led (int what) { led(what, SET, NOW); }
 inline void	toggle_led (int what) { led(what, TOGGLE, NOW); }
-inline void	my_sleep (struct timeval sleeptimeval);
+void		usage (char* name);
 
 /* Global and static variables */
 static const char	devFileName [] = NETDEVFILENAME;
@@ -128,187 +151,298 @@
 static int		keyboardDevice = 0;
 static char		ttyLEDs [MAXVT] = {};
 static ushort		previousActive = (ushort)(MAXVT + 1);
+static int		remindVTcoef = 0;
 static int		opt_b = FALSE, opt_d = FALSE, opt_h = FALSE,
-			opt_k = FALSE, opt_q = FALSE, opt_v = FALSE,
-			opt_c = FALSE;
+		opt_k = FALSE, opt_q = FALSE, opt_v = FALSE,
+		opt_V = FALSE, opt_c = FALSE;
 
 /* The code */
 int	main (int argc, char* argv [])
 {
-	char*	interfaceName;
-	char	buffer [MAXLEN];
-	ulong	ledVal;	
-	char*	tmpPointer;
-	char**	list;
-	pid_t	pid;
-	int	sleeptime;
-	int	wasInDeepSleep;
-	struct timeval sleeptimeval;
-	
-	interfaceName = NULL;
-	sleeptime = 0;
-	handle_my_argvs(&interfaceName, &sleeptime, argc, argv);
-	check_sanity();	/* Checks and maybe changes the option flags. */
+struct interfaceList* interfaces;
+struct interfaceList* tempInterfaces;
+char* message;
+long received, transmitted, numlock, scrolllock;
+FILE* devFile;
+char	buffer [MAXLEN];
+ulong	ledVal;	
+char*	tmpPointer;
+char**	list;
+pid_t	pid;
+int	sleeptime;
+int	wasInDeepSleep;
+struct timeval sleeptimeval;
+
+interfaces = NULL;
+sleeptime = 0;
+check_kernel_version(); /* May die here */
+handle_my_argvs(&interfaces, &sleeptime, argc, argv);
+check_sanity();	/* Checks and maybe changes the option flags. */
 #ifdef DEBUG
-	opt_b = TRUE;	/* We are debugging so don't go to the background */
+opt_b = TRUE;	/* We are debugging so don't go to the background */
 #endif
-	if (opt_v && !opt_q)
-		fprintf(stderr,
-		    "%s version %s, GPL (c) 1997 Jouni.Lohikoski@iki.fi\n",
-		    MYNAME, VERSION);
-	strcpy(pidFileName, _PATH_TMP);
-	strcpy(rootPidFileName, _PATH_VARRUN);
-	strcat(pidFileName, MYNAME); /* Was argv[0]. Probs coz/if path. */
-	strcat(rootPidFileName, MYNAME);
-	strcat(pidFileName, ".pid");
-	strcat(rootPidFileName, ".pid");
-	if (opt_k) {
-		return kill_old_process();
-	}
-	if (opt_h) {
-		usage(argv[0]);
-		return 0;
-	}
-	if (! opt_q) {
-		printf("Setting keyboard LEDs based on %s %s %s %s\n",
-		    "changes of Receive/Transmit\npackets of", interfaceName,
-		    "in", devFileName);
-		printf("Delay between updates is %d milliseconds.\n",
-		    sleeptime);
-	}
-	if (! find_device_line(buffer, interfaceName) && !opt_q) {
-		printf(
-		    "There is currently no such interface as %s in %s.\n%s\n",
-		    interfaceName, devFileName,
-		    "Maybe later there will be. Kill me (-k) if ya want.");
-	}
-	
-	if(! opt_b) {
-		if (-1 == (pid = fork())) {
-			perror("tleds: fork");
-			return 1;
-		}
-	} else {
-		pid = getpid();
-	}
-	if (pid) {
-		create_pid_file(pid, argv[0]);
-		if (! opt_q)
-			printf("Running in %sground. Pid: %ld\n",
-				(opt_b ? "fore" : "back"),
-				(long)pid);
-		if (! opt_b)
-			exit(0);
-	}
-	if (atexit(my_exit)) {
-		perror("tleds: atexit() failed");
+if (opt_v && !opt_q) {
+	printf(
+	    "%s version %s\n"
+	    "GNU GPL (c) 1998 Jouni.Lohikoski@iki.fi\n"
+	    "            2002 roland.stigge@epost.de\n",
+	    MYNAME, VERSION);
+	printf("<URL: http://www.iki.fi/Jouni.Lohikoski/tleds.html>\n");
+}
+strcpy(pidFileName, _PATH_TMP);
+strcpy(rootPidFileName, _PATH_VARRUN);
+strcat(pidFileName, MYNAME); /* Was argv[0]. Probs coz/if path. */
+strcat(rootPidFileName, MYNAME);
+strcat(pidFileName, ".pid");
+strcat(rootPidFileName, ".pid");
+if (opt_k) {
+	return kill_old_process();
+}
+if (opt_h) {
+	usage(argv[0]);
+	return 0;
+}
+if (! opt_q) {
+	printf("Setting keyboard LEDs based on "
+	       "changes of Receive/Transmit\npackets of");
+	tempInterfaces = interfaces;
+	while (tempInterfaces) {
+	  printf(" %s", tempInterfaces->interfaceName);
+	  tempInterfaces = tempInterfaces->next;
+	}
+	printf(" %s %s\n", "in", devFileName);
+	printf("Delay between updates is %d milliseconds.\n",
+	    sleeptime);
+}
+
+sort_interfaces(&interfaces); /* prepare to start right now */
+
+tempInterfaces = interfaces;
+message = "";
+while (tempInterfaces) {
+  if (! tempInterfaces->row && ! opt_q) {
+    printf("There is currently no such interface as %s in %s.\n",
+	   tempInterfaces->interfaceName, devFileName);
+    message = "Maybe later there will be. Kill me (-k) if ya want.\n";
+  }
+  tempInterfaces = tempInterfaces->next;
+}
+printf(message);
+
+if(! opt_b) {
+	if (-1 == (pid = fork())) {
+		perror("tleds: fork");
 		return 1;
 	}
-	if (! opt_b) {
-		signal(SIGUSR1, parent_wants_me_dead);
+} else {
+	pid = getpid();
+}
+if (pid) {
+	create_pid_file(pid, argv[0]);
+	if (! opt_q)
+		printf("Running in %sground. Pid: %ld\n",
+			(opt_b ? "fore" : "back"),
+			(long)pid);
+	if (! opt_b)
+		exit(0);
+}
+if (atexit(my_exit)) {
+	perror("tleds: atexit() failed");
+	return 1;
+}
+if (! opt_b) {
+	signal(SIGUSR1, parent_wants_me_dead);
+}
+signal(SIGHUP, SIG_IGN);
+signal(SIGTERM, my_signal_handler);
+signal(SIGINT, my_signal_handler);
+signal(SIGQUIT, my_signal_handler);
+signal(SIGTSTP, my_signal_handler); 
+signal(SIGUSR2, SIG_IGN);
+signal(SIGPIPE, my_signal_handler);
+if (! geteuid()) {	/* We are running as EUID root - CONSOLE */
+	if (-1 == (keyboardDevice = open(KEYBOARDDEVICE, O_RDONLY))) {
+		perror("tleds");
+		fprintf(stderr, "%s:%s", KEYBOARDDEVICE, TERMINATESTR);
+		exit(1);
 	}
-	signal(SIGHUP, SIG_IGN);
-	signal(SIGTERM, my_signal_handler);
-	signal(SIGINT, my_signal_handler);
-	signal(SIGQUIT, my_signal_handler);
-	signal(SIGTSTP, my_signal_handler); 
-	signal(SIGUSR2, SIG_IGN);
-	signal(SIGPIPE, my_signal_handler);
-	if (! geteuid()) {	/* We are running as EUID root - CONSOLE */
-		if (-1 == (keyboardDevice = open(KEYBOARDDEVICE, O_RDONLY))) {
-			perror("tleds");
-			fprintf(stderr, "%s:%s", KEYBOARDDEVICE, TERMINATESTR);
-			exit(1);
-		}
-	} else {		/* EUID not root */
+} else {		/* EUID not root */
 #if (! REMOVE_X_CODE)
-		if (! (myDisplay = XOpenDisplay(NULL))		/* X  */
-	  		&& ioctl(0, KDGETLED, &ledVal) ) { 	/* VT */
-			perror(
-			   "tleds: Can't open X DISPLAY on the current host.");
+	if (! (myDisplay = XOpenDisplay(NULL))		/* X  */
+		&& ioctl(0, KDGETLED, &ledVal) ) { 	/* VT */
+		perror(
+		   "tleds: Can't open X DISPLAY on the current host.");
 #else
-		if (ioctl(0, KDGETLED, &ledVal) ) {
-			perror("tleds: KDGETLED");
-			fprintf(stderr,
-				"Error reading current led setting.\n%s\n",
-				"Maybe stdin is not a VT?");
+	if (ioctl(0, KDGETLED, &ledVal) ) {
+		perror("tleds: KDGETLED");
+		fprintf(stderr,
+			"Error reading current led setting.\n%s\n",
+			"Maybe stdin is not a VT?");
 #endif
-			fprintf(stderr, TERMINATESTR);
-			exit (1);
-		}
+		fprintf(stderr, TERMINATESTR);
+		exit (1);
 	}
-	sleeptimeval.tv_sec = (int)((long)sleeptime * 1000L) / 1000000L;
-	sleeptimeval.tv_usec = (int)((long)sleeptime * 1000L) % 1000000L;
-	wasInDeepSleep = TRUE;
-	
-	/* The main loop */
-	while (1) {
-		if ((tmpPointer = find_device_line(buffer, interfaceName))) {
-			if (wasInDeepSleep) {
-				wasInDeepSleep = FALSE;
-				detach_vt_leds(TRUE);
-			}
-			list = split_on_blank(tmpPointer);
-			report_traffic(list);
-			my_sleep(sleeptimeval);
-		} else {
-			if (! wasInDeepSleep) {
-				wasInDeepSleep = TRUE;
-				detach_vt_leds(FALSE);
-				previousActive = (ushort)(MAXVT + 1);
-			}
-			sleep(DEEPSLEEP);
-		}
-	}
-	return 0;	/* Yeah right, never gets this far. */
+}
+sleeptimeval.tv_sec = (int)((long)sleeptime * 1000L) / 1000000L;
+sleeptimeval.tv_usec = (int)((long)sleeptime * 1000L) % 1000000L;
+remindVTcoef = (int)( (long)REMINDVTDELAY * 1000L / (long)sleeptime ); 
+wasInDeepSleep = TRUE;
+
+/* The main loop */
+while (1) {
+  tempInterfaces = interfaces;
+  numlock = 0;
+  scrolllock = 0;
+  devFile = open_device();
+  do {
+    if ((tmpPointer = find_device_line(buffer, devFile, tempInterfaces->interfaceName))) {
+      list = split_on_blank(tmpPointer);
+#if KERNEL2_0
+      received = atol(list[1]);
+      transmitted = atol(list[6]);
+#else
+      received = atol(list[2]);
+      transmitted = atol(list[10]);	/* Kernel v2.1.119 */
+#endif
+      if (tempInterfaces->rxled & 1) numlock += received;
+      if (tempInterfaces->rxled & 2) scrolllock += received;
+      if (tempInterfaces->txled & 1) numlock += transmitted;
+      if (tempInterfaces->txled & 2) scrolllock += transmitted;;
+    }
+    tempInterfaces = tempInterfaces->next;
+  } while (tempInterfaces && tmpPointer);
+  fclose(devFile);
+  if (tmpPointer) {
+    if (wasInDeepSleep) {
+      wasInDeepSleep = FALSE;
+      detach_all_vt_leds(TRUE);
+    }
+    report_traffic(numlock, scrolllock);
+    my_sleep(sleeptimeval);
+  } else {
+    if (! wasInDeepSleep) {
+      wasInDeepSleep = TRUE;
+      detach_all_vt_leds(FALSE);
+      previousActive = (ushort)(MAXVT + 1);
+    }
+    sleep(DEEPSLEEP);
+    sort_interfaces(&interfaces); /* maybe this time it works */
+  }
+}
+return 0;	/* Yeah right, never gets this far. */
 }
 
-char*	find_device_line (char* buffer, char* netDeviceName)
-{
-	static long	fileOffset = 0L; 
-	register FILE*	devFile;
-	
-	if (! (devFile = fopen(devFileName, "r")) ) {
-		perror(devFileName);
-		exit(1);
-	}
-	/* Skip two lines. (the header) */
-	/* Two choices how to do this. Didn't find any differences in speed. */
+/*
+ * find interfaces in device file
+ * and make the list ordered like the device file
+ */
+void sort_interfaces(struct interfaceList** interfaces) {
+  struct interfaceList** interfaces2;
+  struct interfaceList* tempInterfaces;
+  int neighbours;
+
+  /* find row numbers for interfaces */
+  tempInterfaces = *interfaces;
+  while (tempInterfaces) {
+    tempInterfaces->row = find_device_row(tempInterfaces->interfaceName);
+    tempInterfaces = tempInterfaces->next;
+  }
+
+  /* sort in ascending order */
+  while (*interfaces) {
+    interfaces2 = interfaces;
+    while (*interfaces2) {
+      if ((*interfaces)->row > (*interfaces2)->row) { /* swap */
+	if ((*interfaces)->next == *interfaces2)
+	  neighbours = 1;
+	else
+	  neighbours = 0;
+	tempInterfaces = *interfaces;
+	*interfaces = *interfaces2;
+	*interfaces2 = tempInterfaces;
+	tempInterfaces = (*interfaces)->next;
+	(*interfaces)->next = (*interfaces2)->next;
+	(*interfaces2)->next = tempInterfaces;
+	if (neighbours) interfaces2 = &(*interfaces)->next;
+      }
+      interfaces2 = &(*interfaces2)->next;
+    }
+    interfaces = &(*interfaces)->next;
+  }
+}
+
+/* prepare reading statistical lines from device file */
+FILE* open_device() {
+  char	buffer [MAXLEN];
+  static long	fileOffset = 0L; 
+  FILE* devFile;
+  
+  if (! (devFile = fopen(devFileName, "r")) ) {
+    perror(devFileName);
+    exit(1);
+  }
+
+  /* Skip two lines. (the header) */
+  /* Two choices how to do this. Didn't find any differences in speed. */
 #if 0
-	fgets(buffer, MAXLEN, devFile);
-	fgets(buffer, MAXLEN, devFile);
+  fgets(buffer, MAXLEN, devFile);
+  fgets(buffer, MAXLEN, devFile);
 #else
-	if (fileOffset) {
-		fseek(devFile, fileOffset, SEEK_SET);
-	} else {
-		fgets(buffer, MAXLEN, devFile);
-		fileOffset += (long)strlen(buffer);
-		fgets(buffer, MAXLEN, devFile);
-		fileOffset += (long)strlen(buffer);
-	}
+  if (fileOffset) {
+    fseek(devFile, fileOffset, SEEK_SET);
+  } else {
+    fgets(buffer, MAXLEN, devFile);
+    fileOffset += (long)strlen(buffer);
+    fgets(buffer, MAXLEN, devFile);
+    fileOffset += (long)strlen(buffer);
+  }
 #endif
 
-	while ( fgets(buffer, MAXLEN, devFile) ) {
-		while(isblank(*buffer))
-			buffer++;
-		if (buffer == strstr(buffer, netDeviceName)) {
-			fclose(devFile);
-			return buffer;
-		}
+  return devFile;
+}
+
+char*	find_device_line (char* buffer, FILE* devFile, char* netDeviceName)
+{
+
+while ( fgets(buffer, MAXLEN, devFile) ) {
+	while(isblank(*buffer))
+		buffer++;
+	if (buffer == strstr(buffer, netDeviceName))
+		return buffer;
+}
+return NULL;
+}
+
+int	find_device_row (char* netDeviceName)
+{
+char	tempbuffer [MAXLEN];
+char*	buffer = tempbuffer;
+FILE* devFile;
+int returnValue = 0;
+
+devFile = open_device();
+while ( fgets(buffer, MAXLEN, devFile) ) {
+	returnValue++;
+	while(isblank(*buffer))
+		buffer++;
+	if (buffer == strstr(buffer, netDeviceName)) {
+		fclose(devFile);
+		return returnValue;
 	}
-	fclose(devFile);
-	return NULL;
+}
+fclose(devFile);
+return 0;
 }
 
 void	my_sleep (struct timeval sleeptimeval)
 {
 #if 1
-	select(1, NULL, NULL, NULL, &sleeptimeval);
+select(1, NULL, NULL, NULL, &sleeptimeval);
 #else
-	usleep(sleeptimeval.tv_usec);
+usleep(sleeptimeval.tv_usec);
 #endif
 }
-	
+
 char**	split_on_blank (char* line)
 {
 /*
@@ -316,458 +450,558 @@
 Look at the end of this file for example /proc/net/dev listing.
 */
 
-	static char* 	list [FIELDCOUNT] = {};
-	register int 	i;
+static char* 	list [FIELDCOUNT] = {};
+register int 	i;
 
-	i = 0;
-	goto middle;	/* speed(?) hack */
-	for (; i < FIELDCOUNT; i++) {
-		while (isblank(*line))
-			line++;
-	middle:
-		list[i] = line;
-		while (! isblank(*line) && *line != ':' && *line != '\n')
-			line++;
-		*(line++) = '\0';
-	}
-	return list;
+i = 0;
+goto middle;	/* speed(?) hack */
+for (; i < FIELDCOUNT; i++) {
+	while (isblank(*line))
+		line++;
+middle:
+	list[i] = line;
+	while (! isblank(*line) && *line != ':' && *line != '\n')
+		line++;
+	*(line++) = '\0';
 }
-	
-void	report_traffic (char** list)
+return list;
+}
+
+char** split_on_comma (char* line)
 {
-	static long	formerReceived = 0L;
-	static long	formerTransmitted = 0L;
-	register long	received, transmitted;
+  int i;
+  static char* list [INTPARAMS];
 
-	received = atol(list[1]);
-	transmitted = atol(list[6]);
-	
-	if (received != formerReceived) {
-		led(NUMLOCKLED, SET, DELAYED);
-		formerReceived = received;
-	} else {
-		led(NUMLOCKLED, CLEAR, DELAYED);
-	}
-	
-	if (transmitted != formerTransmitted) {
-		led(SCROLLLOCKLED, SET, FINISH);
-		formerTransmitted = transmitted;
-	} else {
-		led(SCROLLLOCKLED, CLEAR, FINISH);
-	}
+  for (i = 0; i < INTPARAMS; i++) {
+    list[i] = line;
+    while (*line != ',' && *line != '\0') line++;
+    if (*line != '\0') *(line++) = '\0';
+  }
+  return list;
+}
+
+void	report_traffic (long numlock, long scrolllock)
+{
+static long	formerNumlock = 0L;
+static long	formerScrolllock = 0L;
+
+if (numlock != formerNumlock) {
+	led(NUMLOCKLED, SET, DELAYED);
+	formerNumlock = numlock;
+} else {
+	led(NUMLOCKLED, CLEAR, DELAYED);
+}
+
+if (scrolllock != formerScrolllock) {
+	led(SCROLLLOCKLED, SET, FINISH);
+	formerScrolllock = scrolllock;
+} else {
+	led(SCROLLLOCKLED, CLEAR, FINISH);
+}
 }
 
 void	led (int led, LedMode mode, ActionMode doAction)
 /* Only LED_NUM can be ActionMode DELAYED */
 {
-	static ulong	ledReminder = 0x00;
-	ulong		ledVal;
+static ulong	ledReminder = 0x00;
+ulong		ledVal;
 #if (! REMOVE_X_CODE)
-	XKeyboardControl values;
+XKeyboardControl values;
 #endif
 #ifdef DEBUG
-	printf("led(%d, %d)\n", led, (int)mode);
+printf("led(%d, %d)\n", led, (int)mode);
 #endif
 #if (! REMOVE_X_CODE)
-	if (myDisplay) {
-		switch (mode) {
-			case SET:
-				values.led_mode = LedModeOn;
-				break;
-			case CLEAR:
-				values.led_mode = LedModeOff;
-				break;
-			case TOGGLE:
-				values.led_mode = LedModeOn;
-		}
+if (myDisplay) {
+	switch (mode) {
+		case SET:
+			values.led_mode = LedModeOn;
+			break;
+		case CLEAR:
+			values.led_mode = LedModeOff;
+			break;
+		case TOGGLE:
+			values.led_mode = LedModeOn;
 	}
-	values.led = led;
+}
+values.led = led;
 #endif
-	if (myDisplay) {
+if (myDisplay) {
 #if (! REMOVE_X_CODE)
-		XChangeKeyboardControl(myDisplay, KBLed | KBLedMode, &values);
-		if (doAction != DELAYED)
-			XSync(myDisplay, FALSE);
-#endif
-	} else {
-		if (doAction != FINISH) { 
-			if (ioctl(keyboardDevice, KDGETLED, &ledVal)) {
-				perror("tleds: KDGETLED");
-				exit(1);
-			}
-		} else {
-			ledVal = 0L;
-		}
-		switch (led) {
-			case SCROLLLOCKLED:
-				if (mode == SET)
-					ledVal |= LED_SCR;
-				else
-					ledVal &= ~LED_SCR;
-				break;
-			case NUMLOCKLED:
-				if (mode == SET)
-					ledVal |= LED_NUM;
-				else
-					ledVal &= ~LED_NUM;
-				break;
-			default:
-				perror("tleds: wrong led-value");
-				exit(1);
-		}
-		if (opt_c && doAction != FINISH) {
-			ledVal = correct_caps(ledVal);
+	XChangeKeyboardControl(myDisplay, KBLed | KBLedMode, &values);
+	if (doAction != DELAYED)
+		XSync(myDisplay, FALSE);
+#endif
+} else {
+	if (doAction != FINISH) { 
+		if (ioctl(keyboardDevice, KDGETLED, &ledVal)) {
+			perror("tleds: KDGETLED");
+			exit(1);
 		}
-		if (doAction) { /* FINISH or NOW */
-			if (doAction == FINISH)
-				ledVal |= ledReminder;
-			if (ioctl(keyboardDevice, KDSETLED, (char)ledVal)) {
-				perror("tleds: KDSETLED");
-				exit(1);
-			}
-			ledReminder = 0x00;
-		} else {
-			/* Well, we know from report_traffic(), LED_SCR is
-			   processed later. OK, kludge. */
-			ledReminder = ledVal & ~LED_SCR;
+	} else {
+		ledVal = 0L;
+	}
+	switch (led) {
+		case SCROLLLOCKLED:
+			if (mode == SET)
+				ledVal |= LED_SCR;
+			else
+				ledVal &= ~LED_SCR;
+			break;
+		case NUMLOCKLED:
+			if (mode == SET)
+				ledVal |= LED_NUM;
+			else
+				ledVal &= ~LED_NUM;
+			break;
+		default:
+			perror("tleds: wrong led-value");
+			exit(1);
+	}
+	if (opt_c && doAction != FINISH) {
+		ledVal = correct_caps(ledVal);
+	}
+	if (doAction) { /* FINISH or NOW */
+		if (doAction == FINISH)
+			ledVal |= ledReminder;
+		if (ioctl(keyboardDevice, KDSETLED, (char)ledVal)) {
+			perror("tleds: KDSETLED");
+			exit(1);
 		}
+		ledReminder = 0x00;
+	} else {
+		/* Well, we know from report_traffic(), LED_SCR is
+		   processed later. OK, kludge. */
+		ledReminder = ledVal & ~LED_SCR;
 	}
 }
+}
 
 int	is_on_X (int ttyFd)
 {
-	long	mode;
-	
-	if (ioctl(ttyFd, KDGETMODE, &mode))
-		return TRUE;	/* perror is not wanted here */
-	return (mode & KD_GRAPHICS);
+long	mode;
+
+if (ioctl(ttyFd, KDGETMODE, &mode))
+	return TRUE;	/* perror is not wanted here */
+return (mode & KD_GRAPHICS);
 }
 
 ulong	correct_caps (ulong ledVal)
 {
-	struct vt_stat	vtStat;
-	int		currentVT;
-	ulong		flagVal;
-
-	currentVT = open(CURRENTTTY, O_RDONLY); /* Blah, only for root. */
-	if (-1 != currentVT) {
-		if (! ioctl(currentVT, KDGKBLED, &flagVal)
-		    && ! ioctl(currentVT, VT_GETSTATE, &vtStat)) {
-			if (previousActive == --vtStat.v_active) {
-		    		if (is_on_X(currentVT)) {
-					ioctl(currentVT, KDGETLED, &flagVal);
-				}
-				if (flagVal & LED_CAP)
-					ledVal |= LED_CAP;
-				else
-					ledVal &= ~LED_CAP;
-				ttyLEDs[previousActive] = (char)ledVal;
-			} else {
-				previousActive = vtStat.v_active;
-				ledVal = (ulong)ttyLEDs[previousActive];
+static int	remindVTRound = 0;
+struct vt_stat	vtStat;
+int		currentVT;
+ulong		flagVal;
+
+currentVT = open(CURRENTTTY, O_RDONLY); /* Blah, only for root. */
+if (-1 != currentVT) {
+	if (! ioctl(currentVT, KDGKBLED, &flagVal)
+	    && ! ioctl(currentVT, VT_GETSTATE, &vtStat)) {
+		if (previousActive == --vtStat.v_active) {
+			if (is_on_X(currentVT)) {
+				ioctl(currentVT, KDGETLED, &flagVal);
 			}
+			if (flagVal & LED_CAP)
+				ledVal |= LED_CAP;
+			else
+				ledVal &= ~LED_CAP;
+			ttyLEDs[previousActive] = (char)ledVal;
+		} else {
+			previousActive = vtStat.v_active;
+			ledVal = (ulong)ttyLEDs[previousActive];
 		}
-		close(currentVT);
 	}
-	return ledVal;
+	if(remindVTRound++ > remindVTcoef) {
+		remindVTRound = 0;
+		detach_vt_leds(currentVT, TRUE);
+	}
+	close(currentVT);
+}
+return ledVal;
+}
+
+ulong	detach_vt_leds (int tty, int wantDetach)
+/* 
+What I really would like to do, is to deattach only num-lock and scroll-lock
+leds and leave caps-lock led attached to indicate current keyboard caps
+lock flag. But Linux kernel (2.0.x) doesn't allow this, it's either all or
+nothing. Someone should patch the kernel to correct this for 2.2.0?
+*/
+{
+ulong	ledVal;
+
+if (ioctl(tty, KDGETLED, &ledVal)) {
+	return 0;
+}
+ledVal &= ~LED_SCR;
+ledVal &= ~LED_NUM;
+if (!wantDetach && !is_on_X(tty)) {
+	ioctl(tty, KDGKBLED, &ledVal);
+	ledVal |= 0x08;	/* Reattach. */
+}
+ioctl(tty, KDSETLED, (char)ledVal);
+return ledVal;
+}
+
+void	detach_all_vt_leds (int wantDetach)
+{
+ulong	ledVal;
+int	i, maxVT, tty;
+char	ttyFileName [30];
+char	ttyFileNameTmp [30];
+
+strcpy(ttyFileName, _PATH_TTY);
+maxVT = find_max_VT();
+for (i=0; i <= maxVT; i++) {
+	if (i > 0)
+		ttyLEDs[i-1] = 0x00;
+	/* No error checkings here, if we can't, we can't. */
+	sprintf(ttyFileNameTmp, "%s%d", ttyFileName, i);
+	if (-1 == (tty = open(ttyFileNameTmp, O_RDONLY))) {
+		continue;
+	}
+	ledVal = detach_vt_leds(tty, wantDetach);
+	if (i > 0)
+		ttyLEDs[i-1] = (char)ledVal;
+	close(tty);
+}
+}
+
+int	find_max_VT ()
+{
+return MAXVT;
 }
 
 void	parent_wants_me_dead (int x)
 {
-	exit(x);
+exit(x);
 }
 
 void	my_signal_handler (int x)
 {
-	exit(x);
+exit(x);
 }
 
 void	my_exit ()
 {
-	if (opt_b && ! opt_q)
-		printf("Bye-Bye !\n");
-	if (myDisplay) {
+if (opt_b && ! opt_q)
+	printf("Bye-Bye !\n");
+if (myDisplay) {
 #if (! REMOVE_X_CODE)
-		clear_led(NUMLOCKLED);
-		clear_led(SCROLLLOCKLED);
-		XCloseDisplay(myDisplay);	/* X */
+	clear_led(NUMLOCKLED);
+	clear_led(SCROLLLOCKLED);
+	XCloseDisplay(myDisplay);	/* X */
 #endif
-	}
-	detach_vt_leds(FALSE);			/* re-attach */
-	if (keyboardDevice) 	/* EUID root - CONSOLE */
-		close(keyboardDevice);
-	if(getpid() == get_old_pid()) {
-		unlink(pidFileName);
-		unlink(rootPidFileName);
-	}
+}
+detach_all_vt_leds(FALSE);		/* re-attach */
+if (keyboardDevice) 	/* EUID root - CONSOLE */
+	close(keyboardDevice);
+if(getpid() == get_old_pid()) {
+	unlink(pidFileName);
+	unlink(rootPidFileName);
+}
 }
 
 int	kill_old_process ()
 {
-	pid_t	pid, pid2;
+pid_t	pid, pid2;
 
-	if (! (pid = get_old_pid())) {
-		if (!opt_q) {
-			fprintf(stderr,
-				"Couldn't find what to kill.\n");
-			perror(pidFileName);
-		}
-		return 1;
-	}
-	kill(pid, SIGUSR1);
-	if (!opt_q) 
-		printf("One moment...(3 secs)...\n");
-	sleep(3);
-	if ((pid2 = get_old_pid())) {
-		if (!opt_q)
-			fprintf(stderr,
-		   	"PID: %d - Hmm...not sure if I succeeded in kill.\n",
-		   		pid2);
-		return 1;
+if (! (pid = get_old_pid())) {
+	if (!opt_q) {
+		fprintf(stderr,
+			"Couldn't find what to kill.\n");
+		perror(pidFileName);
 	}
-	if (! opt_q)
-		printf("Killed. (The old PID was %d)\n", pid);
-	return 0;
+	return 1;
+}
+kill(pid, SIGUSR1);
+if (!opt_q) 
+	printf("One moment...(3 secs)...\n");
+sleep(3);
+if ((pid2 = get_old_pid())) {
+	if (!opt_q)
+		fprintf(stderr,
+		"PID: %d - Hmm...not sure if I succeeded in kill.\n",
+			pid2);
+	return 1;
+}
+if (! opt_q)
+	printf("Killed. (The old PID was %d)\n", pid);
+return 0;
 }
 
 void	create_pid_file (pid_t pid, const char* name)
 {
-	FILE*		pidFile;
-	pid_t		oldPid;
-	char		procFileName [80];
-	char		*tmpPidFileName;
-	char		pidString [11]; /* "length" of UINT_MAX */
-	struct stat	status;
-	int		isAnother;
-	
-	if (geteuid())
-		tmpPidFileName = pidFileName;
-	else
-		tmpPidFileName = rootPidFileName;  /* root */
-	/*
-	We check if there already is the *.pid file and if maybe the
-	process' (child) which created it is dead, so we could try to fix.
-	*/
-	isAnother = FALSE;
-	oldPid = (pid_t) 0;
-	if (! stat(pidFileName, &status)
-	    || ! stat(rootPidFileName, &status)) { 
-		if ((oldPid = get_old_pid())) {
-			strcpy(procFileName, "/proc/");
-			sprintf(pidString, "%ld", (long)oldPid);
-			strcat(procFileName, pidString);
-			strcat(procFileName, "/environ");			
-			if(! stat(procFileName, &status)) { /* The old proc. */
-				isAnother = TRUE;
-			} else {
-			/* The old process was not alive, so we try to fix. */
-				unlink(rootPidFileName);
-				unlink(pidFileName);
-				if (get_old_pid()) {
-					fprintf(stderr,
-					  "%s: Can't remove %s or %s\n%s\n",
-					  MYNAME, pidFileName,
-					  rootPidFileName,
-					  "Program terminated.");
-					  exit(1);
-				}
-			}
-		} else {
+FILE*		pidFile;
+pid_t		oldPid;
+char		procFileName [80];
+char		*tmpPidFileName;
+char		pidString [11]; /* "length" of UINT_MAX */
+struct stat	status;
+int		isAnother;
+
+if (geteuid())
+	tmpPidFileName = pidFileName;
+else
+	tmpPidFileName = rootPidFileName;  /* root */
+/*
+We check if there already is the *.pid file and if maybe the
+process' (child) which created it is dead, so we could try to fix.
+*/
+isAnother = FALSE;
+oldPid = (pid_t) 0;
+if (! stat(pidFileName, &status)
+    || ! stat(rootPidFileName, &status)) { 
+	if ((oldPid = get_old_pid())) {
+		strcpy(procFileName, "/proc/");
+		sprintf(pidString, "%ld", (long)oldPid);
+		strcat(procFileName, pidString);
+		strcat(procFileName, "/environ");			
+		if(! stat(procFileName, &status)) { /* The old proc. */
 			isAnother = TRUE;
-		}				
-	}
+		} else {
+		/* The old process was not alive, so we try to fix. */
+			unlink(rootPidFileName);
+			unlink(pidFileName);
+			if (get_old_pid()) {
+				fprintf(stderr,
+				  "%s: Can't remove %s or %s\n%s\n",
+				  MYNAME, pidFileName,
+				  rootPidFileName,
+				  "Program terminated.");
+				  exit(1);
+			}
+		}
+	} else {
+		isAnother = TRUE;
+	}				
+}
+
+if (isAnother) {
+	if (oldPid)
+		fprintf(stderr, "(The old PID %ld) ", (long)oldPid);
+	fprintf(stderr, "%s %s runnning.\n%s %s %s\n",
+		"\nSorry, can't run. There might be another",
+		name, "If not, try: rm", pidFileName, rootPidFileName);
+	kill(pid, SIGUSR1);
+	exit(1);
+}
 	
-	if (isAnother) {
-		if (oldPid)
-			fprintf(stderr, "(The old PID %ld) ", (long)oldPid);
-		fprintf(stderr, "%s %s runnning.\n%s %s %s\n",
-			"\nSorry, can't run. There might be another",
-			name, "If not, try: rm", pidFileName, rootPidFileName);
-		kill(pid, SIGUSR1);
-		exit(1);
-	}
-		
-	if( !(pidFile = fopen(tmpPidFileName, "w"))) {
-		perror(tmpPidFileName);
-		kill(pid, SIGUSR1);
-		exit(1);
-	}
-	fprintf(pidFile, "%ld\n", (long)pid);
-	fclose(pidFile);
-	if (chmod(tmpPidFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) {
-		perror(tmpPidFileName);
+if( !(pidFile = fopen(tmpPidFileName, "w"))) {
+	perror(tmpPidFileName);
+	kill(pid, SIGUSR1);
+	exit(1);
+}
+fprintf(pidFile, "%ld\n", (long)pid);
+fclose(pidFile);
+if (chmod(tmpPidFileName, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) {
+	perror(tmpPidFileName);
+	exit(1);
+}
+if (! geteuid()) {  /* EUID root */
+	if (symlink(tmpPidFileName, pidFileName)) {
+		perror(pidFileName);
 		exit(1);
 	}
-	if (! geteuid()) {  /* EUID root */
-		if (symlink(tmpPidFileName, pidFileName)) {
-			perror(pidFileName);
-			exit(1);
-		}
-	}
+}
 }
 
 pid_t	get_old_pid ()
 {
-	FILE*	pidFile;
-	long	returnValue;
+FILE*	pidFile;
+long	returnValue;
 
-	if (! (pidFile = fopen(pidFileName, "r"))) {
-		if (! (pidFile = fopen(rootPidFileName, "r")))
-			return (pid_t)0L;
-	}
-	fscanf(pidFile, "%ld", &returnValue);
-	fclose(pidFile);
-	return (pid_t)returnValue;
-}
-
-void	handle_my_argvs (char** interfaceName, int* sleeptime,
-			int argc, char* argv [])
-{
-	int	c;
-
-	while(EOF != (c = getopt(argc, argv, "bcd:hkqv"))) {
-		switch (c) {
-			case 'b':
-				opt_b = TRUE;
-				break;
-			case 'c':
-				opt_c = TRUE;
-				break;
-			case 'd':
-				opt_d = TRUE;
-				*sleeptime
-					= get_sleeptime(TRUE, NULL);
-				break;
-			case 'h':
-				opt_h = TRUE;
-				break;
-			case 'k':
-				opt_k = TRUE;
-				break;
-			case 'q':
-				opt_q = TRUE;
-				break;
-			case 'v':
-				opt_v = TRUE;
-				break;
-			default:
-				opt_h = TRUE;
-				/* assert(0); */
-		}
-	}
-	*interfaceName = argv[optind];
-	if (! *interfaceName || ! (*interfaceName)[0]) {
-		opt_h = TRUE; /* We may also have opt_k so we won't get h. */
-		return;
-	}
-	if (! *sleeptime)
-		*sleeptime = get_sleeptime(FALSE, *interfaceName);
+if (! (pidFile = fopen(pidFileName, "r"))) {
+	if (! (pidFile = fopen(rootPidFileName, "r")))
+		return (pid_t)0L;
+}
+fscanf(pidFile, "%ld", &returnValue);
+fclose(pidFile);
+return (pid_t)returnValue;
+}
+
+void	handle_my_argvs (struct interfaceList** interfaces, int* sleeptime,
+		int argc, char* argv [])
+{
+int	c;
+struct interfaceList** tempInterfaces = interfaces;
+char** list;
+
+while(EOF != (c = getopt(argc, argv, "bcd:hkqvV"))) {
+	switch (c) {
+		case 'V':
+			opt_V = TRUE;
+			break;
+		case 'b':
+			opt_b = TRUE;
+			break;
+		case 'c':
+			opt_c = TRUE;
+			break;
+		case 'd':
+			opt_d = TRUE;
+			*sleeptime
+				= get_sleeptime(TRUE, NULL);
+			break;
+		case 'h':
+			opt_h = TRUE;
+			break;
+		case 'k':
+			opt_k = TRUE;
+			break;
+		case 'q':
+			opt_q = TRUE;
+			break;
+		case 'v':
+			opt_v = TRUE;
+			break;
+		default:
+			opt_h = TRUE;
+			/* assert(0); */
+	}
+}
+/* build interface list */
+do { /* new member */
+  if (! argv[optind] || ! (argv[optind])[0]) { /* bad argv */
+	  opt_h = TRUE; /* We may also have opt_k so we won't get h. */
+	  return;
+  }
+  *tempInterfaces = (struct interfaceList*)malloc(sizeof(struct interfaceList));
+  list = split_on_comma(argv[optind]);
+  (*tempInterfaces)->interfaceName = list[0];
+  if (*list[1]) { /* RX LED parameter */
+    (*tempInterfaces)->rxled = atoi(list[1]);
+    if (*list[2]) /* TX LED parameter */
+      (*tempInterfaces)->txled = atoi(list[2]);
+    else
+      (*tempInterfaces)->txled = atoi(list[1]);
+  } else {
+    (*tempInterfaces)->rxled = 1;
+    (*tempInterfaces)->txled = 2;
+  }
+  (*tempInterfaces)->row = 0;
+  (*tempInterfaces)->next = NULL;
+  tempInterfaces = &((*tempInterfaces)->next);
+  optind++;
+} while (optind < argc);
+if (opt_V)
+	printf("Marjo Helena Salmela on %svalehtelija ja paskiainen.\n",
+		"minua kohtaan ollut "); /* Don't ask. */
+if (! *sleeptime)
+	*sleeptime = get_sleeptime(FALSE, *interfaces);
 }
 
 void	check_sanity ()
 {
-	if (opt_c && geteuid()) {
-		opt_c = FALSE;
-		if (! opt_q)
-			fprintf(stderr,
-			    "You have to be EUID root for -c. -c removed.\n");
-	}
+if (opt_c && geteuid()) {
+	opt_c = FALSE;
+	if (! opt_q)
+		fprintf(stderr,
+		    "You have to be EUID root for -c. -c removed.\n");
+}
 }
 
-int	get_sleeptime (int isDefinedByUser, char* interfaceName)
+int	get_sleeptime (int isDefinedByUser, struct interfaceList* interfaces)
 {
-	int	returnValue;
-	
-	if (isDefinedByUser) {
-		returnValue = atol(optarg);
-		if (returnValue < 0 || returnValue > 10000) {
-			opt_h = TRUE;  /* Illegal value. */
-			return 0;
-		}
-		return returnValue;
-	} else {
-	/* Ok, we have to figure ourselves what would be good update delay. */
-		if (interfaceName == strstr(interfaceName, "eth"))
-			returnValue = DEFETHDELAY;
-		else
-			returnValue = DEFPPPDELAY;
-		return returnValue;
+int	returnValue;
+
+if (isDefinedByUser) {
+	returnValue = atol(optarg);
+	if (returnValue < 0 || returnValue > 10000) {
+		opt_h = TRUE;  /* Illegal value. */
+		return 0;
 	}
+	return returnValue;
+} else {
+/* Ok, we have to figure ourselves what would be good update delay. */
+  returnValue = 0;
+  while (interfaces) {
+    if (interfaces->interfaceName == strstr(interfaces->interfaceName, "eth")) {
+      /* Return minimum */
+      if (!returnValue || returnValue > DEFETHDELAY) returnValue = DEFETHDELAY;
+    } else {
+      if (!returnValue || returnValue > DEFPPPDELAY) returnValue = DEFPPPDELAY;
+    }
+    interfaces = interfaces->next;
+  }
+  return returnValue;
 }
-
-int	find_max_VT ()
-{
-	return MAXVT;
 }
 
-void	detach_vt_leds (int wantDetach)
-/* 
-   What I really would like to do, is to deattach only num-lock and scroll-lock
-   leds and leave caps-lock led attached to indicate current keyboard caps
-   lock flag. But Linux kernel (2.0.x) doesn't allow this, it's either all or
-   nothing. Someone should patch the kernel to correct this for 2.2.0?
-*/
-{
-	int	i, maxVT, tty;
-	char	ttyFileName [30];
-	char	ttyFileNameTmp [30];
-	ulong	ledVal;
-	
-	strcpy(ttyFileName, _PATH_TTY);
-	maxVT = find_max_VT();
-	for (i=0; i <= maxVT; i++) {
-		if (i > 0)
-			ttyLEDs[i-1] = 0x00;
-		/* No error checkings here, if we can't, we can't. */
-		sprintf(ttyFileNameTmp, "%s%d", ttyFileName, i);
-		if (-1 == (tty = open(ttyFileNameTmp, O_RDONLY))) {
-			continue;
-		}
-		if (ioctl(tty, KDGETLED, &ledVal)) {
-			close(tty);
-			continue;
-		}
-		ledVal &= ~LED_SCR;
-		ledVal &= ~LED_NUM;
-		if (!wantDetach && !is_on_X(tty)) {
-			ioctl(tty, KDGKBLED, &ledVal);
-			ledVal |= 8;	/* Reattach. */
-		}
-		ioctl(tty, KDSETLED, (char)ledVal);
-		if (i > 0)
-			ttyLEDs[i-1] = (char)ledVal;
-		close(tty);
-	}
+void	check_kernel_version ()
+{
+struct utsname	buffer;
+
+if (-1 == uname(&buffer)) {
+	perror("tleds: check_kernel_version()");
+	exit(1);
+}
+#if KERNEL2_0
+if (strncmp("2.0.", (const char*)buffer.release, 4)) {
+	fprintf(stderr,
+		"%s was compiled for v2.0 kernel. Check Makefile. %s",
+		MYNAME, TERMINATESTR);
+	exit(1);
+}
+#else
+if (! strncmp("2.0.", (const char*)buffer.release, 4)) {
+	fprintf(stderr, "%s was compiled for v2.1 (2.2?) kernel. %s",
+		MYNAME, TERMINATESTR);
+	exit(1);
+}
+#endif
 }
 
 void	usage (char* name)
 {
-	fprintf(stderr,
-	    "Usage: %s [-bchkqv] [-d <update_delay>] <interface_name>\n",
-	    name);
-	fprintf(stderr, "Example: %s -d 300 ppp0\n", name);
-	fprintf(stderr, "Options:\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
-		"\t-b\tDon't go to the background.",
-		"\t-c\tFix the CapsLED in VTs. Only for EUID root.",
-		"\t-d N\tSet update delay.",
-		"\t\tN must be between 1 and 10000 (milliseconds)",
-		"\t-h\tHelp. (this)",
-		"\t-k\tKill (old) (x)tleds running.",
-		"\t-q\tBe quiet.",
-		"\t-v\tPrint version information.",
-		"\t\t(`cat /proc/net/dev` to see your interfaces.)");
+printf("Usage: %s [-bchkqv] [-d <update_delay>] [<interface_name>] ...\n",
+    name);
+printf("Example: %s -d 300 ppp0 eth0,1 eth1,2\n", name);
+printf("<interface_name>:\n"
+       "\tinterface (e.g. eth0)\n"
+       "\tOR interface,led (e.g. eth1,1)\n"
+       "\tOR interface,rx_led,tx_led (e.g. eth2,2,1)\n"
+       "led:\n\t1\tNUM LOCK LED\n\t2\tSCROLL LOCK LED\n");
+printf("Options:\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n",
+	"\t-b\tDon't go to the background.",
+	"\t-c\tFix the CapsLED in VTs. Only for EUID root.",
+	"\t-d N\tSet update delay.",
+	"\t\tN must be between 1 and 10000 (milliseconds)",
+	"\t-h\tHelp. (this)",
+	"\t-k\tKill (old) (x)tleds running.",
+	"\t-q\tBe quiet.",
+	"\t-v\tPrint version information.",
+	"\t\t(`cat /proc/net/dev` to see your interfaces.)");
 }
 
 /*
-If the format of /proc/net/dev is changed this program will prolly not work,
-because the optimizations in e.g. find_device_line()
-
+In v2.0.x kernels:
 $ cat /proc/net/dev
 Inter-|   Receive                  |  Transmit
- face |packets errs drop fifo frame|packets errs drop fifo colls carrier
-     lo:      2    0    0    0    0        2    0    0    0     0    0
-   eth0:   3154    0    0    0    0     2553    0    0    0     0    0
-  dummy: No statistics available.
-   ppp0:  26619    0    0    0    0    42230    0    0    0     0    0
+face |packets errs drop fifo frame|packets errs drop fifo colls carrier
+lo:      2    0    0    0    0        2    0    0    0     0    0
+eth0:   3154    0    0    0    0     2553    0    0    0     0    0
+dummy: No statistics available.
+ppp0:  26619    0    0    0    0    42230    0    0    0     0    0
+$
+
+In v2.1 kernels they haven't obviously decided yet what it will be in v2.2.x
+
+In v2.1.72 +/- N kernels:
+$ cat /proc/net/dev
+Inter-|   Receive                           |  Transmit
+face |bytes    packets errs drop fifo frame|bytes    packets errs drop fifo colls carrier
+lo:  388390    7747    0    0    0    0   388390     7747    0    0    0     0    0    0
+ppp0:       0  496878   19   19    0    0        0   301287    0    0    0     0    0    0
+$
+
+In v2.1.97 +/- N kernels:
+$ cat /proc/net/dev
+Inter-|   Receive                                                |  Transmit
+face |bytes    packets errs drop fifo frame compressed multicast|bytes packets errs drop fifo colls carrier compressed
+lo: 4171066   19848    0    0    0     0          0         0  4171066 19848    0    0    0     0    0    0
+eth0: 2699632   19917    0    0    0     0          0         0  15993153 23079    0    0    0  1983    0    0
+ppp0:  391413    4588    1    0    0     0          0         0   4447 6560    0    0    0     0    0    0
 $
 */   
+
